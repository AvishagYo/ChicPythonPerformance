{"traceEvents": [{"ph": "M", "pid": 1137456, "tid": 1137456, "name": "process_name", "args": {"name": "MainProcess"}}, {"ph": "M", "pid": 1137456, "tid": 1137456, "name": "thread_name", "args": {"name": "MainThread"}}, {"pid": 1137456, "tid": 1137456, "ts": 153906889066.73, "ph": "X", "dur": 8.134551472453435, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889076.091, "ph": "X", "dur": 0.04166668132299273, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889078.745, "ph": "X", "dur": 0.0911458653940466, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889079.335, "ph": "X", "dur": 0.2343750824418341, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889078.449, "ph": "X", "dur": 2.1970493839269705, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889083.468, "ph": "X", "dur": 7.401044269996583, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889091.665, "ph": "X", "dur": 0.1006944798638991, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889091.98, "ph": "X", "dur": 0.07031252473255023, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889092.669, "ph": "X", "dur": 0.3385417857493159, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889094.284, "ph": "X", "dur": 0.16145839012659685, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889094.559, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889098.559, "ph": "X", "dur": 0.33680567402752454, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889100.121, "ph": "X", "dur": 0.10156253572479479, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889100.413, "ph": "X", "dur": 0.05034723993194955, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889100.565, "ph": "X", "dur": 0.047743072349262505, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889097.864, "ph": "X", "dur": 3.021702451777869, "name": "standardize_constraints (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py:1066)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889102.983, "ph": "X", "dur": 0.047743072349262505, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889107.559, "ph": "X", "dur": 0.1597222784048055, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889107.253, "ph": "X", "dur": 0.5338543544508443, "name": "_arr_to_scalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:11)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889108.947, "ph": "X", "dur": 0.046875016488366825, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889108.851, "ph": "X", "dur": 0.17621533976182344, "name": "_arr_to_scalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:11)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889106.452, "ph": "X", "dur": 2.7708343079790168, "name": "old_bound_to_new.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:437)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889109.36, "ph": "X", "dur": 1.620660292292238, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889111.901, "ph": "X", "dur": 0.40364597531649204, "name": "old_bound_to_new.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:439)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889112.388, "ph": "X", "dur": 0.3654515174370821, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889104.205, "ph": "X", "dur": 8.697919726174732, "name": "old_bound_to_new (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:424)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889116.939, "ph": "X", "dur": 0.3776042994896216, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889116.438, "ph": "X", "dur": 0.9375003297673364, "name": "issparse (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/sparse/_base.py:1388)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889117.664, "ph": "X", "dur": 0.044270848905679776, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889117.603, "ph": "X", "dur": 0.14496532876957885, "name": "issparse (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/sparse/_base.py:1388)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889118.05, "ph": "X", "dur": 0.05295140751463659, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889118.362, "ph": "X", "dur": 0.06597224542807183, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889118.636, "ph": "X", "dur": 0.0815972509241941, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889118.28, "ph": "X", "dur": 0.6597224542807182, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889119.337, "ph": "X", "dur": 0.035590290296722955, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889119.554, "ph": "X", "dur": 0.05555557509732364, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889119.718, "ph": "X", "dur": 0.04079862546209705, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889119.499, "ph": "X", "dur": 0.34201400919289865, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889120.289, "ph": "X", "dur": 0.10590281502927318, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889120.235, "ph": "X", "dur": 0.20225701558869388, "name": "issparse (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/sparse/_base.py:1388)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889120.579, "ph": "X", "dur": 0.035590290296722955, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889120.821, "ph": "X", "dur": 0.02690973168776614, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889120.938, "ph": "X", "dur": 1.2256948755847028, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889122.745, "ph": "X", "dur": 1.874132603673777, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889120.769, "ph": "X", "dur": 3.953126390518935, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889125.328, "ph": "X", "dur": 2.82638988307634, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889131.668, "ph": "X", "dur": 0.13020837913435226, "name": "_broadcast_arrays_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889136.009, "ph": "X", "dur": 0.5399307454771141, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889136.73, "ph": "X", "dur": 0.08767364195046387, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889136.936, "ph": "X", "dur": 0.06944446887165455, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889135.618, "ph": "X", "dur": 1.4375005056432493, "name": "broadcast_arrays.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:542)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889141.665, "ph": "X", "dur": 0.07031252473255023, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889138.608, "ph": "X", "dur": 4.620661347547714, "name": "_broadcast_shape (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:413)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889151.52, "ph": "X", "dur": 0.10156253572479479, "name": "builtins.iter", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889151.159, "ph": "X", "dur": 0.7265627555696856, "name": "iterable (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:339)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889152.254, "ph": "X", "dur": 0.17013894873555363, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889153.637, "ph": "X", "dur": 0.16145839012659685, "name": "_broadcast_to.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:345)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889153.913, "ph": "X", "dur": 0.09895836814210773, "name": "_broadcast_to.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:345)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889153.05, "ph": "X", "dur": 1.1223962281381166, "name": "builtins.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889164.358, "ph": "X", "dur": 0.28472232237378364, "name": "numpy.nditer.__exit__", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889166.113, "ph": "X", "dur": 0.3098959423397584, "name": "_maybe_view_as_subclass (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:24)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889149.863, "ph": "X", "dur": 19.82292363941379, "name": "_broadcast_to (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:340)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889144.815, "ph": "X", "dur": 25.219626926602245, "name": "broadcast_arrays.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:546)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889134.645, "ph": "X", "dur": 35.70487367036119, "name": "broadcast_arrays (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:481)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889129.877, "ph": "X", "dur": 41.1102575161586, "name": "Bounds._input_validation (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:249)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889115.3, "ph": "X", "dur": 55.84029741969742, "name": "Bounds.__init__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889102.457, "ph": "X", "dur": 68.89585756756848, "name": "standardize_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py:1053)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889187.031, "ph": "X", "dur": 0.13628477016062207, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889192.685, "ph": "X", "dur": 0.14670144049137024, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889193.612, "ph": "X", "dur": 0.9461808883762933, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889196.74, "ph": "X", "dur": 9.55469086087877, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889192.279, "ph": "X", "dur": 14.17622026428738, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889189.608, "ph": "X", "dur": 17.03125599077328, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889207.895, "ph": "X", "dur": 0.09027780953315091, "name": "_broadcast_to_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:363)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889209.147, "ph": "X", "dur": 0.10416670330748183, "name": "builtins.iter", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889209.064, "ph": "X", "dur": 0.27604176376482686, "name": "iterable (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:339)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889209.624, "ph": "X", "dur": 0.1866320100925716, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889210.233, "ph": "X", "dur": 0.15277783151764002, "name": "_broadcast_to.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:345)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889210.449, "ph": "X", "dur": 0.06510418956717613, "name": "_broadcast_to.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:345)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889210.114, "ph": "X", "dur": 0.49652795243233006, "name": "builtins.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889213.576, "ph": "X", "dur": 0.10156253572479479, "name": "numpy.nditer.__exit__", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889213.922, "ph": "X", "dur": 0.2109375741976507, "name": "_maybe_view_as_subclass (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:24)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889208.881, "ph": "X", "dur": 5.349828270700087, "name": "_broadcast_to (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:340)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889208.591, "ph": "X", "dur": 5.769099251512702, "name": "broadcast_to (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:367)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889214.766, "ph": "X", "dur": 0.08680558608956818, "name": "_broadcast_to_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:363)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889215.279, "ph": "X", "dur": 0.0815972509241941, "name": "builtins.iter", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889215.226, "ph": "X", "dur": 0.1918403452579457, "name": "iterable (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:339)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889215.544, "ph": "X", "dur": 0.11458337363823, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889215.887, "ph": "X", "dur": 0.08940975367225523, "name": "_broadcast_to.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:345)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889216.033, "ph": "X", "dur": 0.45659738283112866, "name": "_broadcast_to.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:345)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889215.806, "ph": "X", "dur": 0.7604169341446173, "name": "builtins.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889218.24, "ph": "X", "dur": 0.04947918407105387, "name": "numpy.nditer.__exit__", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889218.434, "ph": "X", "dur": 0.16059033426570116, "name": "_maybe_view_as_subclass (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:24)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889215.1, "ph": "X", "dur": 3.5625012531158786, "name": "_broadcast_to (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:340)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889214.949, "ph": "X", "dur": 5.013890652533458, "name": "broadcast_to (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:367)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889173.094, "ph": "X", "dur": 47.05904433087671, "name": "_validate_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py:1037)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889226.24, "ph": "X", "dur": 0.11371531777733432, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889227.658, "ph": "X", "dur": 0.05381946337553228, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889227.99, "ph": "X", "dur": 0.40364597531649204, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889229.148, "ph": "X", "dur": 2.6345495378183945, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889227.507, "ph": "X", "dur": 4.365452924444384, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889226.896, "ph": "X", "dur": 5.123265691006314, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889232.307, "ph": "X", "dur": 0.05989585440180205, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889232.693, "ph": "X", "dur": 0.07812502748061137, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889232.836, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889233.052, "ph": "X", "dur": 0.029513899270453184, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889233.13, "ph": "X", "dur": 0.024305564105079093, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889233.267, "ph": "X", "dur": 0.024305564105079093, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889233.329, "ph": "X", "dur": 0.021701396522392044, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889237.874, "ph": "X", "dur": 1.3680560367715946, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889237.466, "ph": "X", "dur": 1.8697923243692987, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889233.905, "ph": "X", "dur": 5.525175554601016, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889240.158, "ph": "X", "dur": 0.06423613370628045, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889242.164, "ph": "X", "dur": 0.07378474817613297, "name": "_broadcast_to_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:363)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889242.691, "ph": "X", "dur": 0.5052085110412868, "name": "builtins.iter", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889242.63, "ph": "X", "dur": 1.4878477455751988, "name": "iterable (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:339)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889244.362, "ph": "X", "dur": 0.12326393224718683, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889244.826, "ph": "X", "dur": 0.13368060257793501, "name": "_broadcast_to.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:345)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889245.026, "ph": "X", "dur": 0.09722225642031637, "name": "_broadcast_to.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:345)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889244.723, "ph": "X", "dur": 0.4652779414400855, "name": "builtins.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889247.579, "ph": "X", "dur": 0.06597224542807183, "name": "numpy.nditer.__exit__", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889247.805, "ph": "X", "dur": 0.14670144049137024, "name": "_maybe_view_as_subclass (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:24)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889242.506, "ph": "X", "dur": 5.531251945627285, "name": "_broadcast_to (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:340)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889242.365, "ph": "X", "dur": 5.842883999688834, "name": "broadcast_to (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:367)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889248.429, "ph": "X", "dur": 0.06944446887165455, "name": "_broadcast_to_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:363)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889248.89, "ph": "X", "dur": 0.23263897072004275, "name": "builtins.iter", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889248.842, "ph": "X", "dur": 0.5156251813720351, "name": "iterable (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:339)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889249.496, "ph": "X", "dur": 0.09548614469852501, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889249.837, "ph": "X", "dur": 0.08246530678508977, "name": "_broadcast_to.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:345)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889249.977, "ph": "X", "dur": 0.05468751923642796, "name": "_broadcast_to.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:345)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889249.773, "ph": "X", "dur": 0.3211806685314023, "name": "builtins.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889251.525, "ph": "X", "dur": 0.07204863645434159, "name": "numpy.nditer.__exit__", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889251.707, "ph": "X", "dur": 0.12152782052539547, "name": "_maybe_view_as_subclass (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:24)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889248.731, "ph": "X", "dur": 3.157119166077595, "name": "_broadcast_to (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:340)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889248.607, "ph": "X", "dur": 3.3472233996137493, "name": "broadcast_to (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:367)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889252.964, "ph": "X", "dur": 5.167536539911994, "name": "new_bounds_to_old.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:418)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889258.862, "ph": "X", "dur": 0.9557295028461457, "name": "new_bounds_to_old.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:419)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889241.795, "ph": "X", "dur": 19.357645697973705, "name": "new_bounds_to_old (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:406)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889239.83, "ph": "X", "dur": 21.522577015047535, "name": "standardize_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py:1053)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889263.577, "ph": "X", "dur": 0.07899308334150705, "name": "_wrap_callback (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:88)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889286.445, "ph": "X", "dur": 0.2664931492949743, "name": "_check_unknown_options (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:175)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889288.079, "ph": "X", "dur": 0.6961808004383369, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889292.504, "ph": "X", "dur": 0.39496541670753527, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889298.527, "ph": "X", "dur": 0.3593751264108123, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889297.407, "ph": "X", "dur": 1.5512158234205835, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889294.388, "ph": "X", "dur": 4.7560780618474405, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889291.69, "ph": "X", "dur": 7.559030436679598, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889300.426, "ph": "X", "dur": 0.21961813280660752, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889307.163, "ph": "X", "dur": 0.6328127225929522, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889308.304, "ph": "X", "dur": 0.12413198810808251, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889308.822, "ph": "X", "dur": 0.25954870240780886, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889306.848, "ph": "X", "dur": 3.7934041121141298, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889310.896, "ph": "X", "dur": 0.07031252473255023, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889313.487, "ph": "X", "dur": 0.5876738178263766, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889305.67, "ph": "X", "dur": 8.673614162069653, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889316.598, "ph": "X", "dur": 1.15191012740857, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889316.172, "ph": "X", "dur": 1.6484380798409, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889322.182, "ph": "X", "dur": 0.08072919506329843, "name": "_reshape_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889325.878, "ph": "X", "dur": 0.1345486584388307, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889326.317, "ph": "X", "dur": 0.9704864524813723, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889325.701, "ph": "X", "dur": 1.7048617107991193, "name": "_wrapfunc (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:51)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889323.757, "ph": "X", "dur": 3.7977443914186084, "name": "reshape (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:211)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889320.599, "ph": "X", "dur": 7.057294149081894, "name": "reshape (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:371)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889318.739, "ph": "X", "dur": 9.092885142882267, "name": "get_xp.<locals>.inner.<locals>.wrapped_f (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/_internal.py:26)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889328.082, "ph": "X", "dur": 0.08072919506329843, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889329.899, "ph": "X", "dur": 0.3298612271403591, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889329.7, "ph": "X", "dur": 0.608507158487873, "name": "_arr_to_scalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:11)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889330.784, "ph": "X", "dur": 0.051215295792845235, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889330.687, "ph": "X", "dur": 0.19444451284063274, "name": "_arr_to_scalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:11)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889329.406, "ph": "X", "dur": 1.5894102812999935, "name": "old_bound_to_new.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:437)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889331.108, "ph": "X", "dur": 0.8897572574180739, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889332.34, "ph": "X", "dur": 0.23784730588541683, "name": "old_bound_to_new.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:439)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889332.655, "ph": "X", "dur": 0.3836806905158914, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889328.4, "ph": "X", "dur": 4.7560780618474405, "name": "old_bound_to_new (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:424)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889334.395, "ph": "X", "dur": 0.15017366393495296, "name": "_clip_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889337.776, "ph": "X", "dur": 0.46267377385739844, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889342.184, "ph": "X", "dur": 4.857640597572235, "name": "_clip (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:99)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889338.46, "ph": "X", "dur": 8.711808619949062, "name": "numpy.ndarray.clip", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889337.672, "ph": "X", "dur": 9.56684364293131, "name": "_wrapfunc (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:51)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889336.659, "ph": "X", "dur": 10.832469088117215, "name": "clip (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2241)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889347.982, "ph": "X", "dur": 0.09201392125494227, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889349.113, "ph": "X", "dur": 0.15538199910032705, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889349.879, "ph": "X", "dur": 0.06944446887165455, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889351.355, "ph": "X", "dur": 0.28472232237378364, "name": "_minimize_slsqp.<locals>.cjac_factory (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889352.046, "ph": "X", "dur": 0.10850698261196023, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889352.809, "ph": "X", "dur": 0.07465280403702865, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889353.125, "ph": "X", "dur": 0.044270848905679776, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889354.75, "ph": "X", "dur": 0.17100700459644932, "name": "_minimize_slsqp.<locals>.cjac_factory (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889355.074, "ph": "X", "dur": 0.07378474817613297, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889355.635, "ph": "X", "dur": 0.05989585440180205, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889355.895, "ph": "X", "dur": 0.03993056960120137, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889356.191, "ph": "X", "dur": 0.1284722674125609, "name": "_minimize_slsqp.<locals>.cjac_factory (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889356.48, "ph": "X", "dur": 0.04166668132299273, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889358.706, "ph": "X", "dur": 0.13107643499524796, "name": "_minimize_slsqp.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:334)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889359.29, "ph": "X", "dur": 0.4444446007785891, "name": "builtins.sum", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889361.441, "ph": "X", "dur": 1.967014580789615, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889363.824, "ph": "X", "dur": 0.044270848905679776, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889365.96, "ph": "X", "dur": 0.09982642400300341, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889366.299, "ph": "X", "dur": 0.7491322079529734, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889367.384, "ph": "X", "dur": 0.49913212001501706, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889365.824, "ph": "X", "dur": 2.1588549260475607, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889368.938, "ph": "X", "dur": 0.6614585660025095, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889369.723, "ph": "X", "dur": 0.05555557509732364, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889370.23, "ph": "X", "dur": 0.04947918407105387, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889370.365, "ph": "X", "dur": 0.18142367492719752, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889370.645, "ph": "X", "dur": 0.21006951833675502, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889370.158, "ph": "X", "dur": 0.7569447107010346, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889371.386, "ph": "X", "dur": 0.4019098635947007, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889371.901, "ph": "X", "dur": 0.04079862546209705, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889372.317, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889372.439, "ph": "X", "dur": 0.3107639982006541, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889372.858, "ph": "X", "dur": 0.14670144049137024, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889372.257, "ph": "X", "dur": 0.8098961182156712, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889360.402, "ph": "X", "dur": 12.771705881358168, "name": "_minimize_slsqp.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:336)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889373.395, "ph": "X", "dur": 0.5998265998789162, "name": "builtins.sum", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889374.276, "ph": "X", "dur": 0.7977433361631316, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889377.49, "ph": "X", "dur": 7.526912369826458, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889377.267, "ph": "X", "dur": 7.8706624907411475, "name": "_amax (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:42)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889375.576, "ph": "X", "dur": 9.736114535805967, "name": "numpy.ndarray.max", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889385.513, "ph": "X", "dur": 0.08506947436777682, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889386.671, "ph": "X", "dur": 1.3446185285274113, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889388.095, "ph": "X", "dur": 0.4496529359439632, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889388.672, "ph": "X", "dur": 0.07204863645434159, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889390.158, "ph": "X", "dur": 0.09375003297673365, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889389.993, "ph": "X", "dur": 0.33246539472304615, "name": "_arr_to_scalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:11)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889390.557, "ph": "X", "dur": 0.10937503847285591, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889390.48, "ph": "X", "dur": 0.23003480313735572, "name": "_arr_to_scalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:11)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889391.051, "ph": "X", "dur": 0.05034723993194955, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889390.98, "ph": "X", "dur": 0.17447922804003207, "name": "_arr_to_scalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:11)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889391.559, "ph": "X", "dur": 0.039062513740305685, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889391.265, "ph": "X", "dur": 0.3836806905158914, "name": "_arr_to_scalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:11)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889389.668, "ph": "X", "dur": 2.122396579889942, "name": "_minimize_slsqp.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:361)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889392.006, "ph": "X", "dur": 2.360243885775359, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889398.282, "ph": "X", "dur": 1.394097712598465, "name": "errstate.__init__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py:430)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889402.332, "ph": "X", "dur": 1.001736463473617, "name": "numpy._core._multiarray_umath._make_extobj", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889404.224, "ph": "X", "dur": 1.391493545015778, "name": "_contextvars.ContextVar.set", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889401.497, "ph": "X", "dur": 4.294272343850938, "name": "errstate.__enter__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py:440)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889411.066, "ph": "X", "dur": 0.5755210357738371, "name": "_contextvars.ContextVar.reset", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889410.568, "ph": "X", "dur": 1.164930965322005, "name": "errstate.__exit__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py:456)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889412.888, "ph": "X", "dur": 1.942709016684536, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889412.671, "ph": "X", "dur": 2.240452176971755, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889412.329, "ph": "X", "dur": 2.6805564984458656, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889427.724, "ph": "X", "dur": 0.06770835714986319, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889436.861, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889437.206, "ph": "X", "dur": 0.038194457879410004, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889437.683, "ph": "X", "dur": 0.2526042555206434, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889438.888, "ph": "X", "dur": 0.10329864744658615, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889440.996, "ph": "X", "dur": 0.15625005496122274, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889440.619, "ph": "X", "dur": 0.603298823322499, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889439.837, "ph": "X", "dur": 1.552083879281479, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889438.632, "ph": "X", "dur": 2.8498273913205234, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889441.787, "ph": "X", "dur": 0.21875007694571183, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889442.844, "ph": "X", "dur": 0.2248264679719816, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889443.264, "ph": "X", "dur": 0.11111115019464728, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889443.554, "ph": "X", "dur": 0.10763892675106455, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889442.713, "ph": "X", "dur": 1.4800352428271375, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889444.357, "ph": "X", "dur": 0.051215295792845235, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889445.255, "ph": "X", "dur": 0.26128481412960025, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889442.567, "ph": "X", "dur": 3.1649316688256564, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889446.978, "ph": "X", "dur": 0.4887154496842689, "name": "_wrapper_fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889448.901, "ph": "X", "dur": 0.7248266438478944, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889448.687, "ph": "X", "dur": 1.006944798638991, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889455.949, "ph": "X", "dur": 0.09375003297673365, "name": "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889457.087, "ph": "X", "dur": 0.7925350009977576, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889456.775, "ph": "X", "dur": 1.1718754122091704, "name": "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889458.831, "ph": "X", "dur": 2.513021717292999, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:8)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889463.193, "ph": "X", "dur": 0.09461808883762933, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889462.667, "ph": "X", "dur": 0.7074655266299806, "name": "isscalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:1927)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889454.778, "ph": "X", "dur": 8.707468340644585, "name": "_wrapper_fun.<locals>.wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:16)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889453.146, "ph": "X", "dur": 10.913198283180513, "name": "ScalarFunction._update_fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:293)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889465.921, "ph": "X", "dur": 0.048611128210158186, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889465.698, "ph": "X", "dur": 0.698784968021024, "name": "_wrapper_grad (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:35)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889468.277, "ph": "X", "dur": 0.09982642400300341, "name": "ScalarFunction._update_fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:293)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889478.454, "ph": "X", "dur": 0.15885422254390977, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889479.191, "ph": "X", "dur": 0.036458346157618636, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889480.561, "ph": "X", "dur": 0.09027780953315091, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889480.303, "ph": "X", "dur": 0.40885431048186616, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889479.653, "ph": "X", "dur": 1.2187504286975372, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889479.037, "ph": "X", "dur": 1.8949659443352735, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889481.219, "ph": "X", "dur": 0.20312507144958958, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889482.932, "ph": "X", "dur": 0.15364588737853568, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889483.25, "ph": "X", "dur": 0.05989585440180205, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889483.448, "ph": "X", "dur": 0.07812502748061137, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889482.794, "ph": "X", "dur": 1.0486114799619837, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889483.999, "ph": "X", "dur": 0.06597224542807183, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889484.625, "ph": "X", "dur": 0.17361117217913635, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889482.666, "ph": "X", "dur": 2.264757741076834, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889485.488, "ph": "X", "dur": 0.3906251374030568, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889485.349, "ph": "X", "dur": 0.5781252033565242, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889488.788, "ph": "X", "dur": 0.25173619965974775, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889488.47, "ph": "X", "dur": 0.698784968021024, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889489.395, "ph": "X", "dur": 0.06597224542807183, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889489.27, "ph": "X", "dur": 0.21788202108481616, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889489.569, "ph": "X", "dur": 0.07638891575882001, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889487.271, "ph": "X", "dur": 2.8463551678769408, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889491.809, "ph": "X", "dur": 0.1154514294991257, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889493.121, "ph": "X", "dur": 0.07465280403702865, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889493.453, "ph": "X", "dur": 0.436632098030528, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889494.161, "ph": "X", "dur": 0.6597224542807182, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889492.513, "ph": "X", "dur": 2.394966120211186, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889499.847, "ph": "X", "dur": 0.1388889377433091, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889501.572, "ph": "X", "dur": 0.10763892675106455, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889501.953, "ph": "X", "dur": 0.5685765888866716, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889503.409, "ph": "X", "dur": 1.8324659223507844, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889501.368, "ph": "X", "dur": 4.026911138695068, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889500.632, "ph": "X", "dur": 4.914932284391351, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889510.478, "ph": "X", "dur": 1.3637157574671162, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889534.041, "ph": "X", "dur": 0.3211806685314023, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889533.771, "ph": "X", "dur": 0.736979425900434, "name": "finfo.__new__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/getlimits.py:493)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889537.423, "ph": "X", "dur": 0.7890627775541748, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889537.147, "ph": "X", "dur": 1.8914937208916909, "name": "issubclass_ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:289)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889540.065, "ph": "X", "dur": 0.14756949635226593, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889539.99, "ph": "X", "dur": 0.2638889817122873, "name": "issubclass_ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:289)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889540.366, "ph": "X", "dur": 0.05295140751463659, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889536.182, "ph": "X", "dur": 4.263890388719589, "name": "issubdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:471)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889540.914, "ph": "X", "dur": 0.10156253572479479, "name": "dict.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889540.791, "ph": "X", "dur": 0.3012153837308016, "name": "finfo.__new__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/getlimits.py:493)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889542.005, "ph": "X", "dur": 0.1597222784048055, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889541.943, "ph": "X", "dur": 0.4157987573690316, "name": "issubclass_ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:289)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889542.651, "ph": "X", "dur": 0.03993056960120137, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889542.596, "ph": "X", "dur": 0.12586809982987388, "name": "issubclass_ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:289)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889542.8, "ph": "X", "dur": 0.0286458434095575, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889541.816, "ph": "X", "dur": 1.0416670330748181, "name": "issubdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:471)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889528.635, "ph": "X", "dur": 15.030387231408731, "name": "_eps_for_method (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:92)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889551.838, "ph": "X", "dur": 0.1006944798638991, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889562.784, "ph": "X", "dur": 0.0911458653940466, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889566.223, "ph": "X", "dur": 0.07552085989792433, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889570.156, "ph": "X", "dur": 0.08680558608956818, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889565.085, "ph": "X", "dur": 7.617190179359608, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889577.693, "ph": "X", "dur": 0.06423613370628045, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889578.941, "ph": "X", "dur": 0.06336807784538477, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889579.238, "ph": "X", "dur": 0.4592015504138157, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889580.518, "ph": "X", "dur": 1.8602437098994462, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889578.755, "ph": "X", "dur": 3.754341598373824, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889578.222, "ph": "X", "dur": 4.394098767853941, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889584.423, "ph": "X", "dur": 0.49652795243233006, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889561.113, "ph": "X", "dur": 44.806439371852406, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889611.201, "ph": "X", "dur": 0.6380210577583262, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889612.032, "ph": "X", "dur": 0.2439236969116866, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889612.374, "ph": "X", "dur": 0.15538199910032705, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889612.757, "ph": "X", "dur": 1.0164934131088434, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889617.542, "ph": "X", "dur": 0.24565980863347797, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889618.021, "ph": "X", "dur": 0.07118058059344591, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889618.245, "ph": "X", "dur": 0.10763892675106455, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889617.352, "ph": "X", "dur": 1.5095491420975906, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889619.058, "ph": "X", "dur": 0.06597224542807183, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889619.775, "ph": "X", "dur": 0.25173619965974775, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889617.17, "ph": "X", "dur": 4.33593902517393, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889622.16, "ph": "X", "dur": 0.4670140531618769, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889622.024, "ph": "X", "dur": 0.6727432921941535, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889623.81, "ph": "X", "dur": 0.0815972509241941, "name": "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889624.24, "ph": "X", "dur": 0.4548612711093373, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889624.079, "ph": "X", "dur": 0.6718752363332579, "name": "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889625.045, "ph": "X", "dur": 0.8454864085123942, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:8)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889626.447, "ph": "X", "dur": 0.08680558608956818, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889626.31, "ph": "X", "dur": 0.29600704856542753, "name": "isscalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:1927)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889623.278, "ph": "X", "dur": 3.43142481812063, "name": "_wrapper_fun.<locals>.wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:16)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889627.014, "ph": "X", "dur": 0.10329864744658615, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889627.727, "ph": "X", "dur": 0.11718754122091705, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889628.09, "ph": "X", "dur": 0.31336816578334115, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889628.694, "ph": "X", "dur": 0.47222238832725094, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889627.63, "ph": "X", "dur": 1.6189241805704466, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889616.79, "ph": "X", "dur": 12.716150306260845, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889635.426, "ph": "X", "dur": 0.14496532876957885, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889635.685, "ph": "X", "dur": 0.07378474817613297, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889635.873, "ph": "X", "dur": 0.09635420055942069, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889635.309, "ph": "X", "dur": 0.9392364414891278, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889636.37, "ph": "X", "dur": 0.052083351653740916, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889636.902, "ph": "X", "dur": 0.14149310532599613, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889635.152, "ph": "X", "dur": 2.065104893070827, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889637.718, "ph": "X", "dur": 0.3541667912454382, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889637.591, "ph": "X", "dur": 0.5529515833905493, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889638.833, "ph": "X", "dur": 0.08854169781135955, "name": "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889640.557, "ph": "X", "dur": 0.3237848361140893, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889640.419, "ph": "X", "dur": 0.49479184071053867, "name": "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889641.151, "ph": "X", "dur": 0.5937502088526464, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:8)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889642.041, "ph": "X", "dur": 0.044270848905679776, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889641.97, "ph": "X", "dur": 0.1675347811528666, "name": "isscalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:1927)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889638.47, "ph": "X", "dur": 3.7534735425129284, "name": "_wrapper_fun.<locals>.wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:16)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889642.412, "ph": "X", "dur": 0.04079862546209705, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889642.834, "ph": "X", "dur": 0.08420141850688113, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889643.07, "ph": "X", "dur": 0.22569452383287728, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889643.496, "ph": "X", "dur": 0.25000008793795636, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889642.761, "ph": "X", "dur": 1.0416670330748181, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889634.925, "ph": "X", "dur": 9.046878182254797, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889647.255, "ph": "X", "dur": 0.07378474817613297, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889648.961, "ph": "X", "dur": 0.14583338463047454, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889649.192, "ph": "X", "dur": 0.05034723993194955, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889649.665, "ph": "X", "dur": 0.9140628215231531, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889648.359, "ph": "X", "dur": 2.2873271934601216, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889610.633, "ph": "X", "dur": 40.848972702029, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889477.763, "ph": "X", "dur": 174.02610288064452, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889469.388, "ph": "X", "dur": 183.38548117282176, "name": "_wrapper_grad.<locals>.wrapped1 (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:46)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889467.86, "ph": "X", "dur": 185.30301656954032, "name": "ScalarFunction._update_grad (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:303)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889653.317, "ph": "X", "dur": 0.09201392125494227, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889656.051, "ph": "X", "dur": 0.025173619965974774, "name": "builtins.callable", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889656.286, "ph": "X", "dur": 0.07118058059344591, "name": "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889656.635, "ph": "X", "dur": 0.33940984161021165, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889656.562, "ph": "X", "dur": 0.455729326970233, "name": "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889657.515, "ph": "X", "dur": 0.04340279304478409, "name": "_prepare_scalar_function.<locals>.hess (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:283)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889658.599, "ph": "X", "dur": 0.060763910262697736, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889658.251, "ph": "X", "dur": 0.4496529359439632, "name": "issparse (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/sparse/_base.py:1388)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889658.938, "ph": "X", "dur": 0.04947918407105387, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889659.493, "ph": "X", "dur": 1.0399309213530268, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889661.062, "ph": "X", "dur": 0.05642363095821932, "name": "_atleast_2d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:76)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889662.846, "ph": "X", "dur": 0.05381946337553228, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889663.265, "ph": "X", "dur": 0.5173612930938264, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889663.968, "ph": "X", "dur": 0.11631948536002137, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889664.283, "ph": "X", "dur": 0.08333336264598545, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889662.623, "ph": "X", "dur": 1.9192715084403527, "name": "atleast_2d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:80)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889655.88, "ph": "X", "dur": 8.904517021067905, "name": "_wrapper_hess (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:55)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889436.563, "ph": "X", "dur": 228.8898374568343, "name": "ScalarFunction.__init__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:166)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889427.608, "ph": "X", "dur": 238.30737549169154, "name": "_prepare_scalar_function (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:203)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889666.751, "ph": "X", "dur": 0.2812500989302009, "name": "_clip_x_for_func (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:297)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889667.431, "ph": "X", "dur": 0.1345486584388307, "name": "_clip_x_for_func (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:297)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889667.791, "ph": "X", "dur": 0.5546876951123407, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889668.6, "ph": "X", "dur": 0.26996537273855703, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889668.987, "ph": "X", "dur": 0.15625005496122274, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889669.277, "ph": "X", "dur": 0.2447917527725823, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889670.386, "ph": "X", "dur": 0.1484375522131616, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889670.618, "ph": "X", "dur": 0.1493056080740573, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889670.853, "ph": "X", "dur": 0.29600704856542753, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889671.21, "ph": "X", "dur": 0.16493061357017955, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889671.436, "ph": "X", "dur": 0.13368060257793501, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889671.633, "ph": "X", "dur": 0.13715282602151774, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889671.852, "ph": "X", "dur": 0.28819454581736637, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889672.214, "ph": "X", "dur": 0.171875060457345, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889672.456, "ph": "X", "dur": 0.1432292170477875, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889672.685, "ph": "X", "dur": 0.19878479214511113, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889672.951, "ph": "X", "dur": 0.33940984161021165, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889673.355, "ph": "X", "dur": 0.21875007694571183, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889673.635, "ph": "X", "dur": 0.16145839012659685, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889673.871, "ph": "X", "dur": 0.19097228939705002, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889674.122, "ph": "X", "dur": 0.17621533976182344, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889674.379, "ph": "X", "dur": 0.37673624362872593, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889674.843, "ph": "X", "dur": 0.16493061357017955, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889678.619, "ph": "X", "dur": 2.0399312731048522, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889678.386, "ph": "X", "dur": 2.3446188802792367, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889678.06, "ph": "X", "dur": 2.8029523748321568, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889682.013, "ph": "X", "dur": 0.8880211456962825, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889681.887, "ph": "X", "dur": 1.059028150292732, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889681.686, "ph": "X", "dur": 1.3385421375011415, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889677.096, "ph": "X", "dur": 6.059897964912755, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889684.79, "ph": "X", "dur": 0.09375003297673365, "name": "_array_equal_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2456)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889689.013, "ph": "X", "dur": 0.07725697161971569, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889689.17, "ph": "X", "dur": 0.05468751923642796, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889690.841, "ph": "X", "dur": 0.04340279304478409, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889694.748, "ph": "X", "dur": 1.1206601164163252, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889694.185, "ph": "X", "dur": 1.7309033866259897, "name": "_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:67)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889691.298, "ph": "X", "dur": 4.709203045359074, "name": "numpy.ndarray.all", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889688.731, "ph": "X", "dur": 7.471356794729134, "name": "array_equal (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2475)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889696.647, "ph": "X", "dur": 0.11718754122091705, "name": "ScalarFunction._update_fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:293)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889683.994, "ph": "X", "dur": 12.88194897569192, "name": "ScalarFunction.fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:323)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889675.641, "ph": "X", "dur": 21.30556304982362, "name": "_clip_x_for_func.<locals>.eval (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:303)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889698.333, "ph": "X", "dur": 0.8715280843392647, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889698.211, "ph": "X", "dur": 1.039062865492131, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889698.002, "ph": "X", "dur": 1.3437504726665157, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889700.192, "ph": "X", "dur": 0.7934030568586533, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889700.093, "ph": "X", "dur": 0.9322919946019623, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889699.929, "ph": "X", "dur": 1.1753476356527532, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889697.356, "ph": "X", "dur": 3.830730514132644, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889701.898, "ph": "X", "dur": 0.08246530678508977, "name": "_array_equal_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2456)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889702.223, "ph": "X", "dur": 0.04079862546209705, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889702.333, "ph": "X", "dur": 0.024305564105079093, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889703.151, "ph": "X", "dur": 0.039062513740305685, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889703.58, "ph": "X", "dur": 0.813368341659254, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889703.454, "ph": "X", "dur": 1.8463548161251153, "name": "_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:67)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889703.267, "ph": "X", "dur": 2.150174367438604, "name": "numpy.ndarray.all", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889702.142, "ph": "X", "dur": 3.3793414664668893, "name": "array_equal (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2475)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889705.834, "ph": "X", "dur": 0.11371531777733432, "name": "ScalarFunction._update_grad (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:303)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889701.653, "ph": "X", "dur": 4.48090435394351, "name": "ScalarFunction.grad (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:329)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889697.222, "ph": "X", "dur": 8.963544819608812, "name": "_clip_x_for_func.<locals>.eval (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:303)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889706.953, "ph": "X", "dur": 0.06423613370628045, "name": "_append_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:5640)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889708.189, "ph": "X", "dur": 0.04340279304478409, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889708.791, "ph": "X", "dur": 0.07031252473255023, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889709.33, "ph": "X", "dur": 0.06684030128896751, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889709.469, "ph": "X", "dur": 0.3333334505839418, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889709.917, "ph": "X", "dur": 0.23177091485914708, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889709.144, "ph": "X", "dur": 1.066840653040793, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889711.832, "ph": "X", "dur": 0.07204863645434159, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889708.01, "ph": "X", "dur": 5.8246548266100255, "name": "append (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:5644)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889715.845, "ph": "X", "dur": 0.5269099075636788, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889718.343, "ph": "X", "dur": 0.7248266438478944, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889720.158, "ph": "X", "dur": 0.06250002198448909, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889720.896, "ph": "X", "dur": 0.08420141850688113, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889721.14, "ph": "X", "dur": 0.2552084231033305, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889721.599, "ph": "X", "dur": 0.341145953332003, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889720.81, "ph": "X", "dur": 1.2144101493930588, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889722.617, "ph": "X", "dur": 0.48350711451889483, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889723.26, "ph": "X", "dur": 0.04947918407105387, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889723.706, "ph": "X", "dur": 0.036458346157618636, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889723.842, "ph": "X", "dur": 0.2161459093630248, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889724.223, "ph": "X", "dur": 0.18836812181436297, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889723.628, "ph": "X", "dur": 0.8411461292079156, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889724.792, "ph": "X", "dur": 0.3142362216442368, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889725.243, "ph": "X", "dur": 0.033854178574931594, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889725.602, "ph": "X", "dur": 0.036458346157618636, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889725.726, "ph": "X", "dur": 0.3359376181666289, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889726.167, "ph": "X", "dur": 0.1571181108221184, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889725.547, "ph": "X", "dur": 0.8368058499034373, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889717.468, "ph": "X", "dur": 9.025176785732405, "name": "_eval_constraint.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:480)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889726.877, "ph": "X", "dur": 0.05989585440180205, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889728.646, "ph": "X", "dur": 0.047743072349262505, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889715.57, "ph": "X", "dur": 13.956602131480773, "name": "_eval_constraint (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:471)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889731.585, "ph": "X", "dur": 0.42447931597798844, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889735.831, "ph": "X", "dur": 1.0746531557888541, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889735.699, "ph": "X", "dur": 1.2682296127685913, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889735.492, "ph": "X", "dur": 1.5651047171949144, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889738.345, "ph": "X", "dur": 0.8246530678508978, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889737.894, "ph": "X", "dur": 1.3220490761441235, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889737.718, "ph": "X", "dur": 1.5763894433865582, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889734.795, "ph": "X", "dur": 4.579862722085618, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889741.399, "ph": "X", "dur": 0.15885422254390977, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889742.22, "ph": "X", "dur": 0.10677087089016886, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889744.308, "ph": "X", "dur": 0.0859375302286725, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889744.0, "ph": "X", "dur": 0.48350711451889483, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889743.359, "ph": "X", "dur": 1.3758685395196557, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889742.041, "ph": "X", "dur": 2.790799592779617, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889745.061, "ph": "X", "dur": 0.1918403452579457, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889745.817, "ph": "X", "dur": 0.1666667252919709, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889746.159, "ph": "X", "dur": 0.08333336264598545, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889746.384, "ph": "X", "dur": 0.07812502748061137, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889745.685, "ph": "X", "dur": 1.178819859096336, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889746.992, "ph": "X", "dur": 0.05555557509732364, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889747.701, "ph": "X", "dur": 0.20225701558869388, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889745.553, "ph": "X", "dur": 2.555556454476888, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889748.66, "ph": "X", "dur": 0.4765626676317294, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889748.508, "ph": "X", "dur": 0.6857641301075887, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889750.317, "ph": "X", "dur": 0.21961813280660752, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889750.12, "ph": "X", "dur": 0.46267377385739844, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889751.091, "ph": "X", "dur": 0.06597224542807183, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889750.678, "ph": "X", "dur": 0.5286460192854703, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889751.277, "ph": "X", "dur": 0.10416670330748183, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889749.706, "ph": "X", "dur": 2.103299350950237, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889753.143, "ph": "X", "dur": 0.0815972509241941, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889753.357, "ph": "X", "dur": 0.06510418956717613, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889753.533, "ph": "X", "dur": 0.03993056960120137, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889753.042, "ph": "X", "dur": 0.7881947216932791, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889753.93, "ph": "X", "dur": 0.047743072349262505, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889754.394, "ph": "X", "dur": 0.11284726191643864, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889752.945, "ph": "X", "dur": 1.6710075322241875, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889755.046, "ph": "X", "dur": 0.25781259068601753, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889754.96, "ph": "X", "dur": 0.38541680223768277, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889755.766, "ph": "X", "dur": 0.5980904881571248, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889756.598, "ph": "X", "dur": 0.060763910262697736, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889757.154, "ph": "X", "dur": 0.03993056960120137, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889757.348, "ph": "X", "dur": 0.3012153837308016, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889757.845, "ph": "X", "dur": 0.33940984161021165, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889757.074, "ph": "X", "dur": 1.1796879149572317, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889752.712, "ph": "X", "dur": 5.711807564693586, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889760.375, "ph": "X", "dur": 0.1006944798638991, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889761.771, "ph": "X", "dur": 0.07118058059344591, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889762.111, "ph": "X", "dur": 0.4496529359439632, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889763.18, "ph": "X", "dur": 1.3324657464748717, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889761.55, "ph": "X", "dur": 3.092014976510419, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889761.003, "ph": "X", "dur": 3.7586818776783026, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889766.517, "ph": "X", "dur": 0.5989585440180205, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889775.198, "ph": "X", "dur": 0.09288197711583795, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889778.559, "ph": "X", "dur": 0.07725697161971569, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889780.264, "ph": "X", "dur": 0.06163196612359342, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889781.398, "ph": "X", "dur": 0.0859375302286725, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889779.862, "ph": "X", "dur": 2.9131954691659083, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889785.451, "ph": "X", "dur": 0.06510418956717613, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889786.369, "ph": "X", "dur": 0.047743072349262505, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889786.605, "ph": "X", "dur": 0.341145953332003, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889787.324, "ph": "X", "dur": 1.306424070648001, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889786.215, "ph": "X", "dur": 2.499132823518668, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889785.754, "ph": "X", "dur": 3.0529524627701132, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889790.004, "ph": "X", "dur": 0.2812500989302009, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889778.051, "ph": "X", "dur": 24.353307177428356, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889803.46, "ph": "X", "dur": 0.43315987458694527, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889804.033, "ph": "X", "dur": 0.21354174178033772, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889804.324, "ph": "X", "dur": 0.14670144049137024, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889804.622, "ph": "X", "dur": 0.4652779414400855, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889807.447, "ph": "X", "dur": 0.13194449085614365, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889807.728, "ph": "X", "dur": 0.07031252473255023, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889807.906, "ph": "X", "dur": 0.07638891575882001, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889807.08, "ph": "X", "dur": 1.2387157134981381, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889808.455, "ph": "X", "dur": 0.05902779854090637, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889809.049, "ph": "X", "dur": 0.14670144049137024, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889806.961, "ph": "X", "dur": 2.3888897291849167, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889809.98, "ph": "X", "dur": 0.38802096982036977, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889809.68, "ph": "X", "dur": 0.7300349790132684, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889810.801, "ph": "X", "dur": 0.5190974048156177, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889811.556, "ph": "X", "dur": 0.05555557509732364, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889812.105, "ph": "X", "dur": 0.05555557509732364, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889812.34, "ph": "X", "dur": 0.24565980863347797, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889812.783, "ph": "X", "dur": 0.28038204306930525, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889812.041, "ph": "X", "dur": 1.0963545523112461, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889806.725, "ph": "X", "dur": 6.616321771746887, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889817.192, "ph": "X", "dur": 0.09809031228121205, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889817.432, "ph": "X", "dur": 0.051215295792845235, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889817.58, "ph": "X", "dur": 0.04079862546209705, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889817.069, "ph": "X", "dur": 0.8012155596067143, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889817.973, "ph": "X", "dur": 0.037326402018514324, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889818.43, "ph": "X", "dur": 0.10503475916837751, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889816.968, "ph": "X", "dur": 1.7039936549382235, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889819.073, "ph": "X", "dur": 0.3081598306179671, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889818.938, "ph": "X", "dur": 0.48524322624068617, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889819.737, "ph": "X", "dur": 0.41493070150813594, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889820.289, "ph": "X", "dur": 0.05468751923642796, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889820.72, "ph": "X", "dur": 0.036458346157618636, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889820.92, "ph": "X", "dur": 0.18836812181436297, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889821.227, "ph": "X", "dur": 0.2013889597277982, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889820.642, "ph": "X", "dur": 0.8454864085123942, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889816.747, "ph": "X", "dur": 4.879341994094628, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889825.903, "ph": "X", "dur": 0.0815972509241941, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889826.342, "ph": "X", "dur": 0.06250002198448909, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889826.486, "ph": "X", "dur": 0.07118058059344591, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889826.666, "ph": "X", "dur": 0.24218758518989522, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889826.199, "ph": "X", "dur": 0.7673613810317828, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889803.154, "ph": "X", "dur": 24.102439033629505, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889741.036, "ph": "X", "dur": 86.45055124246186, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889734.511, "ph": "X", "dur": 93.66322739064407, "name": "_minimize_slsqp.<locals>.cjac_factory.<locals>.cjac (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:300)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889830.093, "ph": "X", "dur": 1.4409727290868317, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889829.853, "ph": "X", "dur": 1.7404520010958422, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889829.628, "ph": "X", "dur": 2.054688222740079, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889832.649, "ph": "X", "dur": 0.8090280623547755, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889832.54, "ph": "X", "dur": 0.9574656145679371, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889832.366, "ph": "X", "dur": 1.2100698700885806, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889828.959, "ph": "X", "dur": 4.723091939133406, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889834.554, "ph": "X", "dur": 0.15451394323943138, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889835.17, "ph": "X", "dur": 0.08072919506329843, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889836.575, "ph": "X", "dur": 0.08506947436777682, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889836.317, "ph": "X", "dur": 0.4227432042561971, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889835.793, "ph": "X", "dur": 1.1085073343637857, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889835.02, "ph": "X", "dur": 1.9461812401281189, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889837.153, "ph": "X", "dur": 0.17013894873555363, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889837.779, "ph": "X", "dur": 0.10850698261196023, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889837.982, "ph": "X", "dur": 0.05815974268001069, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889838.133, "ph": "X", "dur": 0.052083351653740916, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889837.672, "ph": "X", "dur": 0.8194447326855238, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889838.588, "ph": "X", "dur": 0.036458346157618636, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889839.066, "ph": "X", "dur": 0.10763892675106455, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889837.567, "ph": "X", "dur": 1.7569450624528602, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889839.811, "ph": "X", "dur": 0.3689237408806648, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889839.705, "ph": "X", "dur": 0.5347224103117401, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889840.995, "ph": "X", "dur": 0.1779514514836148, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889840.816, "ph": "X", "dur": 0.401041807733805, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889841.444, "ph": "X", "dur": 0.06684030128896751, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889841.285, "ph": "X", "dur": 0.2552084231033305, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889841.614, "ph": "X", "dur": 0.07638891575882001, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889840.507, "ph": "X", "dur": 1.5190977565674433, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889843.159, "ph": "X", "dur": 0.09982642400300341, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889843.358, "ph": "X", "dur": 0.04079862546209705, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889843.494, "ph": "X", "dur": 0.032118066853140226, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889843.053, "ph": "X", "dur": 0.7126738617953549, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889843.855, "ph": "X", "dur": 0.034722234435827275, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889844.207, "ph": "X", "dur": 0.10243059158569047, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889842.974, "ph": "X", "dur": 1.421875500147127, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889844.749, "ph": "X", "dur": 0.28211815479109664, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889844.652, "ph": "X", "dur": 0.4218751483953014, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889846.281, "ph": "X", "dur": 0.5772571474956285, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889847.021, "ph": "X", "dur": 0.04253473718388841, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889847.617, "ph": "X", "dur": 0.05902779854090637, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889847.804, "ph": "X", "dur": 0.2013889597277982, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889848.181, "ph": "X", "dur": 0.264757037573183, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889847.533, "ph": "X", "dur": 0.9843753462557032, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889842.821, "ph": "X", "dur": 5.838543720384357, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889850.469, "ph": "X", "dur": 0.1006944798638991, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889851.632, "ph": "X", "dur": 0.047743072349262505, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889851.891, "ph": "X", "dur": 0.40538208703828343, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889852.705, "ph": "X", "dur": 1.1770837473745446, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889851.481, "ph": "X", "dur": 2.4982647676577727, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889851.035, "ph": "X", "dur": 3.047744127604739, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889855.561, "ph": "X", "dur": 0.4262154276997798, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889862.712, "ph": "X", "dur": 0.09461808883762933, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889865.359, "ph": "X", "dur": 0.07204863645434159, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889865.906, "ph": "X", "dur": 0.08072919506329843, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889866.741, "ph": "X", "dur": 0.06944446887165455, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889865.607, "ph": "X", "dur": 2.1258688033335247, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889869.989, "ph": "X", "dur": 0.07725697161971569, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889871.403, "ph": "X", "dur": 0.032118066853140226, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889871.603, "ph": "X", "dur": 0.4861112821015819, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889872.449, "ph": "X", "dur": 1.0815976026760195, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889870.674, "ph": "X", "dur": 2.9531260387671097, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889870.296, "ph": "X", "dur": 3.402778974711073, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889874.772, "ph": "X", "dur": 0.2621528699904959, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889864.995, "ph": "X", "dur": 20.85851428146234, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889886.794, "ph": "X", "dur": 0.3498265119409598, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889887.317, "ph": "X", "dur": 0.19357645697973705, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889887.596, "ph": "X", "dur": 0.15364588737853568, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889887.909, "ph": "X", "dur": 0.35156262366275115, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889890.061, "ph": "X", "dur": 0.13715282602151774, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889890.34, "ph": "X", "dur": 0.08072919506329843, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889890.545, "ph": "X", "dur": 0.04079862546209705, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889889.959, "ph": "X", "dur": 0.9817711786730161, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889891.048, "ph": "X", "dur": 0.06163196612359342, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889891.591, "ph": "X", "dur": 0.11718754122091705, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889889.835, "ph": "X", "dur": 2.0486118317138096, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889892.364, "ph": "X", "dur": 0.3315973388621505, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889892.215, "ph": "X", "dur": 0.5381946337553228, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889893.129, "ph": "X", "dur": 0.5520835275296537, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889893.854, "ph": "X", "dur": 0.045138904766575456, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889894.37, "ph": "X", "dur": 0.06944446887165455, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889894.606, "ph": "X", "dur": 0.2057292390322766, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889895.038, "ph": "X", "dur": 0.2552084231033305, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889894.27, "ph": "X", "dur": 1.1032989991984117, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889889.636, "ph": "X", "dur": 5.919272915447655, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889901.729, "ph": "X", "dur": 0.09895836814210773, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889901.923, "ph": "X", "dur": 0.07812502748061137, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889902.113, "ph": "X", "dur": 0.039062513740305685, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889901.626, "ph": "X", "dur": 0.7881947216932791, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889902.503, "ph": "X", "dur": 0.034722234435827275, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889902.928, "ph": "X", "dur": 0.11111115019464728, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889901.532, "ph": "X", "dur": 1.6223964040140295, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889903.499, "ph": "X", "dur": 0.33246539472304615, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889903.414, "ph": "X", "dur": 0.46006960627471144, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889904.135, "ph": "X", "dur": 0.38194457879410004, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889904.651, "ph": "X", "dur": 0.052083351653740916, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889905.059, "ph": "X", "dur": 0.06250002198448909, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889905.22, "ph": "X", "dur": 0.16927089287465796, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889905.548, "ph": "X", "dur": 0.20920146247585933, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889904.982, "ph": "X", "dur": 0.8454864085123942, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889901.019, "ph": "X", "dur": 4.921876731278517, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889908.236, "ph": "X", "dur": 0.09635420055942069, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889908.673, "ph": "X", "dur": 0.04947918407105387, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889908.818, "ph": "X", "dur": 0.07465280403702865, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889908.985, "ph": "X", "dur": 0.1666667252919709, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889908.522, "ph": "X", "dur": 0.6831599625249016, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889886.472, "ph": "X", "dur": 23.009556704761838, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889834.26, "ph": "X", "dur": 75.43665847941745, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889828.749, "ph": "X", "dur": 81.45575781886811, "name": "_minimize_slsqp.<locals>.cjac_factory.<locals>.cjac (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:300)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889912.098, "ph": "X", "dur": 1.3897574332939866, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889911.881, "ph": "X", "dur": 1.6744797556677704, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889911.672, "ph": "X", "dur": 1.9626743014851367, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889914.632, "ph": "X", "dur": 0.8359377940425416, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889914.502, "ph": "X", "dur": 1.0060767427780952, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889914.318, "ph": "X", "dur": 1.2699657244903826, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889911.006, "ph": "X", "dur": 4.697050263306535, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889916.471, "ph": "X", "dur": 0.13715282602151774, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889917.009, "ph": "X", "dur": 0.09722225642031637, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889918.324, "ph": "X", "dur": 0.06857641301075887, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889918.08, "ph": "X", "dur": 0.38020846707230865, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889917.576, "ph": "X", "dur": 1.0243059158569048, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889916.886, "ph": "X", "dur": 1.7673617327836082, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889918.837, "ph": "X", "dur": 0.17013894873555363, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889919.431, "ph": "X", "dur": 0.07465280403702865, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889919.647, "ph": "X", "dur": 0.05902779854090637, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889919.835, "ph": "X", "dur": 0.032118066853140226, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889919.31, "ph": "X", "dur": 0.8203127885464194, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889920.23, "ph": "X", "dur": 0.05642363095821932, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889920.724, "ph": "X", "dur": 0.12673615569076954, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889919.206, "ph": "X", "dur": 1.770833956227191, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889921.501, "ph": "X", "dur": 0.32812511541856776, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889921.359, "ph": "X", "dur": 1.2864587858474006, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889923.423, "ph": "X", "dur": 0.15364588737853568, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889923.261, "ph": "X", "dur": 0.3593751264108123, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889923.862, "ph": "X", "dur": 0.06597224542807183, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889923.679, "ph": "X", "dur": 0.2769098196257225, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889924.035, "ph": "X", "dur": 0.07465280403702865, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889922.938, "ph": "X", "dur": 1.508681086236695, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889925.624, "ph": "X", "dur": 0.07204863645434159, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889925.821, "ph": "X", "dur": 0.045138904766575456, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889925.952, "ph": "X", "dur": 0.05034723993194955, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889925.524, "ph": "X", "dur": 0.7378474817613296, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889926.351, "ph": "X", "dur": 0.05642363095821932, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889926.764, "ph": "X", "dur": 0.08246530678508977, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889925.431, "ph": "X", "dur": 1.508681086236695, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889927.335, "ph": "X", "dur": 0.30902788647886276, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889927.233, "ph": "X", "dur": 0.4522571035266503, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889928.003, "ph": "X", "dur": 0.5373265778944271, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889928.718, "ph": "X", "dur": 0.045138904766575456, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889929.197, "ph": "X", "dur": 0.047743072349262505, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889929.357, "ph": "X", "dur": 0.23350702658093844, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889929.778, "ph": "X", "dur": 0.2630209258513916, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889929.121, "ph": "X", "dur": 0.9956600724473471, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889925.229, "ph": "X", "dur": 5.0625017807436175, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889932.069, "ph": "X", "dur": 0.10677087089016886, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889933.153, "ph": "X", "dur": 0.06423613370628045, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889933.452, "ph": "X", "dur": 0.4140626456472402, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889934.24, "ph": "X", "dur": 1.2352434900545552, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889932.986, "ph": "X", "dur": 2.5824661861646536, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889932.553, "ph": "X", "dur": 3.118924708198185, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889937.129, "ph": "X", "dur": 0.4496529359439632, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889944.003, "ph": "X", "dur": 0.09288197711583795, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889946.31, "ph": "X", "dur": 0.07638891575882001, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889946.818, "ph": "X", "dur": 0.06510418956717613, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889947.57, "ph": "X", "dur": 0.07812502748061137, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889946.559, "ph": "X", "dur": 1.9409729049627447, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889950.705, "ph": "X", "dur": 0.08072919506329843, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889951.487, "ph": "X", "dur": 0.03298612271403591, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889951.702, "ph": "X", "dur": 0.29427093684363614, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889952.333, "ph": "X", "dur": 1.061632317875419, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889951.348, "ph": "X", "dur": 2.1250007474726296, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889950.984, "ph": "X", "dur": 2.557292566198679, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889954.681, "ph": "X", "dur": 0.23350702658093844, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889945.997, "ph": "X", "dur": 19.472229071611935, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889966.368, "ph": "X", "dur": 0.302951495452593, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889966.779, "ph": "X", "dur": 0.1875000659534673, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889967.05, "ph": "X", "dur": 0.15277783151764002, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889967.374, "ph": "X", "dur": 0.3289931712794634, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889970.52, "ph": "X", "dur": 0.14236116118689182, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889970.786, "ph": "X", "dur": 0.07725697161971569, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889970.98, "ph": "X", "dur": 0.051215295792845235, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889970.414, "ph": "X", "dur": 0.9210072684103184, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889971.428, "ph": "X", "dur": 0.036458346157618636, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889971.959, "ph": "X", "dur": 0.11892365294270842, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889970.291, "ph": "X", "dur": 1.9557298545979713, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889972.722, "ph": "X", "dur": 0.3229167802531937, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889972.607, "ph": "X", "dur": 0.4800348910753121, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889973.453, "ph": "X", "dur": 0.48697933796247755, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889974.137, "ph": "X", "dur": 0.032118066853140226, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889974.606, "ph": "X", "dur": 0.04600696062747114, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889974.767, "ph": "X", "dur": 0.21267368591944205, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889975.206, "ph": "X", "dur": 0.23177091485914708, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889974.528, "ph": "X", "dur": 0.9913197931428687, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889970.05, "ph": "X", "dur": 5.639758928239245, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889979.053, "ph": "X", "dur": 0.09722225642031637, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889979.266, "ph": "X", "dur": 0.057291686819115, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889979.4, "ph": "X", "dur": 0.033854178574931594, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889978.952, "ph": "X", "dur": 0.780382218945218, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889979.83, "ph": "X", "dur": 0.057291686819115, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889980.214, "ph": "X", "dur": 0.11718754122091705, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889978.864, "ph": "X", "dur": 1.5989588957698462, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889980.852, "ph": "X", "dur": 0.30555566303528003, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889980.765, "ph": "X", "dur": 0.4522571035266503, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889981.473, "ph": "X", "dur": 0.3637154057152907, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889981.987, "ph": "X", "dur": 0.036458346157618636, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889982.371, "ph": "X", "dur": 0.034722234435827275, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889982.491, "ph": "X", "dur": 0.1631945018483882, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889982.779, "ph": "X", "dur": 0.18142367492719752, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889982.306, "ph": "X", "dur": 0.7187502528216246, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889978.706, "ph": "X", "dur": 4.465279348447388, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889985.315, "ph": "X", "dur": 0.08680558608956818, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889985.739, "ph": "X", "dur": 0.048611128210158186, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889985.871, "ph": "X", "dur": 0.06857641301075887, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889986.021, "ph": "X", "dur": 0.16579866943107524, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889985.583, "ph": "X", "dur": 0.6666669011678836, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889966.094, "ph": "X", "dur": 20.388896060717776, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889916.213, "ph": "X", "dur": 70.45835811718071, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889910.845, "ph": "X", "dur": 76.33856851888805, "name": "_minimize_slsqp.<locals>.cjac_factory.<locals>.cjac (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:300)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889733.185, "ph": "X", "dur": 254.1797769081691, "name": "_eval_con_normals.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:499)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889988.952, "ph": "X", "dur": 0.4383682097523193, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889988.791, "ph": "X", "dur": 0.8602433581476208, "name": "_arrays_for_stack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:208)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889988.152, "ph": "X", "dur": 1.5729172199429757, "name": "_vhstack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:216)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889990.712, "ph": "X", "dur": 0.052083351653740916, "name": "_atleast_2d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:76)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889991.173, "ph": "X", "dur": 0.04947918407105387, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889993.333, "ph": "X", "dur": 0.09635420055942069, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889993.595, "ph": "X", "dur": 0.051215295792845235, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889994.089, "ph": "X", "dur": 0.06336807784538477, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889994.242, "ph": "X", "dur": 0.02690973168776614, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889994.756, "ph": "X", "dur": 0.026041675826870458, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889994.911, "ph": "X", "dur": 0.08940975367225523, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889990.964, "ph": "X", "dur": 4.217883428092119, "name": "atleast_2d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:80)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889995.527, "ph": "X", "dur": 0.057291686819115, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889996.269, "ph": "X", "dur": 0.07638891575882001, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889990.409, "ph": "X", "dur": 8.335940432181232, "name": "vstack (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:220)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889999.837, "ph": "X", "dur": 0.22916674727646, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889999.743, "ph": "X", "dur": 0.4878473938233732, "name": "_arrays_for_stack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:208)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889999.617, "ph": "X", "dur": 0.6892363535511714, "name": "_vhstack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:216)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890000.686, "ph": "X", "dur": 0.04166668132299273, "name": "_atleast_2d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:76)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890001.002, "ph": "X", "dur": 0.02690973168776614, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890001.232, "ph": "X", "dur": 0.06336807784538477, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890001.929, "ph": "X", "dur": 0.04340279304478409, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890002.124, "ph": "X", "dur": 0.03298612271403591, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890002.273, "ph": "X", "dur": 0.05642363095821932, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890000.863, "ph": "X", "dur": 1.5625005496122273, "name": "atleast_2d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:80)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890002.651, "ph": "X", "dur": 0.04253473718388841, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890002.982, "ph": "X", "dur": 0.06510418956717613, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890000.456, "ph": "X", "dur": 3.9149319326395253, "name": "vstack (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:220)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890004.683, "ph": "X", "dur": 0.8385419616252288, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890005.864, "ph": "X", "dur": 0.05034723993194955, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889731.353, "ph": "X", "dur": 275.8915901008919, "name": "_eval_con_normals (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:490)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890027.281, "ph": "X", "dur": 1.7829867382797306, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890027.072, "ph": "X", "dur": 2.076389619262471, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890026.785, "ph": "X", "dur": 2.4618064215001536, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890030.248, "ph": "X", "dur": 0.835069738181646, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890030.138, "ph": "X", "dur": 0.9982642400300341, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890029.965, "ph": "X", "dur": 1.2491323838288864, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890025.916, "ph": "X", "dur": 5.412328292684577, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890031.858, "ph": "X", "dur": 0.09461808883762933, "name": "_array_equal_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2456)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890032.212, "ph": "X", "dur": 0.05989585440180205, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890032.335, "ph": "X", "dur": 0.0286458434095575, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890033.406, "ph": "X", "dur": 0.05381946337553228, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890033.962, "ph": "X", "dur": 0.856771134704038, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890033.808, "ph": "X", "dur": 1.0529517592664621, "name": "_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:67)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890033.561, "ph": "X", "dur": 1.3784727071023428, "name": "numpy.ndarray.all", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890032.12, "ph": "X", "dur": 2.9861121614811457, "name": "array_equal (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2475)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890037.787, "ph": "X", "dur": 0.1822917307880932, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890038.858, "ph": "X", "dur": 0.10416670330748183, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890040.364, "ph": "X", "dur": 0.09027780953315091, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890040.136, "ph": "X", "dur": 0.40451403117738777, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890039.549, "ph": "X", "dur": 1.1614587418784224, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890038.646, "ph": "X", "dur": 2.164063261212935, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890042.079, "ph": "X", "dur": 0.15104171979584866, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890042.8, "ph": "X", "dur": 0.44270848905679777, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890042.66, "ph": "X", "dur": 0.646701616367283, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890037.424, "ph": "X", "dur": 6.144967439280532, "name": "ScalarFunction._update_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:270)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890044.759, "ph": "X", "dur": 0.08680558608956818, "name": "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890045.153, "ph": "X", "dur": 0.4644098855791898, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890045.006, "ph": "X", "dur": 0.6779516273595275, "name": "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890046.414, "ph": "X", "dur": 1.3854171539895084, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:8)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890048.297, "ph": "X", "dur": 0.07031252473255023, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890048.17, "ph": "X", "dur": 0.27083342859945275, "name": "isscalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:1927)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890044.187, "ph": "X", "dur": 4.352432086530949, "name": "_wrapper_fun.<locals>.wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:16)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890043.819, "ph": "X", "dur": 5.285592136993807, "name": "ScalarFunction._update_fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:293)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890031.571, "ph": "X", "dur": 17.656256210618167, "name": "ScalarFunction.fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:323)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890025.717, "ph": "X", "dur": 23.567716623317764, "name": "_clip_x_for_func.<locals>.eval (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:303)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890049.684, "ph": "X", "dur": 0.34201400919289865, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890050.912, "ph": "X", "dur": 0.5060765669021825, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890051.618, "ph": "X", "dur": 0.04253473718388841, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890052.237, "ph": "X", "dur": 0.09461808883762933, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890052.489, "ph": "X", "dur": 0.24305564105079094, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890052.958, "ph": "X", "dur": 0.3550348471063339, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890052.156, "ph": "X", "dur": 1.241319881080825, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890053.745, "ph": "X", "dur": 0.40885431048186616, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890054.265, "ph": "X", "dur": 0.051215295792845235, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890054.634, "ph": "X", "dur": 0.03993056960120137, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890054.766, "ph": "X", "dur": 0.15190977565674432, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890055.062, "ph": "X", "dur": 0.15104171979584866, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890054.578, "ph": "X", "dur": 0.6901044094120671, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890055.548, "ph": "X", "dur": 0.3350695623057332, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890055.995, "ph": "X", "dur": 0.034722234435827275, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890056.336, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890056.473, "ph": "X", "dur": 0.1597222784048055, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890056.733, "ph": "X", "dur": 0.16232644598749252, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890056.281, "ph": "X", "dur": 0.6692710687505707, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890050.523, "ph": "X", "dur": 6.803821837700354, "name": "_eval_constraint.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:480)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890057.621, "ph": "X", "dur": 0.2439236969116866, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890059.66, "ph": "X", "dur": 0.07552085989792433, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890049.515, "ph": "X", "dur": 10.949656629338131, "name": "_eval_constraint (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:471)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890064.033, "ph": "X", "dur": 4.578994666224722, "name": "builtins.abs", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890076.37, "ph": "X", "dur": 1.5295144268981915, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890076.187, "ph": "X", "dur": 1.7717020120880869, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890075.957, "ph": "X", "dur": 2.0911465688976976, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890079.068, "ph": "X", "dur": 0.8272572354335848, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890078.959, "ph": "X", "dur": 0.9782989552294334, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890078.799, "ph": "X", "dur": 1.217014316975746, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890075.24, "ph": "X", "dur": 4.86892532376388, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890080.57, "ph": "X", "dur": 0.08072919506329843, "name": "_array_equal_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2456)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890081.736, "ph": "X", "dur": 0.057291686819115, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890081.872, "ph": "X", "dur": 0.026041675826870458, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890082.907, "ph": "X", "dur": 0.051215295792845235, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890083.34, "ph": "X", "dur": 0.9253475477147969, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890083.203, "ph": "X", "dur": 1.1197920605554295, "name": "_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:67)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890083.025, "ph": "X", "dur": 1.383681042267717, "name": "numpy.ndarray.all", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890081.63, "ph": "X", "dur": 2.9322926981056137, "name": "array_equal (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2475)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890085.265, "ph": "X", "dur": 0.11284726191643864, "name": "ScalarFunction._update_fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:293)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890087.68, "ph": "X", "dur": 0.16927089287465796, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890088.825, "ph": "X", "dur": 0.08333336264598545, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890090.054, "ph": "X", "dur": 0.07118058059344591, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890089.828, "ph": "X", "dur": 0.3585070705499166, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890089.416, "ph": "X", "dur": 0.95486144698525, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890088.163, "ph": "X", "dur": 2.284723025877435, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890090.641, "ph": "X", "dur": 0.38628485809857843, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890091.54, "ph": "X", "dur": 0.20486118317138094, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890091.911, "ph": "X", "dur": 0.09809031228121205, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890092.198, "ph": "X", "dur": 0.07031252473255023, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890091.411, "ph": "X", "dur": 1.288194897569192, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890092.81, "ph": "X", "dur": 0.05468751923642796, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890093.463, "ph": "X", "dur": 0.23003480313735572, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890091.291, "ph": "X", "dur": 2.5842022978864447, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890094.454, "ph": "X", "dur": 0.44704876836127616, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890094.302, "ph": "X", "dur": 0.6675349570287793, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890095.844, "ph": "X", "dur": 0.23784730588541683, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890095.651, "ph": "X", "dur": 0.48697933796247755, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890096.369, "ph": "X", "dur": 0.06770835714986319, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890096.22, "ph": "X", "dur": 0.24565980863347797, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890096.532, "ph": "X", "dur": 0.07812502748061137, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890095.295, "ph": "X", "dur": 1.6666672529197093, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890097.888, "ph": "X", "dur": 0.036458346157618636, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890098.353, "ph": "X", "dur": 0.03993056960120137, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890098.54, "ph": "X", "dur": 0.1866320100925716, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890098.864, "ph": "X", "dur": 0.283854266512888, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890098.302, "ph": "X", "dur": 0.9149308773840487, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890101.164, "ph": "X", "dur": 0.10763892675106455, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890102.477, "ph": "X", "dur": 0.07552085989792433, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890102.779, "ph": "X", "dur": 0.39670152842932666, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890103.755, "ph": "X", "dur": 1.2057295907841021, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890102.242, "ph": "X", "dur": 2.8229176596327576, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890101.738, "ph": "X", "dur": 3.419272036068091, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890106.738, "ph": "X", "dur": 0.4383682097523193, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890114.613, "ph": "X", "dur": 0.09288197711583795, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890117.441, "ph": "X", "dur": 0.09288197711583795, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890117.964, "ph": "X", "dur": 0.06510418956717613, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890118.87, "ph": "X", "dur": 0.07899308334150705, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890117.681, "ph": "X", "dur": 2.2960077520690785, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890123.384, "ph": "X", "dur": 0.06857641301075887, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890124.311, "ph": "X", "dur": 0.03298612271403591, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890124.529, "ph": "X", "dur": 0.3472223443582727, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890125.285, "ph": "X", "dur": 1.1527781832694655, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890124.128, "ph": "X", "dur": 2.3923619526284994, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890123.667, "ph": "X", "dur": 2.9227440836357608, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890127.778, "ph": "X", "dur": 0.25781259068601753, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890117.072, "ph": "X", "dur": 21.76736876782012, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890139.74, "ph": "X", "dur": 0.3750001319069346, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890140.246, "ph": "X", "dur": 0.19357645697973705, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890140.531, "ph": "X", "dur": 0.14409727290868318, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890140.831, "ph": "X", "dur": 0.39756958429022227, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890143.249, "ph": "X", "dur": 0.13281254671703935, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890143.531, "ph": "X", "dur": 0.07986113920240274, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890143.75, "ph": "X", "dur": 0.07204863645434159, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890143.131, "ph": "X", "dur": 1.0477434241010881, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890144.289, "ph": "X", "dur": 0.05555557509732364, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890144.883, "ph": "X", "dur": 0.16579866943107524, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890143.012, "ph": "X", "dur": 2.2178827245884674, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890145.809, "ph": "X", "dur": 0.3203126126705066, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890145.65, "ph": "X", "dur": 0.5364585220335314, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890147.084, "ph": "X", "dur": 0.07204863645434159, "name": "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890147.448, "ph": "X", "dur": 0.36111123813260365, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890147.318, "ph": "X", "dur": 0.5373265778944271, "name": "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890148.118, "ph": "X", "dur": 0.7439238727875994, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:8)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890149.202, "ph": "X", "dur": 0.047743072349262505, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890149.108, "ph": "X", "dur": 0.20399312731048524, "name": "isscalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:1927)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890146.67, "ph": "X", "dur": 2.7265634590733367, "name": "_wrapper_fun.<locals>.wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:16)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890149.628, "ph": "X", "dur": 0.04166668132299273, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890150.123, "ph": "X", "dur": 0.10156253572479479, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890150.381, "ph": "X", "dur": 0.23524313830272978, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890150.853, "ph": "X", "dur": 0.3211806685314023, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890150.06, "ph": "X", "dur": 1.1987851438969366, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890142.799, "ph": "X", "dur": 8.698787782035629, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890155.135, "ph": "X", "dur": 0.12065976466449978, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890155.387, "ph": "X", "dur": 0.052083351653740916, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890155.554, "ph": "X", "dur": 0.07291669231523727, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890155.037, "ph": "X", "dur": 0.8671878050347861, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890156.023, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890156.453, "ph": "X", "dur": 0.10156253572479479, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890154.921, "ph": "X", "dur": 1.751736727287486, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890157.121, "ph": "X", "dur": 0.31510427750513254, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890157.005, "ph": "X", "dur": 0.47222238832725094, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890158.098, "ph": "X", "dur": 0.06423613370628045, "name": "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890158.364, "ph": "X", "dur": 0.2777778754866182, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890158.279, "ph": "X", "dur": 0.40538208703828343, "name": "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890160.088, "ph": "X", "dur": 0.5173612930938264, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:8)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890160.907, "ph": "X", "dur": 0.039062513740305685, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890160.826, "ph": "X", "dur": 0.15538199910032705, "name": "isscalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:1927)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890157.791, "ph": "X", "dur": 3.265626148689555, "name": "_wrapper_fun.<locals>.wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:16)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890161.257, "ph": "X", "dur": 0.04166668132299273, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890161.621, "ph": "X", "dur": 0.08072919506329843, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890161.814, "ph": "X", "dur": 0.2144097976412334, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890162.186, "ph": "X", "dur": 0.20399312731048524, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890161.553, "ph": "X", "dur": 0.9088544863577789, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890154.719, "ph": "X", "dur": 7.881079161071896, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890164.96, "ph": "X", "dur": 0.08680558608956818, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890165.439, "ph": "X", "dur": 0.047743072349262505, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890165.555, "ph": "X", "dur": 0.06684030128896751, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890165.722, "ph": "X", "dur": 0.21267368591944205, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890165.284, "ph": "X", "dur": 0.7031252473255023, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890139.446, "ph": "X", "dur": 26.788203867240743, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890087.365, "ph": "X", "dur": 79.08943754206648, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890086.037, "ph": "X", "dur": 84.79082843642931, "name": "_wrapper_grad.<locals>.wrapped1 (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:46)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890084.872, "ph": "X", "dur": 86.26999562339554, "name": "ScalarFunction._update_grad (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:303)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890080.317, "ph": "X", "dur": 90.95923338395403, "name": "ScalarFunction.grad (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:329)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890075.099, "ph": "X", "dur": 96.23527690647799, "name": "_clip_x_for_func.<locals>.eval (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:303)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890171.489, "ph": "X", "dur": 0.07725697161971569, "name": "_append_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:5640)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890171.871, "ph": "X", "dur": 0.05468751923642796, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890172.307, "ph": "X", "dur": 0.05989585440180205, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890172.723, "ph": "X", "dur": 0.057291686819115, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890172.838, "ph": "X", "dur": 0.27604176376482686, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890173.203, "ph": "X", "dur": 0.11284726191643864, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890172.604, "ph": "X", "dur": 0.7517363755356605, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890173.851, "ph": "X", "dur": 0.09288197711583795, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890171.779, "ph": "X", "dur": 3.2838553217683644, "name": "append (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:5644)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890175.733, "ph": "X", "dur": 0.4800348910753121, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890178.697, "ph": "X", "dur": 1.4123268856772746, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890178.493, "ph": "X", "dur": 1.675347811528666, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890178.296, "ph": "X", "dur": 1.9609381897633456, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890181.245, "ph": "X", "dur": 0.8411461292079156, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890181.101, "ph": "X", "dur": 1.0347225861876528, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890180.928, "ph": "X", "dur": 1.2873268417082961, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890177.235, "ph": "X", "dur": 5.089411512431383, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890183.146, "ph": "X", "dur": 0.37065985260245615, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890183.983, "ph": "X", "dur": 0.07725697161971569, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890185.297, "ph": "X", "dur": 0.07465280403702865, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890185.076, "ph": "X", "dur": 0.3680556850197691, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890184.574, "ph": "X", "dur": 0.9930559048646601, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890183.811, "ph": "X", "dur": 1.8263895313245146, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890185.804, "ph": "X", "dur": 0.17274311631824069, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890186.415, "ph": "X", "dur": 0.1154514294991257, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890186.639, "ph": "X", "dur": 0.05381946337553228, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890187.737, "ph": "X", "dur": 0.07291669231523727, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890186.301, "ph": "X", "dur": 1.8602437098994462, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890188.278, "ph": "X", "dur": 0.039062513740305685, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890188.864, "ph": "X", "dur": 0.14756949635226593, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890186.21, "ph": "X", "dur": 2.921007971913969, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890189.6, "ph": "X", "dur": 0.436632098030528, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890189.47, "ph": "X", "dur": 0.608507158487873, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890190.899, "ph": "X", "dur": 0.1918403452579457, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890190.733, "ph": "X", "dur": 0.4105904222036575, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890191.358, "ph": "X", "dur": 0.07465280403702865, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890191.213, "ph": "X", "dur": 0.24826397621616503, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890191.517, "ph": "X", "dur": 0.07899308334150705, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890190.397, "ph": "X", "dur": 1.5451394323943137, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890193.118, "ph": "X", "dur": 0.09635420055942069, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890193.312, "ph": "X", "dur": 0.04079862546209705, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890193.465, "ph": "X", "dur": 0.03993056960120137, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890193.034, "ph": "X", "dur": 0.7196183086825203, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890193.853, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890194.249, "ph": "X", "dur": 0.10503475916837751, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890192.955, "ph": "X", "dur": 1.4861116338534073, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890194.804, "ph": "X", "dur": 0.3237848361140893, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890194.713, "ph": "X", "dur": 0.45659738283112866, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890195.521, "ph": "X", "dur": 0.6605905101416139, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890196.351, "ph": "X", "dur": 0.045138904766575456, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890196.845, "ph": "X", "dur": 0.038194457879410004, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890197.042, "ph": "X", "dur": 0.28211815479109664, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890197.532, "ph": "X", "dur": 0.2899306575391577, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890196.761, "ph": "X", "dur": 1.1223962281381166, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890192.809, "ph": "X", "dur": 5.252606014279771, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890199.801, "ph": "X", "dur": 0.10416670330748183, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890200.896, "ph": "X", "dur": 0.07378474817613297, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890201.18, "ph": "X", "dur": 0.39322930498574393, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890202.031, "ph": "X", "dur": 1.2109379259494764, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890200.725, "ph": "X", "dur": 2.6258689792094376, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890200.286, "ph": "X", "dur": 3.1579872219384906, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890204.95, "ph": "X", "dur": 0.4079862546209705, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890211.728, "ph": "X", "dur": 0.10329864744658615, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890213.976, "ph": "X", "dur": 0.06770835714986319, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890214.502, "ph": "X", "dur": 0.05815974268001069, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890215.228, "ph": "X", "dur": 0.08246530678508977, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890214.206, "ph": "X", "dur": 1.9626743014851367, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890218.32, "ph": "X", "dur": 0.06597224542807183, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890219.187, "ph": "X", "dur": 0.046875016488366825, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890219.445, "ph": "X", "dur": 0.26128481412960025, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890220.081, "ph": "X", "dur": 1.0520837034055663, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890219.03, "ph": "X", "dur": 2.1779521549872656, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890218.608, "ph": "X", "dur": 2.697049559802884, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890223.598, "ph": "X", "dur": 0.2447917527725823, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890213.658, "ph": "X", "dur": 21.20226440237703, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890235.741, "ph": "X", "dur": 0.3350695623057332, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890236.193, "ph": "X", "dur": 0.18402784250988455, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890236.457, "ph": "X", "dur": 0.15277783151764002, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890236.763, "ph": "X", "dur": 0.36024318227170793, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890238.885, "ph": "X", "dur": 0.10243059158569047, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890239.128, "ph": "X", "dur": 0.07118058059344591, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890239.32, "ph": "X", "dur": 0.039062513740305685, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890238.779, "ph": "X", "dur": 0.9157989332449443, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890239.811, "ph": "X", "dur": 0.057291686819115, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890240.352, "ph": "X", "dur": 0.1493056080740573, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890238.687, "ph": "X", "dur": 1.9609381897633456, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890241.28, "ph": "X", "dur": 0.33246539472304615, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890241.157, "ph": "X", "dur": 0.5156251813720351, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890242.042, "ph": "X", "dur": 0.638889113619222, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890242.87, "ph": "X", "dur": 0.044270848905679776, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890243.331, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890243.495, "ph": "X", "dur": 0.24826397621616503, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890243.953, "ph": "X", "dur": 0.2717014844603484, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890243.246, "ph": "X", "dur": 1.0486114799619837, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890238.487, "ph": "X", "dur": 5.968752099518709, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890247.848, "ph": "X", "dur": 0.07812502748061137, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890248.056, "ph": "X", "dur": 0.05295140751463659, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890248.205, "ph": "X", "dur": 0.03993056960120137, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890247.746, "ph": "X", "dur": 0.761284990005513, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890248.607, "ph": "X", "dur": 0.038194457879410004, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890249.021, "ph": "X", "dur": 0.12326393224718683, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890247.657, "ph": "X", "dur": 1.593750560604472, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890249.659, "ph": "X", "dur": 0.3107639982006541, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890249.537, "ph": "X", "dur": 0.47569461177083366, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890250.27, "ph": "X", "dur": 0.3680556850197691, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890250.767, "ph": "X", "dur": 0.04340279304478409, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890251.155, "ph": "X", "dur": 0.034722234435827275, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890251.274, "ph": "X", "dur": 0.1918403452579457, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890251.61, "ph": "X", "dur": 0.1779514514836148, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890251.093, "ph": "X", "dur": 0.7569447107010346, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890247.486, "ph": "X", "dur": 4.48698074496978, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890254.194, "ph": "X", "dur": 0.14583338463047454, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890254.858, "ph": "X", "dur": 0.06684030128896751, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890255.001, "ph": "X", "dur": 0.046875016488366825, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890255.13, "ph": "X", "dur": 0.1666667252919709, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890254.554, "ph": "X", "dur": 0.8116322299374625, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890235.459, "ph": "X", "dur": 20.145840419666982, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890182.862, "ph": "X", "dur": 72.952282605534, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890177.081, "ph": "X", "dur": 79.28735427835069, "name": "_minimize_slsqp.<locals>.cjac_factory.<locals>.cjac (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:300)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890258.912, "ph": "X", "dur": 1.3706602043542817, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890258.706, "ph": "X", "dur": 1.6302089067620904, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890258.524, "ph": "X", "dur": 1.9149312291358742, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890261.418, "ph": "X", "dur": 0.851562799538664, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890261.297, "ph": "X", "dur": 1.0173614689697392, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890261.114, "ph": "X", "dur": 1.2786462830993395, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890257.853, "ph": "X", "dur": 4.639758576487419, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890263.218, "ph": "X", "dur": 0.14149310532599613, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890263.766, "ph": "X", "dur": 0.06684030128896751, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890264.975, "ph": "X", "dur": 0.05468751923642796, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890264.746, "ph": "X", "dur": 0.3524306795236469, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890264.307, "ph": "X", "dur": 0.9444447766545019, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890263.633, "ph": "X", "dur": 1.6744797556677704, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890265.46, "ph": "X", "dur": 0.15364588737853568, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890266.09, "ph": "X", "dur": 0.07899308334150705, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890266.246, "ph": "X", "dur": 0.07725697161971569, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890266.402, "ph": "X", "dur": 0.057291686819115, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890265.979, "ph": "X", "dur": 0.7630211017273043, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890266.849, "ph": "X", "dur": 0.037326402018514324, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890267.318, "ph": "X", "dur": 0.10156253572479479, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890265.852, "ph": "X", "dur": 1.683160314276727, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890268.023, "ph": "X", "dur": 0.3237848361140893, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890267.903, "ph": "X", "dur": 0.48697933796247755, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890269.142, "ph": "X", "dur": 0.13802088188241343, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890268.989, "ph": "X", "dur": 0.341145953332003, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890269.522, "ph": "X", "dur": 0.06684030128896751, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890269.393, "ph": "X", "dur": 0.22309035625019025, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890269.687, "ph": "X", "dur": 0.06597224542807183, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890268.694, "ph": "X", "dur": 1.3446185285274113, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890271.084, "ph": "X", "dur": 0.09722225642031637, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890271.282, "ph": "X", "dur": 0.046875016488366825, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890271.405, "ph": "X", "dur": 0.032118066853140226, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890271.006, "ph": "X", "dur": 0.6762155156377362, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890271.768, "ph": "X", "dur": 0.037326402018514324, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890272.103, "ph": "X", "dur": 0.08246530678508977, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890270.927, "ph": "X", "dur": 1.350694919553681, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890272.617, "ph": "X", "dur": 0.28038204306930525, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890272.527, "ph": "X", "dur": 0.4322918187260496, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890273.201, "ph": "X", "dur": 0.6137154936532471, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890273.964, "ph": "X", "dur": 0.044270848905679776, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890274.416, "ph": "X", "dur": 0.04340279304478409, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890274.629, "ph": "X", "dur": 0.21875007694571183, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890275.022, "ph": "X", "dur": 0.23263897072004275, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890274.328, "ph": "X", "dur": 0.9765628435076421, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890270.803, "ph": "X", "dur": 4.688369704697577, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890277.236, "ph": "X", "dur": 0.20312507144958958, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890278.561, "ph": "X", "dur": 0.05815974268001069, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890279.776, "ph": "X", "dur": 0.4079862546209705, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890280.614, "ph": "X", "dur": 1.1449656805214046, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890278.379, "ph": "X", "dur": 3.4852442814961626, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890277.82, "ph": "X", "dur": 4.150175070942255, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890283.364, "ph": "X", "dur": 0.39930569601201366, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890289.983, "ph": "X", "dur": 0.10763892675106455, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890292.297, "ph": "X", "dur": 0.09635420055942069, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890292.807, "ph": "X", "dur": 0.07638891575882001, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890293.555, "ph": "X", "dur": 0.12152782052539547, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890292.555, "ph": "X", "dur": 1.9843756980075289, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890296.68, "ph": "X", "dur": 0.10156253572479479, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890297.634, "ph": "X", "dur": 0.046875016488366825, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890297.909, "ph": "X", "dur": 0.2769098196257225, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890298.518, "ph": "X", "dur": 1.0416670330748181, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890297.493, "ph": "X", "dur": 2.1406257529687513, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890296.996, "ph": "X", "dur": 2.7065981742727363, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890300.868, "ph": "X", "dur": 0.2152778535021291, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890291.97, "ph": "X", "dur": 19.487854077108057, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890312.311, "ph": "X", "dur": 0.302951495452593, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890312.749, "ph": "X", "dur": 0.1770833956227191, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890313.009, "ph": "X", "dur": 0.14670144049137024, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890313.296, "ph": "X", "dur": 0.3541667912454382, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890315.353, "ph": "X", "dur": 0.12673615569076954, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890315.608, "ph": "X", "dur": 0.07638891575882001, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890315.776, "ph": "X", "dur": 0.05642363095821932, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890315.242, "ph": "X", "dur": 0.9097225422186745, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890316.268, "ph": "X", "dur": 0.048611128210158186, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890316.805, "ph": "X", "dur": 0.13802088188241343, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890315.133, "ph": "X", "dur": 1.9461812401281189, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890317.685, "ph": "X", "dur": 0.2907987134000534, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890317.568, "ph": "X", "dur": 0.4496529359439632, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890318.397, "ph": "X", "dur": 0.6657988453069881, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890319.218, "ph": "X", "dur": 0.04340279304478409, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890319.723, "ph": "X", "dur": 0.07638891575882001, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890319.962, "ph": "X", "dur": 0.22569452383287728, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890320.397, "ph": "X", "dur": 0.264757037573183, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890319.647, "ph": "X", "dur": 1.099826775754829, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890314.976, "ph": "X", "dur": 5.960071540909752, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890324.338, "ph": "X", "dur": 0.11631948536002137, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890324.557, "ph": "X", "dur": 0.04947918407105387, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890324.681, "ph": "X", "dur": 0.04166668132299273, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890324.237, "ph": "X", "dur": 0.7630211017273043, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890325.097, "ph": "X", "dur": 0.05555557509732364, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890325.526, "ph": "X", "dur": 0.09288197711583795, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890324.144, "ph": "X", "dur": 1.5815977785519324, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890326.113, "ph": "X", "dur": 0.28298621065199225, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890325.996, "ph": "X", "dur": 1.3255212995877061, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890327.585, "ph": "X", "dur": 0.43750015389142366, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890328.163, "ph": "X", "dur": 0.04340279304478409, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890328.601, "ph": "X", "dur": 0.06857641301075887, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890328.765, "ph": "X", "dur": 0.18402784250988455, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890329.097, "ph": "X", "dur": 0.17361117217913635, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890328.513, "ph": "X", "dur": 0.8229169561291064, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890323.963, "ph": "X", "dur": 5.503474158078623, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890331.703, "ph": "X", "dur": 0.10590281502927318, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890332.136, "ph": "X", "dur": 0.044270848905679776, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890332.278, "ph": "X", "dur": 0.05468751923642796, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890332.421, "ph": "X", "dur": 0.17881950734451046, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890331.998, "ph": "X", "dur": 0.6553821749762399, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890312.032, "ph": "X", "dur": 20.851569834575173, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890262.937, "ph": "X", "dur": 70.16408718033706, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890257.71, "ph": "X", "dur": 75.86547807469991, "name": "_minimize_slsqp.<locals>.cjac_factory.<locals>.cjac (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:300)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890335.24, "ph": "X", "dur": 1.3072921265088968, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890335.05, "ph": "X", "dur": 1.5529519351423748, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890334.854, "ph": "X", "dur": 1.8376742575161586, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890337.647, "ph": "X", "dur": 0.7934030568586533, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890337.544, "ph": "X", "dur": 0.9409725532109191, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890337.373, "ph": "X", "dur": 1.1918406970097712, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890334.236, "ph": "X", "dur": 4.440105728481412, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890342.044, "ph": "X", "dur": 0.14236116118689182, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890342.591, "ph": "X", "dur": 0.07986113920240274, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890343.862, "ph": "X", "dur": 0.06770835714986319, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890343.648, "ph": "X", "dur": 0.36284734985439504, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890343.175, "ph": "X", "dur": 0.990451737281973, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890342.47, "ph": "X", "dur": 1.7473964479830078, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890344.379, "ph": "X", "dur": 0.1597222784048055, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890345.013, "ph": "X", "dur": 0.07812502748061137, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890345.194, "ph": "X", "dur": 0.06163196612359342, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890345.404, "ph": "X", "dur": 0.05989585440180205, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890344.898, "ph": "X", "dur": 0.8637155815912034, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890345.868, "ph": "X", "dur": 0.033854178574931594, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890346.34, "ph": "X", "dur": 0.09982642400300341, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890344.796, "ph": "X", "dur": 1.7508686714265902, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890347.031, "ph": "X", "dur": 0.3506945678018555, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890346.919, "ph": "X", "dur": 0.5043404551803912, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890348.485, "ph": "X", "dur": 0.15190977565674432, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890348.334, "ph": "X", "dur": 0.3463542884973771, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890348.873, "ph": "X", "dur": 0.07812502748061137, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890348.745, "ph": "X", "dur": 0.23611119416362547, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890349.048, "ph": "X", "dur": 0.06336807784538477, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890347.708, "ph": "X", "dur": 1.7335075542086769, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890350.523, "ph": "X", "dur": 0.07638891575882001, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890350.676, "ph": "X", "dur": 0.04253473718388841, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890352.498, "ph": "X", "dur": 0.05034723993194955, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890350.435, "ph": "X", "dur": 2.3993063995156647, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890352.945, "ph": "X", "dur": 0.039062513740305685, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890353.338, "ph": "X", "dur": 0.10329864744658615, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890350.355, "ph": "X", "dur": 3.1901052887916306, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890353.971, "ph": "X", "dur": 0.2986112161481146, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890353.865, "ph": "X", "dur": 0.44704876836127616, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890354.661, "ph": "X", "dur": 0.6145835495141427, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890355.447, "ph": "X", "dur": 0.04253473718388841, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890356.012, "ph": "X", "dur": 0.05295140751463659, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890356.231, "ph": "X", "dur": 0.24131952932899955, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890356.65, "ph": "X", "dur": 0.2656250934340787, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890355.936, "ph": "X", "dur": 1.0572920385709406, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890350.194, "ph": "X", "dur": 6.953995501635307, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890358.833, "ph": "X", "dur": 0.10677087089016886, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890359.93, "ph": "X", "dur": 0.06770835714986319, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890360.196, "ph": "X", "dur": 0.3828126346549957, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890360.985, "ph": "X", "dur": 1.181424026679023, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890359.792, "ph": "X", "dur": 2.4739592035526936, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890359.345, "ph": "X", "dur": 3.0225705076387643, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890363.798, "ph": "X", "dur": 0.417534869090823, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890370.673, "ph": "X", "dur": 0.16059033426570116, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890374.47, "ph": "X", "dur": 0.12760421155166524, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890375.252, "ph": "X", "dur": 0.08246530678508977, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890376.009, "ph": "X", "dur": 0.07638891575882001, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890374.795, "ph": "X", "dur": 2.180556322569953, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890379.338, "ph": "X", "dur": 0.08420141850688113, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890380.701, "ph": "X", "dur": 0.04947918407105387, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890381.197, "ph": "X", "dur": 0.3203126126705066, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890381.904, "ph": "X", "dur": 1.0607642620145232, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890380.512, "ph": "X", "dur": 2.535591169676287, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890379.878, "ph": "X", "dur": 3.239584472862685, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890384.263, "ph": "X", "dur": 0.23697925002452114, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890372.702, "ph": "X", "dur": 22.253480049921702, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890395.787, "ph": "X", "dur": 0.3046876071743843, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890396.198, "ph": "X", "dur": 0.18836812181436297, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890396.47, "ph": "X", "dur": 0.1484375522131616, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890396.747, "ph": "X", "dur": 0.3541667912454382, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890398.811, "ph": "X", "dur": 0.0859375302286725, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890399.041, "ph": "X", "dur": 0.07031252473255023, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890399.223, "ph": "X", "dur": 0.06684030128896751, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890398.709, "ph": "X", "dur": 0.894965592583448, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890399.713, "ph": "X", "dur": 0.037326402018514324, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890400.172, "ph": "X", "dur": 0.1102430943337516, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890398.624, "ph": "X", "dur": 1.809028414106601, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890400.937, "ph": "X", "dur": 0.34548623263648137, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890400.828, "ph": "X", "dur": 1.7074658783818064, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890402.915, "ph": "X", "dur": 0.6189238288186212, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890403.739, "ph": "X", "dur": 0.046875016488366825, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890404.275, "ph": "X", "dur": 0.06597224542807183, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890404.497, "ph": "X", "dur": 0.2343750824418341, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890404.937, "ph": "X", "dur": 0.28819454581736637, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890404.2, "ph": "X", "dur": 1.1067712226419943, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890398.425, "ph": "X", "dur": 7.053821925638311, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890408.942, "ph": "X", "dur": 0.09548614469852501, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890409.149, "ph": "X", "dur": 0.06684030128896751, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890409.287, "ph": "X", "dur": 0.04079862546209705, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890408.842, "ph": "X", "dur": 0.7378474817613296, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890409.676, "ph": "X", "dur": 0.036458346157618636, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890410.114, "ph": "X", "dur": 0.10850698261196023, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890408.759, "ph": "X", "dur": 1.5842019461346195, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890410.914, "ph": "X", "dur": 0.2890626016782621, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890410.809, "ph": "X", "dur": 0.436632098030528, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890411.542, "ph": "X", "dur": 0.40625014289917916, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890412.099, "ph": "X", "dur": 0.04600696062747114, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890412.509, "ph": "X", "dur": 0.060763910262697736, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890412.686, "ph": "X", "dur": 0.1666667252919709, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890412.989, "ph": "X", "dur": 0.17361117217913635, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890412.429, "ph": "X", "dur": 0.7829863865279051, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890408.577, "ph": "X", "dur": 4.769966955621772, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890415.565, "ph": "X", "dur": 0.08246530678508977, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890415.963, "ph": "X", "dur": 0.04340279304478409, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890416.095, "ph": "X", "dur": 0.04166668132299273, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890416.227, "ph": "X", "dur": 0.17274311631824069, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890415.832, "ph": "X", "dur": 0.6258682757057867, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890395.511, "ph": "X", "dur": 21.20052829065524, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890339.114, "ph": "X", "dur": 77.81252737068893, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890334.101, "ph": "X", "dur": 83.21530704890365, "name": "_minimize_slsqp.<locals>.cjac_factory.<locals>.cjac (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:300)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890176.643, "ph": "X", "dur": 241.07300146450518, "name": "_eval_con_normals.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:499)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890418.212, "ph": "X", "dur": 0.171875060457345, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890418.095, "ph": "X", "dur": 0.5043404551803912, "name": "_arrays_for_stack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:208)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890417.947, "ph": "X", "dur": 0.7265627555696856, "name": "_vhstack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:216)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890419.082, "ph": "X", "dur": 0.047743072349262505, "name": "_atleast_2d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:76)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890419.461, "ph": "X", "dur": 0.04079862546209705, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890420.273, "ph": "X", "dur": 0.1006944798638991, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890420.528, "ph": "X", "dur": 0.038194457879410004, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890420.902, "ph": "X", "dur": 0.04947918407105387, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890421.029, "ph": "X", "dur": 0.02777778754866182, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890421.332, "ph": "X", "dur": 0.026041675826870458, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890421.495, "ph": "X", "dur": 0.06423613370628045, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890419.274, "ph": "X", "dur": 2.4539939187520927, "name": "atleast_2d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:80)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890422.002, "ph": "X", "dur": 0.045138904766575456, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890422.371, "ph": "X", "dur": 0.07552085989792433, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890418.853, "ph": "X", "dur": 6.313370276294294, "name": "vstack (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:220)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890426.162, "ph": "X", "dur": 0.11805559708181274, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890426.085, "ph": "X", "dur": 0.31684038922692387, "name": "_arrays_for_stack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:208)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890425.963, "ph": "X", "dur": 0.5095487903457653, "name": "_vhstack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:216)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890426.819, "ph": "X", "dur": 0.05555557509732364, "name": "_atleast_2d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:76)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890427.182, "ph": "X", "dur": 0.024305564105079093, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890427.42, "ph": "X", "dur": 0.044270848905679776, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890427.525, "ph": "X", "dur": 0.023437508244183412, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890427.693, "ph": "X", "dur": 0.034722234435827275, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890427.795, "ph": "X", "dur": 0.07118058059344591, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890427.036, "ph": "X", "dur": 0.9791670110903292, "name": "atleast_2d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:80)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890428.251, "ph": "X", "dur": 0.029513899270453184, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890428.484, "ph": "X", "dur": 0.038194457879410004, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890426.611, "ph": "X", "dur": 3.072049691709818, "name": "vstack (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:220)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890429.997, "ph": "X", "dur": 0.4409723773350064, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890430.768, "ph": "X", "dur": 0.044270848905679776, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890175.546, "ph": "X", "dur": 256.35859711901725, "name": "_eval_con_normals (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:490)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890433.74, "ph": "X", "dur": 0.627604387427578, "name": "builtins.abs", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890443.622, "ph": "X", "dur": 1.593750560604472, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890443.403, "ph": "X", "dur": 1.8845492740045253, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890443.157, "ph": "X", "dur": 2.231771618362798, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890446.413, "ph": "X", "dur": 0.8585072464258294, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890446.292, "ph": "X", "dur": 1.0190975806915306, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890446.11, "ph": "X", "dur": 1.2916671210127748, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890442.352, "ph": "X", "dur": 5.152779590276768, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890448.141, "ph": "X", "dur": 0.09635420055942069, "name": "_array_equal_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2456)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890448.496, "ph": "X", "dur": 0.060763910262697736, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890448.631, "ph": "X", "dur": 0.0286458434095575, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890449.7, "ph": "X", "dur": 0.05034723993194955, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890450.31, "ph": "X", "dur": 0.8836808663918041, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890450.128, "ph": "X", "dur": 1.1085073343637857, "name": "_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:67)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890449.826, "ph": "X", "dur": 1.486979689714303, "name": "numpy.ndarray.all", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890448.408, "ph": "X", "dur": 3.0815983061796706, "name": "array_equal (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2475)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890452.038, "ph": "X", "dur": 0.09982642400300341, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890452.708, "ph": "X", "dur": 0.07118058059344591, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890454.12, "ph": "X", "dur": 0.07465280403702865, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890453.875, "ph": "X", "dur": 0.39930569601201366, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890453.348, "ph": "X", "dur": 1.1006948316157246, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890452.52, "ph": "X", "dur": 1.9887159773120073, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890454.786, "ph": "X", "dur": 0.17881950734451046, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890455.412, "ph": "X", "dur": 0.4496529359439632, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890455.292, "ph": "X", "dur": 0.6319446667320564, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890451.845, "ph": "X", "dur": 4.332466801730348, "name": "ScalarFunction._update_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:270)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890457.269, "ph": "X", "dur": 0.15017366393495296, "name": "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890457.782, "ph": "X", "dur": 0.47048627660545955, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890457.564, "ph": "X", "dur": 0.7335072024568511, "name": "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890459.57, "ph": "X", "dur": 0.9418406090718148, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:8)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890460.945, "ph": "X", "dur": 0.057291686819115, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890460.836, "ph": "X", "dur": 0.2309028589982514, "name": "isscalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:1927)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890456.779, "ph": "X", "dur": 4.368925147887967, "name": "_wrapper_fun.<locals>.wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:16)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890456.499, "ph": "X", "dur": 5.167536539911994, "name": "ScalarFunction._update_fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:293)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890447.781, "ph": "X", "dur": 14.007817427273618, "name": "ScalarFunction.fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:323)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890442.201, "ph": "X", "dur": 19.643236076208385, "name": "_clip_x_for_func.<locals>.eval (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:303)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890462.265, "ph": "X", "dur": 0.3333334505839418, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890463.484, "ph": "X", "dur": 0.5225696282592005, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890464.225, "ph": "X", "dur": 0.05034723993194955, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890465.035, "ph": "X", "dur": 0.09027780953315091, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890465.312, "ph": "X", "dur": 0.28038204306930525, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890465.81, "ph": "X", "dur": 0.319444556809611, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890464.953, "ph": "X", "dur": 1.2534726631333646, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890466.609, "ph": "X", "dur": 0.42708348356067544, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890467.157, "ph": "X", "dur": 0.052083351653740916, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890467.516, "ph": "X", "dur": 0.06336807784538477, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890467.683, "ph": "X", "dur": 0.1397569936042048, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890467.929, "ph": "X", "dur": 0.15625005496122274, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890467.46, "ph": "X", "dur": 0.6814238508031103, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890468.434, "ph": "X", "dur": 0.30729177475707137, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890468.853, "ph": "X", "dur": 0.033854178574931594, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890469.192, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890469.312, "ph": "X", "dur": 0.15625005496122274, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890469.574, "ph": "X", "dur": 0.1388889377433091, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890469.135, "ph": "X", "dur": 0.6328127225929522, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890463.083, "ph": "X", "dur": 6.799481558395876, "name": "_eval_constraint.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:480)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890470.183, "ph": "X", "dur": 0.07118058059344591, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890471.919, "ph": "X", "dur": 0.044270848905679776, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890462.091, "ph": "X", "dur": 10.645837078024643, "name": "_eval_constraint (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:471)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890475.065, "ph": "X", "dur": 0.6067710467660816, "name": "builtins.abs", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890481.2, "ph": "X", "dur": 1.2248268197238072, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890480.991, "ph": "X", "dur": 1.4765630193835548, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890480.752, "ph": "X", "dur": 1.802952023080331, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890483.524, "ph": "X", "dur": 0.8289933471553762, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890483.416, "ph": "X", "dur": 0.9765628435076421, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890483.251, "ph": "X", "dur": 1.2256948755847028, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890480.131, "ph": "X", "dur": 4.457466845699327, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890485.068, "ph": "X", "dur": 0.10243059158569047, "name": "_array_equal_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2456)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890485.421, "ph": "X", "dur": 0.036458346157618636, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890485.507, "ph": "X", "dur": 0.034722234435827275, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890486.474, "ph": "X", "dur": 0.05555557509732364, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890486.916, "ph": "X", "dur": 0.8342016823207502, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890486.759, "ph": "X", "dur": 1.0338545303267572, "name": "_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:67)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890486.591, "ph": "X", "dur": 1.2829865624038177, "name": "numpy.ndarray.all", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890485.335, "ph": "X", "dur": 2.696181503941988, "name": "array_equal (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2475)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890488.435, "ph": "X", "dur": 0.09027780953315091, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890489.93, "ph": "X", "dur": 0.08072919506329843, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890491.166, "ph": "X", "dur": 0.07986113920240274, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890490.969, "ph": "X", "dur": 0.33246539472304615, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890490.508, "ph": "X", "dur": 0.9435767207936062, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890489.77, "ph": "X", "dur": 1.7552089507310689, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890491.75, "ph": "X", "dur": 0.18923617767525866, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890492.389, "ph": "X", "dur": 0.39496541670753527, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890492.253, "ph": "X", "dur": 0.5772571474956285, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890488.307, "ph": "X", "dur": 4.71614749224624, "name": "ScalarFunction._update_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:270)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890494.298, "ph": "X", "dur": 0.1006944798638991, "name": "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890494.66, "ph": "X", "dur": 0.29600704856542753, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890494.518, "ph": "X", "dur": 0.48350711451889483, "name": "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890495.242, "ph": "X", "dur": 0.8463544643732899, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:8)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890496.629, "ph": "X", "dur": 0.07031252473255023, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890496.369, "ph": "X", "dur": 0.39322930498574393, "name": "isscalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:1927)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890493.413, "ph": "X", "dur": 3.4305567622597346, "name": "_wrapper_fun.<locals>.wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:16)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890493.182, "ph": "X", "dur": 4.085070881375079, "name": "ScalarFunction._update_fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:293)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890484.782, "ph": "X", "dur": 12.589414150570073, "name": "ScalarFunction.fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:323)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890479.983, "ph": "X", "dur": 17.446186692281415, "name": "_clip_x_for_func.<locals>.eval (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:303)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890497.762, "ph": "X", "dur": 0.2899306575391577, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890498.634, "ph": "X", "dur": 0.4192709808126144, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890499.223, "ph": "X", "dur": 0.045138904766575456, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890499.669, "ph": "X", "dur": 0.06944446887165455, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890499.85, "ph": "X", "dur": 0.1961806245624241, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890500.22, "ph": "X", "dur": 0.24826397621616503, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890499.588, "ph": "X", "dur": 0.9739586759249551, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890500.894, "ph": "X", "dur": 0.37065985260245615, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890501.392, "ph": "X", "dur": 0.035590290296722955, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890501.747, "ph": "X", "dur": 0.03993056960120137, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890501.885, "ph": "X", "dur": 0.16059033426570116, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890502.153, "ph": "X", "dur": 0.1493056080740573, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890501.691, "ph": "X", "dur": 0.6692710687505707, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890502.63, "ph": "X", "dur": 0.3020834395916973, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890503.044, "ph": "X", "dur": 0.033854178574931594, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890503.364, "ph": "X", "dur": 0.03993056960120137, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890503.51, "ph": "X", "dur": 0.1579861666830141, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890503.781, "ph": "X", "dur": 0.1484375522131616, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890503.313, "ph": "X", "dur": 0.6805557949422145, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890498.383, "ph": "X", "dur": 5.710939508832691, "name": "_eval_constraint.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:480)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890504.372, "ph": "X", "dur": 0.06944446887165455, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890505.777, "ph": "X", "dur": 0.05989585440180205, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890497.622, "ph": "X", "dur": 8.863718395605806, "name": "_eval_constraint (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:471)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890508.572, "ph": "X", "dur": 0.5425349130598012, "name": "builtins.abs", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890521.18, "ph": "X", "dur": 1.2439240486635121, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890520.974, "ph": "X", "dur": 1.5043408069322168, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890520.773, "ph": "X", "dur": 1.7968756320540615, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890524.433, "ph": "X", "dur": 0.8289933471553762, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890524.322, "ph": "X", "dur": 0.9869795138383903, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890524.149, "ph": "X", "dur": 1.2404518252199292, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890520.169, "ph": "X", "dur": 5.324654650734113, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890525.949, "ph": "X", "dur": 0.09461808883762933, "name": "_array_equal_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2456)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890526.299, "ph": "X", "dur": 0.031250010992244545, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890526.391, "ph": "X", "dur": 0.035590290296722955, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890527.391, "ph": "X", "dur": 0.044270848905679776, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890527.824, "ph": "X", "dur": 0.8741322519219515, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890527.661, "ph": "X", "dur": 1.0815976026760195, "name": "_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:67)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890527.502, "ph": "X", "dur": 1.3203129644223321, "name": "numpy.ndarray.all", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890526.201, "ph": "X", "dur": 2.742188464569459, "name": "array_equal (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2475)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890529.669, "ph": "X", "dur": 0.401041807733805, "name": "ScalarFunction._update_fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:293)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890531.921, "ph": "X", "dur": 0.17013894873555363, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890532.543, "ph": "X", "dur": 0.08420141850688113, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890533.576, "ph": "X", "dur": 0.07378474817613297, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890533.391, "ph": "X", "dur": 0.3064237188961757, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890533.036, "ph": "X", "dur": 0.7977433361631316, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890532.368, "ph": "X", "dur": 1.5668408289167057, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890534.136, "ph": "X", "dur": 0.17274311631824069, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890534.827, "ph": "X", "dur": 0.15364588737853568, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890535.147, "ph": "X", "dur": 0.08854169781135955, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890535.355, "ph": "X", "dur": 0.08680558608956818, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890534.707, "ph": "X", "dur": 1.10763927850289, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890535.917, "ph": "X", "dur": 0.05034723993194955, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890536.52, "ph": "X", "dur": 0.20312507144958958, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890534.571, "ph": "X", "dur": 2.3229174837568447, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890537.428, "ph": "X", "dur": 0.5546876951123407, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890537.295, "ph": "X", "dur": 0.7430558169267036, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890538.852, "ph": "X", "dur": 0.16579866943107524, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890538.684, "ph": "X", "dur": 0.3871529139594741, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890539.267, "ph": "X", "dur": 0.06597224542807183, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890539.148, "ph": "X", "dur": 0.23350702658093844, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890539.444, "ph": "X", "dur": 0.07118058059344591, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890538.353, "ph": "X", "dur": 1.5434033206725224, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890540.795, "ph": "X", "dur": 0.04253473718388841, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890541.363, "ph": "X", "dur": 0.07291669231523727, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890541.617, "ph": "X", "dur": 0.24131952932899955, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890542.044, "ph": "X", "dur": 0.32812511541856776, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890541.291, "ph": "X", "dur": 1.1597226301566308, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890544.325, "ph": "X", "dur": 0.10763892675106455, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890545.566, "ph": "X", "dur": 0.07465280403702865, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890545.865, "ph": "X", "dur": 0.398437640151118, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890546.75, "ph": "X", "dur": 1.1414934570778217, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890545.345, "ph": "X", "dur": 2.659723157784369, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890544.862, "ph": "X", "dur": 3.2586817018023897, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890549.608, "ph": "X", "dur": 0.42013903667351005, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890557.931, "ph": "X", "dur": 0.0911458653940466, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890560.52, "ph": "X", "dur": 0.08506947436777682, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890561.059, "ph": "X", "dur": 0.05381946337553228, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890561.828, "ph": "X", "dur": 0.06510418956717613, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890560.776, "ph": "X", "dur": 2.049479887574705, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890565.302, "ph": "X", "dur": 0.07465280403702865, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890566.379, "ph": "X", "dur": 0.031250010992244545, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890566.621, "ph": "X", "dur": 0.26996537273855703, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890567.273, "ph": "X", "dur": 1.0364586979094443, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890566.203, "ph": "X", "dur": 2.2022577190923447, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890565.804, "ph": "X", "dur": 2.681424554306761, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890569.649, "ph": "X", "dur": 0.2769098196257225, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890560.161, "ph": "X", "dur": 20.341152988368513, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890581.385, "ph": "X", "dur": 0.3776042994896216, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890581.888, "ph": "X", "dur": 0.22569452383287728, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890582.194, "ph": "X", "dur": 0.15277783151764002, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890582.497, "ph": "X", "dur": 0.40538208703828343, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890584.943, "ph": "X", "dur": 0.17447922804003207, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890585.282, "ph": "X", "dur": 0.08767364195046387, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890585.503, "ph": "X", "dur": 0.06163196612359342, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890584.832, "ph": "X", "dur": 1.0607642620145232, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890586.021, "ph": "X", "dur": 0.036458346157618636, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890586.595, "ph": "X", "dur": 0.12065976466449978, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890584.726, "ph": "X", "dur": 2.1588549260475607, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890587.385, "ph": "X", "dur": 0.34895845608006415, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890587.248, "ph": "X", "dur": 0.5468751923642795, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890588.708, "ph": "X", "dur": 0.08767364195046387, "name": "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890589.062, "ph": "X", "dur": 0.3715279084633518, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890588.943, "ph": "X", "dur": 0.5364585220335314, "name": "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890589.747, "ph": "X", "dur": 0.7074655266299806, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:8)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890590.81, "ph": "X", "dur": 0.037326402018514324, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890590.683, "ph": "X", "dur": 0.2248264679719816, "name": "isscalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:1927)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890588.302, "ph": "X", "dur": 2.6944453922201963, "name": "_wrapper_fun.<locals>.wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:16)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890591.262, "ph": "X", "dur": 0.04340279304478409, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890591.815, "ph": "X", "dur": 0.07638891575882001, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890592.085, "ph": "X", "dur": 0.24218758518989522, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890592.567, "ph": "X", "dur": 0.28559037823467937, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890591.736, "ph": "X", "dur": 1.195312920453354, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890584.493, "ph": "X", "dur": 8.63368359246845, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890596.652, "ph": "X", "dur": 0.09722225642031637, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890596.876, "ph": "X", "dur": 0.06857641301075887, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890597.039, "ph": "X", "dur": 0.04166668132299273, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890596.549, "ph": "X", "dur": 0.80208361546761, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890597.454, "ph": "X", "dur": 0.038194457879410004, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890597.822, "ph": "X", "dur": 0.08940975367225523, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890596.44, "ph": "X", "dur": 1.5954866723262633, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890598.504, "ph": "X", "dur": 0.3229167802531937, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890598.398, "ph": "X", "dur": 1.3532990871363682, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890600.326, "ph": "X", "dur": 0.09201392125494227, "name": "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890600.654, "ph": "X", "dur": 0.3098959423397584, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890600.547, "ph": "X", "dur": 0.4496529359439632, "name": "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890601.212, "ph": "X", "dur": 0.46354182971829416, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:8)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890601.962, "ph": "X", "dur": 0.037326402018514324, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890601.891, "ph": "X", "dur": 0.14149310532599613, "name": "isscalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:1927)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890600.082, "ph": "X", "dur": 2.011285429695295, "name": "_wrapper_fun.<locals>.wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:16)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890602.284, "ph": "X", "dur": 0.03298612271403591, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890602.671, "ph": "X", "dur": 0.07378474817613297, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890602.87, "ph": "X", "dur": 0.20920146247585933, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890603.236, "ph": "X", "dur": 0.17968756320540616, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890602.604, "ph": "X", "dur": 0.8862850339744912, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890596.286, "ph": "X", "dur": 7.348960918342843, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890605.888, "ph": "X", "dur": 0.08506947436777682, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890606.313, "ph": "X", "dur": 0.07031252473255023, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890606.473, "ph": "X", "dur": 0.06857641301075887, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890606.646, "ph": "X", "dur": 0.2907987134000534, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890606.182, "ph": "X", "dur": 0.8046877830502971, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890581.087, "ph": "X", "dur": 26.120668910211965, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890531.616, "ph": "X", "dur": 75.83422806370766, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890530.511, "ph": "X", "dur": 77.74568706939995, "name": "_wrapper_grad.<locals>.wrapped1 (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:46)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890529.276, "ph": "X", "dur": 79.27606955215904, "name": "ScalarFunction._update_grad (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:303)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890525.674, "ph": "X", "dur": 82.99308474851435, "name": "ScalarFunction.grad (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:329)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890520.022, "ph": "X", "dur": 88.70402425734704, "name": "_clip_x_for_func.<locals>.eval (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:303)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890608.922, "ph": "X", "dur": 0.08333336264598545, "name": "_append_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:5640)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890609.257, "ph": "X", "dur": 0.045138904766575456, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890609.674, "ph": "X", "dur": 0.05642363095821932, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890610.109, "ph": "X", "dur": 0.06684030128896751, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890610.24, "ph": "X", "dur": 0.23611119416362547, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890610.547, "ph": "X", "dur": 0.15538199910032705, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890609.963, "ph": "X", "dur": 0.7812502748061136, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890611.225, "ph": "X", "dur": 0.07204863645434159, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890609.174, "ph": "X", "dur": 3.1840288977653612, "name": "append (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:5644)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890613.055, "ph": "X", "dur": 0.3697917967415605, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890615.465, "ph": "X", "dur": 1.4921880248796773, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890615.275, "ph": "X", "dur": 1.7361117217913637, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890615.06, "ph": "X", "dur": 2.0364590496612696, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890618.095, "ph": "X", "dur": 0.8263891795726892, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890617.981, "ph": "X", "dur": 0.9800350669512249, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890617.809, "ph": "X", "dur": 1.2317712666109726, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890614.389, "ph": "X", "dur": 4.76041834115192, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890619.91, "ph": "X", "dur": 0.14496532876957885, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890620.437, "ph": "X", "dur": 0.08506947436777682, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890621.836, "ph": "X", "dur": 0.07725697161971569, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890621.592, "ph": "X", "dur": 0.3906251374030568, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890621.079, "ph": "X", "dur": 2.037327105522165, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890620.303, "ph": "X", "dur": 2.903646854696056, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890623.421, "ph": "X", "dur": 0.19878479214511113, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890624.06, "ph": "X", "dur": 0.14062504946510046, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890624.346, "ph": "X", "dur": 0.06944446887165455, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890624.518, "ph": "X", "dur": 0.05902779854090637, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890623.953, "ph": "X", "dur": 0.9001739277488221, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890624.967, "ph": "X", "dur": 0.046875016488366825, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890625.607, "ph": "X", "dur": 0.1006944798638991, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890623.858, "ph": "X", "dur": 1.9713548600940936, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890626.328, "ph": "X", "dur": 0.4348959863087366, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890626.184, "ph": "X", "dur": 0.6423613370628046, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890627.614, "ph": "X", "dur": 0.18489589837078024, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890627.464, "ph": "X", "dur": 0.3836806905158914, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890628.059, "ph": "X", "dur": 0.07031252473255023, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890627.927, "ph": "X", "dur": 0.22916674727646, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890628.221, "ph": "X", "dur": 0.06857641301075887, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890627.115, "ph": "X", "dur": 1.5399310972289397, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890629.829, "ph": "X", "dur": 0.09722225642031637, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890630.027, "ph": "X", "dur": 0.04166668132299273, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890630.174, "ph": "X", "dur": 0.03298612271403591, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890629.746, "ph": "X", "dur": 0.7022571914646066, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890630.551, "ph": "X", "dur": 0.04947918407105387, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890630.959, "ph": "X", "dur": 0.0815972509241941, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890629.627, "ph": "X", "dur": 1.5260422034546086, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890631.56, "ph": "X", "dur": 0.29600704856542753, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890631.463, "ph": "X", "dur": 0.455729326970233, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890632.275, "ph": "X", "dur": 0.6831599625249016, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890633.153, "ph": "X", "dur": 0.044270848905679776, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890633.681, "ph": "X", "dur": 0.07725697161971569, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890633.904, "ph": "X", "dur": 0.2717014844603484, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890634.335, "ph": "X", "dur": 0.31510427750513254, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890633.604, "ph": "X", "dur": 1.1276045633034908, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890629.473, "ph": "X", "dur": 5.4678838677819, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890636.705, "ph": "X", "dur": 0.08680558608956818, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890637.817, "ph": "X", "dur": 0.07552085989792433, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890638.093, "ph": "X", "dur": 0.4314237628651539, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890638.907, "ph": "X", "dur": 1.1927087528706668, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890637.664, "ph": "X", "dur": 2.5451397841461394, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890637.181, "ph": "X", "dur": 3.135417769555203, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890641.851, "ph": "X", "dur": 0.39670152842932666, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890648.506, "ph": "X", "dur": 0.09982642400300341, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890650.885, "ph": "X", "dur": 0.07465280403702865, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890651.367, "ph": "X", "dur": 0.07465280403702865, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890652.155, "ph": "X", "dur": 0.06684030128896751, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890651.118, "ph": "X", "dur": 2.013889597277982, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890655.349, "ph": "X", "dur": 0.07812502748061137, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890657.109, "ph": "X", "dur": 0.05034723993194955, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890657.378, "ph": "X", "dur": 0.3081598306179671, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890658.089, "ph": "X", "dur": 1.0607642620145232, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890656.943, "ph": "X", "dur": 2.2986119196517656, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890656.54, "ph": "X", "dur": 2.7717023638399123, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890660.402, "ph": "X", "dur": 0.2491320320770607, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890650.545, "ph": "X", "dur": 20.398444675187626, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890671.799, "ph": "X", "dur": 0.28211815479109664, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890672.204, "ph": "X", "dur": 0.20920146247585933, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890672.487, "ph": "X", "dur": 0.14409727290868318, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890672.777, "ph": "X", "dur": 0.36284734985439504, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890674.912, "ph": "X", "dur": 0.12673615569076954, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890675.204, "ph": "X", "dur": 0.06684030128896751, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890675.391, "ph": "X", "dur": 0.06857641301075887, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890674.811, "ph": "X", "dur": 0.9600697821506242, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890675.897, "ph": "X", "dur": 0.06770835714986319, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890676.46, "ph": "X", "dur": 0.11197920605554296, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890674.72, "ph": "X", "dur": 1.959202078041554, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890677.297, "ph": "X", "dur": 0.34288206505379437, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890677.178, "ph": "X", "dur": 0.5199654606765134, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890678.09, "ph": "X", "dur": 0.49739600829322567, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890678.754, "ph": "X", "dur": 0.051215295792845235, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890679.267, "ph": "X", "dur": 0.07204863645434159, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890679.517, "ph": "X", "dur": 0.25000008793795636, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890679.98, "ph": "X", "dur": 0.27256954032124414, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890679.172, "ph": "X", "dur": 1.1640629094611095, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890674.485, "ph": "X", "dur": 6.069446579382608, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890683.893, "ph": "X", "dur": 0.10677087089016886, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890684.116, "ph": "X", "dur": 0.04600696062747114, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890684.232, "ph": "X", "dur": 0.031250010992244545, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890683.793, "ph": "X", "dur": 0.7300349790132684, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890684.622, "ph": "X", "dur": 0.039062513740305685, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890684.988, "ph": "X", "dur": 0.10156253572479479, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890683.697, "ph": "X", "dur": 1.5078130303757993, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890685.761, "ph": "X", "dur": 0.2934028809827405, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890685.658, "ph": "X", "dur": 0.4383682097523193, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890686.387, "ph": "X", "dur": 0.4192709808126144, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890686.943, "ph": "X", "dur": 0.04340279304478409, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890687.352, "ph": "X", "dur": 0.07725697161971569, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890687.523, "ph": "X", "dur": 0.1857639542316759, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890687.841, "ph": "X", "dur": 0.1770833956227191, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890687.26, "ph": "X", "dur": 0.8203127885464194, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890683.53, "ph": "X", "dur": 4.666668308175185, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890690.639, "ph": "X", "dur": 0.08246530678508977, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890691.029, "ph": "X", "dur": 0.04947918407105387, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890691.159, "ph": "X", "dur": 0.06944446887165455, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890692.24, "ph": "X", "dur": 0.17100700459644932, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890690.91, "ph": "X", "dur": 1.5572922144468533, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890671.522, "ph": "X", "dur": 21.201396346516134, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890619.656, "ph": "X", "dur": 73.2543660451257, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890614.227, "ph": "X", "dur": 79.21183341845277, "name": "_minimize_slsqp.<locals>.cjac_factory.<locals>.cjac (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:300)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890695.538, "ph": "X", "dur": 1.37500048365876, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890695.368, "ph": "X", "dur": 1.5998269516307417, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890695.17, "ph": "X", "dur": 1.8862853857263167, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890698.056, "ph": "X", "dur": 0.8072919506329841, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890697.94, "ph": "X", "dur": 0.9696183966204767, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890697.779, "ph": "X", "dur": 1.2126740376712675, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890694.494, "ph": "X", "dur": 4.598959951025323, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890699.804, "ph": "X", "dur": 0.10850698261196023, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890700.335, "ph": "X", "dur": 0.07465280403702865, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890701.55, "ph": "X", "dur": 0.06684030128896751, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890701.338, "ph": "X", "dur": 0.3472223443582727, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890700.893, "ph": "X", "dur": 0.9427086649327104, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890700.19, "ph": "X", "dur": 1.7178825487125544, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890702.082, "ph": "X", "dur": 0.1579861666830141, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890702.673, "ph": "X", "dur": 0.11631948536002137, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890702.897, "ph": "X", "dur": 0.05381946337553228, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890703.063, "ph": "X", "dur": 0.04166668132299273, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890702.578, "ph": "X", "dur": 0.7951391685804445, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890703.481, "ph": "X", "dur": 0.038194457879410004, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890704.004, "ph": "X", "dur": 0.09809031228121205, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890702.463, "ph": "X", "dur": 1.7630214534791298, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890704.662, "ph": "X", "dur": 0.3645834615761864, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890704.543, "ph": "X", "dur": 0.5251737958418876, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890705.839, "ph": "X", "dur": 0.1388889377433091, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890705.672, "ph": "X", "dur": 0.34027789747110726, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890706.201, "ph": "X", "dur": 0.06770835714986319, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890706.07, "ph": "X", "dur": 0.24565980863347797, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890706.377, "ph": "X", "dur": 0.06336807784538477, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890705.363, "ph": "X", "dur": 1.3732643719369686, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890707.814, "ph": "X", "dur": 0.09027780953315091, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890707.995, "ph": "X", "dur": 0.04079862546209705, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890708.107, "ph": "X", "dur": 0.038194457879410004, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890707.735, "ph": "X", "dur": 0.6571182866980312, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890708.487, "ph": "X", "dur": 0.03993056960120137, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890708.831, "ph": "X", "dur": 0.09548614469852501, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890707.644, "ph": "X", "dur": 1.372396316076073, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890709.418, "ph": "X", "dur": 0.28472232237378364, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890709.314, "ph": "X", "dur": 0.42968765114336255, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890710.076, "ph": "X", "dur": 0.627604387427578, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890710.884, "ph": "X", "dur": 0.045138904766575456, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890711.339, "ph": "X", "dur": 0.06857641301075887, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890711.556, "ph": "X", "dur": 0.23177091485914708, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890712.821, "ph": "X", "dur": 0.2777778754866182, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890711.261, "ph": "X", "dur": 1.912327061553187, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890707.517, "ph": "X", "dur": 5.854168725880479, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890715.177, "ph": "X", "dur": 0.10763892675106455, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890716.26, "ph": "X", "dur": 0.07118058059344591, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890716.546, "ph": "X", "dur": 0.38194457879410004, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890717.333, "ph": "X", "dur": 1.2378476576372424, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890716.09, "ph": "X", "dur": 2.581598130303758, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890715.672, "ph": "X", "dur": 3.1006955351193755, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890720.188, "ph": "X", "dur": 0.3593751264108123, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890726.719, "ph": "X", "dur": 0.1006944798638991, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890728.886, "ph": "X", "dur": 0.09895836814210773, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890729.377, "ph": "X", "dur": 0.07118058059344591, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890730.126, "ph": "X", "dur": 0.07899308334150705, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890729.149, "ph": "X", "dur": 1.8750006595346729, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890733.162, "ph": "X", "dur": 0.07552085989792433, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890733.981, "ph": "X", "dur": 0.046875016488366825, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890734.226, "ph": "X", "dur": 0.2925348251218448, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890734.902, "ph": "X", "dur": 0.9939239607255558, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890733.839, "ph": "X", "dur": 2.153646590882187, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890733.446, "ph": "X", "dur": 2.6154523088786896, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890737.142, "ph": "X", "dur": 0.2664931492949743, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890728.574, "ph": "X", "dur": 19.054694202521112, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890748.448, "ph": "X", "dur": 0.28298621065199225, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890748.835, "ph": "X", "dur": 0.1961806245624241, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890749.116, "ph": "X", "dur": 0.16232644598749252, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890749.434, "ph": "X", "dur": 0.34201400919289865, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890751.51, "ph": "X", "dur": 0.1571181108221184, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890751.808, "ph": "X", "dur": 0.07552085989792433, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890751.987, "ph": "X", "dur": 0.07552085989792433, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890751.416, "ph": "X", "dur": 0.9453128325153975, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890752.496, "ph": "X", "dur": 0.05555557509732364, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890752.994, "ph": "X", "dur": 0.10329864744658615, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890751.318, "ph": "X", "dur": 1.942709016684536, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890753.936, "ph": "X", "dur": 0.32812511541856776, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890753.793, "ph": "X", "dur": 0.513021013789348, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890754.672, "ph": "X", "dur": 0.5373265778944271, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890755.396, "ph": "X", "dur": 0.04600696062747114, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890755.833, "ph": "X", "dur": 0.05902779854090637, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890756.008, "ph": "X", "dur": 0.22569452383287728, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890756.458, "ph": "X", "dur": 0.2569445348251218, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890755.756, "ph": "X", "dur": 1.0381948096312354, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890751.129, "ph": "X", "dur": 5.849828446576, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890760.123, "ph": "X", "dur": 0.07812502748061137, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890760.349, "ph": "X", "dur": 0.046875016488366825, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890760.488, "ph": "X", "dur": 0.04253473718388841, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890760.034, "ph": "X", "dur": 1.6215283481531337, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890761.763, "ph": "X", "dur": 0.038194457879410004, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890762.22, "ph": "X", "dur": 0.0859375302286725, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890759.939, "ph": "X", "dur": 2.4982647676577727, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890762.861, "ph": "X", "dur": 0.2873264899564707, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890762.753, "ph": "X", "dur": 0.45746543869202433, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890763.423, "ph": "X", "dur": 0.40451403117738777, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890763.98, "ph": "X", "dur": 0.047743072349262505, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890764.346, "ph": "X", "dur": 0.07118058059344591, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890764.538, "ph": "X", "dur": 0.16406255770928388, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890764.866, "ph": "X", "dur": 0.16927089287465796, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890764.268, "ph": "X", "dur": 0.813368341659254, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890759.787, "ph": "X", "dur": 5.427085242319803, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890767.458, "ph": "X", "dur": 0.08506947436777682, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890767.853, "ph": "X", "dur": 0.051215295792845235, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890767.969, "ph": "X", "dur": 0.06250002198448909, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890768.131, "ph": "X", "dur": 0.17447922804003207, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890767.729, "ph": "X", "dur": 0.6328127225929522, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890748.18, "ph": "X", "dur": 20.40278495449211, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890699.555, "ph": "X", "dur": 69.21617018023899, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890693.975, "ph": "X", "dur": 75.2231167376371, "name": "_minimize_slsqp.<locals>.cjac_factory.<locals>.cjac (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:300)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890770.887, "ph": "X", "dur": 1.2439240486635121, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890770.708, "ph": "X", "dur": 1.4661463490528068, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890770.53, "ph": "X", "dur": 1.7317714424868853, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890773.227, "ph": "X", "dur": 0.8081600064938798, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890773.12, "ph": "X", "dur": 0.9565975587070414, "name": "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890772.958, "ph": "X", "dur": 1.1987851438969366, "name": "numpy.ndarray.any", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890769.885, "ph": "X", "dur": 4.375001538914236, "name": "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890774.936, "ph": "X", "dur": 0.1493056080740573, "name": "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890775.497, "ph": "X", "dur": 0.08246530678508977, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890776.864, "ph": "X", "dur": 0.06944446887165455, "name": "Enum.value (/usr/lib/python3.11/enum.py:1257)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890776.629, "ph": "X", "dur": 0.3741320760460389, "name": "property.__get__ (/usr/lib/python3.11/enum.py:193)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890776.077, "ph": "X", "dur": 1.0720489882061672, "name": "numpy.array", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890775.358, "ph": "X", "dur": 1.8454867602642195, "name": "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890777.361, "ph": "X", "dur": 0.17447922804003207, "name": "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890777.96, "ph": "X", "dur": 0.08072919506329843, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890778.135, "ph": "X", "dur": 0.045138904766575456, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890778.309, "ph": "X", "dur": 0.060763910262697736, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890777.868, "ph": "X", "dur": 0.813368341659254, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890778.782, "ph": "X", "dur": 0.039062513740305685, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890779.296, "ph": "X", "dur": 0.09548614469852501, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890777.761, "ph": "X", "dur": 1.7595492300355473, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890779.951, "ph": "X", "dur": 0.39149319326395254, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890779.84, "ph": "X", "dur": 0.5598960302777147, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890781.175, "ph": "X", "dur": 0.12586809982987388, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890781.017, "ph": "X", "dur": 0.3237848361140893, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890781.538, "ph": "X", "dur": 0.07291669231523727, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890781.408, "ph": "X", "dur": 1.0659725971798972, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890782.561, "ph": "X", "dur": 0.08680558608956818, "name": "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890780.718, "ph": "X", "dur": 2.2309035625019025, "name": "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890784.096, "ph": "X", "dur": 0.09375003297673365, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890784.3, "ph": "X", "dur": 0.04166668132299273, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890784.417, "ph": "X", "dur": 0.03298612271403591, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890783.998, "ph": "X", "dur": 0.7092016383517721, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890784.795, "ph": "X", "dur": 0.039062513740305685, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890785.161, "ph": "X", "dur": 0.0815972509241941, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890783.905, "ph": "X", "dur": 1.4348963380605622, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890785.769, "ph": "X", "dur": 0.2873264899564707, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890785.671, "ph": "X", "dur": 0.42708348356067544, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890786.395, "ph": "X", "dur": 0.5642363095821933, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890787.124, "ph": "X", "dur": 0.04340279304478409, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890787.602, "ph": "X", "dur": 0.06684030128896751, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890787.867, "ph": "X", "dur": 0.2057292390322766, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890788.247, "ph": "X", "dur": 0.27256954032124414, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890787.504, "ph": "X", "dur": 1.0642364854581061, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890783.753, "ph": "X", "dur": 4.989585088428379, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890790.527, "ph": "X", "dur": 0.09982642400300341, "name": "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890791.536, "ph": "X", "dur": 0.07291669231523727, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890791.841, "ph": "X", "dur": 0.35156262366275115, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890792.573, "ph": "X", "dur": 1.0868059378413937, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890791.393, "ph": "X", "dur": 2.360243885775359, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890790.999, "ph": "X", "dur": 2.8611121175121674, "name": "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890795.201, "ph": "X", "dur": 0.3828126346549957, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890801.708, "ph": "X", "dur": 0.09895836814210773, "name": "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890803.879, "ph": "X", "dur": 0.08506947436777682, "name": "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890804.368, "ph": "X", "dur": 0.08246530678508977, "name": "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890805.083, "ph": "X", "dur": 0.07899308334150705, "name": "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890804.125, "ph": "X", "dur": 1.8619798216212375, "name": "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890808.096, "ph": "X", "dur": 0.060763910262697736, "name": "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890808.921, "ph": "X", "dur": 0.044270848905679776, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890809.136, "ph": "X", "dur": 0.2907987134000534, "name": "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890809.82, "ph": "X", "dur": 1.0555559268491492, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890808.765, "ph": "X", "dur": 2.198785495648762, "name": "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890808.358, "ph": "X", "dur": 2.68576483361124, "name": "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890812.112, "ph": "X", "dur": 0.23611119416362547, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890803.589, "ph": "X", "dur": 19.00521501845006, "name": "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890823.415, "ph": "X", "dur": 0.28038204306930525, "name": "numpy.empty", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890823.824, "ph": "X", "dur": 0.2005209038669025, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890824.111, "ph": "X", "dur": 0.15277783151764002, "name": "numpy.ndarray.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890824.417, "ph": "X", "dur": 0.3385417857493159, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890826.435, "ph": "X", "dur": 0.14496532876957885, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890826.688, "ph": "X", "dur": 0.08680558608956818, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890826.866, "ph": "X", "dur": 0.06857641301075887, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890826.333, "ph": "X", "dur": 2.0225701558869384, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890828.483, "ph": "X", "dur": 0.06423613370628045, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890829.102, "ph": "X", "dur": 0.13368060257793501, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890826.196, "ph": "X", "dur": 3.1718761157128217, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890829.89, "ph": "X", "dur": 0.29427093684363614, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890829.761, "ph": "X", "dur": 0.46267377385739844, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890830.592, "ph": "X", "dur": 0.5173612930938264, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890831.287, "ph": "X", "dur": 0.045138904766575456, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890831.832, "ph": "X", "dur": 0.07031252473255023, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890832.07, "ph": "X", "dur": 0.24218758518989522, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890832.524, "ph": "X", "dur": 0.25000008793795636, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890831.738, "ph": "X", "dur": 1.1171878929727426, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890826.021, "ph": "X", "dur": 7.002606629845466, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890836.28, "ph": "X", "dur": 0.09461808883762933, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890836.479, "ph": "X", "dur": 0.07465280403702865, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890836.642, "ph": "X", "dur": 0.05989585440180205, "name": "dict.values", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890836.178, "ph": "X", "dur": 0.7951391685804445, "name": "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890837.072, "ph": "X", "dur": 0.03993056960120137, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890837.5, "ph": "X", "dur": 0.08333336264598545, "name": "set.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890836.067, "ph": "X", "dur": 1.6171880688486553, "name": "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890838.042, "ph": "X", "dur": 0.2916667692609491, "name": "numpy.ndarray.astype", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890837.96, "ph": "X", "dur": 0.4157987573690316, "name": "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890838.625, "ph": "X", "dur": 0.44357654491769344, "name": "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890839.192, "ph": "X", "dur": 0.044270848905679776, "name": "_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890839.589, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890839.732, "ph": "X", "dur": 0.19097228939705002, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890840.046, "ph": "X", "dur": 0.19097228939705002, "name": "numpy.ndarray.reshape", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890839.524, "ph": "X", "dur": 0.7638891575882001, "name": "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890835.902, "ph": "X", "dur": 4.501737694605006, "name": "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890842.603, "ph": "X", "dur": 0.07638891575882001, "name": "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890842.974, "ph": "X", "dur": 0.051215295792845235, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890843.098, "ph": "X", "dur": 0.04253473718388841, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890843.255, "ph": "X", "dur": 0.16493061357017955, "name": "numpy.ndarray.ravel", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890842.868, "ph": "X", "dur": 0.605902990905186, "name": "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890823.124, "ph": "X", "dur": 20.573791959088556, "name": "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890774.702, "ph": "X", "dur": 69.17797572235958, "name": "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890769.72, "ph": "X", "dur": 74.59898457365311, "name": "_minimize_slsqp.<locals>.cjac_factory.<locals>.cjac (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:300)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890613.839, "ph": "X", "dur": 230.64938668686983, "name": "_eval_con_normals.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:499)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890844.951, "ph": "X", "dur": 0.17447922804003207, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890844.84, "ph": "X", "dur": 0.49131961726695594, "name": "_arrays_for_stack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:208)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890844.708, "ph": "X", "dur": 0.6970488562992325, "name": "_vhstack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:216)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890845.746, "ph": "X", "dur": 0.048611128210158186, "name": "_atleast_2d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:76)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890846.123, "ph": "X", "dur": 0.038194457879410004, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890846.843, "ph": "X", "dur": 0.07465280403702865, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890847.036, "ph": "X", "dur": 0.02777778754866182, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890847.396, "ph": "X", "dur": 0.04340279304478409, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890847.534, "ph": "X", "dur": 0.02690973168776614, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890849.821, "ph": "X", "dur": 0.026041675826870458, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890849.965, "ph": "X", "dur": 0.07378474817613297, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890845.958, "ph": "X", "dur": 4.234376489449136, "name": "atleast_2d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:80)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890850.462, "ph": "X", "dur": 0.045138904766575456, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890850.853, "ph": "X", "dur": 0.07812502748061137, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890845.564, "ph": "X", "dur": 7.013891356037109, "name": "vstack (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:220)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890853.498, "ph": "X", "dur": 0.1284722674125609, "name": "builtins.hasattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890853.433, "ph": "X", "dur": 0.29513899270453187, "name": "_arrays_for_stack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:208)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890853.321, "ph": "X", "dur": 0.46354182971829416, "name": "_vhstack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:216)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890854.101, "ph": "X", "dur": 0.03298612271403591, "name": "_atleast_2d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:76)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890854.373, "ph": "X", "dur": 0.05295140751463659, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890854.65, "ph": "X", "dur": 0.05034723993194955, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890854.78, "ph": "X", "dur": 0.0286458434095575, "name": "numpy.asanyarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890854.959, "ph": "X", "dur": 0.026041675826870458, "name": "list.append", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890855.078, "ph": "X", "dur": 0.04947918407105387, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890854.268, "ph": "X", "dur": 0.9609378380115199, "name": "atleast_2d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:80)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890855.41, "ph": "X", "dur": 0.05381946337553228, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890855.696, "ph": "X", "dur": 0.06250002198448909, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890853.919, "ph": "X", "dur": 2.819445436189175, "name": "vstack (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:220)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890857.021, "ph": "X", "dur": 0.40451403117738777, "name": "numpy.zeros", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890857.698, "ph": "X", "dur": 0.05381946337553228, "name": "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890612.86, "ph": "X", "dur": 245.85685731390132, "name": "_eval_con_normals (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:490)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890860.285, "ph": "X", "dur": 0.5737849240520457, "name": "builtins.abs", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890868.689, "ph": "X", "dur": 0.5434029689206968, "name": "builtins.abs", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890871.405, "ph": "X", "dur": 0.2526042555206434, "name": "ScalarFunction.nfev (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:258)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890872.245, "ph": "X", "dur": 0.07899308334150705, "name": "ScalarFunction.ngev (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:262)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889285.086, "ph": "X", "dur": 1589.9371912075571, "name": "_minimize_slsqp (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:216)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890880.544, "ph": "X", "dur": 0.32725705955767204, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889065.577, "ph": "X", "dur": 1815.3791107849138, "name": "minimize (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py:53)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890888.84, "ph": "X", "dur": 2.3793411147150643, "name": "_RichResult.__getattr__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1089)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890886.127, "ph": "X", "dur": 5.611981140690584, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890893.765, "ph": "X", "dur": 0.08854169781135955, "name": "OptimizeResult.keys", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890897.425, "ph": "X", "dur": 0.09201392125494227, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890897.938, "ph": "X", "dur": 0.045138904766575456, "name": "OptimizeResult.keys", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890898.675, "ph": "X", "dur": 0.7543405431183475, "name": "builtins.max", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890901.087, "ph": "X", "dur": 0.07899308334150705, "name": "OptimizeResult.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890902.446, "ph": "X", "dur": 0.3732640201851432, "name": "_RichResult.__repr__.<locals>.omit_redundant (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890902.927, "ph": "X", "dur": 0.1866320100925716, "name": "_RichResult.__repr__.<locals>.omit_redundant (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890903.184, "ph": "X", "dur": 0.10156253572479479, "name": "_RichResult.__repr__.<locals>.omit_redundant (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890903.353, "ph": "X", "dur": 0.08767364195046387, "name": "_RichResult.__repr__.<locals>.omit_redundant (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890903.51, "ph": "X", "dur": 0.36284734985439504, "name": "_RichResult.__repr__.<locals>.omit_redundant (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890903.94, "ph": "X", "dur": 0.11111115019464728, "name": "_RichResult.__repr__.<locals>.omit_redundant (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890904.116, "ph": "X", "dur": 0.07552085989792433, "name": "_RichResult.__repr__.<locals>.omit_redundant (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890904.259, "ph": "X", "dur": 0.07031252473255023, "name": "_RichResult.__repr__.<locals>.omit_redundant (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890904.392, "ph": "X", "dur": 0.09548614469852501, "name": "_RichResult.__repr__.<locals>.omit_redundant (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890904.754, "ph": "X", "dur": 0.1493056080740573, "name": "_RichResult.__repr__.<locals>.omit_redundant (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1114)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890907.94, "ph": "X", "dur": 0.18315978664898888, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890908.261, "ph": "X", "dur": 0.2395834176072082, "name": "list.index", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890907.649, "ph": "X", "dur": 0.9444447766545019, "name": "_RichResult.__repr__.<locals>.key (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890908.876, "ph": "X", "dur": 0.044270848905679776, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890908.997, "ph": "X", "dur": 0.08420141850688113, "name": "list.index", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890908.79, "ph": "X", "dur": 0.341145953332003, "name": "_RichResult.__repr__.<locals>.key (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890909.349, "ph": "X", "dur": 0.032118066853140226, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890909.432, "ph": "X", "dur": 1.3159726851178537, "name": "list.index", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890909.272, "ph": "X", "dur": 2.2682299645204167, "name": "_RichResult.__repr__.<locals>.key (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890911.773, "ph": "X", "dur": 0.034722234435827275, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890911.86, "ph": "X", "dur": 0.13107643499524796, "name": "list.index", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890911.69, "ph": "X", "dur": 0.3524306795236469, "name": "_RichResult.__repr__.<locals>.key (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890912.284, "ph": "X", "dur": 0.044270848905679776, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890912.377, "ph": "X", "dur": 0.44357654491769344, "name": "list.index", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890912.159, "ph": "X", "dur": 0.8958336484443437, "name": "_RichResult.__repr__.<locals>.key (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890913.261, "ph": "X", "dur": 0.03298612271403591, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890913.342, "ph": "X", "dur": 0.24652786449437367, "name": "list.index", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890913.173, "ph": "X", "dur": 0.6310766108711607, "name": "_RichResult.__repr__.<locals>.key (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890913.992, "ph": "X", "dur": 0.046875016488366825, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890914.088, "ph": "X", "dur": 0.07118058059344591, "name": "list.index", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890913.912, "ph": "X", "dur": 0.29427093684363614, "name": "_RichResult.__repr__.<locals>.key (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890914.663, "ph": "X", "dur": 0.06423613370628045, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890914.781, "ph": "X", "dur": 0.06597224542807183, "name": "list.index", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890914.322, "ph": "X", "dur": 0.5781252033565242, "name": "_RichResult.__repr__.<locals>.key (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890915.162, "ph": "X", "dur": 0.038194457879410004, "name": "str.lower", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890915.254, "ph": "X", "dur": 0.09895836814210773, "name": "list.index", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890915.037, "ph": "X", "dur": 0.3697917967415605, "name": "_RichResult.__repr__.<locals>.key (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890901.471, "ph": "X", "dur": 15.209206738753242, "name": "builtins.sorted", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890900.691, "ph": "X", "dur": 16.098095940310422, "name": "_RichResult.__repr__.<locals>.item_sorter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1120)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890918.738, "ph": "X", "dur": 0.5138890696502436, "name": "str.rjust", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890920.01, "ph": "X", "dur": 0.09982642400300341, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890926.977, "ph": "X", "dur": 0.25954870240780886, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890924.308, "ph": "X", "dur": 3.2500011431934333, "name": "_GeneratorContextManagerBase.__init__ (/usr/lib/python3.11/contextlib.py:104)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890921.811, "ph": "X", "dur": 5.885418736872723, "name": "contextmanager.<locals>.helper (/usr/lib/python3.11/contextlib.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890939.149, "ph": "X", "dur": 1.438368561504145, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890940.723, "ph": "X", "dur": 0.047743072349262505, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890941.983, "ph": "X", "dur": 1.2569448865769473, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890958.439, "ph": "X", "dur": 1.1414934570778217, "name": "_abc._abc_subclasscheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890958.382, "ph": "X", "dur": 1.3663199250498033, "name": "ABCMeta.__subclasscheck__ (<frozen abc>:121)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890956.253, "ph": "X", "dur": 3.872397195455637, "name": "_abc._abc_subclasscheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890956.197, "ph": "X", "dur": 3.973959731180432, "name": "ABCMeta.__subclasscheck__ (<frozen abc>:121)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890954.069, "ph": "X", "dur": 6.39062724791401, "name": "_abc._abc_subclasscheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890954.011, "ph": "X", "dur": 6.480905057447162, "name": "ABCMeta.__subclasscheck__ (<frozen abc>:121)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890951.49, "ph": "X", "dur": 9.245662974399908, "name": "_abc._abc_subclasscheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890951.432, "ph": "X", "dur": 9.332468560489477, "name": "ABCMeta.__subclasscheck__ (<frozen abc>:121)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890948.346, "ph": "X", "dur": 12.656254451859041, "name": "_abc._abc_subclasscheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890948.047, "ph": "X", "dur": 12.982643455555818, "name": "ABCMeta.__subclasscheck__ (<frozen abc>:121)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890946.685, "ph": "X", "dur": 15.513026290066732, "name": "_abc._abc_instancecheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890946.433, "ph": "X", "dur": 15.81684584138022, "name": "ABCMeta.__instancecheck__ (<frozen abc>:117)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890945.308, "ph": "X", "dur": 17.092019901035975, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890938.518, "ph": "X", "dur": 27.23698874732381, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890967.041, "ph": "X", "dur": 0.22222230038929455, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890968.203, "ph": "X", "dur": 0.2543403672424348, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890968.941, "ph": "X", "dur": 0.6206599405404125, "name": "_contextvars.ContextVar.set", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890933.241, "ph": "X", "dur": 36.39150585632967, "name": "_set_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:298)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890971.263, "ph": "X", "dur": 0.057291686819115, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890971.438, "ph": "X", "dur": 0.171875060457345, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890971.146, "ph": "X", "dur": 1.8185770285764535, "name": "get_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:318)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890930.524, "ph": "X", "dur": 42.53126496044483, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890929.323, "ph": "X", "dur": 43.82727236076208, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890928.963, "ph": "X", "dur": 44.242203062270214, "name": "_GeneratorContextManager.__enter__ (/usr/lib/python3.11/contextlib.py:132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890977.709, "ph": "X", "dur": 0.4314237628651539, "name": "_contextvars.ContextVar.reset", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890977.365, "ph": "X", "dur": 0.9704864524813723, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890977.229, "ph": "X", "dur": 1.519965812428339, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890977.055, "ph": "X", "dur": 2.5972231357998803, "name": "_GeneratorContextManager.__exit__ (/usr/lib/python3.11/contextlib.py:141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890919.868, "ph": "X", "dur": 60.23613229927316, "name": "_dict_formatter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1154)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890981.303, "ph": "X", "dur": 0.31336816578334115, "name": "str.split", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890982.072, "ph": "X", "dur": 0.1397569936042048, "name": "str.join", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890981.075, "ph": "X", "dur": 1.2161462611148504, "name": "_indenter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890982.755, "ph": "X", "dur": 0.19704868042331977, "name": "str.rjust", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890983.543, "ph": "X", "dur": 0.7786461072234266, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890986.108, "ph": "X", "dur": 0.08940975367225523, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890985.255, "ph": "X", "dur": 1.1145837253900557, "name": "_GeneratorContextManagerBase.__init__ (/usr/lib/python3.11/contextlib.py:104)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890984.884, "ph": "X", "dur": 1.568576940638497, "name": "contextmanager.<locals>.helper (/usr/lib/python3.11/contextlib.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890987.843, "ph": "X", "dur": 0.8003475037458186, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890988.755, "ph": "X", "dur": 0.05555557509732364, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890989.399, "ph": "X", "dur": 1.1085073343637857, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890991.678, "ph": "X", "dur": 0.2508681437988521, "name": "_abc._abc_instancecheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890991.583, "ph": "X", "dur": 0.3897570815421612, "name": "ABCMeta.__instancecheck__ (<frozen abc>:117)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890991.389, "ph": "X", "dur": 0.6649307894460923, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890987.669, "ph": "X", "dur": 5.440974136094134, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890993.487, "ph": "X", "dur": 0.07118058059344591, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890993.912, "ph": "X", "dur": 0.15364588737853568, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890994.277, "ph": "X", "dur": 0.19357645697973705, "name": "_contextvars.ContextVar.set", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890987.454, "ph": "X", "dur": 7.077259433882495, "name": "_set_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:298)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890995.002, "ph": "X", "dur": 0.051215295792845235, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890995.159, "ph": "X", "dur": 0.09982642400300341, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890994.889, "ph": "X", "dur": 0.8836808663918041, "name": "get_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:318)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890987.116, "ph": "X", "dur": 8.723093346140708, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890986.963, "ph": "X", "dur": 8.958336484443436, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890986.676, "ph": "X", "dur": 9.292537990888276, "name": "_GeneratorContextManager.__enter__ (/usr/lib/python3.11/contextlib.py:132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890997.11, "ph": "X", "dur": 0.2109375741976507, "name": "_contextvars.ContextVar.reset", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890996.962, "ph": "X", "dur": 0.44184043319590205, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890996.865, "ph": "X", "dur": 0.6953127445774412, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890996.729, "ph": "X", "dur": 2.005209038669025, "name": "_GeneratorContextManager.__exit__ (/usr/lib/python3.11/contextlib.py:141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890983.446, "ph": "X", "dur": 15.527783239701957, "name": "_dict_formatter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1154)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890999.373, "ph": "X", "dur": 0.14496532876957885, "name": "str.split", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890999.81, "ph": "X", "dur": 0.05468751923642796, "name": "str.join", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890999.229, "ph": "X", "dur": 0.7256946997087901, "name": "_indenter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891000.339, "ph": "X", "dur": 0.14062504946510046, "name": "str.rjust", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891001.028, "ph": "X", "dur": 0.07031252473255023, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891002.234, "ph": "X", "dur": 0.060763910262697736, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891001.679, "ph": "X", "dur": 0.6840280183857973, "name": "_GeneratorContextManagerBase.__init__ (/usr/lib/python3.11/contextlib.py:104)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891001.486, "ph": "X", "dur": 0.9409725532109191, "name": "contextmanager.<locals>.helper (/usr/lib/python3.11/contextlib.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891003.489, "ph": "X", "dur": 0.5052085110412868, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891004.085, "ph": "X", "dur": 0.05815974268001069, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891004.528, "ph": "X", "dur": 0.8081600064938798, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891006.16, "ph": "X", "dur": 0.19010423353615433, "name": "_abc._abc_instancecheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891006.091, "ph": "X", "dur": 0.30381955131348864, "name": "ABCMeta.__instancecheck__ (<frozen abc>:117)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891005.965, "ph": "X", "dur": 0.49739600829322567, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891003.333, "ph": "X", "dur": 4.06076531727, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891007.695, "ph": "X", "dur": 0.0815972509241941, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891008.078, "ph": "X", "dur": 0.15104171979584866, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891008.384, "ph": "X", "dur": 0.16232644598749252, "name": "_contextvars.ContextVar.set", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891003.14, "ph": "X", "dur": 5.460939420894735, "name": "_set_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:298)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891009.018, "ph": "X", "dur": 0.046875016488366825, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891009.122, "ph": "X", "dur": 0.06510418956717613, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891008.914, "ph": "X", "dur": 0.6762155156377362, "name": "get_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:318)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891002.881, "ph": "X", "dur": 6.762155156377362, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891002.779, "ph": "X", "dur": 6.940974663721872, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891002.583, "ph": "X", "dur": 7.19878725440789, "name": "_GeneratorContextManager.__enter__ (/usr/lib/python3.11/contextlib.py:132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891010.639, "ph": "X", "dur": 0.17447922804003207, "name": "_contextvars.ContextVar.reset", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891010.547, "ph": "X", "dur": 0.3480904002191684, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891010.46, "ph": "X", "dur": 0.5520835275296537, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891010.358, "ph": "X", "dur": 0.8585072464258294, "name": "_GeneratorContextManager.__exit__ (/usr/lib/python3.11/contextlib.py:141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891000.905, "ph": "X", "dur": 10.50347591683775, "name": "_dict_formatter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1154)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891011.766, "ph": "X", "dur": 0.07725697161971569, "name": "str.split", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891012.053, "ph": "X", "dur": 0.06510418956717613, "name": "str.join", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891011.649, "ph": "X", "dur": 0.5338543544508443, "name": "_indenter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891012.476, "ph": "X", "dur": 0.11458337363823, "name": "str.rjust", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891013.005, "ph": "X", "dur": 0.8810766988091171, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891014.788, "ph": "X", "dur": 0.06944446887165455, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891014.37, "ph": "X", "dur": 0.5572918626950278, "name": "_GeneratorContextManagerBase.__init__ (/usr/lib/python3.11/contextlib.py:104)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891014.18, "ph": "X", "dur": 0.8107641740765669, "name": "contextmanager.<locals>.helper (/usr/lib/python3.11/contextlib.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891015.907, "ph": "X", "dur": 0.4027779194555964, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891016.394, "ph": "X", "dur": 0.029513899270453184, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891016.822, "ph": "X", "dur": 0.7673613810317828, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891018.329, "ph": "X", "dur": 0.09635420055942069, "name": "_abc._abc_instancecheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891018.271, "ph": "X", "dur": 0.18402784250988455, "name": "ABCMeta.__instancecheck__ (<frozen abc>:117)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891018.176, "ph": "X", "dur": 0.3480904002191684, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891015.794, "ph": "X", "dur": 4.41666822023723, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891020.494, "ph": "X", "dur": 0.060763910262697736, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891020.837, "ph": "X", "dur": 0.12413198810808251, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891021.13, "ph": "X", "dur": 0.16579866943107524, "name": "_contextvars.ContextVar.set", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891015.604, "ph": "X", "dur": 5.732640905355083, "name": "_set_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:298)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891021.707, "ph": "X", "dur": 0.0286458434095575, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891021.803, "ph": "X", "dur": 0.06944446887165455, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891021.624, "ph": "X", "dur": 0.6284724432884736, "name": "get_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:318)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891015.366, "ph": "X", "dur": 6.933162160973811, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891015.268, "ph": "X", "dur": 7.108509444874739, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891015.128, "ph": "X", "dur": 7.278648393610292, "name": "_GeneratorContextManager.__enter__ (/usr/lib/python3.11/contextlib.py:132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891027.763, "ph": "X", "dur": 0.21701396522392047, "name": "_contextvars.ContextVar.reset", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891027.328, "ph": "X", "dur": 0.7248266438478944, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891027.239, "ph": "X", "dur": 0.9279517152974839, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891027.154, "ph": "X", "dur": 1.2291670990282855, "name": "_GeneratorContextManager.__exit__ (/usr/lib/python3.11/contextlib.py:141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891012.918, "ph": "X", "dur": 15.623269384400482, "name": "_dict_formatter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1154)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891028.86, "ph": "X", "dur": 0.09635420055942069, "name": "str.split", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891029.17, "ph": "X", "dur": 0.04340279304478409, "name": "str.join", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891028.74, "ph": "X", "dur": 0.5590279744168192, "name": "_indenter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891029.657, "ph": "X", "dur": 0.09982642400300341, "name": "str.rjust", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891030.134, "ph": "X", "dur": 0.09809031228121205, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891031.194, "ph": "X", "dur": 0.06597224542807183, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891030.754, "ph": "X", "dur": 0.5807293709392112, "name": "_GeneratorContextManagerBase.__init__ (/usr/lib/python3.11/contextlib.py:104)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891030.543, "ph": "X", "dur": 0.8663197491738905, "name": "contextmanager.<locals>.helper (/usr/lib/python3.11/contextlib.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891032.386, "ph": "X", "dur": 0.40711819876007477, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891032.861, "ph": "X", "dur": 0.035590290296722955, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891033.332, "ph": "X", "dur": 0.701389135603711, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891034.651, "ph": "X", "dur": 0.09201392125494227, "name": "_abc._abc_instancecheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891034.59, "ph": "X", "dur": 0.1953125687015284, "name": "ABCMeta.__instancecheck__ (<frozen abc>:117)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891034.499, "ph": "X", "dur": 0.3524306795236469, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891032.253, "ph": "X", "dur": 3.410591477459134, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891035.918, "ph": "X", "dur": 0.05902779854090637, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891036.252, "ph": "X", "dur": 0.13802088188241343, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891036.538, "ph": "X", "dur": 0.1666667252919709, "name": "_contextvars.ContextVar.set", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891032.07, "ph": "X", "dur": 4.700522486750118, "name": "_set_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:298)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891037.119, "ph": "X", "dur": 0.031250010992244545, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891037.21, "ph": "X", "dur": 0.07465280403702865, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891037.041, "ph": "X", "dur": 0.5451390806424883, "name": "get_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:318)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891031.755, "ph": "X", "dur": 5.875870122402871, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891031.661, "ph": "X", "dur": 6.045141015277529, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891031.515, "ph": "X", "dur": 6.236981360535474, "name": "_GeneratorContextManager.__enter__ (/usr/lib/python3.11/contextlib.py:132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891047.623, "ph": "X", "dur": 0.037326402018514324, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891051.428, "ph": "X", "dur": 0.6380210577583262, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891052.164, "ph": "X", "dur": 0.03298612271403591, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891052.492, "ph": "X", "dur": 0.7239585879869987, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891051.3, "ph": "X", "dur": 2.390625840906708, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891053.919, "ph": "X", "dur": 0.03993056960120137, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891054.881, "ph": "X", "dur": 0.07638891575882001, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891055.09, "ph": "X", "dur": 0.0911458653940466, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891055.63, "ph": "X", "dur": 0.10416670330748183, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891058.195, "ph": "X", "dur": 0.19010423353615433, "name": "builtins.id", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891058.485, "ph": "X", "dur": 0.1102430943337516, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891059.097, "ph": "X", "dur": 0.08246530678508977, "name": "set.add", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891061.505, "ph": "X", "dur": 0.08680558608956818, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891077.261, "ph": "X", "dur": 0.08680558608956818, "name": "dict.keys", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891078.015, "ph": "X", "dur": 0.34201400919289865, "name": "_get_formatdict.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:475)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891079.326, "ph": "X", "dur": 0.6119793819314557, "name": "_get_formatdict.<locals>.indirect (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:471)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891081.043, "ph": "X", "dur": 0.15451394323943138, "name": "_get_formatdict.<locals>.indirect (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:471)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891081.516, "ph": "X", "dur": 0.046875016488366825, "name": "dict.keys", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891073.666, "ph": "X", "dur": 9.50260750922503, "name": "_get_formatdict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:446)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891083.956, "ph": "X", "dur": 0.10416670330748183, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891084.202, "ph": "X", "dur": 0.030381955131348868, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891084.367, "ph": "X", "dur": 0.039062513740305685, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891084.625, "ph": "X", "dur": 0.1102430943337516, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891085.185, "ph": "X", "dur": 0.05295140751463659, "name": "_get_formatdict.<locals>.indirect.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891068.393, "ph": "X", "dur": 16.9062559468043, "name": "_get_format_function (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:496)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891086.115, "ph": "X", "dur": 0.09635420055942069, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891094.852, "ph": "X", "dur": 0.06770835714986319, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891095.443, "ph": "X", "dur": 0.03298612271403591, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891096.201, "ph": "X", "dur": 0.14583338463047454, "name": "str.rstrip", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891096.421, "ph": "X", "dur": 0.0286458434095575, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891096.529, "ph": "X", "dur": 0.024305564105079093, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891096.594, "ph": "X", "dur": 0.3159723333660282, "name": "builtins.max", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891098.457, "ph": "X", "dur": 0.048611128210158186, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891101.005, "ph": "X", "dur": 0.09461808883762933, "name": "_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891103.173, "ph": "X", "dur": 9.342017174959329, "name": "isposinf (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:70)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891113.134, "ph": "X", "dur": 0.07204863645434159, "name": "_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891114.426, "ph": "X", "dur": 2.1163201888636722, "name": "isneginf (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:140)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891120.247, "ph": "X", "dur": 0.1666667252919709, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891120.656, "ph": "X", "dur": 0.07118058059344591, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891120.951, "ph": "X", "dur": 0.05381946337553228, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891121.152, "ph": "X", "dur": 0.045138904766575456, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891121.564, "ph": "X", "dur": 4.085070881375079, "name": "numpy._core._multiarray_umath.dragon4_scientific", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891119.445, "ph": "X", "dur": 6.28212026530205, "name": "format_float_scientific (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891100.005, "ph": "X", "dur": 25.797752129958766, "name": "_float_formatter_10 (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891098.386, "ph": "X", "dur": 27.530391628306553, "name": "_formatArray.<locals>.recurser (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:837)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891128.827, "ph": "X", "dur": 0.36718762915887343, "name": "str.splitlines", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891129.308, "ph": "X", "dur": 0.045138904766575456, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891130.705, "ph": "X", "dur": 0.037326402018514324, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891130.812, "ph": "X", "dur": 0.024305564105079093, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891131.052, "ph": "X", "dur": 0.021701396522392044, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891131.122, "ph": "X", "dur": 0.019965284800600686, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891130.636, "ph": "X", "dur": 0.8090280623547755, "name": "_extendLine (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:787)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891128.713, "ph": "X", "dur": 3.6406262805964897, "name": "_extendLine_pretty (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:801)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891133.116, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891133.914, "ph": "X", "dur": 0.07465280403702865, "name": "_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891134.344, "ph": "X", "dur": 2.446181416004032, "name": "isposinf (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:70)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891137.051, "ph": "X", "dur": 0.06336807784538477, "name": "_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891137.413, "ph": "X", "dur": 1.6788200349722489, "name": "isneginf (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:140)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891140.128, "ph": "X", "dur": 0.1102430943337516, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891140.386, "ph": "X", "dur": 0.05815974268001069, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891140.583, "ph": "X", "dur": 0.04253473718388841, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891140.767, "ph": "X", "dur": 0.2638889817122873, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891141.155, "ph": "X", "dur": 0.6649307894460923, "name": "numpy._core._multiarray_umath.dragon4_scientific", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891139.98, "ph": "X", "dur": 1.888021497448108, "name": "format_float_scientific (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891133.653, "ph": "X", "dur": 8.276912633640325, "name": "_float_formatter_10 (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891133.054, "ph": "X", "dur": 8.951392037556271, "name": "_formatArray.<locals>.recurser (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:837)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891142.426, "ph": "X", "dur": 0.06423613370628045, "name": "str.splitlines", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891142.584, "ph": "X", "dur": 0.05034723993194955, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891142.872, "ph": "X", "dur": 0.045138904766575456, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891142.992, "ph": "X", "dur": 0.023437508244183412, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891143.131, "ph": "X", "dur": 0.024305564105079093, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891143.206, "ph": "X", "dur": 0.020833340661496363, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891142.826, "ph": "X", "dur": 0.5989585440180205, "name": "_extendLine (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:787)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891142.314, "ph": "X", "dur": 1.1640629094611095, "name": "_extendLine_pretty (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:801)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891143.774, "ph": "X", "dur": 0.02777778754866182, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891094.779, "ph": "X", "dur": 49.53387159029029, "name": "_formatArray.<locals>.recurser (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:837)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891087.601, "ph": "X", "dur": 57.00522838501943, "name": "_formatArray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:828)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891061.387, "ph": "X", "dur": 83.43058490240578, "name": "_array2string (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:567)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891145.376, "ph": "X", "dur": 0.32812511541856776, "name": "set.discard", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891058.007, "ph": "X", "dur": 87.77780865377136, "name": "_recursive_guard.<locals>.decorating_function.<locals>.wrapper (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:550)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891050.969, "ph": "X", "dur": 95.06860982943418, "name": "array2string (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:605)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891047.426, "ph": "X", "dur": 98.78562502578949, "name": "_array_str_implementation (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1685)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891147.175, "ph": "X", "dur": 0.3541667912454382, "name": "_contextvars.ContextVar.reset", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891147.014, "ph": "X", "dur": 0.6119793819314557, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891146.877, "ph": "X", "dur": 0.9704864524813723, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891146.725, "ph": "X", "dur": 1.560764437890436, "name": "_GeneratorContextManager.__exit__ (/usr/lib/python3.11/contextlib.py:141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891030.065, "ph": "X", "dur": 118.47573611848624, "name": "_dict_formatter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1154)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891148.914, "ph": "X", "dur": 0.14756949635226593, "name": "str.split", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891149.377, "ph": "X", "dur": 0.06423613370628045, "name": "str.join", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891148.793, "ph": "X", "dur": 0.7300349790132684, "name": "_indenter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891150.005, "ph": "X", "dur": 0.1293403232734566, "name": "str.rjust", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891150.668, "ph": "X", "dur": 0.09809031228121205, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891152.268, "ph": "X", "dur": 0.06423613370628045, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891151.571, "ph": "X", "dur": 0.8741322519219515, "name": "_GeneratorContextManagerBase.__init__ (/usr/lib/python3.11/contextlib.py:104)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891151.293, "ph": "X", "dur": 1.2586809982987388, "name": "contextmanager.<locals>.helper (/usr/lib/python3.11/contextlib.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891153.959, "ph": "X", "dur": 0.6197918846795168, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891154.66, "ph": "X", "dur": 0.051215295792845235, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891155.198, "ph": "X", "dur": 0.971354508342268, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891157.246, "ph": "X", "dur": 0.1571181108221184, "name": "_abc._abc_instancecheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891157.161, "ph": "X", "dur": 1.2664935010467997, "name": "ABCMeta.__instancecheck__ (<frozen abc>:117)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891157.02, "ph": "X", "dur": 1.5564241585859577, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891153.766, "ph": "X", "dur": 6.047745182860215, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891160.181, "ph": "X", "dur": 0.06423613370628045, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891160.654, "ph": "X", "dur": 0.14756949635226593, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891161.035, "ph": "X", "dur": 0.2621528699904959, "name": "_contextvars.ContextVar.set", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891153.491, "ph": "X", "dur": 7.858509708688608, "name": "_set_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:298)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891161.801, "ph": "X", "dur": 0.0286458434095575, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891161.919, "ph": "X", "dur": 0.09809031228121205, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891161.734, "ph": "X", "dur": 0.892361425000761, "name": "get_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:318)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891153.058, "ph": "X", "dur": 9.63542005594207, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891152.92, "ph": "X", "dur": 9.861114579774947, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891152.742, "ph": "X", "dur": 10.080732712581554, "name": "_GeneratorContextManager.__enter__ (/usr/lib/python3.11/contextlib.py:132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891163.735, "ph": "X", "dur": 0.18402784250988455, "name": "_contextvars.ContextVar.reset", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891163.616, "ph": "X", "dur": 0.379340411211413, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891163.508, "ph": "X", "dur": 0.6319446667320564, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891163.401, "ph": "X", "dur": 1.0190975806915306, "name": "_GeneratorContextManager.__exit__ (/usr/lib/python3.11/contextlib.py:141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891150.529, "ph": "X", "dur": 14.074657728562586, "name": "_dict_formatter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1154)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891164.93, "ph": "X", "dur": 0.10156253572479479, "name": "str.split", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891165.273, "ph": "X", "dur": 0.07465280403702865, "name": "str.join", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891164.834, "ph": "X", "dur": 0.5833335385218982, "name": "_indenter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891165.748, "ph": "X", "dur": 0.11197920605554296, "name": "str.rjust", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891166.962, "ph": "X", "dur": 0.08940975367225523, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891168.02, "ph": "X", "dur": 0.05989585440180205, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891167.572, "ph": "X", "dur": 0.6154516053750384, "name": "_GeneratorContextManagerBase.__init__ (/usr/lib/python3.11/contextlib.py:104)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891167.38, "ph": "X", "dur": 0.8784725312264301, "name": "contextmanager.<locals>.helper (/usr/lib/python3.11/contextlib.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891170.542, "ph": "X", "dur": 0.4539932152484416, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891171.048, "ph": "X", "dur": 0.047743072349262505, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891171.524, "ph": "X", "dur": 0.7118058059344592, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891173.092, "ph": "X", "dur": 0.10937503847285591, "name": "_abc._abc_instancecheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891173.021, "ph": "X", "dur": 0.2248264679719816, "name": "ABCMeta.__instancecheck__ (<frozen abc>:117)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891172.86, "ph": "X", "dur": 0.48524322624068617, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891169.106, "ph": "X", "dur": 5.092883735874965, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891174.452, "ph": "X", "dur": 0.05468751923642796, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891174.787, "ph": "X", "dur": 0.11892365294270842, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891175.042, "ph": "X", "dur": 0.17447922804003207, "name": "_contextvars.ContextVar.set", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891168.905, "ph": "X", "dur": 6.364585572087139, "name": "_set_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:298)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891175.667, "ph": "X", "dur": 0.031250010992244545, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891175.769, "ph": "X", "dur": 0.04947918407105387, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891175.583, "ph": "X", "dur": 0.6319446667320564, "name": "get_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:318)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891168.612, "ph": "X", "dur": 7.656252693099914, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891168.515, "ph": "X", "dur": 7.818579139087406, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891168.365, "ph": "X", "dur": 8.010419484345352, "name": "_GeneratorContextManager.__enter__ (/usr/lib/python3.11/contextlib.py:132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891177.054, "ph": "X", "dur": 0.037326402018514324, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891177.964, "ph": "X", "dur": 0.5477432482251753, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891178.578, "ph": "X", "dur": 0.032118066853140226, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891180.083, "ph": "X", "dur": 0.6614585660025095, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891177.804, "ph": "X", "dur": 3.4010428629892817, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891181.407, "ph": "X", "dur": 0.04166668132299273, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891181.54, "ph": "X", "dur": 0.06597224542807183, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891181.714, "ph": "X", "dur": 0.05468751923642796, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891182.134, "ph": "X", "dur": 0.09461808883762933, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891182.882, "ph": "X", "dur": 0.12065976466449978, "name": "builtins.id", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891183.093, "ph": "X", "dur": 0.08854169781135955, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891183.435, "ph": "X", "dur": 0.07986113920240274, "name": "set.add", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891184.163, "ph": "X", "dur": 0.07204863645434159, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891188.317, "ph": "X", "dur": 0.06163196612359342, "name": "dict.keys", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891188.622, "ph": "X", "dur": 0.2925348251218448, "name": "_get_formatdict.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:475)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891189.557, "ph": "X", "dur": 0.1197917088036041, "name": "_get_formatdict.<locals>.indirect (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:471)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891190.012, "ph": "X", "dur": 0.0911458653940466, "name": "_get_formatdict.<locals>.indirect (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:471)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891190.424, "ph": "X", "dur": 0.031250010992244545, "name": "dict.keys", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891186.963, "ph": "X", "dur": 4.0156264125034244, "name": "_get_formatdict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:446)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891191.427, "ph": "X", "dur": 0.09461808883762933, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891191.64, "ph": "X", "dur": 0.029513899270453184, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891191.747, "ph": "X", "dur": 0.039062513740305685, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891191.913, "ph": "X", "dur": 0.038194457879410004, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891192.176, "ph": "X", "dur": 0.04947918407105387, "name": "_get_formatdict.<locals>.indirect.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:472)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891185.697, "ph": "X", "dur": 6.591148151780913, "name": "_get_format_function (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:496)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891192.922, "ph": "X", "dur": 0.06597224542807183, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891194.014, "ph": "X", "dur": 0.04253473718388841, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891194.498, "ph": "X", "dur": 0.04079862546209705, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891195.13, "ph": "X", "dur": 0.10763892675106455, "name": "str.rstrip", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891195.294, "ph": "X", "dur": 0.02690973168776614, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891195.422, "ph": "X", "dur": 0.023437508244183412, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891195.484, "ph": "X", "dur": 0.22829869141556433, "name": "builtins.max", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891196.735, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891197.581, "ph": "X", "dur": 0.09635420055942069, "name": "_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891198.17, "ph": "X", "dur": 3.014758004890703, "name": "isposinf (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:70)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891201.454, "ph": "X", "dur": 0.07378474817613297, "name": "_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891201.823, "ph": "X", "dur": 1.6744797556677704, "name": "isneginf (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:140)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891204.551, "ph": "X", "dur": 0.13715282602151774, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891204.873, "ph": "X", "dur": 0.05555557509732364, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891205.062, "ph": "X", "dur": 0.05989585440180205, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891205.256, "ph": "X", "dur": 0.05295140751463659, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891205.512, "ph": "X", "dur": 0.9210072684103184, "name": "numpy._core._multiarray_umath.dragon4_scientific", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891204.385, "ph": "X", "dur": 2.109375741976507, "name": "format_float_scientific (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891197.243, "ph": "X", "dur": 9.31163521982798, "name": "_float_formatter_10 (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891196.656, "ph": "X", "dur": 9.987850735465717, "name": "_formatArray.<locals>.recurser (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:837)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891206.993, "ph": "X", "dur": 0.07638891575882001, "name": "str.splitlines", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891207.17, "ph": "X", "dur": 0.05642363095821932, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891207.521, "ph": "X", "dur": 0.035590290296722955, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891207.614, "ph": "X", "dur": 0.021701396522392044, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891207.795, "ph": "X", "dur": 0.024305564105079093, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891208.685, "ph": "X", "dur": 0.0286458434095575, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891207.461, "ph": "X", "dur": 1.500868583488634, "name": "_extendLine (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:787)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891206.899, "ph": "X", "dur": 2.139757697107856, "name": "_extendLine_pretty (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:801)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891212.235, "ph": "X", "dur": 0.04340279304478409, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891212.853, "ph": "X", "dur": 0.07638891575882001, "name": "_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891213.246, "ph": "X", "dur": 2.295139696208183, "name": "isposinf (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:70)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891215.785, "ph": "X", "dur": 0.16840283701376227, "name": "_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:12)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891216.241, "ph": "X", "dur": 1.651042247423587, "name": "isneginf (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:140)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891218.88, "ph": "X", "dur": 0.06336807784538477, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891219.083, "ph": "X", "dur": 0.05381946337553228, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891219.27, "ph": "X", "dur": 0.05034723993194955, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891219.453, "ph": "X", "dur": 0.033854178574931594, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891219.602, "ph": "X", "dur": 0.6866321859684843, "name": "numpy._core._multiarray_umath.dragon4_scientific", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891218.722, "ph": "X", "dur": 1.6145839012659682, "name": "format_float_scientific (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1108)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891212.646, "ph": "X", "dur": 7.742190223328587, "name": "_float_formatter_10 (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891209.615, "ph": "X", "dur": 10.823788529508258, "name": "_formatArray.<locals>.recurser (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:837)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891220.821, "ph": "X", "dur": 0.057291686819115, "name": "str.splitlines", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891220.966, "ph": "X", "dur": 0.038194457879410004, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891221.282, "ph": "X", "dur": 0.047743072349262505, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891221.398, "ph": "X", "dur": 0.02777778754866182, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891221.541, "ph": "X", "dur": 0.026041675826870458, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891221.616, "ph": "X", "dur": 0.023437508244183412, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891221.196, "ph": "X", "dur": 0.6710071804723621, "name": "_extendLine (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:787)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891220.726, "ph": "X", "dur": 1.1883684735661884, "name": "_extendLine_pretty (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:801)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891222.201, "ph": "X", "dur": 0.026041675826870458, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891193.942, "ph": "X", "dur": 28.620669789591528, "name": "_formatArray.<locals>.recurser (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:837)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891193.525, "ph": "X", "dur": 29.32726726036061, "name": "_formatArray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:828)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891184.087, "ph": "X", "dur": 38.93143730531044, "name": "_array2string (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:567)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891223.27, "ph": "X", "dur": 0.10590281502927318, "name": "set.discard", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891182.797, "ph": "X", "dur": 40.64497957471851, "name": "_recursive_guard.<locals>.decorating_function.<locals>.wrapper (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:550)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891177.584, "ph": "X", "dur": 46.02779396813264, "name": "array2string (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:605)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891176.952, "ph": "X", "dur": 46.822065080852184, "name": "_array_str_implementation (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1685)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891224.61, "ph": "X", "dur": 0.24218758518989522, "name": "_contextvars.ContextVar.reset", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891224.478, "ph": "X", "dur": 0.47222238832725094, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891224.345, "ph": "X", "dur": 0.815972509241941, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891224.222, "ph": "X", "dur": 1.30468795892621, "name": "_GeneratorContextManager.__exit__ (/usr/lib/python3.11/contextlib.py:141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891166.157, "ph": "X", "dur": 59.60679180012379, "name": "_dict_formatter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1154)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891226.103, "ph": "X", "dur": 0.10590281502927318, "name": "str.split", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891226.46, "ph": "X", "dur": 0.057291686819115, "name": "str.join", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891226.005, "ph": "X", "dur": 0.5902779854090637, "name": "_indenter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891227.254, "ph": "X", "dur": 0.1293403232734566, "name": "str.rjust", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891227.901, "ph": "X", "dur": 0.1397569936042048, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891229.263, "ph": "X", "dur": 0.07725697161971569, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891228.663, "ph": "X", "dur": 0.7986113920240273, "name": "_GeneratorContextManagerBase.__init__ (/usr/lib/python3.11/contextlib.py:104)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891228.423, "ph": "X", "dur": 1.1258684515816995, "name": "contextmanager.<locals>.helper (/usr/lib/python3.11/contextlib.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891231.105, "ph": "X", "dur": 0.5434029689206968, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891232.648, "ph": "X", "dur": 0.05468751923642796, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891233.131, "ph": "X", "dur": 0.8585072464258294, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891235.04, "ph": "X", "dur": 0.14409727290868318, "name": "_abc._abc_instancecheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891234.957, "ph": "X", "dur": 0.2777778754866182, "name": "ABCMeta.__instancecheck__ (<frozen abc>:117)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891234.803, "ph": "X", "dur": 0.5138890696502436, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891230.955, "ph": "X", "dur": 5.396703287188454, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891236.707, "ph": "X", "dur": 0.06163196612359342, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891237.116, "ph": "X", "dur": 0.16927089287465796, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891237.452, "ph": "X", "dur": 0.20833340661496366, "name": "_contextvars.ContextVar.set", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891230.369, "ph": "X", "dur": 7.3454886948992595, "name": "_set_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:298)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891238.415, "ph": "X", "dur": 0.029513899270453184, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891238.533, "ph": "X", "dur": 0.06944446887165455, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891238.064, "ph": "X", "dur": 1.004340631056304, "name": "get_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:318)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891230.025, "ph": "X", "dur": 9.123267098013617, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891229.916, "ph": "X", "dur": 9.31163521982798, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891229.746, "ph": "X", "dur": 9.546878358130709, "name": "_GeneratorContextManager.__enter__ (/usr/lib/python3.11/contextlib.py:132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891240.115, "ph": "X", "dur": 0.1875000659534673, "name": "_contextvars.ContextVar.reset", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891239.977, "ph": "X", "dur": 0.401041807733805, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891239.887, "ph": "X", "dur": 0.6111113260705601, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891239.79, "ph": "X", "dur": 0.9696183966204767, "name": "_GeneratorContextManager.__exit__ (/usr/lib/python3.11/contextlib.py:141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891227.749, "ph": "X", "dur": 13.190108806309887, "name": "_dict_formatter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1154)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891241.446, "ph": "X", "dur": 0.0859375302286725, "name": "str.split", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891241.762, "ph": "X", "dur": 0.04253473718388841, "name": "str.join", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891241.186, "ph": "X", "dur": 0.6657988453069881, "name": "_indenter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891242.121, "ph": "X", "dur": 0.09635420055942069, "name": "str.rjust", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891242.639, "ph": "X", "dur": 0.09027780953315091, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891243.682, "ph": "X", "dur": 0.060763910262697736, "name": "builtins.getattr", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891243.209, "ph": "X", "dur": 0.5980904881571248, "name": "_GeneratorContextManagerBase.__init__ (/usr/lib/python3.11/contextlib.py:104)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891243.028, "ph": "X", "dur": 0.851562799538664, "name": "contextmanager.<locals>.helper (/usr/lib/python3.11/contextlib.py:299)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891244.845, "ph": "X", "dur": 0.43402793044784094, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891245.367, "ph": "X", "dur": 0.05295140751463659, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891245.757, "ph": "X", "dur": 0.739583593483121, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891247.281, "ph": "X", "dur": 0.1102430943337516, "name": "_abc._abc_instancecheck", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891247.218, "ph": "X", "dur": 0.2161459093630248, "name": "ABCMeta.__instancecheck__ (<frozen abc>:117)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891247.048, "ph": "X", "dur": 0.46267377385739844, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891244.71, "ph": "X", "dur": 3.6197929399349933, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891248.56, "ph": "X", "dur": 0.036458346157618636, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891248.887, "ph": "X", "dur": 0.16059033426570116, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891249.208, "ph": "X", "dur": 0.18836812181436297, "name": "_contextvars.ContextVar.set", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891244.519, "ph": "X", "dur": 4.931425345748369, "name": "_set_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:298)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891249.85, "ph": "X", "dur": 0.05555557509732364, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891249.982, "ph": "X", "dur": 0.05034723993194955, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891249.761, "ph": "X", "dur": 0.6076391026269773, "name": "get_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:318)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891244.275, "ph": "X", "dur": 6.144099383419636, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891244.177, "ph": "X", "dur": 6.316842499737877, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891244.031, "ph": "X", "dur": 6.519099515326571, "name": "_GeneratorContextManager.__enter__ (/usr/lib/python3.11/contextlib.py:132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891251.143, "ph": "X", "dur": 0.1579861666830141, "name": "_contextvars.ContextVar.reset", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891251.045, "ph": "X", "dur": 1.2057295907841021, "name": "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891250.958, "ph": "X", "dur": 1.4548616228611628, "name": "builtins.next", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891250.874, "ph": "X", "dur": 1.7890631293060002, "name": "_GeneratorContextManager.__exit__ (/usr/lib/python3.11/contextlib.py:141)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891242.544, "ph": "X", "dur": 10.29080223091831, "name": "_dict_formatter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1154)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891253.158, "ph": "X", "dur": 0.08767364195046387, "name": "str.split", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891253.449, "ph": "X", "dur": 0.060763910262697736, "name": "str.join", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891253.027, "ph": "X", "dur": 0.529514075146366, "name": "_indenter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1132)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890918.011, "ph": "X", "dur": 335.9766806803692, "name": "_dict_formatter.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1164)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891254.201, "ph": "X", "dur": 0.34375012091469, "name": "str.join", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890897.08, "ph": "X", "dur": 357.80741752603467, "name": "_dict_formatter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1154)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906890885.465, "ph": "X", "dur": 369.5470049887879, "name": "_RichResult.__repr__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1098)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891255.973, "ph": "X", "dur": 9.039065679506736, "name": "builtins.print", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891266.471, "ph": "X", "dur": 0.2916667692609491, "name": "_RichResult.__getattr__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1089)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891269.284, "ph": "X", "dur": 0.10763892675106455, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891270.398, "ph": "X", "dur": 0.5746529799129414, "name": "builtins.locals", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891271.061, "ph": "X", "dur": 0.039062513740305685, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891271.576, "ph": "X", "dur": 0.7864586099714879, "name": "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891270.225, "ph": "X", "dur": 2.7656259728136425, "name": "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891273.213, "ph": "X", "dur": 0.051215295792845235, "name": "_contextvars.ContextVar.get", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891273.356, "ph": "X", "dur": 0.0911458653940466, "name": "dict.copy", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891273.583, "ph": "X", "dur": 0.07986113920240274, "name": "dict.update", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891274.071, "ph": "X", "dur": 0.08506947436777682, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891274.702, "ph": "X", "dur": 0.1006944798638991, "name": "builtins.id", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891274.859, "ph": "X", "dur": 0.07552085989792433, "name": "_thread.get_ident", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891275.247, "ph": "X", "dur": 0.1006944798638991, "name": "set.add", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891275.942, "ph": "X", "dur": 0.171875060457345, "name": "numpy.asarray", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891278.609, "ph": "X", "dur": 1.1527781832694655, "name": "_get_formatdict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:446)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891280.306, "ph": "X", "dur": 0.07204863645434159, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891280.491, "ph": "X", "dur": 0.039062513740305685, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891280.603, "ph": "X", "dur": 0.036458346157618636, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891280.738, "ph": "X", "dur": 0.02777778754866182, "name": "builtins.issubclass", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891284.343, "ph": "X", "dur": 0.1102430943337516, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891285.289, "ph": "X", "dur": 0.12152782052539547, "name": "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891305.163, "ph": "X", "dur": 0.09722225642031637, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891306.559, "ph": "X", "dur": 0.12326393224718683, "name": "_max_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:3047)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891310.656, "ph": "X", "dur": 0.04253473718388841, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891311.4, "ph": "X", "dur": 0.5060765669021825, "name": "_wrapreduction.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:70)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891312.884, "ph": "X", "dur": 3.8732652513165324, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891310.236, "ph": "X", "dur": 6.673613458566002, "name": "_wrapreduction (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:69)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891307.578, "ph": "X", "dur": 9.488718615450699, "name": "max (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:3052)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891317.792, "ph": "X", "dur": 0.07291669231523727, "name": "_min_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:3185)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891319.385, "ph": "X", "dur": 0.057291686819115, "name": "dict.items", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891319.637, "ph": "X", "dur": 0.39670152842932666, "name": "_wrapreduction.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:70)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891320.503, "ph": "X", "dur": 2.1657993729347265, "name": "numpy.ufunc.reduce", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891319.271, "ph": "X", "dur": 3.4817720580525804, "name": "_wrapreduction (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:69)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891318.539, "ph": "X", "dur": 4.316841796234225, "name": "min (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:3190)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891325.102, "ph": "X", "dur": 0.6597224542807182, "name": "errstate.__init__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py:430)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891327.148, "ph": "X", "dur": 0.5703127006084631, "name": "numpy._core._multiarray_umath._make_extobj", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891328.01, "ph": "X", "dur": 0.3506945678018555, "name": "_contextvars.ContextVar.set", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891326.318, "ph": "X", "dur": 2.1710077081001002, "name": "errstate.__enter__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py:440)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891330.098, "ph": "X", "dur": 0.2934028809827405, "name": "_contextvars.ContextVar.reset", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891329.709, "ph": "X", "dur": 0.7743058279189482, "name": "errstate.__exit__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py:456)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891330.915, "ph": "X", "dur": 0.08246530678508977, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891334.284, "ph": "X", "dur": 3.4618067732519795, "name": "numpy._core._multiarray_umath.dragon4_positional", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891333.777, "ph": "X", "dur": 4.062501428991792, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1037)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891338.037, "ph": "X", "dur": 0.1779514514836148, "name": "str.split", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891332.996, "ph": "X", "dur": 5.284724081132911, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1042)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891338.886, "ph": "X", "dur": 1.1119795578073686, "name": "numpy._core._multiarray_umath.dragon4_positional", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891338.581, "ph": "X", "dur": 1.4765630193835548, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1037)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891340.205, "ph": "X", "dur": 0.07465280403702865, "name": "str.split", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891338.428, "ph": "X", "dur": 1.8897576091698995, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1042)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891340.566, "ph": "X", "dur": 2.1840285460135354, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1037)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891340.45, "ph": "X", "dur": 2.5842022978864447, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1042)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891345.755, "ph": "X", "dur": 0.0911458653940466, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891345.236, "ph": "X", "dur": 0.6666669011678836, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1046)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891346.107, "ph": "X", "dur": 0.026041675826870458, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891346.012, "ph": "X", "dur": 0.1484375522131616, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1046)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891346.277, "ph": "X", "dur": 0.06510418956717613, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1046)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891344.574, "ph": "X", "dur": 1.8897576091698995, "name": "builtins.max", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891347.354, "ph": "X", "dur": 0.025173619965974774, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891347.283, "ph": "X", "dur": 0.12326393224718683, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1047)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891347.569, "ph": "X", "dur": 0.023437508244183412, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891347.492, "ph": "X", "dur": 0.12673615569076954, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1047)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891347.722, "ph": "X", "dur": 0.05555557509732364, "name": "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1047)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891346.879, "ph": "X", "dur": 0.966146173176894, "name": "builtins.max", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891295.947, "ph": "X", "dur": 52.95922001738466, "name": "FloatingFormat.fillFormat (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:987)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891284.144, "ph": "X", "dur": 65.23700211389318, "name": "FloatingFormat.__init__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:961)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891281.309, "ph": "X", "dur": 68.3880448889445, "name": "_get_formatdict.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:455)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891277.392, "ph": "X", "dur": 72.42190047452675, "name": "_get_format_function (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:496)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891350.538, "ph": "X", "dur": 0.032118066853140226, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891351.873, "ph": "X", "dur": 0.05295140751463659, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891352.418, "ph": "X", "dur": 0.037326402018514324, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891353.072, "ph": "X", "dur": 0.1197917088036041, "name": "str.rstrip", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891353.257, "ph": "X", "dur": 0.0286458434095575, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891353.367, "ph": "X", "dur": 0.026041675826870458, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891353.433, "ph": "X", "dur": 0.1822917307880932, "name": "builtins.max", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891354.737, "ph": "X", "dur": 0.04253473718388841, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891360.252, "ph": "X", "dur": 1.3550351988581595, "name": "numpy._core._multiarray_umath.dragon4_positional", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891358.308, "ph": "X", "dur": 3.3741331313015155, "name": "FloatingFormat.__call__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1073)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891354.688, "ph": "X", "dur": 7.235245600565508, "name": "_formatArray.<locals>.recurser (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:837)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891362.413, "ph": "X", "dur": 0.14409727290868318, "name": "str.splitlines", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891362.652, "ph": "X", "dur": 0.08333336264598545, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891363.109, "ph": "X", "dur": 0.04079862546209705, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891364.1, "ph": "X", "dur": 0.029513899270453184, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891364.363, "ph": "X", "dur": 0.02690973168776614, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891364.451, "ph": "X", "dur": 0.024305564105079093, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891363.027, "ph": "X", "dur": 1.754340894870173, "name": "_extendLine (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:787)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891362.289, "ph": "X", "dur": 2.568577292390323, "name": "_extendLine_pretty (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:801)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891365.574, "ph": "X", "dur": 0.033854178574931594, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891367.117, "ph": "X", "dur": 1.1154517812509512, "name": "numpy._core._multiarray_umath.dragon4_positional", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891366.096, "ph": "X", "dur": 2.1814243784308487, "name": "FloatingFormat.__call__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1073)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891365.499, "ph": "X", "dur": 2.8819454581736634, "name": "_formatArray.<locals>.recurser (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:837)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891368.808, "ph": "X", "dur": 0.07638891575882001, "name": "str.splitlines", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891368.945, "ph": "X", "dur": 0.051215295792845235, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891369.253, "ph": "X", "dur": 0.02777778754866182, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891369.339, "ph": "X", "dur": 0.02690973168776614, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891369.491, "ph": "X", "dur": 0.02690973168776614, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891369.57, "ph": "X", "dur": 0.025173619965974774, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891369.189, "ph": "X", "dur": 0.6770835714986319, "name": "_extendLine (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:787)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891368.706, "ph": "X", "dur": 1.2161462611148504, "name": "_extendLine_pretty (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:801)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891370.181, "ph": "X", "dur": 0.032118066853140226, "name": "builtins.len", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891351.788, "ph": "X", "dur": 18.901048315142575, "name": "_formatArray.<locals>.recurser (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:837)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891351.233, "ph": "X", "dur": 19.729173606437055, "name": "_formatArray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:828)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891275.874, "ph": "X", "dur": 95.26305434227481, "name": "_array2string (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:567)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891371.565, "ph": "X", "dur": 0.16493061357017955, "name": "set.discard", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891274.63, "ph": "X", "dur": 97.18232585071516, "name": "_recursive_guard.<locals>.decorating_function.<locals>.wrapper (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:550)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891269.979, "ph": "X", "dur": 101.99395948765994, "name": "array2string (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:605)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891269.128, "ph": "X", "dur": 103.03389040901297, "name": "_array_str_implementation (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1685)", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906891372.901, "ph": "X", "dur": 2.40625084640283, "name": "builtins.print", "cat": "FEE"}, {"pid": 1137456, "tid": 1137456, "ts": 153906889048.119, "ph": "X", "dur": 2327.3193950274467, "name": "main (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:6)", "cat": "FEE"}], "viztracer_metadata": {"version": "1.0.4", "overflow": false, "baseTimeNanoseconds": 1747227502019532427}, "file_info": {"files": {"/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py": ["__all__ = ['atleast_1d', 'atleast_2d', 'atleast_3d', 'block', 'hstack',\n           'stack', 'unstack', 'vstack']\n\nimport functools\nimport itertools\nimport operator\n\nfrom . import numeric as _nx\nfrom . import overrides\nfrom .multiarray import array, asanyarray, normalize_axis_index\nfrom . import fromnumeric as _from_nx\n\narray_function_dispatch = functools.partial(\n    overrides.array_function_dispatch, module='numpy')\n\n\ndef _atleast_1d_dispatcher(*arys):\n    return arys\n\n\n@array_function_dispatch(_atleast_1d_dispatcher)\ndef atleast_1d(*arys):\n    \"\"\"\n    Convert inputs to arrays with at least one dimension.\n\n    Scalar inputs are converted to 1-dimensional arrays, whilst\n    higher-dimensional inputs are preserved.\n\n    Parameters\n    ----------\n    arys1, arys2, ... : array_like\n        One or more input arrays.\n\n    Returns\n    -------\n    ret : ndarray\n        An array, or tuple of arrays, each with ``a.ndim >= 1``.\n        Copies are made only if necessary.\n\n    See Also\n    --------\n    atleast_2d, atleast_3d\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.atleast_1d(1.0)\n    array([1.])\n\n    >>> x = np.arange(9.0).reshape(3,3)\n    >>> np.atleast_1d(x)\n    array([[0., 1., 2.],\n           [3., 4., 5.],\n           [6., 7., 8.]])\n    >>> np.atleast_1d(x) is x\n    True\n\n    >>> np.atleast_1d(1, [3, 4])\n    (array([1]), array([3, 4]))\n\n    \"\"\"\n    if len(arys) == 1:\n        result = asanyarray(arys[0])\n        if result.ndim == 0:\n            result = result.reshape(1)\n        return result\n    res = []\n    for ary in arys:\n        result = asanyarray(ary)\n        if result.ndim == 0:\n            result = result.reshape(1)\n        res.append(result)\n    return tuple(res)\n\n\ndef _atleast_2d_dispatcher(*arys):\n    return arys\n\n\n@array_function_dispatch(_atleast_2d_dispatcher)\ndef atleast_2d(*arys):\n    \"\"\"\n    View inputs as arrays with at least two dimensions.\n\n    Parameters\n    ----------\n    arys1, arys2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted\n        to arrays.  Arrays that already have two or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res, res2, ... : ndarray\n        An array, or tuple of arrays, each with ``a.ndim >= 2``.\n        Copies are avoided where possible, and views with two or more\n        dimensions are returned.\n\n    See Also\n    --------\n    atleast_1d, atleast_3d\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.atleast_2d(3.0)\n    array([[3.]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_2d(x)\n    array([[0., 1., 2.]])\n    >>> np.atleast_2d(x).base is x\n    True\n\n    >>> np.atleast_2d(1, [1, 2], [[1, 2]])\n    (array([[1]]), array([[1, 2]]), array([[1, 2]]))\n\n    \"\"\"\n    res = []\n    for ary in arys:\n        ary = asanyarray(ary)\n        if ary.ndim == 0:\n            result = ary.reshape(1, 1)\n        elif ary.ndim == 1:\n            result = ary[_nx.newaxis, :]\n        else:\n            result = ary\n        res.append(result)\n    if len(res) == 1:\n        return res[0]\n    else:\n        return tuple(res)\n\n\ndef _atleast_3d_dispatcher(*arys):\n    return arys\n\n\n@array_function_dispatch(_atleast_3d_dispatcher)\ndef atleast_3d(*arys):\n    \"\"\"\n    View inputs as arrays with at least three dimensions.\n\n    Parameters\n    ----------\n    arys1, arys2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted to\n        arrays.  Arrays that already have three or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res1, res2, ... : ndarray\n        An array, or tuple of arrays, each with ``a.ndim >= 3``.  Copies are\n        avoided where possible, and views with three or more dimensions are\n        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view\n        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a\n        view of shape ``(M, N, 1)``.\n\n    See Also\n    --------\n    atleast_1d, atleast_2d\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.atleast_3d(3.0)\n    array([[[3.]]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_3d(x).shape\n    (1, 3, 1)\n\n    >>> x = np.arange(12.0).reshape(4,3)\n    >>> np.atleast_3d(x).shape\n    (4, 3, 1)\n    >>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\n    True\n\n    >>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n    ...     print(arr, arr.shape) # doctest: +SKIP\n    ...\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1 2]]] (1, 1, 2)\n\n    \"\"\"\n    res = []\n    for ary in arys:\n        ary = asanyarray(ary)\n        if ary.ndim == 0:\n            result = ary.reshape(1, 1, 1)\n        elif ary.ndim == 1:\n            result = ary[_nx.newaxis, :, _nx.newaxis]\n        elif ary.ndim == 2:\n            result = ary[:, :, _nx.newaxis]\n        else:\n            result = ary\n        res.append(result)\n    if len(res) == 1:\n        return res[0]\n    else:\n        return tuple(res)\n\n\ndef _arrays_for_stack_dispatcher(arrays):\n    if not hasattr(arrays, \"__getitem__\"):\n        raise TypeError('arrays to stack must be passed as a \"sequence\" type '\n                        'such as list or tuple.')\n\n    return tuple(arrays)\n\n\ndef _vhstack_dispatcher(tup, *, dtype=None, casting=None):\n    return _arrays_for_stack_dispatcher(tup)\n\n\n@array_function_dispatch(_vhstack_dispatcher)\ndef vstack(tup, *, dtype=None, casting=\"same_kind\"):\n    \"\"\"\n    Stack arrays in sequence vertically (row wise).\n\n    This is equivalent to concatenation along the first axis after 1-D arrays\n    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n    `vsplit`.\n\n    This function makes most sense for arrays with up to 3 dimensions. For\n    instance, for pixel-data with a height (first axis), width (second axis),\n    and r/g/b channels (third axis). The functions `concatenate`, `stack` and\n    `block` provide more general stacking and concatenation operations.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        The arrays must have the same shape along all but the first axis.\n        1-D arrays must have the same length. In the case of a single\n        array_like input, it will be treated as a sequence of arrays; i.e.,\n        each element along the zeroth axis is treated as a separate array.\n\n    dtype : str or dtype\n        If provided, the destination array will have this dtype. Cannot be\n        provided together with `out`.\n\n        .. versionadded:: 1.24\n\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n        .. versionadded:: 1.24\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays, will be at least 2-D.\n\n    See Also\n    --------\n    concatenate : Join a sequence of arrays along an existing axis.\n    stack : Join a sequence of arrays along a new axis.\n    block : Assemble an nd-array from nested lists of blocks.\n    hstack : Stack arrays in sequence horizontally (column wise).\n    dstack : Stack arrays in sequence depth wise (along third axis).\n    column_stack : Stack 1-D arrays as columns into a 2-D array.\n    vsplit : Split an array into multiple sub-arrays vertically (row-wise).\n    unstack : Split an array into a tuple of sub-arrays along an axis.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([4, 5, 6])\n    >>> np.vstack((a,b))\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    >>> a = np.array([[1], [2], [3]])\n    >>> b = np.array([[4], [5], [6]])\n    >>> np.vstack((a,b))\n    array([[1],\n           [2],\n           [3],\n           [4],\n           [5],\n           [6]])\n\n    \"\"\"\n    arrs = atleast_2d(*tup)\n    if not isinstance(arrs, tuple):\n        arrs = (arrs,)\n    return _nx.concatenate(arrs, 0, dtype=dtype, casting=casting)\n\n\n@array_function_dispatch(_vhstack_dispatcher)\ndef hstack(tup, *, dtype=None, casting=\"same_kind\"):\n    \"\"\"\n    Stack arrays in sequence horizontally (column wise).\n\n    This is equivalent to concatenation along the second axis, except for 1-D\n    arrays where it concatenates along the first axis. Rebuilds arrays divided\n    by `hsplit`.\n\n    This function makes most sense for arrays with up to 3 dimensions. For\n    instance, for pixel-data with a height (first axis), width (second axis),\n    and r/g/b channels (third axis). The functions `concatenate`, `stack` and\n    `block` provide more general stacking and concatenation operations.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        The arrays must have the same shape along all but the second axis,\n        except 1-D arrays which can be any length. In the case of a single\n        array_like input, it will be treated as a sequence of arrays; i.e.,\n        each element along the zeroth axis is treated as a separate array.\n\n    dtype : str or dtype\n        If provided, the destination array will have this dtype. Cannot be\n        provided together with `out`.\n\n        .. versionadded:: 1.24\n\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n        .. versionadded:: 1.24\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    concatenate : Join a sequence of arrays along an existing axis.\n    stack : Join a sequence of arrays along a new axis.\n    block : Assemble an nd-array from nested lists of blocks.\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third axis).\n    column_stack : Stack 1-D arrays as columns into a 2-D array.\n    hsplit : Split an array into multiple sub-arrays\n             horizontally (column-wise).\n    unstack : Split an array into a tuple of sub-arrays along an axis.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((4,5,6))\n    >>> np.hstack((a,b))\n    array([1, 2, 3, 4, 5, 6])\n    >>> a = np.array([[1],[2],[3]])\n    >>> b = np.array([[4],[5],[6]])\n    >>> np.hstack((a,b))\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n\n    \"\"\"\n    arrs = atleast_1d(*tup)\n    if not isinstance(arrs, tuple):\n        arrs = (arrs,)\n    # As a special case, dimension 0 of 1-dimensional arrays is \"horizontal\"\n    if arrs and arrs[0].ndim == 1:\n        return _nx.concatenate(arrs, 0, dtype=dtype, casting=casting)\n    else:\n        return _nx.concatenate(arrs, 1, dtype=dtype, casting=casting)\n\n\ndef _stack_dispatcher(arrays, axis=None, out=None, *,\n                      dtype=None, casting=None):\n    arrays = _arrays_for_stack_dispatcher(arrays)\n    if out is not None:\n        # optimize for the typical case where only arrays is provided\n        arrays = list(arrays)\n        arrays.append(out)\n    return arrays\n\n\n@array_function_dispatch(_stack_dispatcher)\ndef stack(arrays, axis=0, out=None, *, dtype=None, casting=\"same_kind\"):\n    \"\"\"\n    Join a sequence of arrays along a new axis.\n\n    The ``axis`` parameter specifies the index of the new axis in the\n    dimensions of the result. For example, if ``axis=0`` it will be the first\n    dimension and if ``axis=-1`` it will be the last dimension.\n\n    Parameters\n    ----------\n    arrays : sequence of ndarrays\n        Each array must have the same shape. In the case of a single ndarray\n        array_like input, it will be treated as a sequence of arrays; i.e.,\n        each element along the zeroth axis is treated as a separate array.\n\n    axis : int, optional\n        The axis in the result array along which the input arrays are stacked.\n\n    out : ndarray, optional\n        If provided, the destination to place the result. The shape must be\n        correct, matching that of what stack would have returned if no\n        out argument were specified.\n\n    dtype : str or dtype\n        If provided, the destination array will have this dtype. Cannot be\n        provided together with `out`.\n\n        .. versionadded:: 1.24\n\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n        .. versionadded:: 1.24\n\n\n    Returns\n    -------\n    stacked : ndarray\n        The stacked array has one more dimension than the input arrays.\n\n    See Also\n    --------\n    concatenate : Join a sequence of arrays along an existing axis.\n    block : Assemble an nd-array from nested lists of blocks.\n    split : Split array into a list of multiple sub-arrays of equal size.\n    unstack : Split an array into a tuple of sub-arrays along an axis.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> rng = np.random.default_rng()\n    >>> arrays = [rng.normal(size=(3,4)) for _ in range(10)]\n    >>> np.stack(arrays, axis=0).shape\n    (10, 3, 4)\n\n    >>> np.stack(arrays, axis=1).shape\n    (3, 10, 4)\n\n    >>> np.stack(arrays, axis=2).shape\n    (3, 4, 10)\n\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([4, 5, 6])\n    >>> np.stack((a, b))\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    >>> np.stack((a, b), axis=-1)\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n\n    \"\"\"\n    arrays = [asanyarray(arr) for arr in arrays]\n    if not arrays:\n        raise ValueError('need at least one array to stack')\n\n    shapes = {arr.shape for arr in arrays}\n    if len(shapes) != 1:\n        raise ValueError('all input arrays must have the same shape')\n\n    result_ndim = arrays[0].ndim + 1\n    axis = normalize_axis_index(axis, result_ndim)\n\n    sl = (slice(None),) * axis + (_nx.newaxis,)\n    expanded_arrays = [arr[sl] for arr in arrays]\n    return _nx.concatenate(expanded_arrays, axis=axis, out=out,\n                           dtype=dtype, casting=casting)\n\ndef _unstack_dispatcher(x, /, *, axis=None):\n    return (x,)\n\n@array_function_dispatch(_unstack_dispatcher)\ndef unstack(x, /, *, axis=0):\n    \"\"\"\n    Split an array into a sequence of arrays along the given axis.\n\n    The ``axis`` parameter specifies the dimension along which the array will\n    be split. For example, if ``axis=0`` (the default) it will be the first\n    dimension and if ``axis=-1`` it will be the last dimension.\n\n    The result is a tuple of arrays split along ``axis``.\n\n    .. versionadded:: 2.1.0\n\n    Parameters\n    ----------\n    x : ndarray\n        The array to be unstacked.\n    axis : int, optional\n        Axis along which the array will be split. Default: ``0``.\n\n    Returns\n    -------\n    unstacked : tuple of ndarrays\n        The unstacked arrays.\n\n    See Also\n    --------\n    stack : Join a sequence of arrays along a new axis.\n    concatenate : Join a sequence of arrays along an existing axis.\n    block : Assemble an nd-array from nested lists of blocks.\n    split : Split array into a list of multiple sub-arrays of equal size.\n\n    Notes\n    -----\n    ``unstack`` serves as the reverse operation of :py:func:`stack`, i.e.,\n    ``stack(unstack(x, axis=axis), axis=axis) == x``.\n\n    This function is equivalent to ``tuple(np.moveaxis(x, axis, 0))``, since\n    iterating on an array iterates along the first axis.\n\n    Examples\n    --------\n    >>> arr = np.arange(24).reshape((2, 3, 4))\n    >>> np.unstack(arr)\n    (array([[ 0,  1,  2,  3],\n            [ 4,  5,  6,  7],\n            [ 8,  9, 10, 11]]),\n     array([[12, 13, 14, 15],\n            [16, 17, 18, 19],\n            [20, 21, 22, 23]]))\n    >>> np.unstack(arr, axis=1)\n    (array([[ 0,  1,  2,  3],\n            [12, 13, 14, 15]]),\n     array([[ 4,  5,  6,  7],\n            [16, 17, 18, 19]]),\n     array([[ 8,  9, 10, 11],\n            [20, 21, 22, 23]]))\n    >>> arr2 = np.stack(np.unstack(arr, axis=1), axis=1)\n    >>> arr2.shape\n    (2, 3, 4)\n    >>> np.all(arr == arr2)\n    np.True_\n\n    \"\"\"\n    if x.ndim == 0:\n        raise ValueError(\"Input array must be at least 1-d.\")\n    return tuple(_nx.moveaxis(x, axis, 0))\n\n# Internal functions to eliminate the overhead of repeated dispatch in one of\n# the two possible paths inside np.block.\n# Use getattr to protect against __array_function__ being disabled.\n_size = getattr(_from_nx.size, '__wrapped__', _from_nx.size)\n_ndim = getattr(_from_nx.ndim, '__wrapped__', _from_nx.ndim)\n_concatenate = getattr(_from_nx.concatenate,\n                       '__wrapped__', _from_nx.concatenate)\n\n\ndef _block_format_index(index):\n    \"\"\"\n    Convert a list of indices ``[0, 1, 2]`` into ``\"arrays[0][1][2]\"``.\n    \"\"\"\n    idx_str = ''.join('[{}]'.format(i) for i in index if i is not None)\n    return 'arrays' + idx_str\n\n\ndef _block_check_depths_match(arrays, parent_index=[]):\n    \"\"\"\n    Recursive function checking that the depths of nested lists in `arrays`\n    all match. Mismatch raises a ValueError as described in the block\n    docstring below.\n\n    The entire index (rather than just the depth) needs to be calculated\n    for each innermost list, in case an error needs to be raised, so that\n    the index of the offending list can be printed as part of the error.\n\n    Parameters\n    ----------\n    arrays : nested list of arrays\n        The arrays to check\n    parent_index : list of int\n        The full index of `arrays` within the nested lists passed to\n        `_block_check_depths_match` at the top of the recursion.\n\n    Returns\n    -------\n    first_index : list of int\n        The full index of an element from the bottom of the nesting in\n        `arrays`. If any element at the bottom is an empty list, this will\n        refer to it, and the last index along the empty axis will be None.\n    max_arr_ndim : int\n        The maximum of the ndims of the arrays nested in `arrays`.\n    final_size: int\n        The number of elements in the final array. This is used the motivate\n        the choice of algorithm used using benchmarking wisdom.\n\n    \"\"\"\n    if type(arrays) is tuple:\n        # not strictly necessary, but saves us from:\n        #  - more than one way to do things - no point treating tuples like\n        #    lists\n        #  - horribly confusing behaviour that results when tuples are\n        #    treated like ndarray\n        raise TypeError(\n            '{} is a tuple. '\n            'Only lists can be used to arrange blocks, and np.block does '\n            'not allow implicit conversion from tuple to ndarray.'.format(\n                _block_format_index(parent_index)\n            )\n        )\n    elif type(arrays) is list and len(arrays) > 0:\n        idxs_ndims = (_block_check_depths_match(arr, parent_index + [i])\n                      for i, arr in enumerate(arrays))\n\n        first_index, max_arr_ndim, final_size = next(idxs_ndims)\n        for index, ndim, size in idxs_ndims:\n            final_size += size\n            if ndim > max_arr_ndim:\n                max_arr_ndim = ndim\n            if len(index) != len(first_index):\n                raise ValueError(\n                    \"List depths are mismatched. First element was at depth \"\n                    \"{}, but there is an element at depth {} ({})\".format(\n                        len(first_index),\n                        len(index),\n                        _block_format_index(index)\n                    )\n                )\n            # propagate our flag that indicates an empty list at the bottom\n            if index[-1] is None:\n                first_index = index\n\n        return first_index, max_arr_ndim, final_size\n    elif type(arrays) is list and len(arrays) == 0:\n        # We've 'bottomed out' on an empty list\n        return parent_index + [None], 0, 0\n    else:\n        # We've 'bottomed out' - arrays is either a scalar or an array\n        size = _size(arrays)\n        return parent_index, _ndim(arrays), size\n\n\ndef _atleast_nd(a, ndim):\n    # Ensures `a` has at least `ndim` dimensions by prepending\n    # ones to `a.shape` as necessary\n    return array(a, ndmin=ndim, copy=None, subok=True)\n\n\ndef _accumulate(values):\n    return list(itertools.accumulate(values))\n\n\ndef _concatenate_shapes(shapes, axis):\n    \"\"\"Given array shapes, return the resulting shape and slices prefixes.\n\n    These help in nested concatenation.\n\n    Returns\n    -------\n    shape: tuple of int\n        This tuple satisfies::\n\n            shape, _ = _concatenate_shapes([arr.shape for shape in arrs], axis)\n            shape == concatenate(arrs, axis).shape\n\n    slice_prefixes: tuple of (slice(start, end), )\n        For a list of arrays being concatenated, this returns the slice\n        in the larger array at axis that needs to be sliced into.\n\n        For example, the following holds::\n\n            ret = concatenate([a, b, c], axis)\n            _, (sl_a, sl_b, sl_c) = concatenate_slices([a, b, c], axis)\n\n            ret[(slice(None),) * axis + sl_a] == a\n            ret[(slice(None),) * axis + sl_b] == b\n            ret[(slice(None),) * axis + sl_c] == c\n\n        These are called slice prefixes since they are used in the recursive\n        blocking algorithm to compute the left-most slices during the\n        recursion. Therefore, they must be prepended to rest of the slice\n        that was computed deeper in the recursion.\n\n        These are returned as tuples to ensure that they can quickly be added\n        to existing slice tuple without creating a new tuple every time.\n\n    \"\"\"\n    # Cache a result that will be reused.\n    shape_at_axis = [shape[axis] for shape in shapes]\n\n    # Take a shape, any shape\n    first_shape = shapes[0]\n    first_shape_pre = first_shape[:axis]\n    first_shape_post = first_shape[axis+1:]\n\n    if any(shape[:axis] != first_shape_pre or\n           shape[axis+1:] != first_shape_post for shape in shapes):\n        raise ValueError(\n            'Mismatched array shapes in block along axis {}.'.format(axis))\n\n    shape = (first_shape_pre + (sum(shape_at_axis),) + first_shape[axis+1:])\n\n    offsets_at_axis = _accumulate(shape_at_axis)\n    slice_prefixes = [(slice(start, end),)\n                      for start, end in zip([0] + offsets_at_axis,\n                                            offsets_at_axis)]\n    return shape, slice_prefixes\n\n\ndef _block_info_recursion(arrays, max_depth, result_ndim, depth=0):\n    \"\"\"\n    Returns the shape of the final array, along with a list\n    of slices and a list of arrays that can be used for assignment inside the\n    new array\n\n    Parameters\n    ----------\n    arrays : nested list of arrays\n        The arrays to check\n    max_depth : list of int\n        The number of nested lists\n    result_ndim : int\n        The number of dimensions in thefinal array.\n\n    Returns\n    -------\n    shape : tuple of int\n        The shape that the final array will take on.\n    slices: list of tuple of slices\n        The slices into the full array required for assignment. These are\n        required to be prepended with ``(Ellipsis, )`` to obtain to correct\n        final index.\n    arrays: list of ndarray\n        The data to assign to each slice of the full array\n\n    \"\"\"\n    if depth < max_depth:\n        shapes, slices, arrays = zip(\n            *[_block_info_recursion(arr, max_depth, result_ndim, depth+1)\n              for arr in arrays])\n\n        axis = result_ndim - max_depth + depth\n        shape, slice_prefixes = _concatenate_shapes(shapes, axis)\n\n        # Prepend the slice prefix and flatten the slices\n        slices = [slice_prefix + the_slice\n                  for slice_prefix, inner_slices in zip(slice_prefixes, slices)\n                  for the_slice in inner_slices]\n\n        # Flatten the array list\n        arrays = functools.reduce(operator.add, arrays)\n\n        return shape, slices, arrays\n    else:\n        # We've 'bottomed out' - arrays is either a scalar or an array\n        # type(arrays) is not list\n        # Return the slice and the array inside a list to be consistent with\n        # the recursive case.\n        arr = _atleast_nd(arrays, result_ndim)\n        return arr.shape, [()], [arr]\n\n\ndef _block(arrays, max_depth, result_ndim, depth=0):\n    \"\"\"\n    Internal implementation of block based on repeated concatenation.\n    `arrays` is the argument passed to\n    block. `max_depth` is the depth of nested lists within `arrays` and\n    `result_ndim` is the greatest of the dimensions of the arrays in\n    `arrays` and the depth of the lists in `arrays` (see block docstring\n    for details).\n    \"\"\"\n    if depth < max_depth:\n        arrs = [_block(arr, max_depth, result_ndim, depth+1)\n                for arr in arrays]\n        return _concatenate(arrs, axis=-(max_depth-depth))\n    else:\n        # We've 'bottomed out' - arrays is either a scalar or an array\n        # type(arrays) is not list\n        return _atleast_nd(arrays, result_ndim)\n\n\ndef _block_dispatcher(arrays):\n    # Use type(...) is list to match the behavior of np.block(), which special\n    # cases list specifically rather than allowing for generic iterables or\n    # tuple. Also, we know that list.__array_function__ will never exist.\n    if type(arrays) is list:\n        for subarrays in arrays:\n            yield from _block_dispatcher(subarrays)\n    else:\n        yield arrays\n\n\n@array_function_dispatch(_block_dispatcher)\ndef block(arrays):\n    \"\"\"\n    Assemble an nd-array from nested lists of blocks.\n\n    Blocks in the innermost lists are concatenated (see `concatenate`) along\n    the last dimension (-1), then these are concatenated along the\n    second-last dimension (-2), and so on until the outermost list is reached.\n\n    Blocks can be of any dimension, but will not be broadcasted using\n    the normal rules. Instead, leading axes of size 1 are inserted,\n    to make ``block.ndim`` the same for all blocks. This is primarily useful\n    for working with scalars, and means that code like ``np.block([v, 1])``\n    is valid, where ``v.ndim == 1``.\n\n    When the nested list is two levels deep, this allows block matrices to be\n    constructed from their components.\n\n    Parameters\n    ----------\n    arrays : nested list of array_like or scalars (but not tuples)\n        If passed a single ndarray or scalar (a nested list of depth 0), this\n        is returned unmodified (and not copied).\n\n        Elements shapes must match along the appropriate axes (without\n        broadcasting), but leading 1s will be prepended to the shape as\n        necessary to make the dimensions match.\n\n    Returns\n    -------\n    block_array : ndarray\n        The array assembled from the given blocks.\n\n        The dimensionality of the output is equal to the greatest of:\n\n        * the dimensionality of all the inputs\n        * the depth to which the input list is nested\n\n    Raises\n    ------\n    ValueError\n        * If list depths are mismatched - for instance, ``[[a, b], c]`` is\n          illegal, and should be spelt ``[[a, b], [c]]``\n        * If lists are empty - for instance, ``[[a, b], []]``\n\n    See Also\n    --------\n    concatenate : Join a sequence of arrays along an existing axis.\n    stack : Join a sequence of arrays along a new axis.\n    vstack : Stack arrays in sequence vertically (row wise).\n    hstack : Stack arrays in sequence horizontally (column wise).\n    dstack : Stack arrays in sequence depth wise (along third axis).\n    column_stack : Stack 1-D arrays as columns into a 2-D array.\n    vsplit : Split an array into multiple sub-arrays vertically (row-wise).\n    unstack : Split an array into a tuple of sub-arrays along an axis.\n\n    Notes\n    -----\n    When called with only scalars, ``np.block`` is equivalent to an ndarray\n    call. So ``np.block([[1, 2], [3, 4]])`` is equivalent to\n    ``np.array([[1, 2], [3, 4]])``.\n\n    This function does not enforce that the blocks lie on a fixed grid.\n    ``np.block([[a, b], [c, d]])`` is not restricted to arrays of the form::\n\n        AAAbb\n        AAAbb\n        cccDD\n\n    But is also allowed to produce, for some ``a, b, c, d``::\n\n        AAAbb\n        AAAbb\n        cDDDD\n\n    Since concatenation happens along the last axis first, `block` is *not*\n    capable of producing the following directly::\n\n        AAAbb\n        cccbb\n        cccDD\n\n    Matlab's \"square bracket stacking\", ``[A, B, ...; p, q, ...]``, is\n    equivalent to ``np.block([[A, B, ...], [p, q, ...]])``.\n\n    Examples\n    --------\n    The most common use of this function is to build a block matrix:\n\n    >>> import numpy as np\n    >>> A = np.eye(2) * 2\n    >>> B = np.eye(3) * 3\n    >>> np.block([\n    ...     [A,               np.zeros((2, 3))],\n    ...     [np.ones((3, 2)), B               ]\n    ... ])\n    array([[2., 0., 0., 0., 0.],\n           [0., 2., 0., 0., 0.],\n           [1., 1., 3., 0., 0.],\n           [1., 1., 0., 3., 0.],\n           [1., 1., 0., 0., 3.]])\n\n    With a list of depth 1, `block` can be used as `hstack`:\n\n    >>> np.block([1, 2, 3])              # hstack([1, 2, 3])\n    array([1, 2, 3])\n\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([4, 5, 6])\n    >>> np.block([a, b, 10])             # hstack([a, b, 10])\n    array([ 1,  2,  3,  4,  5,  6, 10])\n\n    >>> A = np.ones((2, 2), int)\n    >>> B = 2 * A\n    >>> np.block([A, B])                 # hstack([A, B])\n    array([[1, 1, 2, 2],\n           [1, 1, 2, 2]])\n\n    With a list of depth 2, `block` can be used in place of `vstack`:\n\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([4, 5, 6])\n    >>> np.block([[a], [b]])             # vstack([a, b])\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    >>> A = np.ones((2, 2), int)\n    >>> B = 2 * A\n    >>> np.block([[A], [B]])             # vstack([A, B])\n    array([[1, 1],\n           [1, 1],\n           [2, 2],\n           [2, 2]])\n\n    It can also be used in place of `atleast_1d` and `atleast_2d`:\n\n    >>> a = np.array(0)\n    >>> b = np.array([1])\n    >>> np.block([a])                    # atleast_1d(a)\n    array([0])\n    >>> np.block([b])                    # atleast_1d(b)\n    array([1])\n\n    >>> np.block([[a]])                  # atleast_2d(a)\n    array([[0]])\n    >>> np.block([[b]])                  # atleast_2d(b)\n    array([[1]])\n\n\n    \"\"\"\n    arrays, list_ndim, result_ndim, final_size = _block_setup(arrays)\n\n    # It was found through benchmarking that making an array of final size\n    # around 256x256 was faster by straight concatenation on a\n    # i7-7700HQ processor and dual channel ram 2400MHz.\n    # It didn't seem to matter heavily on the dtype used.\n    #\n    # A 2D array using repeated concatenation requires 2 copies of the array.\n    #\n    # The fastest algorithm will depend on the ratio of CPU power to memory\n    # speed.\n    # One can monitor the results of the benchmark\n    # https://pv.github.io/numpy-bench/#bench_shape_base.Block2D.time_block2d\n    # to tune this parameter until a C version of the `_block_info_recursion`\n    # algorithm is implemented which would likely be faster than the python\n    # version.\n    if list_ndim * final_size > (2 * 512 * 512):\n        return _block_slicing(arrays, list_ndim, result_ndim)\n    else:\n        return _block_concatenate(arrays, list_ndim, result_ndim)\n\n\n# These helper functions are mostly used for testing.\n# They allow us to write tests that directly call `_block_slicing`\n# or `_block_concatenate` without blocking large arrays to force the wisdom\n# to trigger the desired path.\ndef _block_setup(arrays):\n    \"\"\"\n    Returns\n    (`arrays`, list_ndim, result_ndim, final_size)\n    \"\"\"\n    bottom_index, arr_ndim, final_size = _block_check_depths_match(arrays)\n    list_ndim = len(bottom_index)\n    if bottom_index and bottom_index[-1] is None:\n        raise ValueError(\n            'List at {} cannot be empty'.format(\n                _block_format_index(bottom_index)\n            )\n        )\n    result_ndim = max(arr_ndim, list_ndim)\n    return arrays, list_ndim, result_ndim, final_size\n\n\ndef _block_slicing(arrays, list_ndim, result_ndim):\n    shape, slices, arrays = _block_info_recursion(\n        arrays, list_ndim, result_ndim)\n    dtype = _nx.result_type(*[arr.dtype for arr in arrays])\n\n    # Test preferring F only in the case that all input arrays are F\n    F_order = all(arr.flags['F_CONTIGUOUS'] for arr in arrays)\n    C_order = all(arr.flags['C_CONTIGUOUS'] for arr in arrays)\n    order = 'F' if F_order and not C_order else 'C'\n    result = _nx.empty(shape=shape, dtype=dtype, order=order)\n    # Note: In a c implementation, the function\n    # PyArray_CreateMultiSortedStridePerm could be used for more advanced\n    # guessing of the desired order.\n\n    for the_slice, arr in zip(slices, arrays):\n        result[(Ellipsis,) + the_slice] = arr\n    return result\n\n\ndef _block_concatenate(arrays, list_ndim, result_ndim):\n    result = _block(arrays, list_ndim, result_ndim)\n    if list_ndim == 0:\n        # Catch an edge case where _block returns a view because\n        # `arrays` is a single numpy array and not a list of numpy arrays.\n        # This might copy scalars or lists twice, but this isn't a likely\n        # usecase for those interested in performance\n        result = result.copy()\n    return result\n", 1004], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py": ["\"\"\"\nUnified interfaces to minimization algorithms.\n\nFunctions\n---------\n- minimize : minimization of a function of several variables.\n- minimize_scalar : minimization of a function of one variable.\n\"\"\"\n\n__all__ = ['minimize', 'minimize_scalar']\n\n\nfrom warnings import warn\n\nimport numpy as np\n\n# unconstrained minimization\nfrom ._optimize import (_minimize_neldermead, _minimize_powell, _minimize_cg,\n                        _minimize_bfgs, _minimize_newtoncg,\n                        _minimize_scalar_brent, _minimize_scalar_bounded,\n                        _minimize_scalar_golden, MemoizeJac, OptimizeResult,\n                        _wrap_callback, _recover_from_bracket_error)\nfrom ._trustregion_dogleg import _minimize_dogleg\nfrom ._trustregion_ncg import _minimize_trust_ncg\nfrom ._trustregion_krylov import _minimize_trust_krylov\nfrom ._trustregion_exact import _minimize_trustregion_exact\nfrom ._trustregion_constr import _minimize_trustregion_constr\n\n# constrained minimization\nfrom ._lbfgsb_py import _minimize_lbfgsb\nfrom ._tnc import _minimize_tnc\nfrom ._cobyla_py import _minimize_cobyla\nfrom ._cobyqa_py import _minimize_cobyqa\nfrom ._slsqp_py import _minimize_slsqp\nfrom ._constraints import (old_bound_to_new, new_bounds_to_old,\n                           old_constraint_to_new, new_constraint_to_old,\n                           NonlinearConstraint, LinearConstraint, Bounds,\n                           PreparedConstraint)\nfrom ._differentiable_functions import FD_METHODS\n\nMINIMIZE_METHODS = ['nelder-mead', 'powell', 'cg', 'bfgs', 'newton-cg',\n                    'l-bfgs-b', 'tnc', 'cobyla', 'cobyqa', 'slsqp',\n                    'trust-constr', 'dogleg', 'trust-ncg', 'trust-exact',\n                    'trust-krylov']\n\n# These methods support the new callback interface (passed an OptimizeResult)\nMINIMIZE_METHODS_NEW_CB = ['nelder-mead', 'powell', 'cg', 'bfgs', 'newton-cg',\n                           'l-bfgs-b', 'trust-constr', 'dogleg', 'trust-ncg',\n                           'trust-exact', 'trust-krylov', 'cobyqa']\n\nMINIMIZE_SCALAR_METHODS = ['brent', 'bounded', 'golden']\n\ndef minimize(fun, x0, args=(), method=None, jac=None, hess=None,\n             hessp=None, bounds=None, constraints=(), tol=None,\n             callback=None, options=None):\n    \"\"\"Minimization of scalar function of one or more variables.\n\n    Parameters\n    ----------\n    fun : callable\n        The objective function to be minimized::\n\n            fun(x, *args) -> float\n\n        where ``x`` is a 1-D array with shape (n,) and ``args``\n        is a tuple of the fixed parameters needed to completely\n        specify the function.\n\n        Suppose the callable has signature ``f0(x, *my_args, **my_kwargs)``, where\n        ``my_args`` and ``my_kwargs`` are required positional and keyword arguments.\n        Rather than passing ``f0`` as the callable, wrap it to accept\n        only ``x``; e.g., pass ``fun=lambda x: f0(x, *my_args, **my_kwargs)`` as the\n        callable, where ``my_args`` (tuple) and ``my_kwargs`` (dict) have been\n        gathered before invoking this function.\n    x0 : ndarray, shape (n,)\n        Initial guess. Array of real elements of size (n,),\n        where ``n`` is the number of independent variables.\n    args : tuple, optional\n        Extra arguments passed to the objective function and its\n        derivatives (`fun`, `jac` and `hess` functions).\n    method : str or callable, optional\n        Type of solver.  Should be one of\n\n        - 'Nelder-Mead' :ref:`(see here) <optimize.minimize-neldermead>`\n        - 'Powell'      :ref:`(see here) <optimize.minimize-powell>`\n        - 'CG'          :ref:`(see here) <optimize.minimize-cg>`\n        - 'BFGS'        :ref:`(see here) <optimize.minimize-bfgs>`\n        - 'Newton-CG'   :ref:`(see here) <optimize.minimize-newtoncg>`\n        - 'L-BFGS-B'    :ref:`(see here) <optimize.minimize-lbfgsb>`\n        - 'TNC'         :ref:`(see here) <optimize.minimize-tnc>`\n        - 'COBYLA'      :ref:`(see here) <optimize.minimize-cobyla>`\n        - 'COBYQA'      :ref:`(see here) <optimize.minimize-cobyqa>`\n        - 'SLSQP'       :ref:`(see here) <optimize.minimize-slsqp>`\n        - 'trust-constr':ref:`(see here) <optimize.minimize-trustconstr>`\n        - 'dogleg'      :ref:`(see here) <optimize.minimize-dogleg>`\n        - 'trust-ncg'   :ref:`(see here) <optimize.minimize-trustncg>`\n        - 'trust-exact' :ref:`(see here) <optimize.minimize-trustexact>`\n        - 'trust-krylov' :ref:`(see here) <optimize.minimize-trustkrylov>`\n        - custom - a callable object, see below for description.\n\n        If not given, chosen to be one of ``BFGS``, ``L-BFGS-B``, ``SLSQP``,\n        depending on whether or not the problem has constraints or bounds.\n    jac : {callable,  '2-point', '3-point', 'cs', bool}, optional\n        Method for computing the gradient vector. Only for CG, BFGS,\n        Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg, trust-krylov,\n        trust-exact and trust-constr.\n        If it is a callable, it should be a function that returns the gradient\n        vector::\n\n            jac(x, *args) -> array_like, shape (n,)\n\n        where ``x`` is an array with shape (n,) and ``args`` is a tuple with\n        the fixed parameters. If `jac` is a Boolean and is True, `fun` is\n        assumed to return a tuple ``(f, g)`` containing the objective\n        function and the gradient.\n        Methods 'Newton-CG', 'trust-ncg', 'dogleg', 'trust-exact', and\n        'trust-krylov' require that either a callable be supplied, or that\n        `fun` return the objective and gradient.\n        If None or False, the gradient will be estimated using 2-point finite\n        difference estimation with an absolute step size.\n        Alternatively, the keywords  {'2-point', '3-point', 'cs'} can be used\n        to select a finite difference scheme for numerical estimation of the\n        gradient with a relative step size. These finite difference schemes\n        obey any specified `bounds`.\n    hess : {callable, '2-point', '3-point', 'cs', HessianUpdateStrategy}, optional\n        Method for computing the Hessian matrix. Only for Newton-CG, dogleg,\n        trust-ncg, trust-krylov, trust-exact and trust-constr.\n        If it is callable, it should return the Hessian matrix::\n\n            hess(x, *args) -> {LinearOperator, spmatrix, array}, (n, n)\n\n        where ``x`` is a (n,) ndarray and ``args`` is a tuple with the fixed\n        parameters.\n        The keywords {'2-point', '3-point', 'cs'} can also be used to select\n        a finite difference scheme for numerical estimation of the hessian.\n        Alternatively, objects implementing the `HessianUpdateStrategy`\n        interface can be used to approximate the Hessian. Available\n        quasi-Newton methods implementing this interface are:\n\n        - `BFGS`\n        - `SR1`\n\n        Not all of the options are available for each of the methods; for\n        availability refer to the notes.\n    hessp : callable, optional\n        Hessian of objective function times an arbitrary vector p. Only for\n        Newton-CG, trust-ncg, trust-krylov, trust-constr.\n        Only one of `hessp` or `hess` needs to be given. If `hess` is\n        provided, then `hessp` will be ignored. `hessp` must compute the\n        Hessian times an arbitrary vector::\n\n            hessp(x, p, *args) ->  ndarray shape (n,)\n\n        where ``x`` is a (n,) ndarray, ``p`` is an arbitrary vector with\n        dimension (n,) and ``args`` is a tuple with the fixed\n        parameters.\n    bounds : sequence or `Bounds`, optional\n        Bounds on variables for Nelder-Mead, L-BFGS-B, TNC, SLSQP, Powell,\n        trust-constr, COBYLA, and COBYQA methods. There are two ways to specify\n        the bounds:\n\n        1. Instance of `Bounds` class.\n        2. Sequence of ``(min, max)`` pairs for each element in `x`. None\n           is used to specify no bound.\n\n    constraints : {Constraint, dict} or List of {Constraint, dict}, optional\n        Constraints definition. Only for COBYLA, COBYQA, SLSQP and trust-constr.\n\n        Constraints for 'trust-constr' and 'cobyqa' are defined as a single object\n        or a list of objects specifying constraints to the optimization problem.\n        Available constraints are:\n\n        - `LinearConstraint`\n        - `NonlinearConstraint`\n\n        Constraints for COBYLA, SLSQP are defined as a list of dictionaries.\n        Each dictionary with fields:\n\n        type : str\n            Constraint type: 'eq' for equality, 'ineq' for inequality.\n        fun : callable\n            The function defining the constraint.\n        jac : callable, optional\n            The Jacobian of `fun` (only for SLSQP).\n        args : sequence, optional\n            Extra arguments to be passed to the function and Jacobian.\n\n        Equality constraint means that the constraint function result is to\n        be zero whereas inequality means that it is to be non-negative.\n        Note that COBYLA only supports inequality constraints.\n\n    tol : float, optional\n        Tolerance for termination. When `tol` is specified, the selected\n        minimization algorithm sets some relevant solver-specific tolerance(s)\n        equal to `tol`. For detailed control, use solver-specific\n        options.\n    options : dict, optional\n        A dictionary of solver options. All methods except `TNC` accept the\n        following generic options:\n\n        maxiter : int\n            Maximum number of iterations to perform. Depending on the\n            method each iteration may use several function evaluations.\n\n            For `TNC` use `maxfun` instead of `maxiter`.\n        disp : bool\n            Set to True to print convergence messages.\n\n        For method-specific options, see :func:`show_options()`.\n    callback : callable, optional\n        A callable called after each iteration.\n\n        All methods except TNC, SLSQP, and COBYLA support a callable with\n        the signature::\n\n            callback(intermediate_result: OptimizeResult)\n\n        where ``intermediate_result`` is a keyword parameter containing an\n        `OptimizeResult` with attributes ``x`` and ``fun``, the present values\n        of the parameter vector and objective function. Note that the name\n        of the parameter must be ``intermediate_result`` for the callback\n        to be passed an `OptimizeResult`. These methods will also terminate if\n        the callback raises ``StopIteration``.\n\n        All methods except trust-constr (also) support a signature like::\n\n            callback(xk)\n\n        where ``xk`` is the current parameter vector.\n\n        Introspection is used to determine which of the signatures above to\n        invoke.\n\n    Returns\n    -------\n    res : OptimizeResult\n        The optimization result represented as a ``OptimizeResult`` object.\n        Important attributes are: ``x`` the solution array, ``success`` a\n        Boolean flag indicating if the optimizer exited successfully and\n        ``message`` which describes the cause of the termination. See\n        `OptimizeResult` for a description of other attributes.\n\n    See also\n    --------\n    minimize_scalar : Interface to minimization algorithms for scalar\n        univariate functions\n    show_options : Additional options accepted by the solvers\n\n    Notes\n    -----\n    This section describes the available solvers that can be selected by the\n    'method' parameter. The default method is *BFGS*.\n\n    **Unconstrained minimization**\n\n    Method :ref:`CG <optimize.minimize-cg>` uses a nonlinear conjugate\n    gradient algorithm by Polak and Ribiere, a variant of the\n    Fletcher-Reeves method described in [5]_ pp.120-122. Only the\n    first derivatives are used.\n\n    Method :ref:`BFGS <optimize.minimize-bfgs>` uses the quasi-Newton\n    method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS) [5]_\n    pp. 136. It uses the first derivatives only. BFGS has proven good\n    performance even for non-smooth optimizations. This method also\n    returns an approximation of the Hessian inverse, stored as\n    `hess_inv` in the OptimizeResult object.\n\n    Method :ref:`Newton-CG <optimize.minimize-newtoncg>` uses a\n    Newton-CG algorithm [5]_ pp. 168 (also known as the truncated\n    Newton method). It uses a CG method to the compute the search\n    direction. See also *TNC* method for a box-constrained\n    minimization with a similar algorithm. Suitable for large-scale\n    problems.\n\n    Method :ref:`dogleg <optimize.minimize-dogleg>` uses the dog-leg\n    trust-region algorithm [5]_ for unconstrained minimization. This\n    algorithm requires the gradient and Hessian; furthermore the\n    Hessian is required to be positive definite.\n\n    Method :ref:`trust-ncg <optimize.minimize-trustncg>` uses the\n    Newton conjugate gradient trust-region algorithm [5]_ for\n    unconstrained minimization. This algorithm requires the gradient\n    and either the Hessian or a function that computes the product of\n    the Hessian with a given vector. Suitable for large-scale problems.\n\n    Method :ref:`trust-krylov <optimize.minimize-trustkrylov>` uses\n    the Newton GLTR trust-region algorithm [14]_, [15]_ for unconstrained\n    minimization. This algorithm requires the gradient\n    and either the Hessian or a function that computes the product of\n    the Hessian with a given vector. Suitable for large-scale problems.\n    On indefinite problems it requires usually less iterations than the\n    `trust-ncg` method and is recommended for medium and large-scale problems.\n\n    Method :ref:`trust-exact <optimize.minimize-trustexact>`\n    is a trust-region method for unconstrained minimization in which\n    quadratic subproblems are solved almost exactly [13]_. This\n    algorithm requires the gradient and the Hessian (which is\n    *not* required to be positive definite). It is, in many\n    situations, the Newton method to converge in fewer iterations\n    and the most recommended for small and medium-size problems.\n\n    **Bound-Constrained minimization**\n\n    Method :ref:`Nelder-Mead <optimize.minimize-neldermead>` uses the\n    Simplex algorithm [1]_, [2]_. This algorithm is robust in many\n    applications. However, if numerical computation of derivative can be\n    trusted, other algorithms using the first and/or second derivatives\n    information might be preferred for their better performance in\n    general.\n\n    Method :ref:`L-BFGS-B <optimize.minimize-lbfgsb>` uses the L-BFGS-B\n    algorithm [6]_, [7]_ for bound constrained minimization.\n\n    Method :ref:`Powell <optimize.minimize-powell>` is a modification\n    of Powell's method [3]_, [4]_ which is a conjugate direction\n    method. It performs sequential one-dimensional minimizations along\n    each vector of the directions set (`direc` field in `options` and\n    `info`), which is updated at each iteration of the main\n    minimization loop. The function need not be differentiable, and no\n    derivatives are taken. If bounds are not provided, then an\n    unbounded line search will be used. If bounds are provided and\n    the initial guess is within the bounds, then every function\n    evaluation throughout the minimization procedure will be within\n    the bounds. If bounds are provided, the initial guess is outside\n    the bounds, and `direc` is full rank (default has full rank), then\n    some function evaluations during the first iteration may be\n    outside the bounds, but every function evaluation after the first\n    iteration will be within the bounds. If `direc` is not full rank,\n    then some parameters may not be optimized and the solution is not\n    guaranteed to be within the bounds.\n\n    Method :ref:`TNC <optimize.minimize-tnc>` uses a truncated Newton\n    algorithm [5]_, [8]_ to minimize a function with variables subject\n    to bounds. This algorithm uses gradient information; it is also\n    called Newton Conjugate-Gradient. It differs from the *Newton-CG*\n    method described above as it wraps a C implementation and allows\n    each variable to be given upper and lower bounds.\n\n    **Constrained Minimization**\n\n    Method :ref:`COBYLA <optimize.minimize-cobyla>` uses the\n    Constrained Optimization BY Linear Approximation (COBYLA) method\n    [9]_, [10]_, [11]_. The algorithm is based on linear\n    approximations to the objective function and each constraint. The\n    method wraps a FORTRAN implementation of the algorithm. The\n    constraints functions 'fun' may return either a single number\n    or an array or list of numbers.\n\n    Method :ref:`COBYQA <optimize.minimize-cobyqa>` uses the Constrained\n    Optimization BY Quadratic Approximations (COBYQA) method [18]_. The\n    algorithm is a derivative-free trust-region SQP method based on quadratic\n    approximations to the objective function and each nonlinear constraint. The\n    bounds are treated as unrelaxable constraints, in the sense that the\n    algorithm always respects them throughout the optimization process.\n\n    Method :ref:`SLSQP <optimize.minimize-slsqp>` uses Sequential\n    Least SQuares Programming to minimize a function of several\n    variables with any combination of bounds, equality and inequality\n    constraints. The method wraps the SLSQP Optimization subroutine\n    originally implemented by Dieter Kraft [12]_. Note that the\n    wrapper handles infinite values in bounds by converting them into\n    large floating values.\n\n    Method :ref:`trust-constr <optimize.minimize-trustconstr>` is a\n    trust-region algorithm for constrained optimization. It switches\n    between two implementations depending on the problem definition.\n    It is the most versatile constrained minimization algorithm\n    implemented in SciPy and the most appropriate for large-scale problems.\n    For equality constrained problems it is an implementation of Byrd-Omojokun\n    Trust-Region SQP method described in [17]_ and in [5]_, p. 549. When\n    inequality constraints are imposed as well, it switches to the trust-region\n    interior point method described in [16]_. This interior point algorithm,\n    in turn, solves inequality constraints by introducing slack variables\n    and solving a sequence of equality-constrained barrier problems\n    for progressively smaller values of the barrier parameter.\n    The previously described equality constrained SQP method is\n    used to solve the subproblems with increasing levels of accuracy\n    as the iterate gets closer to a solution.\n\n    **Finite-Difference Options**\n\n    For Method :ref:`trust-constr <optimize.minimize-trustconstr>`\n    the gradient and the Hessian may be approximated using\n    three finite-difference schemes: {'2-point', '3-point', 'cs'}.\n    The scheme 'cs' is, potentially, the most accurate but it\n    requires the function to correctly handle complex inputs and to\n    be differentiable in the complex plane. The scheme '3-point' is more\n    accurate than '2-point' but requires twice as many operations. If the\n    gradient is estimated via finite-differences the Hessian must be\n    estimated using one of the quasi-Newton strategies.\n\n    **Method specific options for the** `hess` **keyword**\n\n    +--------------+------+----------+-------------------------+-----+\n    | method/Hess  | None | callable | '2-point/'3-point'/'cs' | HUS |\n    +==============+======+==========+=========================+=====+\n    | Newton-CG    | x    | (n, n)   | x                       | x   |\n    |              |      | LO       |                         |     |\n    +--------------+------+----------+-------------------------+-----+\n    | dogleg       |      | (n, n)   |                         |     |\n    +--------------+------+----------+-------------------------+-----+\n    | trust-ncg    |      | (n, n)   | x                       | x   |\n    +--------------+------+----------+-------------------------+-----+\n    | trust-krylov |      | (n, n)   | x                       | x   |\n    +--------------+------+----------+-------------------------+-----+\n    | trust-exact  |      | (n, n)   |                         |     |\n    +--------------+------+----------+-------------------------+-----+\n    | trust-constr | x    | (n, n)   |  x                      | x   |\n    |              |      | LO       |                         |     |\n    |              |      | sp       |                         |     |\n    +--------------+------+----------+-------------------------+-----+\n\n    where LO=LinearOperator, sp=Sparse matrix, HUS=HessianUpdateStrategy\n\n    **Custom minimizers**\n\n    It may be useful to pass a custom minimization method, for example\n    when using a frontend to this method such as `scipy.optimize.basinhopping`\n    or a different library.  You can simply pass a callable as the ``method``\n    parameter.\n\n    The callable is called as ``method(fun, x0, args, **kwargs, **options)``\n    where ``kwargs`` corresponds to any other parameters passed to `minimize`\n    (such as `callback`, `hess`, etc.), except the `options` dict, which has\n    its contents also passed as `method` parameters pair by pair.  Also, if\n    `jac` has been passed as a bool type, `jac` and `fun` are mangled so that\n    `fun` returns just the function values and `jac` is converted to a function\n    returning the Jacobian.  The method shall return an `OptimizeResult`\n    object.\n\n    The provided `method` callable must be able to accept (and possibly ignore)\n    arbitrary parameters; the set of parameters accepted by `minimize` may\n    expand in future versions and then these parameters will be passed to\n    the method.  You can find an example in the scipy.optimize tutorial.\n\n    References\n    ----------\n    .. [1] Nelder, J A, and R Mead. 1965. A Simplex Method for Function\n        Minimization. The Computer Journal 7: 308-13.\n    .. [2] Wright M H. 1996. Direct search methods: Once scorned, now\n        respectable, in Numerical Analysis 1995: Proceedings of the 1995\n        Dundee Biennial Conference in Numerical Analysis (Eds. D F\n        Griffiths and G A Watson). Addison Wesley Longman, Harlow, UK.\n        191-208.\n    .. [3] Powell, M J D. 1964. An efficient method for finding the minimum of\n       a function of several variables without calculating derivatives. The\n       Computer Journal 7: 155-162.\n    .. [4] Press W, S A Teukolsky, W T Vetterling and B P Flannery.\n       Numerical Recipes (any edition), Cambridge University Press.\n    .. [5] Nocedal, J, and S J Wright. 2006. Numerical Optimization.\n       Springer New York.\n    .. [6] Byrd, R H and P Lu and J. Nocedal. 1995. A Limited Memory\n       Algorithm for Bound Constrained Optimization. SIAM Journal on\n       Scientific and Statistical Computing 16 (5): 1190-1208.\n    .. [7] Zhu, C and R H Byrd and J Nocedal. 1997. L-BFGS-B: Algorithm\n       778: L-BFGS-B, FORTRAN routines for large scale bound constrained\n       optimization. ACM Transactions on Mathematical Software 23 (4):\n       550-560.\n    .. [8] Nash, S G. Newton-Type Minimization Via the Lanczos Method.\n       1984. SIAM Journal of Numerical Analysis 21: 770-778.\n    .. [9] Powell, M J D. A direct search optimization method that models\n       the objective and constraint functions by linear interpolation.\n       1994. Advances in Optimization and Numerical Analysis, eds. S. Gomez\n       and J-P Hennart, Kluwer Academic (Dordrecht), 51-67.\n    .. [10] Powell M J D. Direct search algorithms for optimization\n       calculations. 1998. Acta Numerica 7: 287-336.\n    .. [11] Powell M J D. A view of algorithms for optimization without\n       derivatives. 2007.Cambridge University Technical Report DAMTP\n       2007/NA03\n    .. [12] Kraft, D. A software package for sequential quadratic\n       programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace\n       Center -- Institute for Flight Mechanics, Koln, Germany.\n    .. [13] Conn, A. R., Gould, N. I., and Toint, P. L.\n       Trust region methods. 2000. Siam. pp. 169-200.\n    .. [14] F. Lenders, C. Kirches, A. Potschka: \"trlib: A vector-free\n       implementation of the GLTR method for iterative solution of\n       the trust region problem\", :arxiv:`1611.04718`\n    .. [15] N. Gould, S. Lucidi, M. Roma, P. Toint: \"Solving the\n       Trust-Region Subproblem using the Lanczos Method\",\n       SIAM J. Optim., 9(2), 504--525, (1999).\n    .. [16] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999.\n        An interior point algorithm for large-scale nonlinear  programming.\n        SIAM Journal on Optimization 9.4: 877-900.\n    .. [17] Lalee, Marucha, Jorge Nocedal, and Todd Plantenga. 1998. On the\n        implementation of an algorithm for large-scale equality constrained\n        optimization. SIAM Journal on Optimization 8.3: 682-706.\n    .. [18] Ragonneau, T. M. *Model-Based Derivative-Free Optimization Methods\n        and Software*. PhD thesis, Department of Applied Mathematics, The Hong\n        Kong Polytechnic University, Hong Kong, China, 2022. URL:\n        https://theses.lib.polyu.edu.hk/handle/200/12294.\n\n    Examples\n    --------\n    Let us consider the problem of minimizing the Rosenbrock function. This\n    function (and its respective derivatives) is implemented in `rosen`\n    (resp. `rosen_der`, `rosen_hess`) in the `scipy.optimize`.\n\n    >>> from scipy.optimize import minimize, rosen, rosen_der\n\n    A simple application of the *Nelder-Mead* method is:\n\n    >>> x0 = [1.3, 0.7, 0.8, 1.9, 1.2]\n    >>> res = minimize(rosen, x0, method='Nelder-Mead', tol=1e-6)\n    >>> res.x\n    array([ 1.,  1.,  1.,  1.,  1.])\n\n    Now using the *BFGS* algorithm, using the first derivative and a few\n    options:\n\n    >>> res = minimize(rosen, x0, method='BFGS', jac=rosen_der,\n    ...                options={'gtol': 1e-6, 'disp': True})\n    Optimization terminated successfully.\n             Current function value: 0.000000\n             Iterations: 26\n             Function evaluations: 31\n             Gradient evaluations: 31\n    >>> res.x\n    array([ 1.,  1.,  1.,  1.,  1.])\n    >>> print(res.message)\n    Optimization terminated successfully.\n    >>> res.hess_inv\n    array([\n        [ 0.00749589,  0.01255155,  0.02396251,  0.04750988,  0.09495377],  # may vary\n        [ 0.01255155,  0.02510441,  0.04794055,  0.09502834,  0.18996269],\n        [ 0.02396251,  0.04794055,  0.09631614,  0.19092151,  0.38165151],\n        [ 0.04750988,  0.09502834,  0.19092151,  0.38341252,  0.7664427 ],\n        [ 0.09495377,  0.18996269,  0.38165151,  0.7664427,   1.53713523]\n    ])\n\n\n    Next, consider a minimization problem with several constraints (namely\n    Example 16.4 from [5]_). The objective function is:\n\n    >>> fun = lambda x: (x[0] - 1)**2 + (x[1] - 2.5)**2\n\n    There are three constraints defined as:\n\n    >>> cons = ({'type': 'ineq', 'fun': lambda x:  x[0] - 2 * x[1] + 2},\n    ...         {'type': 'ineq', 'fun': lambda x: -x[0] - 2 * x[1] + 6},\n    ...         {'type': 'ineq', 'fun': lambda x: -x[0] + 2 * x[1] + 2})\n\n    And variables must be positive, hence the following bounds:\n\n    >>> bnds = ((0, None), (0, None))\n\n    The optimization problem is solved using the SLSQP method as:\n\n    >>> res = minimize(fun, (2, 0), method='SLSQP', bounds=bnds,\n    ...                constraints=cons)\n\n    It should converge to the theoretical solution (1.4 ,1.7).\n\n    \"\"\"\n    x0 = np.atleast_1d(np.asarray(x0))\n\n    if x0.ndim != 1:\n        raise ValueError(\"'x0' must only have one dimension.\")\n\n    if x0.dtype.kind in np.typecodes[\"AllInteger\"]:\n        x0 = np.asarray(x0, dtype=float)\n\n    if not isinstance(args, tuple):\n        args = (args,)\n\n    if method is None:\n        # Select automatically\n        if constraints:\n            method = 'SLSQP'\n        elif bounds is not None:\n            method = 'L-BFGS-B'\n        else:\n            method = 'BFGS'\n\n    if callable(method):\n        meth = \"_custom\"\n    else:\n        meth = method.lower()\n\n    if options is None:\n        options = {}\n    # check if optional parameters are supported by the selected method\n    # - jac\n    if meth in ('nelder-mead', 'powell', 'cobyla', 'cobyqa') and bool(jac):\n        warn(f'Method {method} does not use gradient information (jac).',\n             RuntimeWarning, stacklevel=2)\n    # - hess\n    if meth not in ('newton-cg', 'dogleg', 'trust-ncg', 'trust-constr',\n                    'trust-krylov', 'trust-exact', '_custom') and hess is not None:\n        warn(f'Method {method} does not use Hessian information (hess).',\n             RuntimeWarning, stacklevel=2)\n    # - hessp\n    if meth not in ('newton-cg', 'trust-ncg', 'trust-constr',\n                    'trust-krylov', '_custom') \\\n       and hessp is not None:\n        warn(f'Method {method} does not use Hessian-vector product'\n             ' information (hessp).',\n             RuntimeWarning, stacklevel=2)\n    # - constraints or bounds\n    if (meth not in ('cobyla', 'cobyqa', 'slsqp', 'trust-constr', '_custom') and\n            np.any(constraints)):\n        warn(f'Method {method} cannot handle constraints.',\n             RuntimeWarning, stacklevel=2)\n    if meth not in (\n            'nelder-mead', 'powell', 'l-bfgs-b', 'cobyla', 'cobyqa', 'slsqp',\n            'tnc', 'trust-constr', '_custom') and bounds is not None:\n        warn(f'Method {method} cannot handle bounds.',\n             RuntimeWarning, stacklevel=2)\n    # - return_all\n    if (meth in ('l-bfgs-b', 'tnc', 'cobyla', 'cobyqa', 'slsqp') and\n            options.get('return_all', False)):\n        warn(f'Method {method} does not support the return_all option.',\n             RuntimeWarning, stacklevel=2)\n\n    # check gradient vector\n    if callable(jac):\n        pass\n    elif jac is True:\n        # fun returns func and grad\n        fun = MemoizeJac(fun)\n        jac = fun.derivative\n    elif (jac in FD_METHODS and\n          meth in ['trust-constr', 'bfgs', 'cg', 'l-bfgs-b', 'tnc', 'slsqp']):\n        # finite differences with relative step\n        pass\n    elif meth in ['trust-constr']:\n        # default jac calculation for this method\n        jac = '2-point'\n    elif jac is None or bool(jac) is False:\n        # this will cause e.g. LBFGS to use forward difference, absolute step\n        jac = None\n    else:\n        # default if jac option is not understood\n        jac = None\n\n    # set default tolerances\n    if tol is not None:\n        options = dict(options)\n        if meth == 'nelder-mead':\n            options.setdefault('xatol', tol)\n            options.setdefault('fatol', tol)\n        if meth in ('newton-cg', 'powell', 'tnc'):\n            options.setdefault('xtol', tol)\n        if meth in ('powell', 'l-bfgs-b', 'tnc', 'slsqp'):\n            options.setdefault('ftol', tol)\n        if meth in ('bfgs', 'cg', 'l-bfgs-b', 'tnc', 'dogleg',\n                    'trust-ncg', 'trust-exact', 'trust-krylov'):\n            options.setdefault('gtol', tol)\n        if meth in ('cobyla', '_custom'):\n            options.setdefault('tol', tol)\n        if meth == 'cobyqa':\n            options.setdefault('final_tr_radius', tol)\n        if meth == 'trust-constr':\n            options.setdefault('xtol', tol)\n            options.setdefault('gtol', tol)\n            options.setdefault('barrier_tol', tol)\n\n    if meth == '_custom':\n        # custom method called before bounds and constraints are 'standardised'\n        # custom method should be able to accept whatever bounds/constraints\n        # are provided to it.\n        return method(fun, x0, args=args, jac=jac, hess=hess, hessp=hessp,\n                      bounds=bounds, constraints=constraints,\n                      callback=callback, **options)\n\n    constraints = standardize_constraints(constraints, x0, meth)\n\n    remove_vars = False\n    if bounds is not None:\n        # convert to new-style bounds so we only have to consider one case\n        bounds = standardize_bounds(bounds, x0, 'new')\n        bounds = _validate_bounds(bounds, x0, meth)\n\n        if meth in {\"tnc\", \"slsqp\", \"l-bfgs-b\"}:\n            # These methods can't take the finite-difference derivatives they\n            # need when a variable is fixed by the bounds. To avoid this issue,\n            # remove fixed variables from the problem.\n            # NOTE: if this list is expanded, then be sure to update the\n            # accompanying tests and test_optimize.eb_data. Consider also if\n            # default OptimizeResult will need updating.\n\n            # determine whether any variables are fixed\n            i_fixed = (bounds.lb == bounds.ub)\n\n            if np.all(i_fixed):\n                # all the parameters are fixed, a minimizer is not able to do\n                # anything\n                return _optimize_result_for_equal_bounds(\n                    fun, bounds, meth, args=args, constraints=constraints\n                )\n\n            # determine whether finite differences are needed for any grad/jac\n            fd_needed = (not callable(jac))\n            for con in constraints:\n                if not callable(con.get('jac', None)):\n                    fd_needed = True\n\n            # If finite differences are ever used, remove all fixed variables\n            # Always remove fixed variables for TNC; see gh-14565\n            remove_vars = i_fixed.any() and (fd_needed or meth == \"tnc\")\n            if remove_vars:\n                x_fixed = (bounds.lb)[i_fixed]\n                x0 = x0[~i_fixed]\n                bounds = _remove_from_bounds(bounds, i_fixed)\n                fun = _remove_from_func(fun, i_fixed, x_fixed)\n                if callable(callback):\n                    callback = _remove_from_func(callback, i_fixed, x_fixed)\n                if callable(jac):\n                    jac = _remove_from_func(jac, i_fixed, x_fixed, remove=1)\n\n                # make a copy of the constraints so the user's version doesn't\n                # get changed. (Shallow copy is ok)\n                constraints = [con.copy() for con in constraints]\n                for con in constraints:  # yes, guaranteed to be a list\n                    con['fun'] = _remove_from_func(con['fun'], i_fixed,\n                                                   x_fixed, min_dim=1,\n                                                   remove=0)\n                    if callable(con.get('jac', None)):\n                        con['jac'] = _remove_from_func(con['jac'], i_fixed,\n                                                       x_fixed, min_dim=2,\n                                                       remove=1)\n        bounds = standardize_bounds(bounds, x0, meth)\n\n    callback = _wrap_callback(callback, meth)\n\n    if meth == 'nelder-mead':\n        res = _minimize_neldermead(fun, x0, args, callback, bounds=bounds,\n                                   **options)\n    elif meth == 'powell':\n        res = _minimize_powell(fun, x0, args, callback, bounds, **options)\n    elif meth == 'cg':\n        res = _minimize_cg(fun, x0, args, jac, callback, **options)\n    elif meth == 'bfgs':\n        res = _minimize_bfgs(fun, x0, args, jac, callback, **options)\n    elif meth == 'newton-cg':\n        res = _minimize_newtoncg(fun, x0, args, jac, hess, hessp, callback,\n                                 **options)\n    elif meth == 'l-bfgs-b':\n        res = _minimize_lbfgsb(fun, x0, args, jac, bounds,\n                               callback=callback, **options)\n    elif meth == 'tnc':\n        res = _minimize_tnc(fun, x0, args, jac, bounds, callback=callback,\n                            **options)\n    elif meth == 'cobyla':\n        res = _minimize_cobyla(fun, x0, args, constraints, callback=callback,\n                               bounds=bounds, **options)\n    elif meth == 'cobyqa':\n        res = _minimize_cobyqa(fun, x0, args, bounds, constraints, callback,\n                               **options)\n    elif meth == 'slsqp':\n        res = _minimize_slsqp(fun, x0, args, jac, bounds,\n                              constraints, callback=callback, **options)\n    elif meth == 'trust-constr':\n        res = _minimize_trustregion_constr(fun, x0, args, jac, hess, hessp,\n                                           bounds, constraints,\n                                           callback=callback, **options)\n    elif meth == 'dogleg':\n        res = _minimize_dogleg(fun, x0, args, jac, hess,\n                               callback=callback, **options)\n    elif meth == 'trust-ncg':\n        res = _minimize_trust_ncg(fun, x0, args, jac, hess, hessp,\n                                  callback=callback, **options)\n    elif meth == 'trust-krylov':\n        res = _minimize_trust_krylov(fun, x0, args, jac, hess, hessp,\n                                     callback=callback, **options)\n    elif meth == 'trust-exact':\n        res = _minimize_trustregion_exact(fun, x0, args, jac, hess,\n                                          callback=callback, **options)\n    else:\n        raise ValueError(f'Unknown solver {method}')\n\n    if remove_vars:\n        res.x = _add_to_array(res.x, i_fixed, x_fixed)\n        res.jac = _add_to_array(res.jac, i_fixed, np.nan)\n        if \"hess_inv\" in res:\n            res.hess_inv = None  # unknown\n\n    if getattr(callback, 'stop_iteration', False):\n        res.success = False\n        res.status = 99\n        res.message = \"`callback` raised `StopIteration`.\"\n\n    return res\n\n\ndef minimize_scalar(fun, bracket=None, bounds=None, args=(),\n                    method=None, tol=None, options=None):\n    \"\"\"Local minimization of scalar function of one variable.\n\n    Parameters\n    ----------\n    fun : callable\n        Objective function.\n        Scalar function, must return a scalar.\n\n        Suppose the callable has signature ``f0(x, *my_args, **my_kwargs)``, where\n        ``my_args`` and ``my_kwargs`` are required positional and keyword arguments.\n        Rather than passing ``f0`` as the callable, wrap it to accept\n        only ``x``; e.g., pass ``fun=lambda x: f0(x, *my_args, **my_kwargs)`` as the\n        callable, where ``my_args`` (tuple) and ``my_kwargs`` (dict) have been\n        gathered before invoking this function.\n\n    bracket : sequence, optional\n        For methods 'brent' and 'golden', `bracket` defines the bracketing\n        interval and is required.\n        Either a triple ``(xa, xb, xc)`` satisfying ``xa < xb < xc`` and\n        ``func(xb) < func(xa) and  func(xb) < func(xc)``, or a pair\n        ``(xa, xb)`` to be used as initial points for a downhill bracket search\n        (see `scipy.optimize.bracket`).\n        The minimizer ``res.x`` will not necessarily satisfy\n        ``xa <= res.x <= xb``.\n    bounds : sequence, optional\n        For method 'bounded', `bounds` is mandatory and must have two finite\n        items corresponding to the optimization bounds.\n    args : tuple, optional\n        Extra arguments passed to the objective function.\n    method : str or callable, optional\n        Type of solver.  Should be one of:\n\n        - :ref:`Brent <optimize.minimize_scalar-brent>`\n        - :ref:`Bounded <optimize.minimize_scalar-bounded>`\n        - :ref:`Golden <optimize.minimize_scalar-golden>`\n        - custom - a callable object (added in version 0.14.0), see below\n\n        Default is \"Bounded\" if bounds are provided and \"Brent\" otherwise.\n        See the 'Notes' section for details of each solver.\n\n    tol : float, optional\n        Tolerance for termination. For detailed control, use solver-specific\n        options.\n    options : dict, optional\n        A dictionary of solver options.\n\n        maxiter : int\n            Maximum number of iterations to perform.\n        disp : bool\n            Set to True to print convergence messages.\n\n        See :func:`show_options()` for solver-specific options.\n\n    Returns\n    -------\n    res : OptimizeResult\n        The optimization result represented as a ``OptimizeResult`` object.\n        Important attributes are: ``x`` the solution array, ``success`` a\n        Boolean flag indicating if the optimizer exited successfully and\n        ``message`` which describes the cause of the termination. See\n        `OptimizeResult` for a description of other attributes.\n\n    See also\n    --------\n    minimize : Interface to minimization algorithms for scalar multivariate\n        functions\n    show_options : Additional options accepted by the solvers\n\n    Notes\n    -----\n    This section describes the available solvers that can be selected by the\n    'method' parameter. The default method is the ``\"Bounded\"`` Brent method if\n    `bounds` are passed and unbounded ``\"Brent\"`` otherwise.\n\n    Method :ref:`Brent <optimize.minimize_scalar-brent>` uses Brent's\n    algorithm [1]_ to find a local minimum.  The algorithm uses inverse\n    parabolic interpolation when possible to speed up convergence of\n    the golden section method.\n\n    Method :ref:`Golden <optimize.minimize_scalar-golden>` uses the\n    golden section search technique [1]_. It uses analog of the bisection\n    method to decrease the bracketed interval. It is usually\n    preferable to use the *Brent* method.\n\n    Method :ref:`Bounded <optimize.minimize_scalar-bounded>` can\n    perform bounded minimization [2]_ [3]_. It uses the Brent method to find a\n    local minimum in the interval x1 < xopt < x2.\n\n    Note that the Brent and Golden methods do not guarantee success unless a\n    valid ``bracket`` triple is provided. If a three-point bracket cannot be\n    found, consider `scipy.optimize.minimize`. Also, all methods are intended\n    only for local minimization. When the function of interest has more than\n    one local minimum, consider :ref:`global_optimization`.\n\n    **Custom minimizers**\n\n    It may be useful to pass a custom minimization method, for example\n    when using some library frontend to minimize_scalar. You can simply\n    pass a callable as the ``method`` parameter.\n\n    The callable is called as ``method(fun, args, **kwargs, **options)``\n    where ``kwargs`` corresponds to any other parameters passed to `minimize`\n    (such as `bracket`, `tol`, etc.), except the `options` dict, which has\n    its contents also passed as `method` parameters pair by pair.  The method\n    shall return an `OptimizeResult` object.\n\n    The provided `method` callable must be able to accept (and possibly ignore)\n    arbitrary parameters; the set of parameters accepted by `minimize` may\n    expand in future versions and then these parameters will be passed to\n    the method. You can find an example in the scipy.optimize tutorial.\n\n    .. versionadded:: 0.11.0\n\n    References\n    ----------\n    .. [1] Press, W., S.A. Teukolsky, W.T. Vetterling, and B.P. Flannery.\n           Numerical Recipes in C. Cambridge University Press.\n    .. [2] Forsythe, G.E., M. A. Malcolm, and C. B. Moler. \"Computer Methods\n           for Mathematical Computations.\" Prentice-Hall Series in Automatic\n           Computation 259 (1977).\n    .. [3] Brent, Richard P. Algorithms for Minimization Without Derivatives.\n           Courier Corporation, 2013.\n\n    Examples\n    --------\n    Consider the problem of minimizing the following function.\n\n    >>> def f(x):\n    ...     return (x - 2) * x * (x + 2)**2\n\n    Using the *Brent* method, we find the local minimum as:\n\n    >>> from scipy.optimize import minimize_scalar\n    >>> res = minimize_scalar(f)\n    >>> res.fun\n    -9.9149495908\n\n    The minimizer is:\n\n    >>> res.x\n    1.28077640403\n\n    Using the *Bounded* method, we find a local minimum with specified\n    bounds as:\n\n    >>> res = minimize_scalar(f, bounds=(-3, -1), method='bounded')\n    >>> res.fun  # minimum\n    3.28365179850e-13\n    >>> res.x  # minimizer\n    -2.0000002026\n\n    \"\"\"\n    if not isinstance(args, tuple):\n        args = (args,)\n\n    if callable(method):\n        meth = \"_custom\"\n    elif method is None:\n        meth = 'brent' if bounds is None else 'bounded'\n    else:\n        meth = method.lower()\n    if options is None:\n        options = {}\n\n    if bounds is not None and meth in {'brent', 'golden'}:\n        message = f\"Use of `bounds` is incompatible with 'method={method}'.\"\n        raise ValueError(message)\n\n    if tol is not None:\n        options = dict(options)\n        if meth == 'bounded' and 'xatol' not in options:\n            warn(\"Method 'bounded' does not support relative tolerance in x; \"\n                 \"defaulting to absolute tolerance.\",\n                 RuntimeWarning, stacklevel=2)\n            options['xatol'] = tol\n        elif meth == '_custom':\n            options.setdefault('tol', tol)\n        else:\n            options.setdefault('xtol', tol)\n\n    # replace boolean \"disp\" option, if specified, by an integer value.\n    disp = options.get('disp')\n    if isinstance(disp, bool):\n        options['disp'] = 2 * int(disp)\n\n    if meth == '_custom':\n        res = method(fun, args=args, bracket=bracket, bounds=bounds, **options)\n    elif meth == 'brent':\n        res = _recover_from_bracket_error(_minimize_scalar_brent,\n                                          fun, bracket, args, **options)\n    elif meth == 'bounded':\n        if bounds is None:\n            raise ValueError('The `bounds` parameter is mandatory for '\n                             'method `bounded`.')\n        res = _minimize_scalar_bounded(fun, bounds, args, **options)\n    elif meth == 'golden':\n        res = _recover_from_bracket_error(_minimize_scalar_golden,\n                                          fun, bracket, args, **options)\n    else:\n        raise ValueError(f'Unknown solver {method}')\n\n    # gh-16196 reported inconsistencies in the output shape of `res.x`. While\n    # fixing this, future-proof it for when the function is vectorized:\n    # the shape of `res.x` should match that of `res.fun`.\n    res.fun = np.asarray(res.fun)[()]\n    res.x = np.reshape(res.x, res.fun.shape)[()]\n    return res\n\n\ndef _remove_from_bounds(bounds, i_fixed):\n    \"\"\"Removes fixed variables from a `Bounds` instance\"\"\"\n    lb = bounds.lb[~i_fixed]\n    ub = bounds.ub[~i_fixed]\n    return Bounds(lb, ub)  # don't mutate original Bounds object\n\n\ndef _remove_from_func(fun_in, i_fixed, x_fixed, min_dim=None, remove=0):\n    \"\"\"Wraps a function such that fixed variables need not be passed in\"\"\"\n    def fun_out(x_in, *args, **kwargs):\n        x_out = np.zeros_like(i_fixed, dtype=x_in.dtype)\n        x_out[i_fixed] = x_fixed\n        x_out[~i_fixed] = x_in\n        y_out = fun_in(x_out, *args, **kwargs)\n        y_out = np.array(y_out)\n\n        if min_dim == 1:\n            y_out = np.atleast_1d(y_out)\n        elif min_dim == 2:\n            y_out = np.atleast_2d(y_out)\n\n        if remove == 1:\n            y_out = y_out[..., ~i_fixed]\n        elif remove == 2:\n            y_out = y_out[~i_fixed, ~i_fixed]\n\n        return y_out\n    return fun_out\n\n\ndef _add_to_array(x_in, i_fixed, x_fixed):\n    \"\"\"Adds fixed variables back to an array\"\"\"\n    i_free = ~i_fixed\n    if x_in.ndim == 2:\n        i_free = i_free[:, None] @ i_free[None, :]\n    x_out = np.zeros_like(i_free, dtype=x_in.dtype)\n    x_out[~i_free] = x_fixed\n    x_out[i_free] = x_in.ravel()\n    return x_out\n\n\ndef _validate_bounds(bounds, x0, meth):\n    \"\"\"Check that bounds are valid.\"\"\"\n\n    msg = \"An upper bound is less than the corresponding lower bound.\"\n    if np.any(bounds.ub < bounds.lb):\n        raise ValueError(msg)\n\n    msg = \"The number of bounds is not compatible with the length of `x0`.\"\n    try:\n        bounds.lb = np.broadcast_to(bounds.lb, x0.shape)\n        bounds.ub = np.broadcast_to(bounds.ub, x0.shape)\n    except Exception as e:\n        raise ValueError(msg) from e\n\n    return bounds\n\ndef standardize_bounds(bounds, x0, meth):\n    \"\"\"Converts bounds to the form required by the solver.\"\"\"\n    if meth in {'trust-constr', 'powell', 'nelder-mead', 'cobyla', 'cobyqa',\n                'new'}:\n        if not isinstance(bounds, Bounds):\n            lb, ub = old_bound_to_new(bounds)\n            bounds = Bounds(lb, ub)\n    elif meth in ('l-bfgs-b', 'tnc', 'slsqp', 'old'):\n        if isinstance(bounds, Bounds):\n            bounds = new_bounds_to_old(bounds.lb, bounds.ub, x0.shape[0])\n    return bounds\n\n\ndef standardize_constraints(constraints, x0, meth):\n    \"\"\"Converts constraints to the form required by the solver.\"\"\"\n    all_constraint_types = (NonlinearConstraint, LinearConstraint, dict)\n    new_constraint_types = all_constraint_types[:-1]\n    if constraints is None:\n        constraints = []\n    elif isinstance(constraints, all_constraint_types):\n        constraints = [constraints]\n    else:\n        constraints = list(constraints)  # ensure it's a mutable sequence\n\n    if meth in ['trust-constr', 'cobyqa', 'new']:\n        for i, con in enumerate(constraints):\n            if not isinstance(con, new_constraint_types):\n                constraints[i] = old_constraint_to_new(i, con)\n    else:\n        # iterate over copy, changing original\n        for i, con in enumerate(list(constraints)):\n            if isinstance(con, new_constraint_types):\n                old_constraints = new_constraint_to_old(con, x0)\n                constraints[i] = old_constraints[0]\n                constraints.extend(old_constraints[1:])  # appends 1 if present\n\n    return constraints\n\n\ndef _optimize_result_for_equal_bounds(\n        fun, bounds, method, args=(), constraints=()\n):\n    \"\"\"\n    Provides a default OptimizeResult for when a bounded minimization method\n    has (lb == ub).all().\n\n    Parameters\n    ----------\n    fun: callable\n    bounds: Bounds\n    method: str\n    constraints: Constraint\n    \"\"\"\n    success = True\n    message = 'All independent variables were fixed by bounds.'\n\n    # bounds is new-style\n    x0 = bounds.lb\n\n    if constraints:\n        message = (\"All independent variables were fixed by bounds at values\"\n                   \" that satisfy the constraints.\")\n        constraints = standardize_constraints(constraints, x0, 'new')\n\n    maxcv = 0\n    for c in constraints:\n        pc = PreparedConstraint(c, x0)\n        violation = pc.violation(x0)\n        if np.sum(violation):\n            maxcv = max(maxcv, np.max(violation))\n            success = False\n            message = (f\"All independent variables were fixed by bounds, but \"\n                       f\"the independent variables do not satisfy the \"\n                       f\"constraints exactly. (Maximum violation: {maxcv}).\")\n\n    return OptimizeResult(\n        x=x0, fun=fun(x0, *args), success=success, message=message, nfev=1,\n        njev=0, nhev=0,\n    )\n", 1131], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py": ["\"\"\"Constraints definition for minimize.\"\"\"\nimport numpy as np\nfrom ._hessian_update_strategy import BFGS\nfrom ._differentiable_functions import (\n    VectorFunction, LinearVectorFunction, IdentityVectorFunction)\nfrom ._optimize import OptimizeWarning\nfrom warnings import warn, catch_warnings, simplefilter, filterwarnings\nfrom scipy.sparse import issparse\n\n\ndef _arr_to_scalar(x):\n    # If x is a numpy array, return x.item().  This will\n    # fail if the array has more than one element.\n    return x.item() if isinstance(x, np.ndarray) else x\n\n\nclass NonlinearConstraint:\n    \"\"\"Nonlinear constraint on the variables.\n\n    The constraint has the general inequality form::\n\n        lb <= fun(x) <= ub\n\n    Here the vector of independent variables x is passed as ndarray of shape\n    (n,) and ``fun`` returns a vector with m components.\n\n    It is possible to use equal bounds to represent an equality constraint or\n    infinite bounds to represent a one-sided constraint.\n\n    Parameters\n    ----------\n    fun : callable\n        The function defining the constraint.\n        The signature is ``fun(x) -> array_like, shape (m,)``.\n    lb, ub : array_like\n        Lower and upper bounds on the constraint. Each array must have the\n        shape (m,) or be a scalar, in the latter case a bound will be the same\n        for all components of the constraint. Use ``np.inf`` with an\n        appropriate sign to specify a one-sided constraint.\n        Set components of `lb` and `ub` equal to represent an equality\n        constraint. Note that you can mix constraints of different types:\n        interval, one-sided or equality, by setting different components of\n        `lb` and `ub` as  necessary.\n    jac : {callable,  '2-point', '3-point', 'cs'}, optional\n        Method of computing the Jacobian matrix (an m-by-n matrix,\n        where element (i, j) is the partial derivative of f[i] with\n        respect to x[j]).  The keywords {'2-point', '3-point',\n        'cs'} select a finite difference scheme for the numerical estimation.\n        A callable must have the following signature::\n\n            jac(x) -> {ndarray, sparse matrix}, shape (m, n)\n\n        Default is '2-point'.\n    hess : {callable, '2-point', '3-point', 'cs', HessianUpdateStrategy, None}, optional\n        Method for computing the Hessian matrix. The keywords\n        {'2-point', '3-point', 'cs'} select a finite difference scheme for\n        numerical  estimation.  Alternatively, objects implementing\n        `HessianUpdateStrategy` interface can be used to approximate the\n        Hessian. Currently available implementations are:\n\n        - `BFGS` (default option)\n        - `SR1`\n\n        A callable must return the Hessian matrix of ``dot(fun, v)`` and\n        must have the following signature:\n        ``hess(x, v) -> {LinearOperator, sparse matrix, array_like}, shape (n, n)``.\n        Here ``v`` is ndarray with shape (m,) containing Lagrange multipliers.\n    keep_feasible : array_like of bool, optional\n        Whether to keep the constraint components feasible throughout\n        iterations. A single value set this property for all components.\n        Default is False. Has no effect for equality constraints.\n    finite_diff_rel_step: None or array_like, optional\n        Relative step size for the finite difference approximation. Default is\n        None, which will select a reasonable value automatically depending\n        on a finite difference scheme.\n    finite_diff_jac_sparsity: {None, array_like, sparse matrix}, optional\n        Defines the sparsity structure of the Jacobian matrix for finite\n        difference estimation, its shape must be (m, n). If the Jacobian has\n        only few non-zero elements in *each* row, providing the sparsity\n        structure will greatly speed up the computations. A zero entry means\n        that a corresponding element in the Jacobian is identically zero.\n        If provided, forces the use of 'lsmr' trust-region solver.\n        If None (default) then dense differencing will be used.\n\n    Notes\n    -----\n    Finite difference schemes {'2-point', '3-point', 'cs'} may be used for\n    approximating either the Jacobian or the Hessian. We, however, do not allow\n    its use for approximating both simultaneously. Hence whenever the Jacobian\n    is estimated via finite-differences, we require the Hessian to be estimated\n    using one of the quasi-Newton strategies.\n\n    The scheme 'cs' is potentially the most accurate, but requires the function\n    to correctly handles complex inputs and be analytically continuable to the\n    complex plane. The scheme '3-point' is more accurate than '2-point' but\n    requires twice as many operations.\n\n    Examples\n    --------\n    Constrain ``x[0] < sin(x[1]) + 1.9``\n\n    >>> from scipy.optimize import NonlinearConstraint\n    >>> import numpy as np\n    >>> con = lambda x: x[0] - np.sin(x[1])\n    >>> nlc = NonlinearConstraint(con, -np.inf, 1.9)\n\n    \"\"\"\n    def __init__(self, fun, lb, ub, jac='2-point', hess=None,\n                 keep_feasible=False, finite_diff_rel_step=None,\n                 finite_diff_jac_sparsity=None):\n        if hess is None:\n            hess = BFGS()\n        self.fun = fun\n        self.lb = lb\n        self.ub = ub\n        self.finite_diff_rel_step = finite_diff_rel_step\n        self.finite_diff_jac_sparsity = finite_diff_jac_sparsity\n        self.jac = jac\n        self.hess = hess\n        self.keep_feasible = keep_feasible\n\n\nclass LinearConstraint:\n    \"\"\"Linear constraint on the variables.\n\n    The constraint has the general inequality form::\n\n        lb <= A.dot(x) <= ub\n\n    Here the vector of independent variables x is passed as ndarray of shape\n    (n,) and the matrix A has shape (m, n).\n\n    It is possible to use equal bounds to represent an equality constraint or\n    infinite bounds to represent a one-sided constraint.\n\n    Parameters\n    ----------\n    A : {array_like, sparse matrix}, shape (m, n)\n        Matrix defining the constraint.\n    lb, ub : dense array_like, optional\n        Lower and upper limits on the constraint. Each array must have the\n        shape (m,) or be a scalar, in the latter case a bound will be the same\n        for all components of the constraint. Use ``np.inf`` with an\n        appropriate sign to specify a one-sided constraint.\n        Set components of `lb` and `ub` equal to represent an equality\n        constraint. Note that you can mix constraints of different types:\n        interval, one-sided or equality, by setting different components of\n        `lb` and `ub` as  necessary. Defaults to ``lb = -np.inf``\n        and ``ub = np.inf`` (no limits).\n    keep_feasible : dense array_like of bool, optional\n        Whether to keep the constraint components feasible throughout\n        iterations. A single value set this property for all components.\n        Default is False. Has no effect for equality constraints.\n    \"\"\"\n    def _input_validation(self):\n        if self.A.ndim != 2:\n            message = \"`A` must have exactly two dimensions.\"\n            raise ValueError(message)\n\n        try:\n            shape = self.A.shape[0:1]\n            self.lb = np.broadcast_to(self.lb, shape)\n            self.ub = np.broadcast_to(self.ub, shape)\n            self.keep_feasible = np.broadcast_to(self.keep_feasible, shape)\n        except ValueError:\n            message = (\"`lb`, `ub`, and `keep_feasible` must be broadcastable \"\n                       \"to shape `A.shape[0:1]`\")\n            raise ValueError(message)\n\n    def __init__(self, A, lb=-np.inf, ub=np.inf, keep_feasible=False):\n        if not issparse(A):\n            # In some cases, if the constraint is not valid, this emits a\n            # VisibleDeprecationWarning about ragged nested sequences\n            # before eventually causing an error. `scipy.optimize.milp` would\n            # prefer that this just error out immediately so it can handle it\n            # rather than concerning the user.\n            with catch_warnings():\n                simplefilter(\"error\")\n                self.A = np.atleast_2d(A).astype(np.float64)\n        else:\n            self.A = A\n        if issparse(lb) or issparse(ub):\n            raise ValueError(\"Constraint limits must be dense arrays.\")\n        self.lb = np.atleast_1d(lb).astype(np.float64)\n        self.ub = np.atleast_1d(ub).astype(np.float64)\n\n        if issparse(keep_feasible):\n            raise ValueError(\"`keep_feasible` must be a dense array.\")\n        self.keep_feasible = np.atleast_1d(keep_feasible).astype(bool)\n        self._input_validation()\n\n    def residual(self, x):\n        \"\"\"\n        Calculate the residual between the constraint function and the limits\n\n        For a linear constraint of the form::\n\n            lb <= A@x <= ub\n\n        the lower and upper residuals between ``A@x`` and the limits are values\n        ``sl`` and ``sb`` such that::\n\n            lb + sl == A@x == ub - sb\n\n        When all elements of ``sl`` and ``sb`` are positive, all elements of\n        the constraint are satisfied; a negative element in ``sl`` or ``sb``\n        indicates that the corresponding element of the constraint is not\n        satisfied.\n\n        Parameters\n        ----------\n        x: array_like\n            Vector of independent variables\n\n        Returns\n        -------\n        sl, sb : array-like\n            The lower and upper residuals\n        \"\"\"\n        return self.A@x - self.lb, self.ub - self.A@x\n\n\nclass Bounds:\n    \"\"\"Bounds constraint on the variables.\n\n    The constraint has the general inequality form::\n\n        lb <= x <= ub\n\n    It is possible to use equal bounds to represent an equality constraint or\n    infinite bounds to represent a one-sided constraint.\n\n    Parameters\n    ----------\n    lb, ub : dense array_like, optional\n        Lower and upper bounds on independent variables. `lb`, `ub`, and\n        `keep_feasible` must be the same shape or broadcastable.\n        Set components of `lb` and `ub` equal\n        to fix a variable. Use ``np.inf`` with an appropriate sign to disable\n        bounds on all or some variables. Note that you can mix constraints of\n        different types: interval, one-sided or equality, by setting different\n        components of `lb` and `ub` as necessary. Defaults to ``lb = -np.inf``\n        and ``ub = np.inf`` (no bounds).\n    keep_feasible : dense array_like of bool, optional\n        Whether to keep the constraint components feasible throughout\n        iterations. Must be broadcastable with `lb` and `ub`.\n        Default is False. Has no effect for equality constraints.\n    \"\"\"\n    def _input_validation(self):\n        try:\n            res = np.broadcast_arrays(self.lb, self.ub, self.keep_feasible)\n            self.lb, self.ub, self.keep_feasible = res\n        except ValueError:\n            message = \"`lb`, `ub`, and `keep_feasible` must be broadcastable.\"\n            raise ValueError(message)\n\n    def __init__(self, lb=-np.inf, ub=np.inf, keep_feasible=False):\n        if issparse(lb) or issparse(ub):\n            raise ValueError(\"Lower and upper bounds must be dense arrays.\")\n        self.lb = np.atleast_1d(lb)\n        self.ub = np.atleast_1d(ub)\n\n        if issparse(keep_feasible):\n            raise ValueError(\"`keep_feasible` must be a dense array.\")\n        self.keep_feasible = np.atleast_1d(keep_feasible).astype(bool)\n        self._input_validation()\n\n    def __repr__(self):\n        start = f\"{type(self).__name__}({self.lb!r}, {self.ub!r}\"\n        if np.any(self.keep_feasible):\n            end = f\", keep_feasible={self.keep_feasible!r})\"\n        else:\n            end = \")\"\n        return start + end\n\n    def residual(self, x):\n        \"\"\"Calculate the residual (slack) between the input and the bounds\n\n        For a bound constraint of the form::\n\n            lb <= x <= ub\n\n        the lower and upper residuals between `x` and the bounds are values\n        ``sl`` and ``sb`` such that::\n\n            lb + sl == x == ub - sb\n\n        When all elements of ``sl`` and ``sb`` are positive, all elements of\n        ``x`` lie within the bounds; a negative element in ``sl`` or ``sb``\n        indicates that the corresponding element of ``x`` is out of bounds.\n\n        Parameters\n        ----------\n        x: array_like\n            Vector of independent variables\n\n        Returns\n        -------\n        sl, sb : array-like\n            The lower and upper residuals\n        \"\"\"\n        return x - self.lb, self.ub - x\n\n\nclass PreparedConstraint:\n    \"\"\"Constraint prepared from a user defined constraint.\n\n    On creation it will check whether a constraint definition is valid and\n    the initial point is feasible. If created successfully, it will contain\n    the attributes listed below.\n\n    Parameters\n    ----------\n    constraint : {NonlinearConstraint, LinearConstraint`, Bounds}\n        Constraint to check and prepare.\n    x0 : array_like\n        Initial vector of independent variables.\n    sparse_jacobian : bool or None, optional\n        If bool, then the Jacobian of the constraint will be converted\n        to the corresponded format if necessary. If None (default), such\n        conversion is not made.\n    finite_diff_bounds : 2-tuple, optional\n        Lower and upper bounds on the independent variables for the finite\n        difference approximation, if applicable. Defaults to no bounds.\n\n    Attributes\n    ----------\n    fun : {VectorFunction, LinearVectorFunction, IdentityVectorFunction}\n        Function defining the constraint wrapped by one of the convenience\n        classes.\n    bounds : 2-tuple\n        Contains lower and upper bounds for the constraints --- lb and ub.\n        These are converted to ndarray and have a size equal to the number of\n        the constraints.\n    keep_feasible : ndarray\n         Array indicating which components must be kept feasible with a size\n         equal to the number of the constraints.\n    \"\"\"\n    def __init__(self, constraint, x0, sparse_jacobian=None,\n                 finite_diff_bounds=(-np.inf, np.inf)):\n        if isinstance(constraint, NonlinearConstraint):\n            fun = VectorFunction(constraint.fun, x0,\n                                 constraint.jac, constraint.hess,\n                                 constraint.finite_diff_rel_step,\n                                 constraint.finite_diff_jac_sparsity,\n                                 finite_diff_bounds, sparse_jacobian)\n        elif isinstance(constraint, LinearConstraint):\n            fun = LinearVectorFunction(constraint.A, x0, sparse_jacobian)\n        elif isinstance(constraint, Bounds):\n            fun = IdentityVectorFunction(x0, sparse_jacobian)\n        else:\n            raise ValueError(\"`constraint` of an unknown type is passed.\")\n\n        m = fun.m\n\n        lb = np.asarray(constraint.lb, dtype=float)\n        ub = np.asarray(constraint.ub, dtype=float)\n        keep_feasible = np.asarray(constraint.keep_feasible, dtype=bool)\n\n        lb = np.broadcast_to(lb, m)\n        ub = np.broadcast_to(ub, m)\n        keep_feasible = np.broadcast_to(keep_feasible, m)\n\n        if keep_feasible.shape != (m,):\n            raise ValueError(\"`keep_feasible` has a wrong shape.\")\n\n        mask = keep_feasible & (lb != ub)\n        f0 = fun.f\n        if np.any(f0[mask] < lb[mask]) or np.any(f0[mask] > ub[mask]):\n            raise ValueError(\"`x0` is infeasible with respect to some \"\n                             \"inequality constraint with `keep_feasible` \"\n                             \"set to True.\")\n\n        self.fun = fun\n        self.bounds = (lb, ub)\n        self.keep_feasible = keep_feasible\n\n    def violation(self, x):\n        \"\"\"How much the constraint is exceeded by.\n\n        Parameters\n        ----------\n        x : array-like\n            Vector of independent variables\n\n        Returns\n        -------\n        excess : array-like\n            How much the constraint is exceeded by, for each of the\n            constraints specified by `PreparedConstraint.fun`.\n        \"\"\"\n        with catch_warnings():\n            # Ignore the following warning, it's not important when\n            # figuring out total violation\n            # UserWarning: delta_grad == 0.0. Check if the approximated\n            # function is linear\n            filterwarnings(\"ignore\", \"delta_grad\", UserWarning)\n            ev = self.fun.fun(np.asarray(x))\n\n        excess_lb = np.maximum(self.bounds[0] - ev, 0)\n        excess_ub = np.maximum(ev - self.bounds[1], 0)\n\n        return excess_lb + excess_ub\n\n\ndef new_bounds_to_old(lb, ub, n):\n    \"\"\"Convert the new bounds representation to the old one.\n\n    The new representation is a tuple (lb, ub) and the old one is a list\n    containing n tuples, ith containing lower and upper bound on a ith\n    variable.\n    If any of the entries in lb/ub are -np.inf/np.inf they are replaced by\n    None.\n    \"\"\"\n    lb = np.broadcast_to(lb, n)\n    ub = np.broadcast_to(ub, n)\n\n    lb = [float(x) if x > -np.inf else None for x in lb]\n    ub = [float(x) if x < np.inf else None for x in ub]\n\n    return list(zip(lb, ub))\n\n\ndef old_bound_to_new(bounds):\n    \"\"\"Convert the old bounds representation to the new one.\n\n    The new representation is a tuple (lb, ub) and the old one is a list\n    containing n tuples, ith containing lower and upper bound on a ith\n    variable.\n    If any of the entries in lb/ub are None they are replaced by\n    -np.inf/np.inf.\n    \"\"\"\n    lb, ub = zip(*bounds)\n\n    # Convert occurrences of None to -inf or inf, and replace occurrences of\n    # any numpy array x with x.item(). Then wrap the results in numpy arrays.\n    lb = np.array([float(_arr_to_scalar(x)) if x is not None else -np.inf\n                   for x in lb])\n    ub = np.array([float(_arr_to_scalar(x)) if x is not None else np.inf\n                   for x in ub])\n\n    return lb, ub\n\n\ndef strict_bounds(lb, ub, keep_feasible, n_vars):\n    \"\"\"Remove bounds which are not asked to be kept feasible.\"\"\"\n    strict_lb = np.resize(lb, n_vars).astype(float)\n    strict_ub = np.resize(ub, n_vars).astype(float)\n    keep_feasible = np.resize(keep_feasible, n_vars)\n    strict_lb[~keep_feasible] = -np.inf\n    strict_ub[~keep_feasible] = np.inf\n    return strict_lb, strict_ub\n\n\ndef new_constraint_to_old(con, x0):\n    \"\"\"\n    Converts new-style constraint objects to old-style constraint dictionaries.\n    \"\"\"\n    if isinstance(con, NonlinearConstraint):\n        if (con.finite_diff_jac_sparsity is not None or\n                con.finite_diff_rel_step is not None or\n                not isinstance(con.hess, BFGS) or  # misses user specified BFGS\n                con.keep_feasible):\n            warn(\"Constraint options `finite_diff_jac_sparsity`, \"\n                 \"`finite_diff_rel_step`, `keep_feasible`, and `hess`\"\n                 \"are ignored by this method.\",\n                 OptimizeWarning, stacklevel=3)\n\n        fun = con.fun\n        if callable(con.jac):\n            jac = con.jac\n        else:\n            jac = None\n\n    else:  # LinearConstraint\n        if np.any(con.keep_feasible):\n            warn(\"Constraint option `keep_feasible` is ignored by this method.\",\n                 OptimizeWarning, stacklevel=3)\n\n        A = con.A\n        if issparse(A):\n            A = A.toarray()\n        def fun(x):\n            return np.dot(A, x)\n        def jac(x):\n            return A\n\n    # FIXME: when bugs in VectorFunction/LinearVectorFunction are worked out,\n    # use pcon.fun.fun and pcon.fun.jac. Until then, get fun/jac above.\n    pcon = PreparedConstraint(con, x0)\n    lb, ub = pcon.bounds\n\n    i_eq = lb == ub\n    i_bound_below = np.logical_xor(lb != -np.inf, i_eq)\n    i_bound_above = np.logical_xor(ub != np.inf, i_eq)\n    i_unbounded = np.logical_and(lb == -np.inf, ub == np.inf)\n\n    if np.any(i_unbounded):\n        warn(\"At least one constraint is unbounded above and below. Such \"\n             \"constraints are ignored.\",\n             OptimizeWarning, stacklevel=3)\n\n    ceq = []\n    if np.any(i_eq):\n        def f_eq(x):\n            y = np.array(fun(x)).flatten()\n            return y[i_eq] - lb[i_eq]\n        ceq = [{\"type\": \"eq\", \"fun\": f_eq}]\n\n        if jac is not None:\n            def j_eq(x):\n                dy = jac(x)\n                if issparse(dy):\n                    dy = dy.toarray()\n                dy = np.atleast_2d(dy)\n                return dy[i_eq, :]\n            ceq[0][\"jac\"] = j_eq\n\n    cineq = []\n    n_bound_below = np.sum(i_bound_below)\n    n_bound_above = np.sum(i_bound_above)\n    if n_bound_below + n_bound_above:\n        def f_ineq(x):\n            y = np.zeros(n_bound_below + n_bound_above)\n            y_all = np.array(fun(x)).flatten()\n            y[:n_bound_below] = y_all[i_bound_below] - lb[i_bound_below]\n            y[n_bound_below:] = -(y_all[i_bound_above] - ub[i_bound_above])\n            return y\n        cineq = [{\"type\": \"ineq\", \"fun\": f_ineq}]\n\n        if jac is not None:\n            def j_ineq(x):\n                dy = np.zeros((n_bound_below + n_bound_above, len(x0)))\n                dy_all = jac(x)\n                if issparse(dy_all):\n                    dy_all = dy_all.toarray()\n                dy_all = np.atleast_2d(dy_all)\n                dy[:n_bound_below, :] = dy_all[i_bound_below]\n                dy[n_bound_below:, :] = -dy_all[i_bound_above]\n                return dy\n            cineq[0][\"jac\"] = j_ineq\n\n    old_constraints = ceq + cineq\n\n    if len(old_constraints) > 1:\n        warn(\"Equality and inequality constraints are specified in the same \"\n             \"element of the constraint list. For efficient use with this \"\n             \"method, equality and inequality constraints should be specified \"\n             \"in separate elements of the constraint list. \",\n             OptimizeWarning, stacklevel=3)\n    return old_constraints\n\n\ndef old_constraint_to_new(ic, con):\n    \"\"\"\n    Converts old-style constraint dictionaries to new-style constraint objects.\n    \"\"\"\n    # check type\n    try:\n        ctype = con['type'].lower()\n    except KeyError as e:\n        raise KeyError('Constraint %d has no type defined.' % ic) from e\n    except TypeError as e:\n        raise TypeError(\n            'Constraints must be a sequence of dictionaries.'\n        ) from e\n    except AttributeError as e:\n        raise TypeError(\"Constraint's type must be a string.\") from e\n    else:\n        if ctype not in ['eq', 'ineq']:\n            raise ValueError(f\"Unknown constraint type '{con['type']}'.\")\n    if 'fun' not in con:\n        raise ValueError('Constraint %d has no function defined.' % ic)\n\n    lb = 0\n    if ctype == 'eq':\n        ub = 0\n    else:\n        ub = np.inf\n\n    jac = '2-point'\n    if 'args' in con:\n        args = con['args']\n        def fun(x):\n            return con[\"fun\"](x, *args)\n        if 'jac' in con:\n            def jac(x):\n                return con[\"jac\"](x, *args)\n    else:\n        fun = con['fun']\n        if 'jac' in con:\n            jac = con['jac']\n\n    return NonlinearConstraint(fun, lb, ub, jac)\n", 594], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/sparse/_base.py": ["\"\"\"Base class for sparse matrices\"\"\"\n\nimport numpy as np\n\nfrom ._sputils import (asmatrix, check_reshape_kwargs, check_shape,\n                       get_sum_dtype, isdense, isscalarlike,\n                       matrix, validateaxis, getdtype)\n\nfrom ._matrix import spmatrix\n\n__all__ = ['isspmatrix', 'issparse', 'sparray',\n           'SparseWarning', 'SparseEfficiencyWarning']\n\n\nclass SparseWarning(Warning):\n    pass\n\n\nclass SparseFormatWarning(SparseWarning):\n    pass\n\n\nclass SparseEfficiencyWarning(SparseWarning):\n    pass\n\n\n# The formats that we might potentially understand.\n_formats = {'csc': [0, \"Compressed Sparse Column\"],\n            'csr': [1, \"Compressed Sparse Row\"],\n            'dok': [2, \"Dictionary Of Keys\"],\n            'lil': [3, \"List of Lists\"],\n            'dod': [4, \"Dictionary of Dictionaries\"],\n            'sss': [5, \"Symmetric Sparse Skyline\"],\n            'coo': [6, \"COOrdinate\"],\n            'lba': [7, \"Linpack BAnded\"],\n            'egd': [8, \"Ellpack-itpack Generalized Diagonal\"],\n            'dia': [9, \"DIAgonal\"],\n            'bsr': [10, \"Block Sparse Row\"],\n            'msr': [11, \"Modified compressed Sparse Row\"],\n            'bsc': [12, \"Block Sparse Column\"],\n            'msc': [13, \"Modified compressed Sparse Column\"],\n            'ssk': [14, \"Symmetric SKyline\"],\n            'nsk': [15, \"Nonsymmetric SKyline\"],\n            'jad': [16, \"JAgged Diagonal\"],\n            'uss': [17, \"Unsymmetric Sparse Skyline\"],\n            'vbr': [18, \"Variable Block Row\"],\n            'und': [19, \"Undefined\"]\n            }\n\n\n# These univariate ufuncs preserve zeros.\n_ufuncs_with_fixed_point_at_zero = frozenset([\n        np.sin, np.tan, np.arcsin, np.arctan, np.sinh, np.tanh, np.arcsinh,\n        np.arctanh, np.rint, np.sign, np.expm1, np.log1p, np.deg2rad,\n        np.rad2deg, np.floor, np.ceil, np.trunc, np.sqrt])\n\n\nMAXPRINT = 50\n\n\nclass _spbase:\n    \"\"\" This class provides a base class for all sparse arrays.  It\n    cannot be instantiated.  Most of the work is provided by subclasses.\n    \"\"\"\n\n    __array_priority__ = 10.1\n    _format = 'und'  # undefined\n    _allow_nd = (2,)\n\n    @property\n    def ndim(self) -> int:\n        return len(self._shape)\n\n    @property\n    def _shape_as_2d(self):\n        s = self._shape\n        return (1, s[-1]) if len(s) == 1 else s\n\n    @property\n    def _bsr_container(self):\n        from ._bsr import bsr_array\n        return bsr_array\n\n    @property\n    def _coo_container(self):\n        from ._coo import coo_array\n        return coo_array\n\n    @property\n    def _csc_container(self):\n        from ._csc import csc_array\n        return csc_array\n\n    @property\n    def _csr_container(self):\n        from ._csr import csr_array\n        return csr_array\n\n    @property\n    def _dia_container(self):\n        from ._dia import dia_array\n        return dia_array\n\n    @property\n    def _dok_container(self):\n        from ._dok import dok_array\n        return dok_array\n\n    @property\n    def _lil_container(self):\n        from ._lil import lil_array\n        return lil_array\n\n    def __init__(self, arg1, *, maxprint=None):\n        self._shape = None\n        if self.__class__.__name__ == '_spbase':\n            raise ValueError(\"This class is not intended\"\n                             \" to be instantiated directly.\")\n        if isinstance(self, sparray) and np.isscalar(arg1):\n            raise ValueError(\n                \"scipy sparse array classes do not support instantiation from a scalar\"\n            )\n        self.maxprint = MAXPRINT if maxprint is None else maxprint\n\n    @property\n    def shape(self):\n        return self._shape\n\n    def reshape(self, *args, **kwargs):\n        \"\"\"reshape(self, shape, order='C', copy=False)\n\n        Gives a new shape to a sparse array/matrix without changing its data.\n\n        Parameters\n        ----------\n        shape : length-2 tuple of ints\n            The new shape should be compatible with the original shape.\n        order : {'C', 'F'}, optional\n            Read the elements using this index order. 'C' means to read and\n            write the elements using C-like index order; e.g., read entire first\n            row, then second row, etc. 'F' means to read and write the elements\n            using Fortran-like index order; e.g., read entire first column, then\n            second column, etc.\n        copy : bool, optional\n            Indicates whether or not attributes of self should be copied\n            whenever possible. The degree to which attributes are copied varies\n            depending on the type of sparse array being used.\n\n        Returns\n        -------\n        reshaped : sparse array/matrix\n            A sparse array/matrix with the given `shape`, not necessarily of the same\n            format as the current object.\n\n        See Also\n        --------\n        numpy.reshape : NumPy's implementation of 'reshape' for ndarrays\n        \"\"\"\n        # If the shape already matches, don't bother doing an actual reshape\n        # Otherwise, the default is to convert to COO and use its reshape\n        # Don't restrict ndim on this first call. That happens in constructor\n        shape = check_shape(args, self.shape, allow_nd=range(1, 65))\n        order, copy = check_reshape_kwargs(kwargs)\n        if shape == self.shape:\n            if copy:\n                return self.copy()\n            else:\n                return self\n\n        return self.tocoo(copy=copy).reshape(shape, order=order, copy=False)\n\n    def resize(self, shape):\n        \"\"\"Resize the array/matrix in-place to dimensions given by ``shape``\n\n        Any elements that lie within the new shape will remain at the same\n        indices, while non-zero elements lying outside the new shape are\n        removed.\n\n        Parameters\n        ----------\n        shape : (int, int)\n            number of rows and columns in the new array/matrix\n\n        Notes\n        -----\n        The semantics are not identical to `numpy.ndarray.resize` or\n        `numpy.resize`. Here, the same data will be maintained at each index\n        before and after reshape, if that index is within the new bounds. In\n        numpy, resizing maintains contiguity of the array, moving elements\n        around in the logical array but not within a flattened representation.\n\n        We give no guarantees about whether the underlying data attributes\n        (arrays, etc.) will be modified in place or replaced with new objects.\n        \"\"\"\n        # As an inplace operation, this requires implementation in each format.\n        raise NotImplementedError(\n            f'{type(self).__name__}.resize is not implemented')\n\n    def astype(self, dtype, casting='unsafe', copy=True):\n        \"\"\"Cast the array/matrix elements to a specified type.\n\n        Parameters\n        ----------\n        dtype : string or numpy dtype\n            Typecode or data-type to which to cast the data.\n        casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n            Controls what kind of data casting may occur.\n            Defaults to 'unsafe' for backwards compatibility.\n            'no' means the data types should not be cast at all.\n            'equiv' means only byte-order changes are allowed.\n            'safe' means only casts which can preserve values are allowed.\n            'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n            'unsafe' means any data conversions may be done.\n        copy : bool, optional\n            If `copy` is `False`, the result might share some memory with this\n            array/matrix. If `copy` is `True`, it is guaranteed that the result and\n            this array/matrix do not share any memory.\n        \"\"\"\n\n        dtype = getdtype(dtype)\n        if self.dtype != dtype:\n            return self.tocsr().astype(\n                dtype, casting=casting, copy=copy).asformat(self.format)\n        elif copy:\n            return self.copy()\n        else:\n            return self\n\n    @classmethod\n    def _ascontainer(cls, X, **kwargs):\n        if issubclass(cls, sparray):\n            return np.asarray(X, **kwargs)\n        else:\n            return asmatrix(X, **kwargs)\n\n    @classmethod\n    def _container(cls, X, **kwargs):\n        if issubclass(cls, sparray):\n            return np.array(X, **kwargs)\n        else:\n            return matrix(X, **kwargs)\n\n    def _asfptype(self):\n        \"\"\"Upcast array to a floating point format (if necessary)\"\"\"\n\n        fp_types = ['f', 'd', 'F', 'D']\n\n        if self.dtype.char in fp_types:\n            return self\n        else:\n            for fp_type in fp_types:\n                if self.dtype <= np.dtype(fp_type):\n                    return self.astype(fp_type)\n\n            raise TypeError(\n                f'cannot upcast [{self.dtype.name}] to a floating point format'\n            )\n\n    def __iter__(self):\n        for r in range(self.shape[0]):\n            yield self[r]\n\n    def _getmaxprint(self):\n        \"\"\"Maximum number of elements to display when printed.\"\"\"\n        return self.maxprint\n\n    def count_nonzero(self, axis=None):\n        \"\"\"Number of non-zero entries, equivalent to\n\n        np.count_nonzero(a.toarray(), axis=axis)\n\n        Unlike the nnz property, which return the number of stored\n        entries (the length of the data attribute), this method counts the\n        actual number of non-zero entries in data.\n\n        Duplicate entries are summed before counting.\n\n        Parameters\n        ----------\n        axis : {-2, -1, 0, 1, None} optional\n            Count nonzeros for the whole array, or along a specified axis.\n\n            .. versionadded:: 1.15.0\n\n        Returns\n        -------\n        numpy array\n            A reduced array (no axis `axis`) holding the number of nonzero values\n            for each of the indices of the nonaxis dimensions.\n\n        Notes\n        -----\n        If you want to count nonzero and explicit zero stored values (e.g. nnz)\n        along an axis, two fast idioms are provided by `numpy` functions for the\n        common CSR, CSC, COO formats.\n\n        For the major axis in CSR (rows) and CSC (cols) use `np.diff`:\n\n            >>> import numpy as np\n            >>> import scipy as sp\n            >>> A = sp.sparse.csr_array([[4, 5, 0], [7, 0, 0]])\n            >>> major_axis_stored_values = np.diff(A.indptr)  # -> np.array([2, 1])\n\n        For the minor axis in CSR (cols) and CSC (rows) use `numpy.bincount` with\n        minlength ``A.shape[1]`` for CSR and ``A.shape[0]`` for CSC:\n\n            >>> csr_minor_stored_values = np.bincount(A.indices, minlength=A.shape[1])\n\n        For COO, use the minor axis approach for either `axis`:\n\n            >>> A = A.tocoo()\n            >>> coo_axis0_stored_values = np.bincount(A.coords[0], minlength=A.shape[1])\n            >>> coo_axis1_stored_values = np.bincount(A.coords[1], minlength=A.shape[0])\n\n        Examples\n        --------\n\n            >>> A = sp.sparse.csr_array([[4, 5, 0], [7, 0, 0]])\n            >>> A.count_nonzero(axis=0)\n            array([2, 1, 0])\n        \"\"\"\n        clsname = self.__class__.__name__\n        raise NotImplementedError(f\"count_nonzero not implemented for {clsname}.\")\n\n    def _getnnz(self, axis=None):\n        \"\"\"Number of stored values, including explicit zeros.\n\n        Parameters\n        ----------\n        axis : {-2, -1, 0, 1, None} optional\n            Report stored values for the whole array, or along a specified axis.\n\n        See also\n        --------\n        count_nonzero : Number of non-zero entries\n        \"\"\"\n        clsname = self.__class__.__name__\n        raise NotImplementedError(f\"getnnz not implemented for {clsname}.\")\n\n    @property\n    def nnz(self) -> int:\n        \"\"\"Number of stored values, including explicit zeros.\n\n        See also\n        --------\n        count_nonzero : Number of non-zero entries\n        \"\"\"\n        return self._getnnz()\n\n    @property\n    def size(self) -> int:\n        \"\"\"Number of stored values.\n\n        See also\n        --------\n        count_nonzero : Number of non-zero values.\n        \"\"\"\n        return self._getnnz()\n\n    @property\n    def format(self) -> str:\n        \"\"\"Format string for matrix.\"\"\"\n        return self._format\n\n    @property\n    def T(self):\n        \"\"\"Transpose.\"\"\"\n        return self.transpose()\n\n    @property\n    def real(self):\n        return self._real()\n\n    @property\n    def imag(self):\n        return self._imag()\n\n    def __repr__(self):\n        _, format_name = _formats[self.format]\n        sparse_cls = 'array' if isinstance(self, sparray) else 'matrix'\n        return (\n            f\"<{format_name} sparse {sparse_cls} of dtype '{self.dtype}'\\n\"\n            f\"\\twith {self.nnz} stored elements and shape {self.shape}>\"\n        )\n\n    def __str__(self):\n        maxprint = self._getmaxprint()\n\n        A = self.tocoo()\n\n        # helper function, outputs \"(i,j)  v\"\n        def tostr(coords, data):\n            pairs = zip(zip(*(c.tolist() for c in coords)), data)\n            return '\\n'.join(f'  {idx}\\t{val}' for idx, val in pairs)\n\n        out = repr(self)\n        if self.nnz == 0:\n            return out\n\n        out += '\\n  Coords\\tValues\\n'\n        if self.nnz > maxprint:\n            half = maxprint // 2\n            out += tostr(tuple(c[:half] for c in A.coords), A.data[:half])\n            out += \"\\n  :\\t:\\n\"\n            half = maxprint - half\n            out += tostr(tuple(c[-half:] for c in A.coords), A.data[-half:])\n        else:\n            out += tostr(A.coords, A.data)\n\n        return out\n\n    def __bool__(self):  # Simple -- other ideas?\n        if self.shape == (1, 1):\n            return self.nnz != 0\n        else:\n            raise ValueError(\"The truth value of an array with more than one \"\n                             \"element is ambiguous. Use a.any() or a.all().\")\n    __nonzero__ = __bool__\n\n    # What should len(sparse) return? For consistency with dense matrices,\n    # perhaps it should be the number of rows?  But for some uses the number of\n    # non-zeros is more important.  For now, raise an exception!\n    def __len__(self):\n        raise TypeError(\"sparse array length is ambiguous; use getnnz()\"\n                        \" or shape[0]\")\n\n    def asformat(self, format, copy=False):\n        \"\"\"Return this array/matrix in the passed format.\n\n        Parameters\n        ----------\n        format : {str, None}\n            The desired sparse format (\"csr\", \"csc\", \"lil\", \"dok\", \"array\", ...)\n            or None for no conversion.\n        copy : bool, optional\n            If True, the result is guaranteed to not share data with self.\n\n        Returns\n        -------\n        A : This array/matrix in the passed format.\n        \"\"\"\n        if format is None or format == self.format:\n            if copy:\n                return self.copy()\n            else:\n                return self\n        else:\n            try:\n                convert_method = getattr(self, 'to' + format)\n            except AttributeError as e:\n                raise ValueError(f'Format {format} is unknown.') from e\n\n            # Forward the copy kwarg, if it's accepted.\n            try:\n                return convert_method(copy=copy)\n            except TypeError:\n                return convert_method()\n\n    ###################################################################\n    #  NOTE: All arithmetic operations use csr_matrix by default.\n    # Therefore a new sparse array format just needs to define a\n    # .tocsr() method to provide arithmetic support. Any of these\n    # methods can be overridden for efficiency.\n    ####################################################################\n\n    def multiply(self, other):\n        \"\"\"Point-wise multiplication by another array/matrix.\"\"\"\n        if isscalarlike(other):\n            return self._mul_scalar(other)\n        return self.tocsr().multiply(other)\n\n    def maximum(self, other):\n        \"\"\"Element-wise maximum between this and another array/matrix.\"\"\"\n        return self.tocsr().maximum(other)\n\n    def minimum(self, other):\n        \"\"\"Element-wise minimum between this and another array/matrix.\"\"\"\n        return self.tocsr().minimum(other)\n\n    def dot(self, other):\n        \"\"\"Ordinary dot product\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from scipy.sparse import csr_array\n        >>> A = csr_array([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n        >>> v = np.array([1, 0, -1])\n        >>> A.dot(v)\n        array([ 1, -3, -1], dtype=int64)\n\n        \"\"\"\n        if np.isscalar(other):\n            return self * other\n        else:\n            return self @ other\n\n    def power(self, n, dtype=None):\n        \"\"\"Element-wise power.\"\"\"\n        return self.tocsr().power(n, dtype=dtype)\n\n    def _broadcast_to(self, shape, copy=False):\n        if self.shape == shape:\n            return self.copy() if copy else self\n        else:\n            return self.tocsr()._broadcast_to(shape, copy)\n\n    def __eq__(self, other):\n        return self.tocsr().__eq__(other)\n\n    def __ne__(self, other):\n        return self.tocsr().__ne__(other)\n\n    def __lt__(self, other):\n        return self.tocsr().__lt__(other)\n\n    def __gt__(self, other):\n        return self.tocsr().__gt__(other)\n\n    def __le__(self, other):\n        return self.tocsr().__le__(other)\n\n    def __ge__(self, other):\n        return self.tocsr().__ge__(other)\n\n    def __abs__(self):\n        return abs(self.tocsr())\n\n    def __round__(self, ndigits=0):\n        return round(self.tocsr(), ndigits=ndigits)\n\n    def _add_sparse(self, other):\n        return self.tocsr()._add_sparse(other)\n\n    def _add_dense(self, other):\n        return self.tocoo()._add_dense(other)\n\n    def _sub_sparse(self, other):\n        return self.tocsr()._sub_sparse(other)\n\n    def _sub_dense(self, other):\n        return self.todense() - other\n\n    def _rsub_dense(self, other):\n        # note: this can't be replaced by other + (-self) for unsigned types\n        return other - self.todense()\n\n    def __add__(self, other):  # self + other\n        if isscalarlike(other):\n            if other == 0:\n                return self.copy()\n            # Now we would add this scalar to every element.\n            raise NotImplementedError('adding a nonzero scalar to a '\n                                      'sparse array is not supported')\n        elif issparse(other):\n            if other.shape != self.shape:\n                raise ValueError(\"inconsistent shapes\")\n            return self._add_sparse(other)\n        elif isdense(other):\n            other = np.broadcast_to(other, self.shape)\n            return self._add_dense(other)\n        else:\n            return NotImplemented\n\n    def __radd__(self,other):  # other + self\n        return self.__add__(other)\n\n    def __sub__(self, other):  # self - other\n        if isscalarlike(other):\n            if other == 0:\n                return self.copy()\n            raise NotImplementedError('subtracting a nonzero scalar from a '\n                                      'sparse array is not supported')\n        elif issparse(other):\n            if other.shape != self.shape:\n                raise ValueError(\"inconsistent shapes\")\n            return self._sub_sparse(other)\n        elif isdense(other):\n            other = np.broadcast_to(other, self.shape)\n            return self._sub_dense(other)\n        else:\n            return NotImplemented\n\n    def __rsub__(self,other):  # other - self\n        if isscalarlike(other):\n            if other == 0:\n                return -self.copy()\n            raise NotImplementedError('subtracting a sparse array from a '\n                                      'nonzero scalar is not supported')\n        elif isdense(other):\n            other = np.broadcast_to(other, self.shape)\n            return self._rsub_dense(other)\n        else:\n            return NotImplemented\n\n    def _matmul_dispatch(self, other):\n        \"\"\"np.array-like matmul & `np.matrix`-like mul, i.e. `dot` or `NotImplemented`\n\n        interpret other and call one of the following\n        self._mul_scalar()\n        self._matmul_vector()\n        self._matmul_multivector()\n        self._matmul_sparse()\n        \"\"\"\n        # This method has to be different from `__matmul__` because it is also\n        # called by sparse matrix classes.\n\n        # Currently matrix multiplication is only supported\n        # for 2D arrays. Hence we unpacked and use only the\n        # two last axes' lengths.\n        M, N = self._shape_as_2d\n\n        if other.__class__ is np.ndarray:\n            # Fast path for the most common case\n            if other.shape == (N,):\n                return self._matmul_vector(other)\n            elif other.shape == (N, 1):\n                result = self._matmul_vector(other.ravel())\n                if self.ndim == 1:\n                    return result.reshape(1)\n                return result.reshape(M, 1)\n            elif other.ndim == 2 and other.shape[0] == N:\n                return self._matmul_multivector(other)\n\n        if isscalarlike(other):\n            # scalar value\n            return self._mul_scalar(other)\n\n        err_prefix = \"matmul: dimension mismatch with signature\"\n        if issparse(other):\n            if N != other.shape[0]:\n                raise ValueError(\n                    f\"{err_prefix} (n,k={N}),(k={other.shape[0]},m)->(n,m)\"\n                )\n            return self._matmul_sparse(other)\n\n        # If it's a list or whatever, treat it like an array\n        other_a = np.asanyarray(other)\n\n        if other_a.ndim == 0 and other_a.dtype == np.object_:\n            # Not interpretable as an array; return NotImplemented so that\n            # other's __rmatmul__ can kick in if that's implemented.\n            return NotImplemented\n\n        try:\n            other.shape\n        except AttributeError:\n            other = other_a\n\n        if other.ndim == 1 or other.ndim == 2 and other.shape[1] == 1:\n            # dense row or column vector\n            if other.shape[0] != N:\n                raise ValueError(\n                    f\"{err_prefix} (n,k={N}),(k={other.shape[0]},1?)->(n,1?)\"\n                )\n\n            result = self._matmul_vector(np.ravel(other))\n\n            if isinstance(other, np.matrix):\n                result = self._ascontainer(result)\n\n            if other.ndim == 2 and other.shape[1] == 1:\n                # If 'other' was an (nx1) column vector, reshape the result\n                if self.ndim == 1:\n                    result = result.reshape(1)\n                else:\n                    result = result.reshape(-1, 1)\n\n            return result\n\n        elif other.ndim == 2:\n            ##\n            # dense 2D array or matrix (\"multivector\")\n\n            if other.shape[0] != N:\n                raise ValueError(\n                    f\"{err_prefix} (n,k={N}),(k={other.shape[0]},m)->(n,m)\"\n                )\n\n            result = self._matmul_multivector(np.asarray(other))\n\n            if isinstance(other, np.matrix):\n                result = self._ascontainer(result)\n\n            return result\n\n        else:\n            raise ValueError('could not interpret dimensions')\n\n    def __mul__(self, other):\n        return self.multiply(other)\n\n    def __rmul__(self, other):  # other * self\n        return self.multiply(other)\n\n    # by default, use CSR for __mul__ handlers\n    def _mul_scalar(self, other):\n        return self.tocsr()._mul_scalar(other)\n\n    def _matmul_vector(self, other):\n        return self.tocsr()._matmul_vector(other)\n\n    def _matmul_multivector(self, other):\n        return self.tocsr()._matmul_multivector(other)\n\n    def _matmul_sparse(self, other):\n        return self.tocsr()._matmul_sparse(other)\n\n    def _rmatmul_dispatch(self, other):\n        if isscalarlike(other):\n            return self._mul_scalar(other)\n        else:\n            # Don't use asarray unless we have to\n            try:\n                tr = other.transpose()\n            except AttributeError:\n                tr = np.asarray(other).transpose()\n            ret = self.transpose()._matmul_dispatch(tr)\n            if ret is NotImplemented:\n                return NotImplemented\n            return ret.transpose()\n\n    #######################\n    # matmul (@) operator #\n    #######################\n\n    def __matmul__(self, other):\n        if isscalarlike(other):\n            raise ValueError(\"Scalar operands are not allowed, \"\n                             \"use '*' instead\")\n        return self._matmul_dispatch(other)\n\n    def __rmatmul__(self, other):\n        if isscalarlike(other):\n            raise ValueError(\"Scalar operands are not allowed, \"\n                             \"use '*' instead\")\n        return self._rmatmul_dispatch(other)\n\n    ####################\n    # Other Arithmetic #\n    ####################\n\n    def _divide(self, other, true_divide=False, rdivide=False):\n        if isscalarlike(other):\n            if rdivide:\n                if true_divide:\n                    return np.true_divide(other, self.todense())\n                else:\n                    return np.divide(other, self.todense())\n\n            if true_divide and np.can_cast(self.dtype, np.float64):\n                return self.astype(np.float64)._mul_scalar(1./other)\n            else:\n                r = self._mul_scalar(1./other)\n\n                scalar_dtype = np.asarray(other).dtype\n                if (np.issubdtype(self.dtype, np.integer) and\n                        np.issubdtype(scalar_dtype, np.integer)):\n                    return r.astype(self.dtype)\n                else:\n                    return r\n\n        elif isdense(other):\n            if not rdivide:\n                if true_divide:\n                    recip = np.true_divide(1., other)\n                else:\n                    recip = np.divide(1., other)\n                return self.multiply(recip)\n            else:\n                if true_divide:\n                    return np.true_divide(other, self.todense())\n                else:\n                    return np.divide(other, self.todense())\n        elif issparse(other):\n            if rdivide:\n                return other._divide(self, true_divide, rdivide=False)\n\n            self_csr = self.tocsr()\n            if true_divide and np.can_cast(self.dtype, np.float64):\n                return self_csr.astype(np.float64)._divide_sparse(other)\n            else:\n                return self_csr._divide_sparse(other)\n        else:\n            return NotImplemented\n\n    def __truediv__(self, other):\n        return self._divide(other, true_divide=True)\n\n    def __div__(self, other):\n        # Always do true division\n        return self._divide(other, true_divide=True)\n\n    def __rtruediv__(self, other):\n        # Implementing this as the inverse would be too magical -- bail out\n        return NotImplemented\n\n    def __rdiv__(self, other):\n        # Implementing this as the inverse would be too magical -- bail out\n        return NotImplemented\n\n    def __neg__(self):\n        return -self.tocsr()\n\n    def __iadd__(self, other):\n        return NotImplemented\n\n    def __isub__(self, other):\n        return NotImplemented\n\n    def __imul__(self, other):\n        return NotImplemented\n\n    def __idiv__(self, other):\n        return self.__itruediv__(other)\n\n    def __itruediv__(self, other):\n        return NotImplemented\n\n    def __pow__(self, *args, **kwargs):\n        return self.power(*args, **kwargs)\n\n    def transpose(self, axes=None, copy=False):\n        \"\"\"\n        Reverses the dimensions of the sparse array/matrix.\n\n        Parameters\n        ----------\n        axes : None, optional\n            This argument is in the signature *solely* for NumPy\n            compatibility reasons. Do not pass in anything except\n            for the default value.\n        copy : bool, optional\n            Indicates whether or not attributes of `self` should be\n            copied whenever possible. The degree to which attributes\n            are copied varies depending on the type of sparse array/matrix\n            being used.\n\n        Returns\n        -------\n        p : `self` with the dimensions reversed.\n\n        Notes\n        -----\n        If `self` is a `csr_array` or a `csc_array`, then this will return a\n        `csc_array` or a `csr_array`, respectively.\n\n        See Also\n        --------\n        numpy.transpose : NumPy's implementation of 'transpose' for ndarrays\n        \"\"\"\n        return self.tocsr(copy=copy).transpose(axes=axes, copy=False)\n\n    def conjugate(self, copy=True):\n        \"\"\"Element-wise complex conjugation.\n\n        If the array/matrix is of non-complex data type and `copy` is False,\n        this method does nothing and the data is not copied.\n\n        Parameters\n        ----------\n        copy : bool, optional\n            If True, the result is guaranteed to not share data with self.\n\n        Returns\n        -------\n        A : The element-wise complex conjugate.\n\n        \"\"\"\n        if np.issubdtype(self.dtype, np.complexfloating):\n            return self.tocsr(copy=copy).conjugate(copy=False)\n        elif copy:\n            return self.copy()\n        else:\n            return self\n\n    def conj(self, copy=True):\n        return self.conjugate(copy=copy)\n\n    conj.__doc__ = conjugate.__doc__\n\n    def _real(self):\n        return self.tocsr()._real()\n\n    def _imag(self):\n        return self.tocsr()._imag()\n\n    def nonzero(self):\n        \"\"\"Nonzero indices of the array/matrix.\n\n        Returns a tuple of arrays (row,col) containing the indices\n        of the non-zero elements of the array.\n\n        Examples\n        --------\n        >>> from scipy.sparse import csr_array\n        >>> A = csr_array([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n        >>> A.nonzero()\n        (array([0, 0, 1, 2, 2], dtype=int32), array([0, 1, 2, 0, 2], dtype=int32))\n\n        \"\"\"\n\n        # convert to COOrdinate format\n        A = self.tocoo()\n        nz_mask = A.data != 0\n        return tuple(idx[nz_mask] for idx in A.coords)\n\n    def _getcol(self, j):\n        \"\"\"Returns a copy of column j of the array, as an (m x 1) sparse\n        array (column vector).\n        \"\"\"\n        if self.ndim == 1:\n            raise ValueError(\"getcol not provided for 1d arrays. Use indexing A[j]\")\n        # Subclasses should override this method for efficiency.\n        # Post-multiply by a (n x 1) column vector 'a' containing all zeros\n        # except for a_j = 1\n        N = self.shape[-1]\n        if j < 0:\n            j += N\n        if j < 0 or j >= N:\n            raise IndexError(\"index out of bounds\")\n        col_selector = self._csc_container(([1], [[j], [0]]),\n                                           shape=(N, 1), dtype=self.dtype)\n        result = self @ col_selector\n        return result\n\n    def _getrow(self, i):\n        \"\"\"Returns a copy of row i of the array, as a (1 x n) sparse\n        array (row vector).\n        \"\"\"\n        if self.ndim == 1:\n            raise ValueError(\"getrow not meaningful for a 1d array\")\n        # Subclasses should override this method for efficiency.\n        # Pre-multiply by a (1 x m) row vector 'a' containing all zeros\n        # except for a_i = 1\n        M = self.shape[0]\n        if i < 0:\n            i += M\n        if i < 0 or i >= M:\n            raise IndexError(\"index out of bounds\")\n        row_selector = self._csr_container(([1], [[0], [i]]),\n                                           shape=(1, M), dtype=self.dtype)\n        return row_selector @ self\n\n    # The following dunder methods cannot be implemented.\n    #\n    # def __array__(self):\n    #     # Sparse matrices rely on NumPy wrapping them in object arrays under\n    #     # the hood to make unary ufuncs work on them. So we cannot raise\n    #     # TypeError here - which would be handy to not give users object\n    #     # arrays they probably don't want (they're looking for `.toarray()`).\n    #     #\n    #     # Conversion with `toarray()` would also break things because of the\n    #     # behavior discussed above, plus we want to avoid densification by\n    #     # accident because that can too easily blow up memory.\n    #\n    # def __array_ufunc__(self):\n    #     # We cannot implement __array_ufunc__ due to mismatching semantics.\n    #     # See gh-7707 and gh-7349 for details.\n    #\n    # def __array_function__(self):\n    #     # We cannot implement __array_function__ due to mismatching semantics.\n    #     # See gh-10362 for details.\n\n    def todense(self, order=None, out=None):\n        \"\"\"\n        Return a dense representation of this sparse array.\n\n        Parameters\n        ----------\n        order : {'C', 'F'}, optional\n            Whether to store multi-dimensional data in C (row-major)\n            or Fortran (column-major) order in memory. The default\n            is 'None', which provides no ordering guarantees.\n            Cannot be specified in conjunction with the `out`\n            argument.\n\n        out : ndarray, 2-D, optional\n            If specified, uses this array as the output buffer\n            instead of allocating a new array to return. The\n            provided array must have the same shape and dtype as\n            the sparse array on which you are calling the method.\n\n        Returns\n        -------\n        arr : ndarray, 2-D\n            An array with the same shape and containing the same\n            data represented by the sparse array, with the requested\n            memory order. If `out` was passed, the same object is\n            returned after being modified in-place to contain the\n            appropriate values.\n        \"\"\"\n        return self._ascontainer(self.toarray(order=order, out=out))\n\n    def toarray(self, order=None, out=None):\n        \"\"\"\n        Return a dense ndarray representation of this sparse array/matrix.\n\n        Parameters\n        ----------\n        order : {'C', 'F'}, optional\n            Whether to store multidimensional data in C (row-major)\n            or Fortran (column-major) order in memory. The default\n            is 'None', which provides no ordering guarantees.\n            Cannot be specified in conjunction with the `out`\n            argument.\n\n        out : ndarray, 2-D, optional\n            If specified, uses this array as the output buffer\n            instead of allocating a new array to return. The provided\n            array must have the same shape and dtype as the sparse\n            array/matrix on which you are calling the method. For most\n            sparse types, `out` is required to be memory contiguous\n            (either C or Fortran ordered).\n\n        Returns\n        -------\n        arr : ndarray, 2-D\n            An array with the same shape and containing the same\n            data represented by the sparse array/matrix, with the requested\n            memory order. If `out` was passed, the same object is\n            returned after being modified in-place to contain the\n            appropriate values.\n        \"\"\"\n        return self.tocoo(copy=False).toarray(order=order, out=out)\n\n    # Any sparse array format deriving from _spbase must define one of\n    # tocsr or tocoo. The other conversion methods may be implemented for\n    # efficiency, but are not required.\n    def tocsr(self, copy=False):\n        \"\"\"Convert this array/matrix to Compressed Sparse Row format.\n\n        With copy=False, the data/indices may be shared between this array/matrix and\n        the resultant csr_array/matrix.\n        \"\"\"\n        return self.tocoo(copy=copy).tocsr(copy=False)\n\n    def todok(self, copy=False):\n        \"\"\"Convert this array/matrix to Dictionary Of Keys format.\n\n        With copy=False, the data/indices may be shared between this array/matrix and\n        the resultant dok_array/matrix.\n        \"\"\"\n        return self.tocoo(copy=copy).todok(copy=False)\n\n    def tocoo(self, copy=False):\n        \"\"\"Convert this array/matrix to COOrdinate format.\n\n        With copy=False, the data/indices may be shared between this array/matrix and\n        the resultant coo_array/matrix.\n        \"\"\"\n        return self.tocsr(copy=False).tocoo(copy=copy)\n\n    def tolil(self, copy=False):\n        \"\"\"Convert this array/matrix to List of Lists format.\n\n        With copy=False, the data/indices may be shared between this array/matrix and\n        the resultant lil_array/matrix.\n        \"\"\"\n        return self.tocsr(copy=False).tolil(copy=copy)\n\n    def todia(self, copy=False):\n        \"\"\"Convert this array/matrix to sparse DIAgonal format.\n\n        With copy=False, the data/indices may be shared between this array/matrix and\n        the resultant dia_array/matrix.\n        \"\"\"\n        return self.tocoo(copy=copy).todia(copy=False)\n\n    def tobsr(self, blocksize=None, copy=False):\n        \"\"\"Convert this array/matrix to Block Sparse Row format.\n\n        With copy=False, the data/indices may be shared between this array/matrix and\n        the resultant bsr_array/matrix.\n\n        When blocksize=(R, C) is provided, it will be used for construction of\n        the bsr_array/matrix.\n        \"\"\"\n        return self.tocsr(copy=False).tobsr(blocksize=blocksize, copy=copy)\n\n    def tocsc(self, copy=False):\n        \"\"\"Convert this array/matrix to Compressed Sparse Column format.\n\n        With copy=False, the data/indices may be shared between this array/matrix and\n        the resultant csc_array/matrix.\n        \"\"\"\n        return self.tocsr(copy=copy).tocsc(copy=False)\n\n    def copy(self):\n        \"\"\"Returns a copy of this array/matrix.\n\n        No data/indices will be shared between the returned value and current\n        array/matrix.\n        \"\"\"\n        return self.__class__(self, copy=True)\n\n    def sum(self, axis=None, dtype=None, out=None):\n        \"\"\"\n        Sum the array/matrix elements over a given axis.\n\n        Parameters\n        ----------\n        axis : {-2, -1, 0, 1, None} optional\n            Axis along which the sum is computed. The default is to\n            compute the sum of all the array/matrix elements, returning a scalar\n            (i.e., `axis` = `None`).\n        dtype : dtype, optional\n            The type of the returned array/matrix and of the accumulator in which\n            the elements are summed.  The dtype of `a` is used by default\n            unless `a` has an integer dtype of less precision than the default\n            platform integer.  In that case, if `a` is signed then the platform\n            integer is used while if `a` is unsigned then an unsigned integer\n            of the same precision as the platform integer is used.\n\n            .. versionadded:: 0.18.0\n\n        out : np.matrix, optional\n            Alternative output matrix in which to place the result. It must\n            have the same shape as the expected output, but the type of the\n            output values will be cast if necessary.\n\n            .. versionadded:: 0.18.0\n\n        Returns\n        -------\n        sum_along_axis : np.matrix\n            A matrix with the same shape as `self`, with the specified\n            axis removed.\n\n        See Also\n        --------\n        numpy.matrix.sum : NumPy's implementation of 'sum' for matrices\n\n        \"\"\"\n        validateaxis(axis)\n\n        # Mimic numpy's casting.\n        res_dtype = get_sum_dtype(self.dtype)\n\n        if self.ndim == 1:\n            if axis not in (None, -1, 0):\n                raise ValueError(\"axis must be None, -1 or 0\")\n            res = self @ np.ones(self.shape, dtype=res_dtype)\n            return res.sum(dtype=dtype, out=out)\n\n        # We use multiplication by a matrix of ones to achieve this.\n        # For some sparse array formats more efficient methods are\n        # possible -- these should override this function.\n        M, N = self.shape\n\n        if axis is None:\n            # sum over rows and columns\n            return (\n                self @ self._ascontainer(np.ones((N, 1), dtype=res_dtype))\n            ).sum(dtype=dtype, out=out)\n\n        if axis < 0:\n            axis += 2\n\n        # axis = 0 or 1 now\n        if axis == 0:\n            # sum over columns\n            ret = self._ascontainer(\n                np.ones((1, M), dtype=res_dtype)\n            ) @ self\n        else:\n            # sum over rows\n            ret = self @ self._ascontainer(\n                np.ones((N, 1), dtype=res_dtype)\n            )\n\n        return ret.sum(axis=axis, dtype=dtype, out=out)\n\n    def mean(self, axis=None, dtype=None, out=None):\n        \"\"\"\n        Compute the arithmetic mean along the specified axis.\n\n        Returns the average of the array/matrix elements. The average is taken\n        over all elements in the array/matrix by default, otherwise over the\n        specified axis. `float64` intermediate and return values are used\n        for integer inputs.\n\n        Parameters\n        ----------\n        axis : {-2, -1, 0, 1, None} optional\n            Axis along which the mean is computed. The default is to compute\n            the mean of all elements in the array/matrix (i.e., `axis` = `None`).\n        dtype : data-type, optional\n            Type to use in computing the mean. For integer inputs, the default\n            is `float64`; for floating point inputs, it is the same as the\n            input dtype.\n\n            .. versionadded:: 0.18.0\n\n        out : np.matrix, optional\n            Alternative output matrix in which to place the result. It must\n            have the same shape as the expected output, but the type of the\n            output values will be cast if necessary.\n\n            .. versionadded:: 0.18.0\n\n        Returns\n        -------\n        m : np.matrix\n\n        See Also\n        --------\n        numpy.matrix.mean : NumPy's implementation of 'mean' for matrices\n\n        \"\"\"\n        validateaxis(axis)\n\n        res_dtype = self.dtype.type\n        integral = (np.issubdtype(self.dtype, np.integer) or\n                    np.issubdtype(self.dtype, np.bool_))\n\n        # output dtype\n        if dtype is None:\n            if integral:\n                res_dtype = np.float64\n        else:\n            res_dtype = np.dtype(dtype).type\n\n        # intermediate dtype for summation\n        inter_dtype = np.float64 if integral else res_dtype\n        inter_self = self.astype(inter_dtype)\n\n        if self.ndim == 1:\n            if axis not in (None, -1, 0):\n                raise ValueError(\"axis must be None, -1 or 0\")\n            res = inter_self / self.shape[-1]\n            return res.sum(dtype=res_dtype, out=out)\n\n        if axis is None:\n            return (inter_self / (self.shape[0] * self.shape[1]))\\\n                .sum(dtype=res_dtype, out=out)\n\n        if axis < 0:\n            axis += 2\n\n        # axis = 0 or 1 now\n        if axis == 0:\n            return (inter_self * (1.0 / self.shape[0])).sum(\n                axis=0, dtype=res_dtype, out=out)\n        else:\n            return (inter_self * (1.0 / self.shape[1])).sum(\n                axis=1, dtype=res_dtype, out=out)\n\n    def diagonal(self, k=0):\n        \"\"\"Returns the kth diagonal of the array/matrix.\n\n        Parameters\n        ----------\n        k : int, optional\n            Which diagonal to get, corresponding to elements a[i, i+k].\n            Default: 0 (the main diagonal).\n\n            .. versionadded:: 1.0\n\n        See also\n        --------\n        numpy.diagonal : Equivalent numpy function.\n\n        Examples\n        --------\n        >>> from scipy.sparse import csr_array\n        >>> A = csr_array([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n        >>> A.diagonal()\n        array([1, 0, 5])\n        >>> A.diagonal(k=1)\n        array([2, 3])\n        \"\"\"\n        return self.tocsr().diagonal(k=k)\n\n    def trace(self, offset=0):\n        \"\"\"Returns the sum along diagonals of the sparse array/matrix.\n\n        Parameters\n        ----------\n        offset : int, optional\n            Which diagonal to get, corresponding to elements a[i, i+offset].\n            Default: 0 (the main diagonal).\n\n        \"\"\"\n        return self.diagonal(k=offset).sum()\n\n    def setdiag(self, values, k=0):\n        \"\"\"\n        Set diagonal or off-diagonal elements of the array/matrix.\n\n        Parameters\n        ----------\n        values : array_like\n            New values of the diagonal elements.\n\n            Values may have any length. If the diagonal is longer than values,\n            then the remaining diagonal entries will not be set. If values are\n            longer than the diagonal, then the remaining values are ignored.\n\n            If a scalar value is given, all of the diagonal is set to it.\n\n        k : int, optional\n            Which off-diagonal to set, corresponding to elements a[i,i+k].\n            Default: 0 (the main diagonal).\n\n        \"\"\"\n        M, N = self.shape\n        if (k > 0 and k >= N) or (k < 0 and -k >= M):\n            raise ValueError(\"k exceeds array dimensions\")\n        self._setdiag(np.asarray(values), k)\n\n    def _setdiag(self, values, k):\n        \"\"\"This part of the implementation gets overridden by the\n        different formats.\n        \"\"\"\n        M, N = self.shape\n        if k < 0:\n            if values.ndim == 0:\n                # broadcast\n                max_index = min(M+k, N)\n                for i in range(max_index):\n                    self[i - k, i] = values\n            else:\n                max_index = min(M+k, N, len(values))\n                if max_index <= 0:\n                    return\n                for i, v in enumerate(values[:max_index]):\n                    self[i - k, i] = v\n        else:\n            if values.ndim == 0:\n                # broadcast\n                max_index = min(M, N-k)\n                for i in range(max_index):\n                    self[i, i + k] = values\n            else:\n                max_index = min(M, N-k, len(values))\n                if max_index <= 0:\n                    return\n                for i, v in enumerate(values[:max_index]):\n                    self[i, i + k] = v\n\n    def _process_toarray_args(self, order, out):\n        if out is not None:\n            if order is not None:\n                raise ValueError('order cannot be specified if out '\n                                 'is not None')\n            if out.shape != self.shape or out.dtype != self.dtype:\n                raise ValueError('out array must be same dtype and shape as '\n                                 'sparse array')\n            out[...] = 0.\n            return out\n        else:\n            return np.zeros(self.shape, dtype=self.dtype, order=order)\n\n    def _get_index_dtype(self, arrays=(), maxval=None, check_contents=False):\n        \"\"\"\n        Determine index dtype for array.\n\n        This wraps _sputils.get_index_dtype, providing compatibility for both\n        array and matrix API sparse matrices. Matrix API sparse matrices would\n        attempt to downcast the indices - which can be computationally\n        expensive and undesirable for users. The array API changes this\n        behaviour.\n\n        See discussion: https://github.com/scipy/scipy/issues/16774\n\n        The get_index_dtype import is due to implementation details of the test\n        suite. It allows the decorator ``with_64bit_maxval_limit`` to mock a\n        lower int32 max value for checks on the matrix API's downcasting\n        behaviour.\n        \"\"\"\n        from ._sputils import get_index_dtype\n\n        # Don't check contents for array API\n        return get_index_dtype(arrays,\n                               maxval,\n                               (check_contents and not isinstance(self, sparray)))\n\n\nclass sparray:\n    \"\"\"A namespace class to separate sparray from spmatrix\"\"\"\n\n\nsparray.__doc__ = _spbase.__doc__\n\n\ndef issparse(x):\n    \"\"\"Is `x` of a sparse array or sparse matrix type?\n\n    Parameters\n    ----------\n    x\n        object to check for being a sparse array or sparse matrix\n\n    Returns\n    -------\n    bool\n        True if `x` is a sparse array or a sparse matrix, False otherwise\n\n    Notes\n    -----\n    Use `isinstance(x, sp.sparse.sparray)` to check between an array or matrix.\n    Use `a.format` to check the sparse format, e.g. `a.format == 'csr'`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.sparse import csr_array, csr_matrix, issparse\n    >>> issparse(csr_matrix([[5]]))\n    True\n    >>> issparse(csr_array([[5]]))\n    True\n    >>> issparse(np.array([[5]]))\n    False\n    >>> issparse(5)\n    False\n    \"\"\"\n    return isinstance(x, _spbase)\n\n\ndef isspmatrix(x):\n    \"\"\"Is `x` of a sparse matrix type?\n\n    Parameters\n    ----------\n    x\n        object to check for being a sparse matrix\n\n    Returns\n    -------\n    bool\n        True if `x` is a sparse matrix, False otherwise\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.sparse import csr_array, csr_matrix, isspmatrix\n    >>> isspmatrix(csr_matrix([[5]]))\n    True\n    >>> isspmatrix(csr_array([[5]]))\n    False\n    >>> isspmatrix(np.array([[5]]))\n    False\n    >>> isspmatrix(5)\n    False\n    \"\"\"\n    return isinstance(x, spmatrix)\n", 1448], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py": ["\"\"\"\nUtilities that manipulate strides to achieve desirable effects.\n\nAn explanation of strides can be found in the :ref:`arrays.ndarray`.\n\n\"\"\"\nimport numpy as np\nfrom numpy._core.numeric import normalize_axis_tuple\nfrom numpy._core.overrides import array_function_dispatch, set_module\n\n__all__ = ['broadcast_to', 'broadcast_arrays', 'broadcast_shapes']\n\n\nclass DummyArray:\n    \"\"\"Dummy object that just exists to hang __array_interface__ dictionaries\n    and possibly keep alive a reference to a base array.\n    \"\"\"\n\n    def __init__(self, interface, base=None):\n        self.__array_interface__ = interface\n        self.base = base\n\n\ndef _maybe_view_as_subclass(original_array, new_array):\n    if type(original_array) is not type(new_array):\n        # if input was an ndarray subclass and subclasses were OK,\n        # then view the result as that subclass.\n        new_array = new_array.view(type=type(original_array))\n        # Since we have done something akin to a view from original_array, we\n        # should let the subclass finalize (if it has it implemented, i.e., is\n        # not None).\n        if new_array.__array_finalize__:\n            new_array.__array_finalize__(original_array)\n    return new_array\n\n\n@set_module(\"numpy.lib.stride_tricks\")\ndef as_strided(x, shape=None, strides=None, subok=False, writeable=True):\n    \"\"\"\n    Create a view into the array with the given shape and strides.\n\n    .. warning:: This function has to be used with extreme care, see notes.\n\n    Parameters\n    ----------\n    x : ndarray\n        Array to create a new.\n    shape : sequence of int, optional\n        The shape of the new array. Defaults to ``x.shape``.\n    strides : sequence of int, optional\n        The strides of the new array. Defaults to ``x.strides``.\n    subok : bool, optional\n        If True, subclasses are preserved.\n    writeable : bool, optional\n        If set to False, the returned array will always be readonly.\n        Otherwise it will be writable if the original array was. It\n        is advisable to set this to False if possible (see Notes).\n\n    Returns\n    -------\n    view : ndarray\n\n    See also\n    --------\n    broadcast_to : broadcast an array to a given shape.\n    reshape : reshape an array.\n    lib.stride_tricks.sliding_window_view :\n        userfriendly and safe function for a creation of sliding window views.\n\n    Notes\n    -----\n    ``as_strided`` creates a view into the array given the exact strides\n    and shape. This means it manipulates the internal data structure of\n    ndarray and, if done incorrectly, the array elements can point to\n    invalid memory and can corrupt results or crash your program.\n    It is advisable to always use the original ``x.strides`` when\n    calculating new strides to avoid reliance on a contiguous memory\n    layout.\n\n    Furthermore, arrays created with this function often contain self\n    overlapping memory, so that two elements are identical.\n    Vectorized write operations on such arrays will typically be\n    unpredictable. They may even give different results for small, large,\n    or transposed arrays.\n\n    Since writing to these arrays has to be tested and done with great\n    care, you may want to use ``writeable=False`` to avoid accidental write\n    operations.\n\n    For these reasons it is advisable to avoid ``as_strided`` when\n    possible.\n    \"\"\"\n    # first convert input to array, possibly keeping subclass\n    x = np.array(x, copy=None, subok=subok)\n    interface = dict(x.__array_interface__)\n    if shape is not None:\n        interface['shape'] = tuple(shape)\n    if strides is not None:\n        interface['strides'] = tuple(strides)\n\n    array = np.asarray(DummyArray(interface, base=x))\n    # The route via `__interface__` does not preserve structured\n    # dtypes. Since dtype should remain unchanged, we set it explicitly.\n    array.dtype = x.dtype\n\n    view = _maybe_view_as_subclass(x, array)\n\n    if view.flags.writeable and not writeable:\n        view.flags.writeable = False\n\n    return view\n\n\ndef _sliding_window_view_dispatcher(x, window_shape, axis=None, *,\n                                    subok=None, writeable=None):\n    return (x,)\n\n\n@array_function_dispatch(\n    _sliding_window_view_dispatcher, module=\"numpy.lib.stride_tricks\"\n)\ndef sliding_window_view(x, window_shape, axis=None, *,\n                        subok=False, writeable=False):\n    \"\"\"\n    Create a sliding window view into the array with the given window shape.\n\n    Also known as rolling or moving window, the window slides across all\n    dimensions of the array and extracts subsets of the array at all window\n    positions.\n\n    .. versionadded:: 1.20.0\n\n    Parameters\n    ----------\n    x : array_like\n        Array to create the sliding window view from.\n    window_shape : int or tuple of int\n        Size of window over each axis that takes part in the sliding window.\n        If `axis` is not present, must have same length as the number of input\n        array dimensions. Single integers `i` are treated as if they were the\n        tuple `(i,)`.\n    axis : int or tuple of int, optional\n        Axis or axes along which the sliding window is applied.\n        By default, the sliding window is applied to all axes and\n        `window_shape[i]` will refer to axis `i` of `x`.\n        If `axis` is given as a `tuple of int`, `window_shape[i]` will refer to\n        the axis `axis[i]` of `x`.\n        Single integers `i` are treated as if they were the tuple `(i,)`.\n    subok : bool, optional\n        If True, sub-classes will be passed-through, otherwise the returned\n        array will be forced to be a base-class array (default).\n    writeable : bool, optional\n        When true, allow writing to the returned view. The default is false,\n        as this should be used with caution: the returned view contains the\n        same memory location multiple times, so writing to one location will\n        cause others to change.\n\n    Returns\n    -------\n    view : ndarray\n        Sliding window view of the array. The sliding window dimensions are\n        inserted at the end, and the original dimensions are trimmed as\n        required by the size of the sliding window.\n        That is, ``view.shape = x_shape_trimmed + window_shape``, where\n        ``x_shape_trimmed`` is ``x.shape`` with every entry reduced by one less\n        than the corresponding window size.\n\n    See Also\n    --------\n    lib.stride_tricks.as_strided: A lower-level and less safe routine for\n        creating arbitrary views from custom shape and strides.\n    broadcast_to: broadcast an array to a given shape.\n\n    Notes\n    -----\n    For many applications using a sliding window view can be convenient, but\n    potentially very slow. Often specialized solutions exist, for example:\n\n    - `scipy.signal.fftconvolve`\n\n    - filtering functions in `scipy.ndimage`\n\n    - moving window functions provided by\n      `bottleneck <https://github.com/pydata/bottleneck>`_.\n\n    As a rough estimate, a sliding window approach with an input size of `N`\n    and a window size of `W` will scale as `O(N*W)` where frequently a special\n    algorithm can achieve `O(N)`. That means that the sliding window variant\n    for a window size of 100 can be a 100 times slower than a more specialized\n    version.\n\n    Nevertheless, for small window sizes, when no custom algorithm exists, or\n    as a prototyping and developing tool, this function can be a good solution.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from numpy.lib.stride_tricks import sliding_window_view\n    >>> x = np.arange(6)\n    >>> x.shape\n    (6,)\n    >>> v = sliding_window_view(x, 3)\n    >>> v.shape\n    (4, 3)\n    >>> v\n    array([[0, 1, 2],\n           [1, 2, 3],\n           [2, 3, 4],\n           [3, 4, 5]])\n\n    This also works in more dimensions, e.g.\n\n    >>> i, j = np.ogrid[:3, :4]\n    >>> x = 10*i + j\n    >>> x.shape\n    (3, 4)\n    >>> x\n    array([[ 0,  1,  2,  3],\n           [10, 11, 12, 13],\n           [20, 21, 22, 23]])\n    >>> shape = (2,2)\n    >>> v = sliding_window_view(x, shape)\n    >>> v.shape\n    (2, 3, 2, 2)\n    >>> v\n    array([[[[ 0,  1],\n             [10, 11]],\n            [[ 1,  2],\n             [11, 12]],\n            [[ 2,  3],\n             [12, 13]]],\n           [[[10, 11],\n             [20, 21]],\n            [[11, 12],\n             [21, 22]],\n            [[12, 13],\n             [22, 23]]]])\n\n    The axis can be specified explicitly:\n\n    >>> v = sliding_window_view(x, 3, 0)\n    >>> v.shape\n    (1, 4, 3)\n    >>> v\n    array([[[ 0, 10, 20],\n            [ 1, 11, 21],\n            [ 2, 12, 22],\n            [ 3, 13, 23]]])\n\n    The same axis can be used several times. In that case, every use reduces\n    the corresponding original dimension:\n\n    >>> v = sliding_window_view(x, (2, 3), (1, 1))\n    >>> v.shape\n    (3, 1, 2, 3)\n    >>> v\n    array([[[[ 0,  1,  2],\n             [ 1,  2,  3]]],\n           [[[10, 11, 12],\n             [11, 12, 13]]],\n           [[[20, 21, 22],\n             [21, 22, 23]]]])\n\n    Combining with stepped slicing (`::step`), this can be used to take sliding\n    views which skip elements:\n\n    >>> x = np.arange(7)\n    >>> sliding_window_view(x, 5)[:, ::2]\n    array([[0, 2, 4],\n           [1, 3, 5],\n           [2, 4, 6]])\n\n    or views which move by multiple elements\n\n    >>> x = np.arange(7)\n    >>> sliding_window_view(x, 3)[::2, :]\n    array([[0, 1, 2],\n           [2, 3, 4],\n           [4, 5, 6]])\n\n    A common application of `sliding_window_view` is the calculation of running\n    statistics. The simplest example is the\n    `moving average <https://en.wikipedia.org/wiki/Moving_average>`_:\n\n    >>> x = np.arange(6)\n    >>> x.shape\n    (6,)\n    >>> v = sliding_window_view(x, 3)\n    >>> v.shape\n    (4, 3)\n    >>> v\n    array([[0, 1, 2],\n           [1, 2, 3],\n           [2, 3, 4],\n           [3, 4, 5]])\n    >>> moving_average = v.mean(axis=-1)\n    >>> moving_average\n    array([1., 2., 3., 4.])\n\n    Note that a sliding window approach is often **not** optimal (see Notes).\n    \"\"\"\n    window_shape = (tuple(window_shape)\n                    if np.iterable(window_shape)\n                    else (window_shape,))\n    # first convert input to array, possibly keeping subclass\n    x = np.array(x, copy=None, subok=subok)\n\n    window_shape_array = np.array(window_shape)\n    if np.any(window_shape_array < 0):\n        raise ValueError('`window_shape` cannot contain negative values')\n\n    if axis is None:\n        axis = tuple(range(x.ndim))\n        if len(window_shape) != len(axis):\n            raise ValueError(f'Since axis is `None`, must provide '\n                             f'window_shape for all dimensions of `x`; '\n                             f'got {len(window_shape)} window_shape elements '\n                             f'and `x.ndim` is {x.ndim}.')\n    else:\n        axis = normalize_axis_tuple(axis, x.ndim, allow_duplicate=True)\n        if len(window_shape) != len(axis):\n            raise ValueError(f'Must provide matching length window_shape and '\n                             f'axis; got {len(window_shape)} window_shape '\n                             f'elements and {len(axis)} axes elements.')\n\n    out_strides = x.strides + tuple(x.strides[ax] for ax in axis)\n\n    # note: same axis can be windowed repeatedly\n    x_shape_trimmed = list(x.shape)\n    for ax, dim in zip(axis, window_shape):\n        if x_shape_trimmed[ax] < dim:\n            raise ValueError(\n                'window shape cannot be larger than input array shape')\n        x_shape_trimmed[ax] -= dim - 1\n    out_shape = tuple(x_shape_trimmed) + window_shape\n    return as_strided(x, strides=out_strides, shape=out_shape,\n                      subok=subok, writeable=writeable)\n\n\ndef _broadcast_to(array, shape, subok, readonly):\n    shape = tuple(shape) if np.iterable(shape) else (shape,)\n    array = np.array(array, copy=None, subok=subok)\n    if not shape and array.shape:\n        raise ValueError('cannot broadcast a non-scalar to a scalar array')\n    if any(size < 0 for size in shape):\n        raise ValueError('all elements of broadcast shape must be non-'\n                         'negative')\n    extras = []\n    it = np.nditer(\n        (array,), flags=['multi_index', 'refs_ok', 'zerosize_ok'] + extras,\n        op_flags=['readonly'], itershape=shape, order='C')\n    with it:\n        # never really has writebackifcopy semantics\n        broadcast = it.itviews[0]\n    result = _maybe_view_as_subclass(array, broadcast)\n    # In a future version this will go away\n    if not readonly and array.flags._writeable_no_warn:\n        result.flags.writeable = True\n        result.flags._warn_on_write = True\n    return result\n\n\ndef _broadcast_to_dispatcher(array, shape, subok=None):\n    return (array,)\n\n\n@array_function_dispatch(_broadcast_to_dispatcher, module='numpy')\ndef broadcast_to(array, shape, subok=False):\n    \"\"\"Broadcast an array to a new shape.\n\n    Parameters\n    ----------\n    array : array_like\n        The array to broadcast.\n    shape : tuple or int\n        The shape of the desired array. A single integer ``i`` is interpreted\n        as ``(i,)``.\n    subok : bool, optional\n        If True, then sub-classes will be passed-through, otherwise\n        the returned array will be forced to be a base-class array (default).\n\n    Returns\n    -------\n    broadcast : array\n        A readonly view on the original array with the given shape. It is\n        typically not contiguous. Furthermore, more than one element of a\n        broadcasted array may refer to a single memory location.\n\n    Raises\n    ------\n    ValueError\n        If the array is not compatible with the new shape according to NumPy's\n        broadcasting rules.\n\n    See Also\n    --------\n    broadcast\n    broadcast_arrays\n    broadcast_shapes\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.array([1, 2, 3])\n    >>> np.broadcast_to(x, (3, 3))\n    array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]])\n    \"\"\"\n    return _broadcast_to(array, shape, subok=subok, readonly=True)\n\n\ndef _broadcast_shape(*args):\n    \"\"\"Returns the shape of the arrays that would result from broadcasting the\n    supplied arrays against each other.\n    \"\"\"\n    # use the old-iterator because np.nditer does not handle size 0 arrays\n    # consistently\n    b = np.broadcast(*args[:32])\n    # unfortunately, it cannot handle 32 or more arguments directly\n    for pos in range(32, len(args), 31):\n        # ironically, np.broadcast does not properly handle np.broadcast\n        # objects (it treats them as scalars)\n        # use broadcasting to avoid allocating the full array\n        b = broadcast_to(0, b.shape)\n        b = np.broadcast(b, *args[pos:(pos + 31)])\n    return b.shape\n\n\n_size0_dtype = np.dtype([])\n\n\n@set_module('numpy')\ndef broadcast_shapes(*args):\n    \"\"\"\n    Broadcast the input shapes into a single shape.\n\n    :ref:`Learn more about broadcasting here <basics.broadcasting>`.\n\n    .. versionadded:: 1.20.0\n\n    Parameters\n    ----------\n    *args : tuples of ints, or ints\n        The shapes to be broadcast against each other.\n\n    Returns\n    -------\n    tuple\n        Broadcasted shape.\n\n    Raises\n    ------\n    ValueError\n        If the shapes are not compatible and cannot be broadcast according\n        to NumPy's broadcasting rules.\n\n    See Also\n    --------\n    broadcast\n    broadcast_arrays\n    broadcast_to\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.broadcast_shapes((1, 2), (3, 1), (3, 2))\n    (3, 2)\n\n    >>> np.broadcast_shapes((6, 7), (5, 6, 1), (7,), (5, 1, 7))\n    (5, 6, 7)\n    \"\"\"\n    arrays = [np.empty(x, dtype=_size0_dtype) for x in args]\n    return _broadcast_shape(*arrays)\n\n\ndef _broadcast_arrays_dispatcher(*args, subok=None):\n    return args\n\n\n@array_function_dispatch(_broadcast_arrays_dispatcher, module='numpy')\ndef broadcast_arrays(*args, subok=False):\n    \"\"\"\n    Broadcast any number of arrays against each other.\n\n    Parameters\n    ----------\n    *args : array_likes\n        The arrays to broadcast.\n\n    subok : bool, optional\n        If True, then sub-classes will be passed-through, otherwise\n        the returned arrays will be forced to be a base-class array (default).\n\n    Returns\n    -------\n    broadcasted : tuple of arrays\n        These arrays are views on the original arrays.  They are typically\n        not contiguous.  Furthermore, more than one element of a\n        broadcasted array may refer to a single memory location. If you need\n        to write to the arrays, make copies first. While you can set the\n        ``writable`` flag True, writing to a single output value may end up\n        changing more than one location in the output array.\n\n        .. deprecated:: 1.17\n            The output is currently marked so that if written to, a deprecation\n            warning will be emitted. A future version will set the\n            ``writable`` flag False so writing to it will raise an error.\n\n    See Also\n    --------\n    broadcast\n    broadcast_to\n    broadcast_shapes\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.array([[1,2,3]])\n    >>> y = np.array([[4],[5]])\n    >>> np.broadcast_arrays(x, y)\n    (array([[1, 2, 3],\n            [1, 2, 3]]),\n     array([[4, 4, 4],\n            [5, 5, 5]]))\n\n    Here is a useful idiom for getting contiguous copies instead of\n    non-contiguous views.\n\n    >>> [np.array(a) for a in np.broadcast_arrays(x, y)]\n    [array([[1, 2, 3],\n            [1, 2, 3]]),\n     array([[4, 4, 4],\n            [5, 5, 5]])]\n\n    \"\"\"\n    # nditer is not used here to avoid the limit of 32 arrays.\n    # Otherwise, something like the following one-liner would suffice:\n    # return np.nditer(args, flags=['multi_index', 'zerosize_ok'],\n    #                  order='C').itviews\n\n    args = [np.array(_m, copy=None, subok=subok) for _m in args]\n\n    shape = _broadcast_shape(*args)\n\n    result = [array if array.shape == shape\n              else _broadcast_to(array, shape, subok=subok, readonly=False)\n                              for array in args]\n    return tuple(result)\n", 549], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py": ["import builtins\nimport collections.abc\nimport functools\nimport re\nimport sys\nimport warnings\n\nimport numpy as np\nimport numpy._core.numeric as _nx\nfrom numpy._core import transpose, overrides\nfrom numpy._core.numeric import (\n    ones, zeros_like, arange, concatenate, array, asarray, asanyarray, empty,\n    ndarray, take, dot, where, intp, integer, isscalar, absolute\n    )\nfrom numpy._core.umath import (\n    pi, add, arctan2, frompyfunc, cos, less_equal, sqrt, sin,\n    mod, exp, not_equal, subtract, minimum\n    )\nfrom numpy._core.fromnumeric import (\n    ravel, nonzero, partition, mean, any, sum\n    )\nfrom numpy._core.numerictypes import typecodes\nfrom numpy.lib._twodim_base_impl import diag\nfrom numpy._core.multiarray import (\n    _place, bincount, normalize_axis_index, _monotonicity,\n    interp as compiled_interp, interp_complex as compiled_interp_complex\n    )\nfrom numpy._core._multiarray_umath import _array_converter\nfrom numpy._utils import set_module\n\n# needed in this module for compatibility\nfrom numpy.lib._histograms_impl import histogram, histogramdd  # noqa: F401\n\n\narray_function_dispatch = functools.partial(\n    overrides.array_function_dispatch, module='numpy')\n\n\n__all__ = [\n    'select', 'piecewise', 'trim_zeros', 'copy', 'iterable', 'percentile',\n    'diff', 'gradient', 'angle', 'unwrap', 'sort_complex', 'flip',\n    'rot90', 'extract', 'place', 'vectorize', 'asarray_chkfinite', 'average',\n    'bincount', 'digitize', 'cov', 'corrcoef',\n    'median', 'sinc', 'hamming', 'hanning', 'bartlett',\n    'blackman', 'kaiser', 'trapezoid', 'trapz', 'i0',\n    'meshgrid', 'delete', 'insert', 'append', 'interp',\n    'quantile'\n    ]\n\n# _QuantileMethods is a dictionary listing all the supported methods to\n# compute quantile/percentile.\n#\n# Below virtual_index refers to the index of the element where the percentile\n# would be found in the sorted sample.\n# When the sample contains exactly the percentile wanted, the virtual_index is\n# an integer to the index of this element.\n# When the percentile wanted is in between two elements, the virtual_index\n# is made of a integer part (a.k.a 'i' or 'left') and a fractional part\n# (a.k.a 'g' or 'gamma')\n#\n# Each method in _QuantileMethods has two properties\n# get_virtual_index : Callable\n#   The function used to compute the virtual_index.\n# fix_gamma : Callable\n#   A function used for discrete methods to force the index to a specific value.\n_QuantileMethods = dict(\n    # --- HYNDMAN and FAN METHODS\n    # Discrete methods\n    inverted_cdf=dict(\n        get_virtual_index=lambda n, quantiles: _inverted_cdf(n, quantiles),\n        fix_gamma=None,  # should never be called\n    ),\n    averaged_inverted_cdf=dict(\n        get_virtual_index=lambda n, quantiles: (n * quantiles) - 1,\n        fix_gamma=lambda gamma, _: _get_gamma_mask(\n            shape=gamma.shape,\n            default_value=1.,\n            conditioned_value=0.5,\n            where=gamma == 0),\n    ),\n    closest_observation=dict(\n        get_virtual_index=lambda n, quantiles: _closest_observation(n,\n                                                                    quantiles),\n        fix_gamma=None,  # should never be called\n    ),\n    # Continuous methods\n    interpolated_inverted_cdf=dict(\n        get_virtual_index=lambda n, quantiles:\n        _compute_virtual_index(n, quantiles, 0, 1),\n        fix_gamma=lambda gamma, _: gamma,\n    ),\n    hazen=dict(\n        get_virtual_index=lambda n, quantiles:\n        _compute_virtual_index(n, quantiles, 0.5, 0.5),\n        fix_gamma=lambda gamma, _: gamma,\n    ),\n    weibull=dict(\n        get_virtual_index=lambda n, quantiles:\n        _compute_virtual_index(n, quantiles, 0, 0),\n        fix_gamma=lambda gamma, _: gamma,\n    ),\n    # Default method.\n    # To avoid some rounding issues, `(n-1) * quantiles` is preferred to\n    # `_compute_virtual_index(n, quantiles, 1, 1)`.\n    # They are mathematically equivalent.\n    linear=dict(\n        get_virtual_index=lambda n, quantiles: (n - 1) * quantiles,\n        fix_gamma=lambda gamma, _: gamma,\n    ),\n    median_unbiased=dict(\n        get_virtual_index=lambda n, quantiles:\n        _compute_virtual_index(n, quantiles, 1 / 3.0, 1 / 3.0),\n        fix_gamma=lambda gamma, _: gamma,\n    ),\n    normal_unbiased=dict(\n        get_virtual_index=lambda n, quantiles:\n        _compute_virtual_index(n, quantiles, 3 / 8.0, 3 / 8.0),\n        fix_gamma=lambda gamma, _: gamma,\n    ),\n    # --- OTHER METHODS\n    lower=dict(\n        get_virtual_index=lambda n, quantiles: np.floor(\n            (n - 1) * quantiles).astype(np.intp),\n        fix_gamma=None,  # should never be called, index dtype is int\n    ),\n    higher=dict(\n        get_virtual_index=lambda n, quantiles: np.ceil(\n            (n - 1) * quantiles).astype(np.intp),\n        fix_gamma=None,  # should never be called, index dtype is int\n    ),\n    midpoint=dict(\n        get_virtual_index=lambda n, quantiles: 0.5 * (\n                np.floor((n - 1) * quantiles)\n                + np.ceil((n - 1) * quantiles)),\n        fix_gamma=lambda gamma, index: _get_gamma_mask(\n            shape=gamma.shape,\n            default_value=0.5,\n            conditioned_value=0.,\n            where=index % 1 == 0),\n    ),\n    nearest=dict(\n        get_virtual_index=lambda n, quantiles: np.around(\n            (n - 1) * quantiles).astype(np.intp),\n        fix_gamma=None,\n        # should never be called, index dtype is int\n    ))\n\n\ndef _rot90_dispatcher(m, k=None, axes=None):\n    return (m,)\n\n\n@array_function_dispatch(_rot90_dispatcher)\ndef rot90(m, k=1, axes=(0, 1)):\n    \"\"\"\n    Rotate an array by 90 degrees in the plane specified by axes.\n\n    Rotation direction is from the first towards the second axis.\n    This means for a 2D array with the default `k` and `axes`, the\n    rotation will be counterclockwise.\n\n    Parameters\n    ----------\n    m : array_like\n        Array of two or more dimensions.\n    k : integer\n        Number of times the array is rotated by 90 degrees.\n    axes : (2,) array_like\n        The array is rotated in the plane defined by the axes.\n        Axes must be different.\n\n    Returns\n    -------\n    y : ndarray\n        A rotated view of `m`.\n\n    See Also\n    --------\n    flip : Reverse the order of elements in an array along the given axis.\n    fliplr : Flip an array horizontally.\n    flipud : Flip an array vertically.\n\n    Notes\n    -----\n    ``rot90(m, k=1, axes=(1,0))``  is the reverse of\n    ``rot90(m, k=1, axes=(0,1))``\n\n    ``rot90(m, k=1, axes=(1,0))`` is equivalent to\n    ``rot90(m, k=-1, axes=(0,1))``\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> m = np.array([[1,2],[3,4]], int)\n    >>> m\n    array([[1, 2],\n           [3, 4]])\n    >>> np.rot90(m)\n    array([[2, 4],\n           [1, 3]])\n    >>> np.rot90(m, 2)\n    array([[4, 3],\n           [2, 1]])\n    >>> m = np.arange(8).reshape((2,2,2))\n    >>> np.rot90(m, 1, (1,2))\n    array([[[1, 3],\n            [0, 2]],\n           [[5, 7],\n            [4, 6]]])\n\n    \"\"\"\n    axes = tuple(axes)\n    if len(axes) != 2:\n        raise ValueError(\"len(axes) must be 2.\")\n\n    m = asanyarray(m)\n\n    if axes[0] == axes[1] or absolute(axes[0] - axes[1]) == m.ndim:\n        raise ValueError(\"Axes must be different.\")\n\n    if (axes[0] >= m.ndim or axes[0] < -m.ndim\n        or axes[1] >= m.ndim or axes[1] < -m.ndim):\n        raise ValueError(\"Axes={} out of range for array of ndim={}.\"\n            .format(axes, m.ndim))\n\n    k %= 4\n\n    if k == 0:\n        return m[:]\n    if k == 2:\n        return flip(flip(m, axes[0]), axes[1])\n\n    axes_list = arange(0, m.ndim)\n    (axes_list[axes[0]], axes_list[axes[1]]) = (axes_list[axes[1]],\n                                                axes_list[axes[0]])\n\n    if k == 1:\n        return transpose(flip(m, axes[1]), axes_list)\n    else:\n        # k == 3\n        return flip(transpose(m, axes_list), axes[1])\n\n\ndef _flip_dispatcher(m, axis=None):\n    return (m,)\n\n\n@array_function_dispatch(_flip_dispatcher)\ndef flip(m, axis=None):\n    \"\"\"\n    Reverse the order of elements in an array along the given axis.\n\n    The shape of the array is preserved, but the elements are reordered.\n\n    Parameters\n    ----------\n    m : array_like\n        Input array.\n    axis : None or int or tuple of ints, optional\n         Axis or axes along which to flip over. The default,\n         axis=None, will flip over all of the axes of the input array.\n         If axis is negative it counts from the last to the first axis.\n\n         If axis is a tuple of ints, flipping is performed on all of the axes\n         specified in the tuple.\n\n    Returns\n    -------\n    out : array_like\n        A view of `m` with the entries of axis reversed.  Since a view is\n        returned, this operation is done in constant time.\n\n    See Also\n    --------\n    flipud : Flip an array vertically (axis=0).\n    fliplr : Flip an array horizontally (axis=1).\n\n    Notes\n    -----\n    flip(m, 0) is equivalent to flipud(m).\n\n    flip(m, 1) is equivalent to fliplr(m).\n\n    flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.\n\n    flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all\n    positions.\n\n    flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at\n    position 0 and position 1.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> A = np.arange(8).reshape((2,2,2))\n    >>> A\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n    >>> np.flip(A, 0)\n    array([[[4, 5],\n            [6, 7]],\n           [[0, 1],\n            [2, 3]]])\n    >>> np.flip(A, 1)\n    array([[[2, 3],\n            [0, 1]],\n           [[6, 7],\n            [4, 5]]])\n    >>> np.flip(A)\n    array([[[7, 6],\n            [5, 4]],\n           [[3, 2],\n            [1, 0]]])\n    >>> np.flip(A, (0, 2))\n    array([[[5, 4],\n            [7, 6]],\n           [[1, 0],\n            [3, 2]]])\n    >>> rng = np.random.default_rng()\n    >>> A = rng.normal(size=(3,4,5))\n    >>> np.all(np.flip(A,2) == A[:,:,::-1,...])\n    True\n    \"\"\"\n    if not hasattr(m, 'ndim'):\n        m = asarray(m)\n    if axis is None:\n        indexer = (np.s_[::-1],) * m.ndim\n    else:\n        axis = _nx.normalize_axis_tuple(axis, m.ndim)\n        indexer = [np.s_[:]] * m.ndim\n        for ax in axis:\n            indexer[ax] = np.s_[::-1]\n        indexer = tuple(indexer)\n    return m[indexer]\n\n\n@set_module('numpy')\ndef iterable(y):\n    \"\"\"\n    Check whether or not an object can be iterated over.\n\n    Parameters\n    ----------\n    y : object\n      Input object.\n\n    Returns\n    -------\n    b : bool\n      Return ``True`` if the object has an iterator method or is a\n      sequence and ``False`` otherwise.\n\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.iterable([1, 2, 3])\n    True\n    >>> np.iterable(2)\n    False\n\n    Notes\n    -----\n    In most cases, the results of ``np.iterable(obj)`` are consistent with\n    ``isinstance(obj, collections.abc.Iterable)``. One notable exception is\n    the treatment of 0-dimensional arrays::\n\n        >>> from collections.abc import Iterable\n        >>> a = np.array(1.0)  # 0-dimensional numpy array\n        >>> isinstance(a, Iterable)\n        True\n        >>> np.iterable(a)\n        False\n\n    \"\"\"\n    try:\n        iter(y)\n    except TypeError:\n        return False\n    return True\n\n\ndef _weights_are_valid(weights, a, axis):\n    \"\"\"Validate weights array.\n\n    We assume, weights is not None.\n    \"\"\"\n    wgt = np.asanyarray(weights)\n\n    # Sanity checks\n    if a.shape != wgt.shape:\n        if axis is None:\n            raise TypeError(\n                \"Axis must be specified when shapes of a and weights \"\n                \"differ.\")\n        if wgt.shape != tuple(a.shape[ax] for ax in axis):\n            raise ValueError(\n                \"Shape of weights must be consistent with \"\n                \"shape of a along specified axis.\")\n\n        # setup wgt to broadcast along axis\n        wgt = wgt.transpose(np.argsort(axis))\n        wgt = wgt.reshape(tuple((s if ax in axis else 1)\n                                for ax, s in enumerate(a.shape)))\n    return wgt\n\n\ndef _average_dispatcher(a, axis=None, weights=None, returned=None, *,\n                        keepdims=None):\n    return (a, weights)\n\n\n@array_function_dispatch(_average_dispatcher)\ndef average(a, axis=None, weights=None, returned=False, *,\n            keepdims=np._NoValue):\n    \"\"\"\n    Compute the weighted average along the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing data to be averaged. If `a` is not an array, a\n        conversion is attempted.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which to average `a`.  The default,\n        `axis=None`, will average over all of the elements of the input array.\n        If axis is negative it counts from the last to the first axis.\n        If axis is a tuple of ints, averaging is performed on all of the axes\n        specified in the tuple instead of a single axis or all the axes as\n        before.\n    weights : array_like, optional\n        An array of weights associated with the values in `a`. Each value in\n        `a` contributes to the average according to its associated weight.\n        The array of weights must be the same shape as `a` if no axis is\n        specified, otherwise the weights must have dimensions and shape\n        consistent with `a` along the specified axis.\n        If `weights=None`, then all data in `a` are assumed to have a\n        weight equal to one.\n        The calculation is::\n\n            avg = sum(a * weights) / sum(weights)\n\n        where the sum is over all included elements.\n        The only constraint on the values of `weights` is that `sum(weights)`\n        must not be 0.\n    returned : bool, optional\n        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)\n        is returned, otherwise only the average is returned.\n        If `weights=None`, `sum_of_weights` is equivalent to the number of\n        elements over which the average is taken.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n        *Note:* `keepdims` will not work with instances of `numpy.matrix`\n        or other classes whose methods do not support `keepdims`.\n\n        .. versionadded:: 1.23.0\n\n    Returns\n    -------\n    retval, [sum_of_weights] : array_type or double\n        Return the average along the specified axis. When `returned` is `True`,\n        return a tuple with the average as the first element and the sum\n        of the weights as the second element. `sum_of_weights` is of the\n        same type as `retval`. The result dtype follows a general pattern.\n        If `weights` is None, the result dtype will be that of `a` , or ``float64``\n        if `a` is integral. Otherwise, if `weights` is not None and `a` is non-\n        integral, the result type will be the type of lowest precision capable of\n        representing values of both `a` and `weights`. If `a` happens to be\n        integral, the previous rules still applies but the result dtype will\n        at least be ``float64``.\n\n    Raises\n    ------\n    ZeroDivisionError\n        When all weights along axis are zero. See `numpy.ma.average` for a\n        version robust to this type of error.\n    TypeError\n        When `weights` does not have the same shape as `a`, and `axis=None`.\n    ValueError\n        When `weights` does not have dimensions and shape consistent with `a`\n        along specified `axis`.\n\n    See Also\n    --------\n    mean\n\n    ma.average : average for masked arrays -- useful if your data contains\n                 \"missing\" values\n    numpy.result_type : Returns the type that results from applying the\n                        numpy type promotion rules to the arguments.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> data = np.arange(1, 5)\n    >>> data\n    array([1, 2, 3, 4])\n    >>> np.average(data)\n    2.5\n    >>> np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))\n    4.0\n\n    >>> data = np.arange(6).reshape((3, 2))\n    >>> data\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> np.average(data, axis=1, weights=[1./4, 3./4])\n    array([0.75, 2.75, 4.75])\n    >>> np.average(data, weights=[1./4, 3./4])\n    Traceback (most recent call last):\n        ...\n    TypeError: Axis must be specified when shapes of a and weights differ.\n\n    With ``keepdims=True``, the following result has shape (3, 1).\n\n    >>> np.average(data, axis=1, keepdims=True)\n    array([[0.5],\n           [2.5],\n           [4.5]])\n\n    >>> data = np.arange(8).reshape((2, 2, 2))\n    >>> data\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n    >>> np.average(data, axis=(0, 1), weights=[[1./4, 3./4], [1., 1./2]])\n    array([3.4, 4.4])\n    >>> np.average(data, axis=0, weights=[[1./4, 3./4], [1., 1./2]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Shape of weights must be consistent\n    with shape of a along specified axis.\n    \"\"\"\n    a = np.asanyarray(a)\n\n    if axis is not None:\n        axis = _nx.normalize_axis_tuple(axis, a.ndim, argname=\"axis\")\n\n    if keepdims is np._NoValue:\n        # Don't pass on the keepdims argument if one wasn't given.\n        keepdims_kw = {}\n    else:\n        keepdims_kw = {'keepdims': keepdims}\n\n    if weights is None:\n        avg = a.mean(axis, **keepdims_kw)\n        avg_as_array = np.asanyarray(avg)\n        scl = avg_as_array.dtype.type(a.size/avg_as_array.size)\n    else:\n        wgt = _weights_are_valid(weights=weights, a=a, axis=axis)\n\n        if issubclass(a.dtype.type, (np.integer, np.bool)):\n            result_dtype = np.result_type(a.dtype, wgt.dtype, 'f8')\n        else:\n            result_dtype = np.result_type(a.dtype, wgt.dtype)\n\n        scl = wgt.sum(axis=axis, dtype=result_dtype, **keepdims_kw)\n        if np.any(scl == 0.0):\n            raise ZeroDivisionError(\n                \"Weights sum to zero, can't be normalized\")\n\n        avg = avg_as_array = np.multiply(a, wgt,\n                          dtype=result_dtype).sum(axis, **keepdims_kw) / scl\n\n    if returned:\n        if scl.shape != avg_as_array.shape:\n            scl = np.broadcast_to(scl, avg_as_array.shape).copy()\n        return avg, scl\n    else:\n        return avg\n\n\n@set_module('numpy')\ndef asarray_chkfinite(a, dtype=None, order=None):\n    \"\"\"Convert the input to an array, checking for NaNs or Infs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes lists, lists of tuples, tuples, tuples of tuples, tuples\n        of lists and ndarrays.  Success requires no NaNs or Infs.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F', 'A', 'K'}, optional\n        Memory layout.  'A' and 'K' depend on the order of input array a.\n        'C' row-major (C-style),\n        'F' column-major (Fortran-style) memory representation.\n        'A' (any) means 'F' if `a` is Fortran contiguous, 'C' otherwise\n        'K' (keep) preserve input order\n        Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray\n        Array interpretation of `a`.  No copy is performed if the input\n        is already an ndarray.  If `a` is a subclass of ndarray, a base\n        class ndarray is returned.\n\n    Raises\n    ------\n    ValueError\n        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).\n\n    See Also\n    --------\n    asarray : Create and array.\n    asanyarray : Similar function which passes through subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    Convert a list into an array. If all elements are finite, then\n    ``asarray_chkfinite`` is identical to ``asarray``.\n\n    >>> a = [1, 2]\n    >>> np.asarray_chkfinite(a, dtype=float)\n    array([1., 2.])\n\n    Raises ValueError if array_like contains Nans or Infs.\n\n    >>> a = [1, 2, np.inf]\n    >>> try:\n    ...     np.asarray_chkfinite(a)\n    ... except ValueError:\n    ...     print('ValueError')\n    ...\n    ValueError\n\n    \"\"\"\n    a = asarray(a, dtype=dtype, order=order)\n    if a.dtype.char in typecodes['AllFloat'] and not np.isfinite(a).all():\n        raise ValueError(\n            \"array must not contain infs or NaNs\")\n    return a\n\n\ndef _piecewise_dispatcher(x, condlist, funclist, *args, **kw):\n    yield x\n    # support the undocumented behavior of allowing scalars\n    if np.iterable(condlist):\n        yield from condlist\n\n\n@array_function_dispatch(_piecewise_dispatcher)\ndef piecewise(x, condlist, funclist, *args, **kw):\n    \"\"\"\n    Evaluate a piecewise-defined function.\n\n    Given a set of conditions and corresponding functions, evaluate each\n    function on the input data wherever its condition is true.\n\n    Parameters\n    ----------\n    x : ndarray or scalar\n        The input domain.\n    condlist : list of bool arrays or bool scalars\n        Each boolean array corresponds to a function in `funclist`.  Wherever\n        `condlist[i]` is True, `funclist[i](x)` is used as the output value.\n\n        Each boolean array in `condlist` selects a piece of `x`,\n        and should therefore be of the same shape as `x`.\n\n        The length of `condlist` must correspond to that of `funclist`.\n        If one extra function is given, i.e. if\n        ``len(funclist) == len(condlist) + 1``, then that extra function\n        is the default value, used wherever all conditions are false.\n    funclist : list of callables, f(x,*args,**kw), or scalars\n        Each function is evaluated over `x` wherever its corresponding\n        condition is True.  It should take a 1d array as input and give an 1d\n        array or a scalar value as output.  If, instead of a callable,\n        a scalar is provided then a constant function (``lambda x: scalar``) is\n        assumed.\n    args : tuple, optional\n        Any further arguments given to `piecewise` are passed to the functions\n        upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then\n        each function is called as ``f(x, 1, 'a')``.\n    kw : dict, optional\n        Keyword arguments used in calling `piecewise` are passed to the\n        functions upon execution, i.e., if called\n        ``piecewise(..., ..., alpha=1)``, then each function is called as\n        ``f(x, alpha=1)``.\n\n    Returns\n    -------\n    out : ndarray\n        The output is the same shape and type as x and is found by\n        calling the functions in `funclist` on the appropriate portions of `x`,\n        as defined by the boolean arrays in `condlist`.  Portions not covered\n        by any condition have a default value of 0.\n\n\n    See Also\n    --------\n    choose, select, where\n\n    Notes\n    -----\n    This is similar to choose or select, except that functions are\n    evaluated on elements of `x` that satisfy the corresponding condition from\n    `condlist`.\n\n    The result is::\n\n            |--\n            |funclist[0](x[condlist[0]])\n      out = |funclist[1](x[condlist[1]])\n            |...\n            |funclist[n2](x[condlist[n2]])\n            |--\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    Define the signum function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.\n\n    >>> x = np.linspace(-2.5, 2.5, 6)\n    >>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])\n    array([-1., -1., -1.,  1.,  1.,  1.])\n\n    Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for\n    ``x >= 0``.\n\n    >>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])\n    array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])\n\n    Apply the same function to a scalar value.\n\n    >>> y = -2\n    >>> np.piecewise(y, [y < 0, y >= 0], [lambda x: -x, lambda x: x])\n    array(2)\n\n    \"\"\"\n    x = asanyarray(x)\n    n2 = len(funclist)\n\n    # undocumented: single condition is promoted to a list of one condition\n    if isscalar(condlist) or (\n            not isinstance(condlist[0], (list, ndarray)) and x.ndim != 0):\n        condlist = [condlist]\n\n    condlist = asarray(condlist, dtype=bool)\n    n = len(condlist)\n\n    if n == n2 - 1:  # compute the \"otherwise\" condition.\n        condelse = ~np.any(condlist, axis=0, keepdims=True)\n        condlist = np.concatenate([condlist, condelse], axis=0)\n        n += 1\n    elif n != n2:\n        raise ValueError(\n            \"with {} condition(s), either {} or {} functions are expected\"\n            .format(n, n, n+1)\n        )\n\n    y = zeros_like(x)\n    for cond, func in zip(condlist, funclist):\n        if not isinstance(func, collections.abc.Callable):\n            y[cond] = func\n        else:\n            vals = x[cond]\n            if vals.size > 0:\n                y[cond] = func(vals, *args, **kw)\n\n    return y\n\n\ndef _select_dispatcher(condlist, choicelist, default=None):\n    yield from condlist\n    yield from choicelist\n\n\n@array_function_dispatch(_select_dispatcher)\ndef select(condlist, choicelist, default=0):\n    \"\"\"\n    Return an array drawn from elements in choicelist, depending on conditions.\n\n    Parameters\n    ----------\n    condlist : list of bool ndarrays\n        The list of conditions which determine from which array in `choicelist`\n        the output elements are taken. When multiple conditions are satisfied,\n        the first one encountered in `condlist` is used.\n    choicelist : list of ndarrays\n        The list of arrays from which the output elements are taken. It has\n        to be of the same length as `condlist`.\n    default : scalar, optional\n        The element inserted in `output` when all conditions evaluate to False.\n\n    Returns\n    -------\n    output : ndarray\n        The output at position m is the m-th element of the array in\n        `choicelist` where the m-th element of the corresponding array in\n        `condlist` is True.\n\n    See Also\n    --------\n    where : Return elements from one of two arrays depending on condition.\n    take, choose, compress, diag, diagonal\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    Beginning with an array of integers from 0 to 5 (inclusive),\n    elements less than ``3`` are negated, elements greater than ``3``\n    are squared, and elements not meeting either of these conditions\n    (exactly ``3``) are replaced with a `default` value of ``42``.\n\n    >>> x = np.arange(6)\n    >>> condlist = [x<3, x>3]\n    >>> choicelist = [x, x**2]\n    >>> np.select(condlist, choicelist, 42)\n    array([ 0,  1,  2, 42, 16, 25])\n\n    When multiple conditions are satisfied, the first one encountered in\n    `condlist` is used.\n\n    >>> condlist = [x<=4, x>3]\n    >>> choicelist = [x, x**2]\n    >>> np.select(condlist, choicelist, 55)\n    array([ 0,  1,  2,  3,  4, 25])\n\n    \"\"\"\n    # Check the size of condlist and choicelist are the same, or abort.\n    if len(condlist) != len(choicelist):\n        raise ValueError(\n            'list of cases must be same length as list of conditions')\n\n    # Now that the dtype is known, handle the deprecated select([], []) case\n    if len(condlist) == 0:\n        raise ValueError(\"select with an empty condition list is not possible\")\n\n    # TODO: This preserves the Python int, float, complex manually to get the\n    #       right `result_type` with NEP 50.  Most likely we will grow a better\n    #       way to spell this (and this can be replaced).\n    choicelist = [\n        choice if type(choice) in (int, float, complex) else np.asarray(choice)\n        for choice in choicelist]\n    choicelist.append(default if type(default) in (int, float, complex)\n                      else np.asarray(default))\n\n    try:\n        dtype = np.result_type(*choicelist)\n    except TypeError as e:\n        msg = f'Choicelist and default value do not have a common dtype: {e}'\n        raise TypeError(msg) from None\n\n    # Convert conditions to arrays and broadcast conditions and choices\n    # as the shape is needed for the result. Doing it separately optimizes\n    # for example when all choices are scalars.\n    condlist = np.broadcast_arrays(*condlist)\n    choicelist = np.broadcast_arrays(*choicelist)\n\n    # If cond array is not an ndarray in boolean format or scalar bool, abort.\n    for i, cond in enumerate(condlist):\n        if cond.dtype.type is not np.bool:\n            raise TypeError(\n                'invalid entry {} in condlist: should be boolean ndarray'.format(i))\n\n    if choicelist[0].ndim == 0:\n        # This may be common, so avoid the call.\n        result_shape = condlist[0].shape\n    else:\n        result_shape = np.broadcast_arrays(condlist[0], choicelist[0])[0].shape\n\n    result = np.full(result_shape, choicelist[-1], dtype)\n\n    # Use np.copyto to burn each choicelist array onto result, using the\n    # corresponding condlist as a boolean mask. This is done in reverse\n    # order since the first choice should take precedence.\n    choicelist = choicelist[-2::-1]\n    condlist = condlist[::-1]\n    for choice, cond in zip(choicelist, condlist):\n        np.copyto(result, choice, where=cond)\n\n    return result\n\n\ndef _copy_dispatcher(a, order=None, subok=None):\n    return (a,)\n\n\n@array_function_dispatch(_copy_dispatcher)\ndef copy(a, order='K', subok=False):\n    \"\"\"\n    Return an array copy of the given object.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    order : {'C', 'F', 'A', 'K'}, optional\n        Controls the memory layout of the copy. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible. (Note that this function and :meth:`ndarray.copy` are very\n        similar, but have different default values for their order=\n        arguments.)\n    subok : bool, optional\n        If True, then sub-classes will be passed-through, otherwise the\n        returned array will be forced to be a base-class array (defaults to False).\n\n    Returns\n    -------\n    arr : ndarray\n        Array interpretation of `a`.\n\n    See Also\n    --------\n    ndarray.copy : Preferred method for creating an array copy\n\n    Notes\n    -----\n    This is equivalent to:\n\n    >>> np.array(a, copy=True)  #doctest: +SKIP\n\n    The copy made of the data is shallow, i.e., for arrays with object dtype,\n    the new array will point to the same objects.\n    See Examples from `ndarray.copy`.\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    Create an array x, with a reference y and a copy z:\n\n    >>> x = np.array([1, 2, 3])\n    >>> y = x\n    >>> z = np.copy(x)\n\n    Note that, when we modify x, y changes, but not z:\n\n    >>> x[0] = 10\n    >>> x[0] == y[0]\n    True\n    >>> x[0] == z[0]\n    False\n\n    Note that, np.copy clears previously set WRITEABLE=False flag.\n\n    >>> a = np.array([1, 2, 3])\n    >>> a.flags[\"WRITEABLE\"] = False\n    >>> b = np.copy(a)\n    >>> b.flags[\"WRITEABLE\"]\n    True\n    >>> b[0] = 3\n    >>> b\n    array([3, 2, 3])\n    \"\"\"\n    return array(a, order=order, subok=subok, copy=True)\n\n# Basic operations\n\n\ndef _gradient_dispatcher(f, *varargs, axis=None, edge_order=None):\n    yield f\n    yield from varargs\n\n\n@array_function_dispatch(_gradient_dispatcher)\ndef gradient(f, *varargs, axis=None, edge_order=1):\n    \"\"\"\n    Return the gradient of an N-dimensional array.\n\n    The gradient is computed using second order accurate central differences\n    in the interior points and either first or second order accurate one-sides\n    (forward or backwards) differences at the boundaries.\n    The returned gradient hence has the same shape as the input array.\n\n    Parameters\n    ----------\n    f : array_like\n        An N-dimensional array containing samples of a scalar function.\n    varargs : list of scalar or array, optional\n        Spacing between f values. Default unitary spacing for all dimensions.\n        Spacing can be specified using:\n\n        1. single scalar to specify a sample distance for all dimensions.\n        2. N scalars to specify a constant sample distance for each dimension.\n           i.e. `dx`, `dy`, `dz`, ...\n        3. N arrays to specify the coordinates of the values along each\n           dimension of F. The length of the array must match the size of\n           the corresponding dimension\n        4. Any combination of N scalars/arrays with the meaning of 2. and 3.\n\n        If `axis` is given, the number of varargs must equal the number of axes.\n        Default: 1. (see Examples below).\n\n    edge_order : {1, 2}, optional\n        Gradient is calculated using N-th order accurate differences\n        at the boundaries. Default: 1.\n    axis : None or int or tuple of ints, optional\n        Gradient is calculated only along the given axis or axes\n        The default (axis = None) is to calculate the gradient for all the axes\n        of the input array. axis may be negative, in which case it counts from\n        the last to the first axis.\n\n    Returns\n    -------\n    gradient : ndarray or tuple of ndarray\n        A tuple of ndarrays (or a single ndarray if there is only one\n        dimension) corresponding to the derivatives of f with respect\n        to each dimension. Each derivative has the same shape as f.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> f = np.array([1, 2, 4, 7, 11, 16])\n    >>> np.gradient(f)\n    array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])\n    >>> np.gradient(f, 2)\n    array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])\n\n    Spacing can be also specified with an array that represents the coordinates\n    of the values F along the dimensions.\n    For instance a uniform spacing:\n\n    >>> x = np.arange(f.size)\n    >>> np.gradient(f, x)\n    array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n\n    Or a non uniform one:\n\n    >>> x = np.array([0., 1., 1.5, 3.5, 4., 6.])\n    >>> np.gradient(f, x)\n    array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])\n\n    For two dimensional arrays, the return will be two arrays ordered by\n    axis. In this example the first array stands for the gradient in\n    rows and the second one in columns direction:\n\n    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]]))\n    (array([[ 2.,  2., -1.],\n            [ 2.,  2., -1.]]),\n     array([[1. , 2.5, 4. ],\n            [1. , 1. , 1. ]]))\n\n    In this example the spacing is also specified:\n    uniform for axis=0 and non uniform for axis=1\n\n    >>> dx = 2.\n    >>> y = [1., 1.5, 3.5]\n    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]]), dx, y)\n    (array([[ 1. ,  1. , -0.5],\n            [ 1. ,  1. , -0.5]]),\n     array([[2. , 2. , 2. ],\n            [2. , 1.7, 0.5]]))\n\n    It is possible to specify how boundaries are treated using `edge_order`\n\n    >>> x = np.array([0, 1, 2, 3, 4])\n    >>> f = x**2\n    >>> np.gradient(f, edge_order=1)\n    array([1.,  2.,  4.,  6.,  7.])\n    >>> np.gradient(f, edge_order=2)\n    array([0., 2., 4., 6., 8.])\n\n    The `axis` keyword can be used to specify a subset of axes of which the\n    gradient is calculated\n\n    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]]), axis=0)\n    array([[ 2.,  2., -1.],\n           [ 2.,  2., -1.]])\n\n    The `varargs` argument defines the spacing between sample points in the\n    input array. It can take two forms:\n\n    1. An array, specifying coordinates, which may be unevenly spaced:\n\n    >>> x = np.array([0., 2., 3., 6., 8.])\n    >>> y = x ** 2\n    >>> np.gradient(y, x, edge_order=2)\n    array([ 0.,  4.,  6., 12., 16.])\n\n    2. A scalar, representing the fixed sample distance:\n\n    >>> dx = 2\n    >>> x = np.array([0., 2., 4., 6., 8.])\n    >>> y = x ** 2\n    >>> np.gradient(y, dx, edge_order=2)\n    array([ 0.,  4.,  8., 12., 16.])\n\n    It's possible to provide different data for spacing along each dimension.\n    The number of arguments must match the number of dimensions in the input\n    data.\n\n    >>> dx = 2\n    >>> dy = 3\n    >>> x = np.arange(0, 6, dx)\n    >>> y = np.arange(0, 9, dy)\n    >>> xs, ys = np.meshgrid(x, y)\n    >>> zs = xs + 2 * ys\n    >>> np.gradient(zs, dy, dx)  # Passing two scalars\n    (array([[2., 2., 2.],\n            [2., 2., 2.],\n            [2., 2., 2.]]),\n     array([[1., 1., 1.],\n            [1., 1., 1.],\n            [1., 1., 1.]]))\n\n    Mixing scalars and arrays is also allowed:\n\n    >>> np.gradient(zs, y, dx)  # Passing one array and one scalar\n    (array([[2., 2., 2.],\n            [2., 2., 2.],\n            [2., 2., 2.]]),\n     array([[1., 1., 1.],\n            [1., 1., 1.],\n            [1., 1., 1.]]))\n\n    Notes\n    -----\n    Assuming that :math:`f\\\\in C^{3}` (i.e., :math:`f` has at least 3 continuous\n    derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we\n    minimize the \"consistency error\" :math:`\\\\eta_{i}` between the true gradient\n    and its estimate from a linear combination of the neighboring grid-points:\n\n    .. math::\n\n        \\\\eta_{i} = f_{i}^{\\\\left(1\\\\right)} -\n                    \\\\left[ \\\\alpha f\\\\left(x_{i}\\\\right) +\n                            \\\\beta f\\\\left(x_{i} + h_{d}\\\\right) +\n                            \\\\gamma f\\\\left(x_{i}-h_{s}\\\\right)\n                    \\\\right]\n\n    By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`\n    with their Taylor series expansion, this translates into solving\n    the following the linear system:\n\n    .. math::\n\n        \\\\left\\\\{\n            \\\\begin{array}{r}\n                \\\\alpha+\\\\beta+\\\\gamma=0 \\\\\\\\\n                \\\\beta h_{d}-\\\\gamma h_{s}=1 \\\\\\\\\n                \\\\beta h_{d}^{2}+\\\\gamma h_{s}^{2}=0\n            \\\\end{array}\n        \\\\right.\n\n    The resulting approximation of :math:`f_{i}^{(1)}` is the following:\n\n    .. math::\n\n        \\\\hat f_{i}^{(1)} =\n            \\\\frac{\n                h_{s}^{2}f\\\\left(x_{i} + h_{d}\\\\right)\n                + \\\\left(h_{d}^{2} - h_{s}^{2}\\\\right)f\\\\left(x_{i}\\\\right)\n                - h_{d}^{2}f\\\\left(x_{i}-h_{s}\\\\right)}\n                { h_{s}h_{d}\\\\left(h_{d} + h_{s}\\\\right)}\n            + \\\\mathcal{O}\\\\left(\\\\frac{h_{d}h_{s}^{2}\n                                + h_{s}h_{d}^{2}}{h_{d}\n                                + h_{s}}\\\\right)\n\n    It is worth noting that if :math:`h_{s}=h_{d}`\n    (i.e., data are evenly spaced)\n    we find the standard second order approximation:\n\n    .. math::\n\n        \\\\hat f_{i}^{(1)}=\n            \\\\frac{f\\\\left(x_{i+1}\\\\right) - f\\\\left(x_{i-1}\\\\right)}{2h}\n            + \\\\mathcal{O}\\\\left(h^{2}\\\\right)\n\n    With a similar procedure the forward/backward approximations used for\n    boundaries can be derived.\n\n    References\n    ----------\n    .. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics\n            (Texts in Applied Mathematics). New York: Springer.\n    .. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations\n            in Geophysical Fluid Dynamics. New York: Springer.\n    .. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on\n            Arbitrarily Spaced Grids,\n            Mathematics of Computation 51, no. 184 : 699-706.\n            `PDF <https://www.ams.org/journals/mcom/1988-51-184/\n            S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_.\n    \"\"\"\n    f = np.asanyarray(f)\n    N = f.ndim  # number of dimensions\n\n    if axis is None:\n        axes = tuple(range(N))\n    else:\n        axes = _nx.normalize_axis_tuple(axis, N)\n\n    len_axes = len(axes)\n    n = len(varargs)\n    if n == 0:\n        # no spacing argument - use 1 in all axes\n        dx = [1.0] * len_axes\n    elif n == 1 and np.ndim(varargs[0]) == 0:\n        # single scalar for all axes\n        dx = varargs * len_axes\n    elif n == len_axes:\n        # scalar or 1d array for each axis\n        dx = list(varargs)\n        for i, distances in enumerate(dx):\n            distances = np.asanyarray(distances)\n            if distances.ndim == 0:\n                continue\n            elif distances.ndim != 1:\n                raise ValueError(\"distances must be either scalars or 1d\")\n            if len(distances) != f.shape[axes[i]]:\n                raise ValueError(\"when 1d, distances must match \"\n                                 \"the length of the corresponding dimension\")\n            if np.issubdtype(distances.dtype, np.integer):\n                # Convert numpy integer types to float64 to avoid modular\n                # arithmetic in np.diff(distances).\n                distances = distances.astype(np.float64)\n            diffx = np.diff(distances)\n            # if distances are constant reduce to the scalar case\n            # since it brings a consistent speedup\n            if (diffx == diffx[0]).all():\n                diffx = diffx[0]\n            dx[i] = diffx\n    else:\n        raise TypeError(\"invalid number of arguments\")\n\n    if edge_order > 2:\n        raise ValueError(\"'edge_order' greater than 2 not supported\")\n\n    # use central differences on interior and one-sided differences on the\n    # endpoints. This preserves second order-accuracy over the full domain.\n\n    outvals = []\n\n    # create slice objects --- initially all are [:, :, ..., :]\n    slice1 = [slice(None)]*N\n    slice2 = [slice(None)]*N\n    slice3 = [slice(None)]*N\n    slice4 = [slice(None)]*N\n\n    otype = f.dtype\n    if otype.type is np.datetime64:\n        # the timedelta dtype with the same unit information\n        otype = np.dtype(otype.name.replace('datetime', 'timedelta'))\n        # view as timedelta to allow addition\n        f = f.view(otype)\n    elif otype.type is np.timedelta64:\n        pass\n    elif np.issubdtype(otype, np.inexact):\n        pass\n    else:\n        # All other types convert to floating point.\n        # First check if f is a numpy integer type; if so, convert f to float64\n        # to avoid modular arithmetic when computing the changes in f.\n        if np.issubdtype(otype, np.integer):\n            f = f.astype(np.float64)\n        otype = np.float64\n\n    for axis, ax_dx in zip(axes, dx):\n        if f.shape[axis] < edge_order + 1:\n            raise ValueError(\n                \"Shape of array too small to calculate a numerical gradient, \"\n                \"at least (edge_order + 1) elements are required.\")\n        # result allocation\n        out = np.empty_like(f, dtype=otype)\n\n        # spacing for the current axis\n        uniform_spacing = np.ndim(ax_dx) == 0\n\n        # Numerical differentiation: 2nd order interior\n        slice1[axis] = slice(1, -1)\n        slice2[axis] = slice(None, -2)\n        slice3[axis] = slice(1, -1)\n        slice4[axis] = slice(2, None)\n\n        if uniform_spacing:\n            out[tuple(slice1)] = (f[tuple(slice4)] - f[tuple(slice2)]) / (2. * ax_dx)\n        else:\n            dx1 = ax_dx[0:-1]\n            dx2 = ax_dx[1:]\n            a = -(dx2)/(dx1 * (dx1 + dx2))\n            b = (dx2 - dx1) / (dx1 * dx2)\n            c = dx1 / (dx2 * (dx1 + dx2))\n            # fix the shape for broadcasting\n            shape = np.ones(N, dtype=int)\n            shape[axis] = -1\n            a.shape = b.shape = c.shape = shape\n            # 1D equivalent -- out[1:-1] = a * f[:-2] + b * f[1:-1] + c * f[2:]\n            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]\n\n        # Numerical differentiation: 1st order edges\n        if edge_order == 1:\n            slice1[axis] = 0\n            slice2[axis] = 1\n            slice3[axis] = 0\n            dx_0 = ax_dx if uniform_spacing else ax_dx[0]\n            # 1D equivalent -- out[0] = (f[1] - f[0]) / (x[1] - x[0])\n            out[tuple(slice1)] = (f[tuple(slice2)] - f[tuple(slice3)]) / dx_0\n\n            slice1[axis] = -1\n            slice2[axis] = -1\n            slice3[axis] = -2\n            dx_n = ax_dx if uniform_spacing else ax_dx[-1]\n            # 1D equivalent -- out[-1] = (f[-1] - f[-2]) / (x[-1] - x[-2])\n            out[tuple(slice1)] = (f[tuple(slice2)] - f[tuple(slice3)]) / dx_n\n\n        # Numerical differentiation: 2nd order edges\n        else:\n            slice1[axis] = 0\n            slice2[axis] = 0\n            slice3[axis] = 1\n            slice4[axis] = 2\n            if uniform_spacing:\n                a = -1.5 / ax_dx\n                b = 2. / ax_dx\n                c = -0.5 / ax_dx\n            else:\n                dx1 = ax_dx[0]\n                dx2 = ax_dx[1]\n                a = -(2. * dx1 + dx2)/(dx1 * (dx1 + dx2))\n                b = (dx1 + dx2) / (dx1 * dx2)\n                c = - dx1 / (dx2 * (dx1 + dx2))\n            # 1D equivalent -- out[0] = a * f[0] + b * f[1] + c * f[2]\n            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]\n\n            slice1[axis] = -1\n            slice2[axis] = -3\n            slice3[axis] = -2\n            slice4[axis] = -1\n            if uniform_spacing:\n                a = 0.5 / ax_dx\n                b = -2. / ax_dx\n                c = 1.5 / ax_dx\n            else:\n                dx1 = ax_dx[-2]\n                dx2 = ax_dx[-1]\n                a = (dx2) / (dx1 * (dx1 + dx2))\n                b = - (dx2 + dx1) / (dx1 * dx2)\n                c = (2. * dx2 + dx1) / (dx2 * (dx1 + dx2))\n            # 1D equivalent -- out[-1] = a * f[-3] + b * f[-2] + c * f[-1]\n            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]\n\n        outvals.append(out)\n\n        # reset the slice object in this dimension to \":\"\n        slice1[axis] = slice(None)\n        slice2[axis] = slice(None)\n        slice3[axis] = slice(None)\n        slice4[axis] = slice(None)\n\n    if len_axes == 1:\n        return outvals[0]\n    return tuple(outvals)\n\n\ndef _diff_dispatcher(a, n=None, axis=None, prepend=None, append=None):\n    return (a, prepend, append)\n\n\n@array_function_dispatch(_diff_dispatcher)\ndef diff(a, n=1, axis=-1, prepend=np._NoValue, append=np._NoValue):\n    \"\"\"\n    Calculate the n-th discrete difference along the given axis.\n\n    The first difference is given by ``out[i] = a[i+1] - a[i]`` along\n    the given axis, higher differences are calculated by using `diff`\n    recursively.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n    n : int, optional\n        The number of times values are differenced. If zero, the input\n        is returned as-is.\n    axis : int, optional\n        The axis along which the difference is taken, default is the\n        last axis.\n    prepend, append : array_like, optional\n        Values to prepend or append to `a` along axis prior to\n        performing the difference.  Scalar values are expanded to\n        arrays with length 1 in the direction of axis and the shape\n        of the input array in along all other axes.  Otherwise the\n        dimension and shape must match `a` except along axis.\n\n    Returns\n    -------\n    diff : ndarray\n        The n-th differences. The shape of the output is the same as `a`\n        except along `axis` where the dimension is smaller by `n`. The\n        type of the output is the same as the type of the difference\n        between any two elements of `a`. This is the same as the type of\n        `a` in most cases. A notable exception is `datetime64`, which\n        results in a `timedelta64` output array.\n\n    See Also\n    --------\n    gradient, ediff1d, cumsum\n\n    Notes\n    -----\n    Type is preserved for boolean arrays, so the result will contain\n    `False` when consecutive elements are the same and `True` when they\n    differ.\n\n    For unsigned integer arrays, the results will also be unsigned. This\n    should not be surprising, as the result is consistent with\n    calculating the difference directly:\n\n    >>> u8_arr = np.array([1, 0], dtype=np.uint8)\n    >>> np.diff(u8_arr)\n    array([255], dtype=uint8)\n    >>> u8_arr[1,...] - u8_arr[0,...]\n    np.uint8(255)\n\n    If this is not desirable, then the array should be cast to a larger\n    integer type first:\n\n    >>> i16_arr = u8_arr.astype(np.int16)\n    >>> np.diff(i16_arr)\n    array([-1], dtype=int16)\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.array([1, 2, 4, 7, 0])\n    >>> np.diff(x)\n    array([ 1,  2,  3, -7])\n    >>> np.diff(x, n=2)\n    array([  1,   1, -10])\n\n    >>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])\n    >>> np.diff(x)\n    array([[2, 3, 4],\n           [5, 1, 2]])\n    >>> np.diff(x, axis=0)\n    array([[-1,  2,  0, -2]])\n\n    >>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)\n    >>> np.diff(x)\n    array([1, 1], dtype='timedelta64[D]')\n\n    \"\"\"\n    if n == 0:\n        return a\n    if n < 0:\n        raise ValueError(\n            \"order must be non-negative but got \" + repr(n))\n\n    a = asanyarray(a)\n    nd = a.ndim\n    if nd == 0:\n        raise ValueError(\"diff requires input that is at least one dimensional\")\n    axis = normalize_axis_index(axis, nd)\n\n    combined = []\n    if prepend is not np._NoValue:\n        prepend = np.asanyarray(prepend)\n        if prepend.ndim == 0:\n            shape = list(a.shape)\n            shape[axis] = 1\n            prepend = np.broadcast_to(prepend, tuple(shape))\n        combined.append(prepend)\n\n    combined.append(a)\n\n    if append is not np._NoValue:\n        append = np.asanyarray(append)\n        if append.ndim == 0:\n            shape = list(a.shape)\n            shape[axis] = 1\n            append = np.broadcast_to(append, tuple(shape))\n        combined.append(append)\n\n    if len(combined) > 1:\n        a = np.concatenate(combined, axis)\n\n    slice1 = [slice(None)] * nd\n    slice2 = [slice(None)] * nd\n    slice1[axis] = slice(1, None)\n    slice2[axis] = slice(None, -1)\n    slice1 = tuple(slice1)\n    slice2 = tuple(slice2)\n\n    op = not_equal if a.dtype == np.bool else subtract\n    for _ in range(n):\n        a = op(a[slice1], a[slice2])\n\n    return a\n\n\ndef _interp_dispatcher(x, xp, fp, left=None, right=None, period=None):\n    return (x, xp, fp)\n\n\n@array_function_dispatch(_interp_dispatcher)\ndef interp(x, xp, fp, left=None, right=None, period=None):\n    \"\"\"\n    One-dimensional linear interpolation for monotonically increasing sample points.\n\n    Returns the one-dimensional piecewise linear interpolant to a function\n    with given discrete data points (`xp`, `fp`), evaluated at `x`.\n\n    Parameters\n    ----------\n    x : array_like\n        The x-coordinates at which to evaluate the interpolated values.\n\n    xp : 1-D sequence of floats\n        The x-coordinates of the data points, must be increasing if argument\n        `period` is not specified. Otherwise, `xp` is internally sorted after\n        normalizing the periodic boundaries with ``xp = xp % period``.\n\n    fp : 1-D sequence of float or complex\n        The y-coordinates of the data points, same length as `xp`.\n\n    left : optional float or complex corresponding to fp\n        Value to return for `x < xp[0]`, default is `fp[0]`.\n\n    right : optional float or complex corresponding to fp\n        Value to return for `x > xp[-1]`, default is `fp[-1]`.\n\n    period : None or float, optional\n        A period for the x-coordinates. This parameter allows the proper\n        interpolation of angular x-coordinates. Parameters `left` and `right`\n        are ignored if `period` is specified.\n\n    Returns\n    -------\n    y : float or complex (corresponding to fp) or ndarray\n        The interpolated values, same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If `xp` and `fp` have different length\n        If `xp` or `fp` are not 1-D sequences\n        If `period == 0`\n\n    See Also\n    --------\n    scipy.interpolate\n\n    Warnings\n    --------\n    The x-coordinate sequence is expected to be increasing, but this is not\n    explicitly enforced.  However, if the sequence `xp` is non-increasing,\n    interpolation results are meaningless.\n\n    Note that, since NaN is unsortable, `xp` also cannot contain NaNs.\n\n    A simple check for `xp` being strictly increasing is::\n\n        np.all(np.diff(xp) > 0)\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> xp = [1, 2, 3]\n    >>> fp = [3, 2, 0]\n    >>> np.interp(2.5, xp, fp)\n    1.0\n    >>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)\n    array([3.  , 3.  , 2.5 , 0.56, 0.  ])\n    >>> UNDEF = -99.0\n    >>> np.interp(3.14, xp, fp, right=UNDEF)\n    -99.0\n\n    Plot an interpolant to the sine function:\n\n    >>> x = np.linspace(0, 2*np.pi, 10)\n    >>> y = np.sin(x)\n    >>> xvals = np.linspace(0, 2*np.pi, 50)\n    >>> yinterp = np.interp(xvals, x, y)\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(x, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(xvals, yinterp, '-x')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.show()\n\n    Interpolation with periodic x-coordinates:\n\n    >>> x = [-180, -170, -185, 185, -10, -5, 0, 365]\n    >>> xp = [190, -190, 350, -350]\n    >>> fp = [5, 10, 3, 4]\n    >>> np.interp(x, xp, fp, period=360)\n    array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])\n\n    Complex interpolation:\n\n    >>> x = [1.5, 4.0]\n    >>> xp = [2,3,5]\n    >>> fp = [1.0j, 0, 2+3j]\n    >>> np.interp(x, xp, fp)\n    array([0.+1.j , 1.+1.5j])\n\n    \"\"\"\n\n    fp = np.asarray(fp)\n\n    if np.iscomplexobj(fp):\n        interp_func = compiled_interp_complex\n        input_dtype = np.complex128\n    else:\n        interp_func = compiled_interp\n        input_dtype = np.float64\n\n    if period is not None:\n        if period == 0:\n            raise ValueError(\"period must be a non-zero value\")\n        period = abs(period)\n        left = None\n        right = None\n\n        x = np.asarray(x, dtype=np.float64)\n        xp = np.asarray(xp, dtype=np.float64)\n        fp = np.asarray(fp, dtype=input_dtype)\n\n        if xp.ndim != 1 or fp.ndim != 1:\n            raise ValueError(\"Data points must be 1-D sequences\")\n        if xp.shape[0] != fp.shape[0]:\n            raise ValueError(\"fp and xp are not of the same length\")\n        # normalizing periodic boundaries\n        x = x % period\n        xp = xp % period\n        asort_xp = np.argsort(xp)\n        xp = xp[asort_xp]\n        fp = fp[asort_xp]\n        xp = np.concatenate((xp[-1:]-period, xp, xp[0:1]+period))\n        fp = np.concatenate((fp[-1:], fp, fp[0:1]))\n\n    return interp_func(x, xp, fp, left, right)\n\n\ndef _angle_dispatcher(z, deg=None):\n    return (z,)\n\n\n@array_function_dispatch(_angle_dispatcher)\ndef angle(z, deg=False):\n    \"\"\"\n    Return the angle of the complex argument.\n\n    Parameters\n    ----------\n    z : array_like\n        A complex number or sequence of complex numbers.\n    deg : bool, optional\n        Return angle in degrees if True, radians if False (default).\n\n    Returns\n    -------\n    angle : ndarray or scalar\n        The counterclockwise angle from the positive real axis on the complex\n        plane in the range ``(-pi, pi]``, with dtype as numpy.float64.\n\n    See Also\n    --------\n    arctan2\n    absolute\n\n    Notes\n    -----\n    This function passes the imaginary and real parts of the argument to\n    `arctan2` to compute the result; consequently, it follows the convention\n    of `arctan2` when the magnitude of the argument is zero. See example.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.angle([1.0, 1.0j, 1+1j])               # in radians\n    array([ 0.        ,  1.57079633,  0.78539816]) # may vary\n    >>> np.angle(1+1j, deg=True)                  # in degrees\n    45.0\n    >>> np.angle([0., -0., complex(0., -0.), complex(-0., -0.)])  # convention\n    array([ 0.        ,  3.14159265, -0.        , -3.14159265])\n\n    \"\"\"\n    z = asanyarray(z)\n    if issubclass(z.dtype.type, _nx.complexfloating):\n        zimag = z.imag\n        zreal = z.real\n    else:\n        zimag = 0\n        zreal = z\n\n    a = arctan2(zimag, zreal)\n    if deg:\n        a *= 180/pi\n    return a\n\n\ndef _unwrap_dispatcher(p, discont=None, axis=None, *, period=None):\n    return (p,)\n\n\n@array_function_dispatch(_unwrap_dispatcher)\ndef unwrap(p, discont=None, axis=-1, *, period=2*pi):\n    r\"\"\"\n    Unwrap by taking the complement of large deltas with respect to the period.\n\n    This unwraps a signal `p` by changing elements which have an absolute\n    difference from their predecessor of more than ``max(discont, period/2)``\n    to their `period`-complementary values.\n\n    For the default case where `period` is :math:`2\\pi` and `discont` is\n    :math:`\\pi`, this unwraps a radian phase `p` such that adjacent differences\n    are never greater than :math:`\\pi` by adding :math:`2k\\pi` for some\n    integer :math:`k`.\n\n    Parameters\n    ----------\n    p : array_like\n        Input array.\n    discont : float, optional\n        Maximum discontinuity between values, default is ``period/2``.\n        Values below ``period/2`` are treated as if they were ``period/2``.\n        To have an effect different from the default, `discont` should be\n        larger than ``period/2``.\n    axis : int, optional\n        Axis along which unwrap will operate, default is the last axis.\n    period : float, optional\n        Size of the range over which the input wraps. By default, it is\n        ``2 pi``.\n\n        .. versionadded:: 1.21.0\n\n    Returns\n    -------\n    out : ndarray\n        Output array.\n\n    See Also\n    --------\n    rad2deg, deg2rad\n\n    Notes\n    -----\n    If the discontinuity in `p` is smaller than ``period/2``,\n    but larger than `discont`, no unwrapping is done because taking\n    the complement would only make the discontinuity larger.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> phase = np.linspace(0, np.pi, num=5)\n    >>> phase[3:] += np.pi\n    >>> phase\n    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary\n    >>> np.unwrap(phase)\n    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary\n    >>> np.unwrap([0, 1, 2, -1, 0], period=4)\n    array([0, 1, 2, 3, 4])\n    >>> np.unwrap([ 1, 2, 3, 4, 5, 6, 1, 2, 3], period=6)\n    array([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    >>> np.unwrap([2, 3, 4, 5, 2, 3, 4, 5], period=4)\n    array([2, 3, 4, 5, 6, 7, 8, 9])\n    >>> phase_deg = np.mod(np.linspace(0 ,720, 19), 360) - 180\n    >>> np.unwrap(phase_deg, period=360)\n    array([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,\n            180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,\n            540.])\n    \"\"\"\n    p = asarray(p)\n    nd = p.ndim\n    dd = diff(p, axis=axis)\n    if discont is None:\n        discont = period/2\n    slice1 = [slice(None, None)]*nd     # full slices\n    slice1[axis] = slice(1, None)\n    slice1 = tuple(slice1)\n    dtype = np.result_type(dd, period)\n    if _nx.issubdtype(dtype, _nx.integer):\n        interval_high, rem = divmod(period, 2)\n        boundary_ambiguous = rem == 0\n    else:\n        interval_high = period / 2\n        boundary_ambiguous = True\n    interval_low = -interval_high\n    ddmod = mod(dd - interval_low, period) + interval_low\n    if boundary_ambiguous:\n        # for `mask = (abs(dd) == period/2)`, the above line made\n        # `ddmod[mask] == -period/2`. correct these such that\n        # `ddmod[mask] == sign(dd[mask])*period/2`.\n        _nx.copyto(ddmod, interval_high,\n                   where=(ddmod == interval_low) & (dd > 0))\n    ph_correct = ddmod - dd\n    _nx.copyto(ph_correct, 0, where=abs(dd) < discont)\n    up = array(p, copy=True, dtype=dtype)\n    up[slice1] = p[slice1] + ph_correct.cumsum(axis)\n    return up\n\n\ndef _sort_complex(a):\n    return (a,)\n\n\n@array_function_dispatch(_sort_complex)\ndef sort_complex(a):\n    \"\"\"\n    Sort a complex array using the real part first, then the imaginary part.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n\n    Returns\n    -------\n    out : complex ndarray\n        Always returns a sorted complex array.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.sort_complex([5, 3, 6, 2, 1])\n    array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])\n\n    >>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])\n    array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])\n\n    \"\"\"\n    b = array(a, copy=True)\n    b.sort()\n    if not issubclass(b.dtype.type, _nx.complexfloating):\n        if b.dtype.char in 'bhBH':\n            return b.astype('F')\n        elif b.dtype.char == 'g':\n            return b.astype('G')\n        else:\n            return b.astype('D')\n    else:\n        return b\n\n\ndef _arg_trim_zeros(filt):\n    \"\"\"Return indices of the first and last non-zero element.\n\n    Parameters\n    ----------\n    filt : array_like\n        Input array.\n\n    Returns\n    -------\n    start, stop : ndarray\n        Two arrays containing the indices of the first and last non-zero\n        element in each dimension.\n\n    See also\n    --------\n    trim_zeros\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> _arg_trim_zeros(np.array([0, 0, 1, 1, 0]))\n    (array([2]), array([3]))\n    \"\"\"\n    nonzero = (\n        np.argwhere(filt)\n        if filt.dtype != np.object_\n        # Historically, `trim_zeros` treats `None` in an object array\n        # as non-zero while argwhere doesn't, account for that\n        else np.argwhere(filt != 0)\n    )\n    if nonzero.size == 0:\n        start = stop = np.array([], dtype=np.intp)\n    else:\n        start = nonzero.min(axis=0)\n        stop = nonzero.max(axis=0)\n    return start, stop\n\n\ndef _trim_zeros(filt, trim=None, axis=None):\n    return (filt,)\n\n\n@array_function_dispatch(_trim_zeros)\ndef trim_zeros(filt, trim='fb', axis=None):\n    \"\"\"Remove values along a dimension which are zero along all other.\n\n    Parameters\n    ----------\n    filt : array_like\n        Input array.\n    trim : {\"fb\", \"f\", \"b\"}, optional\n        A string with 'f' representing trim from front and 'b' to trim from\n        back. By default, zeros are trimmed on both sides.\n        Front and back refer to the edges of a dimension, with \"front\" refering\n        to the side with the lowest index 0, and \"back\" refering to the highest\n        index (or index -1).\n    axis : int or sequence, optional\n        If None, `filt` is cropped such, that the smallest bounding box is\n        returned that still contains all values which are not zero.\n        If an axis is specified, `filt` will be sliced in that dimension only\n        on the sides specified by `trim`. The remaining area will be the\n        smallest that still contains all values wich are not zero.\n\n    Returns\n    -------\n    trimmed : ndarray or sequence\n        The result of trimming the input. The number of dimensions and the\n        input data type are preserved.\n\n    Notes\n    -----\n    For all-zero arrays, the first axis is trimmed first.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n    >>> np.trim_zeros(a)\n    array([1, 2, 3, 0, 2, 1])\n\n    >>> np.trim_zeros(a, trim='b')\n    array([0, 0, 0, ..., 0, 2, 1])\n\n    Multiple dimensions are supported.\n\n    >>> b = np.array([[0, 0, 2, 3, 0, 0],\n    ...               [0, 1, 0, 3, 0, 0],\n    ...               [0, 0, 0, 0, 0, 0]])\n    >>> np.trim_zeros(b)\n    array([[0, 2, 3],\n           [1, 0, 3]])\n\n    >>> np.trim_zeros(b, axis=-1)\n    array([[0, 2, 3],\n           [1, 0, 3],\n           [0, 0, 0]])\n\n    The input data type is preserved, list/tuple in means list/tuple out.\n\n    >>> np.trim_zeros([0, 1, 2, 0])\n    [1, 2]\n\n    \"\"\"\n    filt_ = np.asarray(filt)\n\n    trim = trim.lower()\n    if trim not in {\"fb\", \"bf\", \"f\", \"b\"}:\n        raise ValueError(f\"unexpected character(s) in `trim`: {trim!r}\")\n\n    start, stop = _arg_trim_zeros(filt_)\n    stop += 1  # Adjust for slicing\n\n    if start.size == 0:\n        # filt is all-zero -> assign same values to start and stop so that\n        # resulting slice will be empty\n        start = stop = np.zeros(filt_.ndim, dtype=np.intp)\n    else:\n        if 'f' not in trim:\n            start = (None,) * filt_.ndim\n        if 'b' not in trim:\n            stop = (None,) * filt_.ndim\n\n    if len(start) == 1:\n        # filt is 1D -> don't use multi-dimensional slicing to preserve\n        # non-array input types\n        sl = slice(start[0], stop[0])\n    elif axis is None:\n        # trim all axes\n        sl = tuple(slice(*x) for x in zip(start, stop))\n    else:\n        # only trim single axis\n        axis = normalize_axis_index(axis, filt_.ndim)\n        sl = (slice(None),) * axis + (slice(start[axis], stop[axis]),) + (...,)\n\n    trimmed = filt[sl]\n    return trimmed\n\n\n\ndef _extract_dispatcher(condition, arr):\n    return (condition, arr)\n\n\n@array_function_dispatch(_extract_dispatcher)\ndef extract(condition, arr):\n    \"\"\"\n    Return the elements of an array that satisfy some condition.\n\n    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If\n    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.\n\n    Note that `place` does the exact opposite of `extract`.\n\n    Parameters\n    ----------\n    condition : array_like\n        An array whose nonzero or True entries indicate the elements of `arr`\n        to extract.\n    arr : array_like\n        Input array of the same size as `condition`.\n\n    Returns\n    -------\n    extract : ndarray\n        Rank 1 array of values from `arr` where `condition` is True.\n\n    See Also\n    --------\n    take, put, copyto, compress, place\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> arr = np.arange(12).reshape((3, 4))\n    >>> arr\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11]])\n    >>> condition = np.mod(arr, 3)==0\n    >>> condition\n    array([[ True, False, False,  True],\n           [False, False,  True, False],\n           [False,  True, False, False]])\n    >>> np.extract(condition, arr)\n    array([0, 3, 6, 9])\n\n\n    If `condition` is boolean:\n\n    >>> arr[condition]\n    array([0, 3, 6, 9])\n\n    \"\"\"\n    return _nx.take(ravel(arr), nonzero(ravel(condition))[0])\n\n\ndef _place_dispatcher(arr, mask, vals):\n    return (arr, mask, vals)\n\n\n@array_function_dispatch(_place_dispatcher)\ndef place(arr, mask, vals):\n    \"\"\"\n    Change elements of an array based on conditional and input values.\n\n    Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that\n    `place` uses the first N elements of `vals`, where N is the number of\n    True values in `mask`, while `copyto` uses the elements where `mask`\n    is True.\n\n    Note that `extract` does the exact opposite of `place`.\n\n    Parameters\n    ----------\n    arr : ndarray\n        Array to put data into.\n    mask : array_like\n        Boolean mask array. Must have the same size as `a`.\n    vals : 1-D sequence\n        Values to put into `a`. Only the first N elements are used, where\n        N is the number of True values in `mask`. If `vals` is smaller\n        than N, it will be repeated, and if elements of `a` are to be masked,\n        this sequence must be non-empty.\n\n    See Also\n    --------\n    copyto, put, take, extract\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> arr = np.arange(6).reshape(2, 3)\n    >>> np.place(arr, arr>2, [44, 55])\n    >>> arr\n    array([[ 0,  1,  2],\n           [44, 55, 44]])\n\n    \"\"\"\n    return _place(arr, mask, vals)\n\n\ndef disp(mesg, device=None, linefeed=True):\n    \"\"\"\n    Display a message on a device.\n\n    .. deprecated:: 2.0\n        Use your own printing function instead.\n\n    Parameters\n    ----------\n    mesg : str\n        Message to display.\n    device : object\n        Device to write message. If None, defaults to ``sys.stdout`` which is\n        very similar to ``print``. `device` needs to have ``write()`` and\n        ``flush()`` methods.\n    linefeed : bool, optional\n        Option whether to print a line feed or not. Defaults to True.\n\n    Raises\n    ------\n    AttributeError\n        If `device` does not have a ``write()`` or ``flush()`` method.\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    Besides ``sys.stdout``, a file-like object can also be used as it has\n    both required methods:\n\n    >>> from io import StringIO\n    >>> buf = StringIO()\n    >>> np.disp('\"Display\" in a file', device=buf)\n    >>> buf.getvalue()\n    '\"Display\" in a file\\\\n'\n\n    \"\"\"\n\n    # Deprecated in NumPy 2.0, 2023-07-11\n    warnings.warn(\n        \"`disp` is deprecated, \"\n        \"use your own printing function instead. \"\n        \"(deprecated in NumPy 2.0)\",\n        DeprecationWarning,\n        stacklevel=2\n    )\n\n    if device is None:\n        device = sys.stdout\n    if linefeed:\n        device.write('%s\\n' % mesg)\n    else:\n        device.write('%s' % mesg)\n    device.flush()\n    return\n\n\n# See https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html\n_DIMENSION_NAME = r'\\w+'\n_CORE_DIMENSION_LIST = '(?:{0:}(?:,{0:})*)?'.format(_DIMENSION_NAME)\n_ARGUMENT = r'\\({}\\)'.format(_CORE_DIMENSION_LIST)\n_ARGUMENT_LIST = '{0:}(?:,{0:})*'.format(_ARGUMENT)\n_SIGNATURE = '^{0:}->{0:}$'.format(_ARGUMENT_LIST)\n\n\ndef _parse_gufunc_signature(signature):\n    \"\"\"\n    Parse string signatures for a generalized universal function.\n\n    Arguments\n    ---------\n    signature : string\n        Generalized universal function signature, e.g., ``(m,n),(n,p)->(m,p)``\n        for ``np.matmul``.\n\n    Returns\n    -------\n    Tuple of input and output core dimensions parsed from the signature, each\n    of the form List[Tuple[str, ...]].\n    \"\"\"\n    signature = re.sub(r'\\s+', '', signature)\n\n    if not re.match(_SIGNATURE, signature):\n        raise ValueError(\n            'not a valid gufunc signature: {}'.format(signature))\n    return tuple([tuple(re.findall(_DIMENSION_NAME, arg))\n                  for arg in re.findall(_ARGUMENT, arg_list)]\n                 for arg_list in signature.split('->'))\n\n\ndef _update_dim_sizes(dim_sizes, arg, core_dims):\n    \"\"\"\n    Incrementally check and update core dimension sizes for a single argument.\n\n    Arguments\n    ---------\n    dim_sizes : Dict[str, int]\n        Sizes of existing core dimensions. Will be updated in-place.\n    arg : ndarray\n        Argument to examine.\n    core_dims : Tuple[str, ...]\n        Core dimensions for this argument.\n    \"\"\"\n    if not core_dims:\n        return\n\n    num_core_dims = len(core_dims)\n    if arg.ndim < num_core_dims:\n        raise ValueError(\n            '%d-dimensional argument does not have enough '\n            'dimensions for all core dimensions %r'\n            % (arg.ndim, core_dims))\n\n    core_shape = arg.shape[-num_core_dims:]\n    for dim, size in zip(core_dims, core_shape):\n        if dim in dim_sizes:\n            if size != dim_sizes[dim]:\n                raise ValueError(\n                    'inconsistent size for core dimension %r: %r vs %r'\n                    % (dim, size, dim_sizes[dim]))\n        else:\n            dim_sizes[dim] = size\n\n\ndef _parse_input_dimensions(args, input_core_dims):\n    \"\"\"\n    Parse broadcast and core dimensions for vectorize with a signature.\n\n    Arguments\n    ---------\n    args : Tuple[ndarray, ...]\n        Tuple of input arguments to examine.\n    input_core_dims : List[Tuple[str, ...]]\n        List of core dimensions corresponding to each input.\n\n    Returns\n    -------\n    broadcast_shape : Tuple[int, ...]\n        Common shape to broadcast all non-core dimensions to.\n    dim_sizes : Dict[str, int]\n        Common sizes for named core dimensions.\n    \"\"\"\n    broadcast_args = []\n    dim_sizes = {}\n    for arg, core_dims in zip(args, input_core_dims):\n        _update_dim_sizes(dim_sizes, arg, core_dims)\n        ndim = arg.ndim - len(core_dims)\n        dummy_array = np.lib.stride_tricks.as_strided(0, arg.shape[:ndim])\n        broadcast_args.append(dummy_array)\n    broadcast_shape = np.lib._stride_tricks_impl._broadcast_shape(\n        *broadcast_args\n    )\n    return broadcast_shape, dim_sizes\n\n\ndef _calculate_shapes(broadcast_shape, dim_sizes, list_of_core_dims):\n    \"\"\"Helper for calculating broadcast shapes with core dimensions.\"\"\"\n    return [broadcast_shape + tuple(dim_sizes[dim] for dim in core_dims)\n            for core_dims in list_of_core_dims]\n\n\ndef _create_arrays(broadcast_shape, dim_sizes, list_of_core_dims, dtypes,\n                   results=None):\n    \"\"\"Helper for creating output arrays in vectorize.\"\"\"\n    shapes = _calculate_shapes(broadcast_shape, dim_sizes, list_of_core_dims)\n    if dtypes is None:\n        dtypes = [None] * len(shapes)\n    if results is None:\n        arrays = tuple(np.empty(shape=shape, dtype=dtype)\n                       for shape, dtype in zip(shapes, dtypes))\n    else:\n        arrays = tuple(np.empty_like(result, shape=shape, dtype=dtype)\n                       for result, shape, dtype\n                       in zip(results, shapes, dtypes))\n    return arrays\n\n\ndef _get_vectorize_dtype(dtype):\n    if dtype.char in \"SU\":\n        return dtype.char\n    return dtype\n\n\n@set_module('numpy')\nclass vectorize:\n    \"\"\"\n    vectorize(pyfunc=np._NoValue, otypes=None, doc=None, excluded=None,\n    cache=False, signature=None)\n\n    Returns an object that acts like pyfunc, but takes arrays as input.\n\n    Define a vectorized function which takes a nested sequence of objects or\n    numpy arrays as inputs and returns a single numpy array or a tuple of numpy\n    arrays. The vectorized function evaluates `pyfunc` over successive tuples\n    of the input arrays like the python map function, except it uses the\n    broadcasting rules of numpy.\n\n    The data type of the output of `vectorized` is determined by calling\n    the function with the first element of the input.  This can be avoided\n    by specifying the `otypes` argument.\n\n    Parameters\n    ----------\n    pyfunc : callable, optional\n        A python function or method.\n        Can be omitted to produce a decorator with keyword arguments.\n    otypes : str or list of dtypes, optional\n        The output data type. It must be specified as either a string of\n        typecode characters or a list of data type specifiers. There should\n        be one data type specifier for each output.\n    doc : str, optional\n        The docstring for the function. If None, the docstring will be the\n        ``pyfunc.__doc__``.\n    excluded : set, optional\n        Set of strings or integers representing the positional or keyword\n        arguments for which the function will not be vectorized. These will be\n        passed directly to `pyfunc` unmodified.\n\n    cache : bool, optional\n        If `True`, then cache the first function call that determines the number\n        of outputs if `otypes` is not provided.\n\n    signature : string, optional\n        Generalized universal function signature, e.g., ``(m,n),(n)->(m)`` for\n        vectorized matrix-vector multiplication. If provided, ``pyfunc`` will\n        be called with (and expected to return) arrays with shapes given by the\n        size of corresponding core dimensions. By default, ``pyfunc`` is\n        assumed to take scalars as input and output.\n\n    Returns\n    -------\n    out : callable\n        A vectorized function if ``pyfunc`` was provided,\n        a decorator otherwise.\n\n    See Also\n    --------\n    frompyfunc : Takes an arbitrary Python function and returns a ufunc\n\n    Notes\n    -----\n    The `vectorize` function is provided primarily for convenience, not for\n    performance. The implementation is essentially a for loop.\n\n    If `otypes` is not specified, then a call to the function with the\n    first argument will be used to determine the number of outputs.  The\n    results of this call will be cached if `cache` is `True` to prevent\n    calling the function twice.  However, to implement the cache, the\n    original function must be wrapped which will slow down subsequent\n    calls, so only do this if your function is expensive.\n\n    The new keyword argument interface and `excluded` argument support\n    further degrades performance.\n\n    References\n    ----------\n    .. [1] :doc:`/reference/c-api/generalized-ufuncs`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> def myfunc(a, b):\n    ...     \"Return a-b if a>b, otherwise return a+b\"\n    ...     if a > b:\n    ...         return a - b\n    ...     else:\n    ...         return a + b\n\n    >>> vfunc = np.vectorize(myfunc)\n    >>> vfunc([1, 2, 3, 4], 2)\n    array([3, 4, 1, 2])\n\n    The docstring is taken from the input function to `vectorize` unless it\n    is specified:\n\n    >>> vfunc.__doc__\n    'Return a-b if a>b, otherwise return a+b'\n    >>> vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`')\n    >>> vfunc.__doc__\n    'Vectorized `myfunc`'\n\n    The output type is determined by evaluating the first element of the input,\n    unless it is specified:\n\n    >>> out = vfunc([1, 2, 3, 4], 2)\n    >>> type(out[0])\n    <class 'numpy.int64'>\n    >>> vfunc = np.vectorize(myfunc, otypes=[float])\n    >>> out = vfunc([1, 2, 3, 4], 2)\n    >>> type(out[0])\n    <class 'numpy.float64'>\n\n    The `excluded` argument can be used to prevent vectorizing over certain\n    arguments.  This can be useful for array-like arguments of a fixed length\n    such as the coefficients for a polynomial as in `polyval`:\n\n    >>> def mypolyval(p, x):\n    ...     _p = list(p)\n    ...     res = _p.pop(0)\n    ...     while _p:\n    ...         res = res*x + _p.pop(0)\n    ...     return res\n\n    Here, we exclude the zeroth argument from vectorization whether it is\n    passed by position or keyword.\n\n    >>> vpolyval = np.vectorize(mypolyval, excluded={0, 'p'})\n    >>> vpolyval([1, 2, 3], x=[0, 1])\n    array([3, 6])\n    >>> vpolyval(p=[1, 2, 3], x=[0, 1])\n    array([3, 6])\n\n    The `signature` argument allows for vectorizing functions that act on\n    non-scalar arrays of fixed length. For example, you can use it for a\n    vectorized calculation of Pearson correlation coefficient and its p-value:\n\n    >>> import scipy.stats\n    >>> pearsonr = np.vectorize(scipy.stats.pearsonr,\n    ...                 signature='(n),(n)->(),()')\n    >>> pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])\n    (array([ 1., -1.]), array([ 0.,  0.]))\n\n    Or for a vectorized convolution:\n\n    >>> convolve = np.vectorize(np.convolve, signature='(n),(m)->(k)')\n    >>> convolve(np.eye(4), [1, 2, 1])\n    array([[1., 2., 1., 0., 0., 0.],\n           [0., 1., 2., 1., 0., 0.],\n           [0., 0., 1., 2., 1., 0.],\n           [0., 0., 0., 1., 2., 1.]])\n\n    Decorator syntax is supported.  The decorator can be called as\n    a function to provide keyword arguments:\n\n    >>> @np.vectorize\n    ... def identity(x):\n    ...     return x\n    ...\n    >>> identity([0, 1, 2])\n    array([0, 1, 2])\n    >>> @np.vectorize(otypes=[float])\n    ... def as_float(x):\n    ...     return x\n    ...\n    >>> as_float([0, 1, 2])\n    array([0., 1., 2.])\n    \"\"\"\n    def __init__(self, pyfunc=np._NoValue, otypes=None, doc=None,\n                 excluded=None, cache=False, signature=None):\n\n        if (pyfunc != np._NoValue) and (not callable(pyfunc)):\n            #Splitting the error message to keep\n            #the length below 79 characters.\n            part1 = \"When used as a decorator, \"\n            part2 = \"only accepts keyword arguments.\"\n            raise TypeError(part1 + part2)\n\n        self.pyfunc = pyfunc\n        self.cache = cache\n        self.signature = signature\n        if pyfunc != np._NoValue and hasattr(pyfunc, '__name__'):\n            self.__name__ = pyfunc.__name__\n\n        self._ufunc = {}    # Caching to improve default performance\n        self._doc = None\n        self.__doc__ = doc\n        if doc is None and hasattr(pyfunc, '__doc__'):\n            self.__doc__ = pyfunc.__doc__\n        else:\n            self._doc = doc\n\n        if isinstance(otypes, str):\n            for char in otypes:\n                if char not in typecodes['All']:\n                    raise ValueError(\"Invalid otype specified: %s\" % (char,))\n        elif iterable(otypes):\n            otypes = [_get_vectorize_dtype(_nx.dtype(x)) for x in otypes]\n        elif otypes is not None:\n            raise ValueError(\"Invalid otype specification\")\n        self.otypes = otypes\n\n        # Excluded variable support\n        if excluded is None:\n            excluded = set()\n        self.excluded = set(excluded)\n\n        if signature is not None:\n            self._in_and_out_core_dims = _parse_gufunc_signature(signature)\n        else:\n            self._in_and_out_core_dims = None\n\n    def _init_stage_2(self, pyfunc, *args, **kwargs):\n        self.__name__ = pyfunc.__name__\n        self.pyfunc = pyfunc\n        if self._doc is None:\n            self.__doc__ = pyfunc.__doc__\n        else:\n            self.__doc__ = self._doc\n\n    def _call_as_normal(self, *args, **kwargs):\n        \"\"\"\n        Return arrays with the results of `pyfunc` broadcast (vectorized) over\n        `args` and `kwargs` not in `excluded`.\n        \"\"\"\n        excluded = self.excluded\n        if not kwargs and not excluded:\n            func = self.pyfunc\n            vargs = args\n        else:\n            # The wrapper accepts only positional arguments: we use `names` and\n            # `inds` to mutate `the_args` and `kwargs` to pass to the original\n            # function.\n            nargs = len(args)\n\n            names = [_n for _n in kwargs if _n not in excluded]\n            inds = [_i for _i in range(nargs) if _i not in excluded]\n            the_args = list(args)\n\n            def func(*vargs):\n                for _n, _i in enumerate(inds):\n                    the_args[_i] = vargs[_n]\n                kwargs.update(zip(names, vargs[len(inds):]))\n                return self.pyfunc(*the_args, **kwargs)\n\n            vargs = [args[_i] for _i in inds]\n            vargs.extend([kwargs[_n] for _n in names])\n\n        return self._vectorize_call(func=func, args=vargs)\n\n    def __call__(self, *args, **kwargs):\n        if self.pyfunc is np._NoValue:\n            self._init_stage_2(*args, **kwargs)\n            return self\n\n        return self._call_as_normal(*args, **kwargs)\n\n    def _get_ufunc_and_otypes(self, func, args):\n        \"\"\"Return (ufunc, otypes).\"\"\"\n        # frompyfunc will fail if args is empty\n        if not args:\n            raise ValueError('args can not be empty')\n\n        if self.otypes is not None:\n            otypes = self.otypes\n\n            # self._ufunc is a dictionary whose keys are the number of\n            # arguments (i.e. len(args)) and whose values are ufuncs created\n            # by frompyfunc. len(args) can be different for different calls if\n            # self.pyfunc has parameters with default values.  We only use the\n            # cache when func is self.pyfunc, which occurs when the call uses\n            # only positional arguments and no arguments are excluded.\n\n            nin = len(args)\n            nout = len(self.otypes)\n            if func is not self.pyfunc or nin not in self._ufunc:\n                ufunc = frompyfunc(func, nin, nout)\n            else:\n                ufunc = None  # We'll get it from self._ufunc\n            if func is self.pyfunc:\n                ufunc = self._ufunc.setdefault(nin, ufunc)\n        else:\n            # Get number of outputs and output types by calling the function on\n            # the first entries of args.  We also cache the result to prevent\n            # the subsequent call when the ufunc is evaluated.\n            # Assumes that ufunc first evaluates the 0th elements in the input\n            # arrays (the input values are not checked to ensure this)\n            args = [asarray(arg) for arg in args]\n            if builtins.any(arg.size == 0 for arg in args):\n                raise ValueError('cannot call `vectorize` on size 0 inputs '\n                                 'unless `otypes` is set')\n\n            inputs = [arg.flat[0] for arg in args]\n            outputs = func(*inputs)\n\n            # Performance note: profiling indicates that -- for simple\n            # functions at least -- this wrapping can almost double the\n            # execution time.\n            # Hence we make it optional.\n            if self.cache:\n                _cache = [outputs]\n\n                def _func(*vargs):\n                    if _cache:\n                        return _cache.pop()\n                    else:\n                        return func(*vargs)\n            else:\n                _func = func\n\n            if isinstance(outputs, tuple):\n                nout = len(outputs)\n            else:\n                nout = 1\n                outputs = (outputs,)\n\n            otypes = ''.join([asarray(outputs[_k]).dtype.char\n                              for _k in range(nout)])\n\n            # Performance note: profiling indicates that creating the ufunc is\n            # not a significant cost compared with wrapping so it seems not\n            # worth trying to cache this.\n            ufunc = frompyfunc(_func, len(args), nout)\n\n        return ufunc, otypes\n\n    def _vectorize_call(self, func, args):\n        \"\"\"Vectorized call to `func` over positional `args`.\"\"\"\n        if self.signature is not None:\n            res = self._vectorize_call_with_signature(func, args)\n        elif not args:\n            res = func()\n        else:\n            ufunc, otypes = self._get_ufunc_and_otypes(func=func, args=args)\n\n            # Convert args to object arrays first\n            inputs = [asanyarray(a, dtype=object) for a in args]\n\n            outputs = ufunc(*inputs)\n\n            if ufunc.nout == 1:\n                res = asanyarray(outputs, dtype=otypes[0])\n            else:\n                res = tuple([asanyarray(x, dtype=t)\n                             for x, t in zip(outputs, otypes)])\n        return res\n\n    def _vectorize_call_with_signature(self, func, args):\n        \"\"\"Vectorized call over positional arguments with a signature.\"\"\"\n        input_core_dims, output_core_dims = self._in_and_out_core_dims\n\n        if len(args) != len(input_core_dims):\n            raise TypeError('wrong number of positional arguments: '\n                            'expected %r, got %r'\n                            % (len(input_core_dims), len(args)))\n        args = tuple(asanyarray(arg) for arg in args)\n\n        broadcast_shape, dim_sizes = _parse_input_dimensions(\n            args, input_core_dims)\n        input_shapes = _calculate_shapes(broadcast_shape, dim_sizes,\n                                         input_core_dims)\n        args = [np.broadcast_to(arg, shape, subok=True)\n                for arg, shape in zip(args, input_shapes)]\n\n        outputs = None\n        otypes = self.otypes\n        nout = len(output_core_dims)\n\n        for index in np.ndindex(*broadcast_shape):\n            results = func(*(arg[index] for arg in args))\n\n            n_results = len(results) if isinstance(results, tuple) else 1\n\n            if nout != n_results:\n                raise ValueError(\n                    'wrong number of outputs from pyfunc: expected %r, got %r'\n                    % (nout, n_results))\n\n            if nout == 1:\n                results = (results,)\n\n            if outputs is None:\n                for result, core_dims in zip(results, output_core_dims):\n                    _update_dim_sizes(dim_sizes, result, core_dims)\n\n                outputs = _create_arrays(broadcast_shape, dim_sizes,\n                                         output_core_dims, otypes, results)\n\n            for output, result in zip(outputs, results):\n                output[index] = result\n\n        if outputs is None:\n            # did not call the function even once\n            if otypes is None:\n                raise ValueError('cannot call `vectorize` on size 0 inputs '\n                                 'unless `otypes` is set')\n            if builtins.any(dim not in dim_sizes\n                            for dims in output_core_dims\n                            for dim in dims):\n                raise ValueError('cannot call `vectorize` with a signature '\n                                 'including new output dimensions on size 0 '\n                                 'inputs')\n            outputs = _create_arrays(broadcast_shape, dim_sizes,\n                                     output_core_dims, otypes)\n\n        return outputs[0] if nout == 1 else outputs\n\n\ndef _cov_dispatcher(m, y=None, rowvar=None, bias=None, ddof=None,\n                    fweights=None, aweights=None, *, dtype=None):\n    return (m, y, fweights, aweights)\n\n\n@array_function_dispatch(_cov_dispatcher)\ndef cov(m, y=None, rowvar=True, bias=False, ddof=None, fweights=None,\n        aweights=None, *, dtype=None):\n    \"\"\"\n    Estimate a covariance matrix, given data and weights.\n\n    Covariance indicates the level to which two variables vary together.\n    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,\n    then the covariance matrix element :math:`C_{ij}` is the covariance of\n    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance\n    of :math:`x_i`.\n\n    See the notes for an outline of the algorithm.\n\n    Parameters\n    ----------\n    m : array_like\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `m` represents a variable, and each column a single\n        observation of all those variables. Also see `rowvar` below.\n    y : array_like, optional\n        An additional set of variables and observations. `y` has the same form\n        as that of `m`.\n    rowvar : bool, optional\n        If `rowvar` is True (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations.\n    bias : bool, optional\n        Default normalization (False) is by ``(N - 1)``, where ``N`` is the\n        number of observations given (unbiased estimate). If `bias` is True,\n        then normalization is by ``N``. These values can be overridden by using\n        the keyword ``ddof`` in numpy versions >= 1.5.\n    ddof : int, optional\n        If not ``None`` the default value implied by `bias` is overridden.\n        Note that ``ddof=1`` will return the unbiased estimate, even if both\n        `fweights` and `aweights` are specified, and ``ddof=0`` will return\n        the simple average. See the notes for the details. The default value\n        is ``None``.\n    fweights : array_like, int, optional\n        1-D array of integer frequency weights; the number of times each\n        observation vector should be repeated.\n    aweights : array_like, optional\n        1-D array of observation vector weights. These relative weights are\n        typically large for observations considered \"important\" and smaller for\n        observations considered less \"important\". If ``ddof=0`` the array of\n        weights can be used to assign probabilities to observation vectors.\n    dtype : data-type, optional\n        Data-type of the result. By default, the return data-type will have\n        at least `numpy.float64` precision.\n\n        .. versionadded:: 1.20\n\n    Returns\n    -------\n    out : ndarray\n        The covariance matrix of the variables.\n\n    See Also\n    --------\n    corrcoef : Normalized covariance matrix\n\n    Notes\n    -----\n    Assume that the observations are in the columns of the observation\n    array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The\n    steps to compute the weighted covariance are as follows::\n\n        >>> m = np.arange(10, dtype=np.float64)\n        >>> f = np.arange(10) * 2\n        >>> a = np.arange(10) ** 2.\n        >>> ddof = 1\n        >>> w = f * a\n        >>> v1 = np.sum(w)\n        >>> v2 = np.sum(w * a)\n        >>> m -= np.sum(m * w, axis=None, keepdims=True) / v1\n        >>> cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)\n\n    Note that when ``a == 1``, the normalization factor\n    ``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``\n    as it should.\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    Consider two variables, :math:`x_0` and :math:`x_1`, which\n    correlate perfectly, but in opposite directions:\n\n    >>> x = np.array([[0, 2], [1, 1], [2, 0]]).T\n    >>> x\n    array([[0, 1, 2],\n           [2, 1, 0]])\n\n    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance\n    matrix shows this clearly:\n\n    >>> np.cov(x)\n    array([[ 1., -1.],\n           [-1.,  1.]])\n\n    Note that element :math:`C_{0,1}`, which shows the correlation between\n    :math:`x_0` and :math:`x_1`, is negative.\n\n    Further, note how `x` and `y` are combined:\n\n    >>> x = [-2.1, -1,  4.3]\n    >>> y = [3,  1.1,  0.12]\n    >>> X = np.stack((x, y), axis=0)\n    >>> np.cov(X)\n    array([[11.71      , -4.286     ], # may vary\n           [-4.286     ,  2.144133]])\n    >>> np.cov(x, y)\n    array([[11.71      , -4.286     ], # may vary\n           [-4.286     ,  2.144133]])\n    >>> np.cov(x)\n    array(11.71)\n\n    \"\"\"\n    # Check inputs\n    if ddof is not None and ddof != int(ddof):\n        raise ValueError(\n            \"ddof must be integer\")\n\n    # Handles complex arrays too\n    m = np.asarray(m)\n    if m.ndim > 2:\n        raise ValueError(\"m has more than 2 dimensions\")\n\n    if y is not None:\n        y = np.asarray(y)\n        if y.ndim > 2:\n            raise ValueError(\"y has more than 2 dimensions\")\n\n    if dtype is None:\n        if y is None:\n            dtype = np.result_type(m, np.float64)\n        else:\n            dtype = np.result_type(m, y, np.float64)\n\n    X = array(m, ndmin=2, dtype=dtype)\n    if not rowvar and m.ndim != 1:\n        X = X.T\n    if X.shape[0] == 0:\n        return np.array([]).reshape(0, 0)\n    if y is not None:\n        y = array(y, copy=None, ndmin=2, dtype=dtype)\n        if not rowvar and y.shape[0] != 1:\n            y = y.T\n        X = np.concatenate((X, y), axis=0)\n\n    if ddof is None:\n        if bias == 0:\n            ddof = 1\n        else:\n            ddof = 0\n\n    # Get the product of frequencies and weights\n    w = None\n    if fweights is not None:\n        fweights = np.asarray(fweights, dtype=float)\n        if not np.all(fweights == np.around(fweights)):\n            raise TypeError(\n                \"fweights must be integer\")\n        if fweights.ndim > 1:\n            raise RuntimeError(\n                \"cannot handle multidimensional fweights\")\n        if fweights.shape[0] != X.shape[1]:\n            raise RuntimeError(\n                \"incompatible numbers of samples and fweights\")\n        if any(fweights < 0):\n            raise ValueError(\n                \"fweights cannot be negative\")\n        w = fweights\n    if aweights is not None:\n        aweights = np.asarray(aweights, dtype=float)\n        if aweights.ndim > 1:\n            raise RuntimeError(\n                \"cannot handle multidimensional aweights\")\n        if aweights.shape[0] != X.shape[1]:\n            raise RuntimeError(\n                \"incompatible numbers of samples and aweights\")\n        if any(aweights < 0):\n            raise ValueError(\n                \"aweights cannot be negative\")\n        if w is None:\n            w = aweights\n        else:\n            w *= aweights\n\n    avg, w_sum = average(X, axis=1, weights=w, returned=True)\n    w_sum = w_sum[0]\n\n    # Determine the normalization\n    if w is None:\n        fact = X.shape[1] - ddof\n    elif ddof == 0:\n        fact = w_sum\n    elif aweights is None:\n        fact = w_sum - ddof\n    else:\n        fact = w_sum - ddof*sum(w*aweights)/w_sum\n\n    if fact <= 0:\n        warnings.warn(\"Degrees of freedom <= 0 for slice\",\n                      RuntimeWarning, stacklevel=2)\n        fact = 0.0\n\n    X -= avg[:, None]\n    if w is None:\n        X_T = X.T\n    else:\n        X_T = (X*w).T\n    c = dot(X, X_T.conj())\n    c *= np.true_divide(1, fact)\n    return c.squeeze()\n\n\ndef _corrcoef_dispatcher(x, y=None, rowvar=None, bias=None, ddof=None, *,\n                         dtype=None):\n    return (x, y)\n\n\n@array_function_dispatch(_corrcoef_dispatcher)\ndef corrcoef(x, y=None, rowvar=True, bias=np._NoValue, ddof=np._NoValue, *,\n             dtype=None):\n    \"\"\"\n    Return Pearson product-moment correlation coefficients.\n\n    Please refer to the documentation for `cov` for more detail.  The\n    relationship between the correlation coefficient matrix, `R`, and the\n    covariance matrix, `C`, is\n\n    .. math:: R_{ij} = \\\\frac{ C_{ij} } { \\\\sqrt{ C_{ii} C_{jj} } }\n\n    The values of `R` are between -1 and 1, inclusive.\n\n    Parameters\n    ----------\n    x : array_like\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `x` represents a variable, and each column a single\n        observation of all those variables. Also see `rowvar` below.\n    y : array_like, optional\n        An additional set of variables and observations. `y` has the same\n        shape as `x`.\n    rowvar : bool, optional\n        If `rowvar` is True (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations.\n    bias : _NoValue, optional\n        Has no effect, do not use.\n\n        .. deprecated:: 1.10.0\n    ddof : _NoValue, optional\n        Has no effect, do not use.\n\n        .. deprecated:: 1.10.0\n    dtype : data-type, optional\n        Data-type of the result. By default, the return data-type will have\n        at least `numpy.float64` precision.\n\n        .. versionadded:: 1.20\n\n    Returns\n    -------\n    R : ndarray\n        The correlation coefficient matrix of the variables.\n\n    See Also\n    --------\n    cov : Covariance matrix\n\n    Notes\n    -----\n    Due to floating point rounding the resulting array may not be Hermitian,\n    the diagonal elements may not be 1, and the elements may not satisfy the\n    inequality abs(a) <= 1. The real and imaginary parts are clipped to the\n    interval [-1,  1] in an attempt to improve on that situation but is not\n    much help in the complex case.\n\n    This function accepts but discards arguments `bias` and `ddof`.  This is\n    for backwards compatibility with previous versions of this function.  These\n    arguments had no effect on the return values of the function and can be\n    safely ignored in this and previous versions of numpy.\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    In this example we generate two random arrays, ``xarr`` and ``yarr``, and\n    compute the row-wise and column-wise Pearson correlation coefficients,\n    ``R``. Since ``rowvar`` is  true by  default, we first find the row-wise\n    Pearson correlation coefficients between the variables of ``xarr``.\n\n    >>> import numpy as np\n    >>> rng = np.random.default_rng(seed=42)\n    >>> xarr = rng.random((3, 3))\n    >>> xarr\n    array([[0.77395605, 0.43887844, 0.85859792],\n           [0.69736803, 0.09417735, 0.97562235],\n           [0.7611397 , 0.78606431, 0.12811363]])\n    >>> R1 = np.corrcoef(xarr)\n    >>> R1\n    array([[ 1.        ,  0.99256089, -0.68080986],\n           [ 0.99256089,  1.        , -0.76492172],\n           [-0.68080986, -0.76492172,  1.        ]])\n\n    If we add another set of variables and observations ``yarr``, we can\n    compute the row-wise Pearson correlation coefficients between the\n    variables in ``xarr`` and ``yarr``.\n\n    >>> yarr = rng.random((3, 3))\n    >>> yarr\n    array([[0.45038594, 0.37079802, 0.92676499],\n           [0.64386512, 0.82276161, 0.4434142 ],\n           [0.22723872, 0.55458479, 0.06381726]])\n    >>> R2 = np.corrcoef(xarr, yarr)\n    >>> R2\n    array([[ 1.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  ,\n            -0.99004057],\n           [ 0.99256089,  1.        , -0.76492172,  0.82502011, -0.97074098,\n            -0.99981569],\n           [-0.68080986, -0.76492172,  1.        , -0.99507202,  0.89721355,\n             0.77714685],\n           [ 0.75008178,  0.82502011, -0.99507202,  1.        , -0.93657855,\n            -0.83571711],\n           [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1.        ,\n             0.97517215],\n           [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215,\n             1.        ]])\n\n    Finally if we use the option ``rowvar=False``, the columns are now\n    being treated as the variables and we will find the column-wise Pearson\n    correlation coefficients between variables in ``xarr`` and ``yarr``.\n\n    >>> R3 = np.corrcoef(xarr, yarr, rowvar=False)\n    >>> R3\n    array([[ 1.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 ,\n             0.22423734],\n           [ 0.77598074,  1.        , -0.92346708, -0.99923895, -0.58826587,\n            -0.44069024],\n           [-0.47458546, -0.92346708,  1.        ,  0.93773029,  0.23297648,\n             0.75137473],\n           [-0.75078643, -0.99923895,  0.93773029,  1.        ,  0.55627469,\n             0.47536961],\n           [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1.        ,\n            -0.46666491],\n           [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491,\n             1.        ]])\n\n    \"\"\"\n    if bias is not np._NoValue or ddof is not np._NoValue:\n        # 2015-03-15, 1.10\n        warnings.warn('bias and ddof have no effect and are deprecated',\n                      DeprecationWarning, stacklevel=2)\n    c = cov(x, y, rowvar, dtype=dtype)\n    try:\n        d = diag(c)\n    except ValueError:\n        # scalar covariance\n        # nan if incorrect value (nan, inf, 0), 1 otherwise\n        return c / c\n    stddev = sqrt(d.real)\n    c /= stddev[:, None]\n    c /= stddev[None, :]\n\n    # Clip real and imaginary parts to [-1, 1].  This does not guarantee\n    # abs(a[i,j]) <= 1 for complex arrays, but is the best we can do without\n    # excessive work.\n    np.clip(c.real, -1, 1, out=c.real)\n    if np.iscomplexobj(c):\n        np.clip(c.imag, -1, 1, out=c.imag)\n\n    return c\n\n\n@set_module('numpy')\ndef blackman(M):\n    \"\"\"\n    Return the Blackman window.\n\n    The Blackman window is a taper formed by using the first three\n    terms of a summation of cosines. It was designed to have close to the\n    minimal leakage possible.  It is close to optimal, only slightly worse\n    than a Kaiser window.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an empty\n        array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, with the maximum value normalized to one (the value one\n        appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Blackman window is defined as\n\n    .. math::  w(n) = 0.42 - 0.5 \\\\cos(2\\\\pi n/M) + 0.08 \\\\cos(4\\\\pi n/M)\n\n    Most references to the Blackman window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function. It is known as a\n    \"near optimal\" tapering function, almost as good (by some measures)\n    as the kaiser window.\n\n    References\n    ----------\n    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,\n    Dover Publications, New York.\n\n    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.\n    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> import matplotlib.pyplot as plt\n    >>> np.blackman(12)\n    array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary\n            4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n            9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n            1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n\n    Plot the window and the frequency response.\n\n    .. plot::\n        :include-source:\n\n        import matplotlib.pyplot as plt\n        from numpy.fft import fft, fftshift\n        window = np.blackman(51)\n        plt.plot(window)\n        plt.title(\"Blackman window\")\n        plt.ylabel(\"Amplitude\")\n        plt.xlabel(\"Sample\")\n        plt.show()  # doctest: +SKIP\n\n        plt.figure()\n        A = fft(window, 2048) / 25.5\n        mag = np.abs(fftshift(A))\n        freq = np.linspace(-0.5, 0.5, len(A))\n        with np.errstate(divide='ignore', invalid='ignore'):\n            response = 20 * np.log10(mag)\n        response = np.clip(response, -100, 100)\n        plt.plot(freq, response)\n        plt.title(\"Frequency response of Blackman window\")\n        plt.ylabel(\"Magnitude [dB]\")\n        plt.xlabel(\"Normalized frequency [cycles per sample]\")\n        plt.axis('tight')\n        plt.show()\n\n    \"\"\"\n    # Ensures at least float64 via 0.0.  M should be an integer, but conversion\n    # to double is safe for a range.\n    values = np.array([0.0, M])\n    M = values[1]\n\n    if M < 1:\n        return array([], dtype=values.dtype)\n    if M == 1:\n        return ones(1, dtype=values.dtype)\n    n = arange(1-M, M, 2)\n    return 0.42 + 0.5*cos(pi*n/(M-1)) + 0.08*cos(2.0*pi*n/(M-1))\n\n\n@set_module('numpy')\ndef bartlett(M):\n    \"\"\"\n    Return the Bartlett window.\n\n    The Bartlett window is very similar to a triangular window, except\n    that the end points are at zero.  It is often used in signal\n    processing for tapering a signal, without generating too much\n    ripple in the frequency domain.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : array\n        The triangular window, with the maximum value normalized to one\n        (the value one appears only if the number of samples is odd), with\n        the first and last samples equal to zero.\n\n    See Also\n    --------\n    blackman, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Bartlett window is defined as\n\n    .. math:: w(n) = \\\\frac{2}{M-1} \\\\left(\n              \\\\frac{M-1}{2} - \\\\left|n - \\\\frac{M-1}{2}\\\\right|\n              \\\\right)\n\n    Most references to the Bartlett window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  Note that convolution with this window produces linear\n    interpolation.  It is also known as an apodization (which means \"removing\n    the foot\", i.e. smoothing discontinuities at the beginning and end of the\n    sampled signal) or tapering function. The Fourier transform of the\n    Bartlett window is the product of two sinc functions. Note the excellent\n    discussion in Kanasewich [2]_.\n\n    References\n    ----------\n    .. [1] M.S. Bartlett, \"Periodogram Analysis and Continuous Spectra\",\n           Biometrika 37, 1-16, 1950.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 109-110.\n    .. [3] A.V. Oppenheim and R.W. Schafer, \"Discrete-Time Signal\n           Processing\", Prentice-Hall, 1999, pp. 468-471.\n    .. [4] Wikipedia, \"Window function\",\n           https://en.wikipedia.org/wiki/Window_function\n    .. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 429.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> import matplotlib.pyplot as plt\n    >>> np.bartlett(12)\n    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary\n            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n            0.18181818,  0.        ])\n\n    Plot the window and its frequency response (requires SciPy and matplotlib).\n\n    .. plot::\n        :include-source:\n\n        import matplotlib.pyplot as plt\n        from numpy.fft import fft, fftshift\n        window = np.bartlett(51)\n        plt.plot(window)\n        plt.title(\"Bartlett window\")\n        plt.ylabel(\"Amplitude\")\n        plt.xlabel(\"Sample\")\n        plt.show()\n        plt.figure()\n        A = fft(window, 2048) / 25.5\n        mag = np.abs(fftshift(A))\n        freq = np.linspace(-0.5, 0.5, len(A))\n        with np.errstate(divide='ignore', invalid='ignore'):\n            response = 20 * np.log10(mag)\n        response = np.clip(response, -100, 100)\n        plt.plot(freq, response)\n        plt.title(\"Frequency response of Bartlett window\")\n        plt.ylabel(\"Magnitude [dB]\")\n        plt.xlabel(\"Normalized frequency [cycles per sample]\")\n        plt.axis('tight')\n        plt.show()\n\n    \"\"\"\n    # Ensures at least float64 via 0.0.  M should be an integer, but conversion\n    # to double is safe for a range.\n    values = np.array([0.0, M])\n    M = values[1]\n\n    if M < 1:\n        return array([], dtype=values.dtype)\n    if M == 1:\n        return ones(1, dtype=values.dtype)\n    n = arange(1-M, M, 2)\n    return where(less_equal(n, 0), 1 + n/(M-1), 1 - n/(M-1))\n\n\n@set_module('numpy')\ndef hanning(M):\n    \"\"\"\n    Return the Hanning window.\n\n    The Hanning window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray, shape(M,)\n        The window, with the maximum value normalized to one (the value\n        one appears only if `M` is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, kaiser\n\n    Notes\n    -----\n    The Hanning window is defined as\n\n    .. math::  w(n) = 0.5 - 0.5\\\\cos\\\\left(\\\\frac{2\\\\pi{n}}{M-1}\\\\right)\n               \\\\qquad 0 \\\\leq n \\\\leq M-1\n\n    The Hanning was named for Julius von Hann, an Austrian meteorologist.\n    It is also known as the Cosine Bell. Some authors prefer that it be\n    called a Hann window, to help avoid confusion with the very similar\n    Hamming window.\n\n    Most references to the Hanning window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 106-108.\n    .. [3] Wikipedia, \"Window function\",\n           https://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.hanning(12)\n    array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,\n           0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,\n           0.07937323, 0.        ])\n\n    Plot the window and its frequency response.\n\n    .. plot::\n        :include-source:\n\n        import matplotlib.pyplot as plt\n        from numpy.fft import fft, fftshift\n        window = np.hanning(51)\n        plt.plot(window)\n        plt.title(\"Hann window\")\n        plt.ylabel(\"Amplitude\")\n        plt.xlabel(\"Sample\")\n        plt.show()\n\n        plt.figure()\n        A = fft(window, 2048) / 25.5\n        mag = np.abs(fftshift(A))\n        freq = np.linspace(-0.5, 0.5, len(A))\n        with np.errstate(divide='ignore', invalid='ignore'):\n            response = 20 * np.log10(mag)\n        response = np.clip(response, -100, 100)\n        plt.plot(freq, response)\n        plt.title(\"Frequency response of the Hann window\")\n        plt.ylabel(\"Magnitude [dB]\")\n        plt.xlabel(\"Normalized frequency [cycles per sample]\")\n        plt.axis('tight')\n        plt.show()\n\n    \"\"\"\n    # Ensures at least float64 via 0.0.  M should be an integer, but conversion\n    # to double is safe for a range.\n    values = np.array([0.0, M])\n    M = values[1]\n\n    if M < 1:\n        return array([], dtype=values.dtype)\n    if M == 1:\n        return ones(1, dtype=values.dtype)\n    n = arange(1-M, M, 2)\n    return 0.5 + 0.5*cos(pi*n/(M-1))\n\n\n@set_module('numpy')\ndef hamming(M):\n    \"\"\"\n    Return the Hamming window.\n\n    The Hamming window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, with the maximum value normalized to one (the value\n        one appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hanning, kaiser\n\n    Notes\n    -----\n    The Hamming window is defined as\n\n    .. math::  w(n) = 0.54 - 0.46\\\\cos\\\\left(\\\\frac{2\\\\pi{n}}{M-1}\\\\right)\n               \\\\qquad 0 \\\\leq n \\\\leq M-1\n\n    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey\n    and is described in Blackman and Tukey. It was recommended for\n    smoothing the truncated autocovariance function in the time domain.\n    Most references to the Hamming window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 109-110.\n    .. [3] Wikipedia, \"Window function\",\n           https://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.hamming(12)\n    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary\n            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n            0.15302337,  0.08      ])\n\n    Plot the window and the frequency response.\n\n    .. plot::\n        :include-source:\n\n        import matplotlib.pyplot as plt\n        from numpy.fft import fft, fftshift\n        window = np.hamming(51)\n        plt.plot(window)\n        plt.title(\"Hamming window\")\n        plt.ylabel(\"Amplitude\")\n        plt.xlabel(\"Sample\")\n        plt.show()\n\n        plt.figure()\n        A = fft(window, 2048) / 25.5\n        mag = np.abs(fftshift(A))\n        freq = np.linspace(-0.5, 0.5, len(A))\n        response = 20 * np.log10(mag)\n        response = np.clip(response, -100, 100)\n        plt.plot(freq, response)\n        plt.title(\"Frequency response of Hamming window\")\n        plt.ylabel(\"Magnitude [dB]\")\n        plt.xlabel(\"Normalized frequency [cycles per sample]\")\n        plt.axis('tight')\n        plt.show()\n\n    \"\"\"\n    # Ensures at least float64 via 0.0.  M should be an integer, but conversion\n    # to double is safe for a range.\n    values = np.array([0.0, M])\n    M = values[1]\n\n    if M < 1:\n        return array([], dtype=values.dtype)\n    if M == 1:\n        return ones(1, dtype=values.dtype)\n    n = arange(1-M, M, 2)\n    return 0.54 + 0.46*cos(pi*n/(M-1))\n\n\n## Code from cephes for i0\n\n_i0A = [\n    -4.41534164647933937950E-18,\n    3.33079451882223809783E-17,\n    -2.43127984654795469359E-16,\n    1.71539128555513303061E-15,\n    -1.16853328779934516808E-14,\n    7.67618549860493561688E-14,\n    -4.85644678311192946090E-13,\n    2.95505266312963983461E-12,\n    -1.72682629144155570723E-11,\n    9.67580903537323691224E-11,\n    -5.18979560163526290666E-10,\n    2.65982372468238665035E-9,\n    -1.30002500998624804212E-8,\n    6.04699502254191894932E-8,\n    -2.67079385394061173391E-7,\n    1.11738753912010371815E-6,\n    -4.41673835845875056359E-6,\n    1.64484480707288970893E-5,\n    -5.75419501008210370398E-5,\n    1.88502885095841655729E-4,\n    -5.76375574538582365885E-4,\n    1.63947561694133579842E-3,\n    -4.32430999505057594430E-3,\n    1.05464603945949983183E-2,\n    -2.37374148058994688156E-2,\n    4.93052842396707084878E-2,\n    -9.49010970480476444210E-2,\n    1.71620901522208775349E-1,\n    -3.04682672343198398683E-1,\n    6.76795274409476084995E-1\n    ]\n\n_i0B = [\n    -7.23318048787475395456E-18,\n    -4.83050448594418207126E-18,\n    4.46562142029675999901E-17,\n    3.46122286769746109310E-17,\n    -2.82762398051658348494E-16,\n    -3.42548561967721913462E-16,\n    1.77256013305652638360E-15,\n    3.81168066935262242075E-15,\n    -9.55484669882830764870E-15,\n    -4.15056934728722208663E-14,\n    1.54008621752140982691E-14,\n    3.85277838274214270114E-13,\n    7.18012445138366623367E-13,\n    -1.79417853150680611778E-12,\n    -1.32158118404477131188E-11,\n    -3.14991652796324136454E-11,\n    1.18891471078464383424E-11,\n    4.94060238822496958910E-10,\n    3.39623202570838634515E-9,\n    2.26666899049817806459E-8,\n    2.04891858946906374183E-7,\n    2.89137052083475648297E-6,\n    6.88975834691682398426E-5,\n    3.36911647825569408990E-3,\n    8.04490411014108831608E-1\n    ]\n\n\ndef _chbevl(x, vals):\n    b0 = vals[0]\n    b1 = 0.0\n\n    for i in range(1, len(vals)):\n        b2 = b1\n        b1 = b0\n        b0 = x*b1 - b2 + vals[i]\n\n    return 0.5*(b0 - b2)\n\n\ndef _i0_1(x):\n    return exp(x) * _chbevl(x/2.0-2, _i0A)\n\n\ndef _i0_2(x):\n    return exp(x) * _chbevl(32.0/x - 2.0, _i0B) / sqrt(x)\n\n\ndef _i0_dispatcher(x):\n    return (x,)\n\n\n@array_function_dispatch(_i0_dispatcher)\ndef i0(x):\n    \"\"\"\n    Modified Bessel function of the first kind, order 0.\n\n    Usually denoted :math:`I_0`.\n\n    Parameters\n    ----------\n    x : array_like of float\n        Argument of the Bessel function.\n\n    Returns\n    -------\n    out : ndarray, shape = x.shape, dtype = float\n        The modified Bessel function evaluated at each of the elements of `x`.\n\n    See Also\n    --------\n    scipy.special.i0, scipy.special.iv, scipy.special.ive\n\n    Notes\n    -----\n    The scipy implementation is recommended over this function: it is a\n    proper ufunc written in C, and more than an order of magnitude faster.\n\n    We use the algorithm published by Clenshaw [1]_ and referenced by\n    Abramowitz and Stegun [2]_, for which the function domain is\n    partitioned into the two intervals [0,8] and (8,inf), and Chebyshev\n    polynomial expansions are employed in each interval. Relative error on\n    the domain [0,30] using IEEE arithmetic is documented [3]_ as having a\n    peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).\n\n    References\n    ----------\n    .. [1] C. W. Clenshaw, \"Chebyshev series for mathematical functions\", in\n           *National Physical Laboratory Mathematical Tables*, vol. 5, London:\n           Her Majesty's Stationery Office, 1962.\n    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical\n           Functions*, 10th printing, New York: Dover, 1964, pp. 379.\n           https://personal.math.ubc.ca/~cbm/aands/page_379.htm\n    .. [3] https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.i0(0.)\n    array(1.0)\n    >>> np.i0([0, 1, 2, 3])\n    array([1.        , 1.26606588, 2.2795853 , 4.88079259])\n\n    \"\"\"\n    x = np.asanyarray(x)\n    if x.dtype.kind == 'c':\n        raise TypeError(\"i0 not supported for complex values\")\n    if x.dtype.kind != 'f':\n        x = x.astype(float)\n    x = np.abs(x)\n    return piecewise(x, [x <= 8.0], [_i0_1, _i0_2])\n\n## End of cephes code for i0\n\n\n@set_module('numpy')\ndef kaiser(M, beta):\n    \"\"\"\n    Return the Kaiser window.\n\n    The Kaiser window is a taper formed by using a Bessel function.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n    beta : float\n        Shape parameter for window.\n\n    Returns\n    -------\n    out : array\n        The window, with the maximum value normalized to one (the value\n        one appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, hanning\n\n    Notes\n    -----\n    The Kaiser window is defined as\n\n    .. math::  w(n) = I_0\\\\left( \\\\beta \\\\sqrt{1-\\\\frac{4n^2}{(M-1)^2}}\n               \\\\right)/I_0(\\\\beta)\n\n    with\n\n    .. math:: \\\\quad -\\\\frac{M-1}{2} \\\\leq n \\\\leq \\\\frac{M-1}{2},\n\n    where :math:`I_0` is the modified zeroth-order Bessel function.\n\n    The Kaiser was named for Jim Kaiser, who discovered a simple\n    approximation to the DPSS window based on Bessel functions.  The Kaiser\n    window is a very good approximation to the Digital Prolate Spheroidal\n    Sequence, or Slepian window, which is the transform which maximizes the\n    energy in the main lobe of the window relative to total energy.\n\n    The Kaiser can approximate many other windows by varying the beta\n    parameter.\n\n    ====  =======================\n    beta  Window shape\n    ====  =======================\n    0     Rectangular\n    5     Similar to a Hamming\n    6     Similar to a Hanning\n    8.6   Similar to a Blackman\n    ====  =======================\n\n    A beta value of 14 is probably a good starting point. Note that as beta\n    gets large, the window narrows, and so the number of samples needs to be\n    large enough to sample the increasingly narrow spike, otherwise NaNs will\n    get returned.\n\n    Most references to the Kaiser window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] J. F. Kaiser, \"Digital Filters\" - Ch 7 in \"Systems analysis by\n           digital computer\", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.\n           John Wiley and Sons, New York, (1966).\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 177-178.\n    .. [3] Wikipedia, \"Window function\",\n           https://en.wikipedia.org/wiki/Window_function\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> import matplotlib.pyplot as plt\n    >>> np.kaiser(12, 14)\n     array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary\n            2.29737120e-01, 5.99885316e-01, 9.45674898e-01,\n            9.45674898e-01, 5.99885316e-01, 2.29737120e-01,\n            4.65200189e-02, 3.46009194e-03, 7.72686684e-06])\n\n\n    Plot the window and the frequency response.\n\n    .. plot::\n        :include-source:\n\n        import matplotlib.pyplot as plt\n        from numpy.fft import fft, fftshift\n        window = np.kaiser(51, 14)\n        plt.plot(window)\n        plt.title(\"Kaiser window\")\n        plt.ylabel(\"Amplitude\")\n        plt.xlabel(\"Sample\")\n        plt.show()\n\n        plt.figure()\n        A = fft(window, 2048) / 25.5\n        mag = np.abs(fftshift(A))\n        freq = np.linspace(-0.5, 0.5, len(A))\n        response = 20 * np.log10(mag)\n        response = np.clip(response, -100, 100)\n        plt.plot(freq, response)\n        plt.title(\"Frequency response of Kaiser window\")\n        plt.ylabel(\"Magnitude [dB]\")\n        plt.xlabel(\"Normalized frequency [cycles per sample]\")\n        plt.axis('tight')\n        plt.show()\n\n    \"\"\"\n    # Ensures at least float64 via 0.0.  M should be an integer, but conversion\n    # to double is safe for a range.  (Simplified result_type with 0.0\n    # strongly typed.  result-type is not/less order sensitive, but that mainly\n    # matters for integers anyway.)\n    values = np.array([0.0, M, beta])\n    M = values[1]\n    beta = values[2]\n\n    if M == 1:\n        return np.ones(1, dtype=values.dtype)\n    n = arange(0, M)\n    alpha = (M-1)/2.0\n    return i0(beta * sqrt(1-((n-alpha)/alpha)**2.0))/i0(beta)\n\n\ndef _sinc_dispatcher(x):\n    return (x,)\n\n\n@array_function_dispatch(_sinc_dispatcher)\ndef sinc(x):\n    r\"\"\"\n    Return the normalized sinc function.\n\n    The sinc function is equal to :math:`\\sin(\\pi x)/(\\pi x)` for any argument\n    :math:`x\\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not\n    only everywhere continuous but also infinitely differentiable.\n\n    .. note::\n\n        Note the normalization factor of ``pi`` used in the definition.\n        This is the most commonly used definition in signal processing.\n        Use ``sinc(x / np.pi)`` to obtain the unnormalized sinc function\n        :math:`\\sin(x)/x` that is more common in mathematics.\n\n    Parameters\n    ----------\n    x : ndarray\n        Array (possibly multi-dimensional) of values for which to calculate\n        ``sinc(x)``.\n\n    Returns\n    -------\n    out : ndarray\n        ``sinc(x)``, which has the same shape as the input.\n\n    Notes\n    -----\n    The name sinc is short for \"sine cardinal\" or \"sinus cardinalis\".\n\n    The sinc function is used in various signal processing applications,\n    including in anti-aliasing, in the construction of a Lanczos resampling\n    filter, and in interpolation.\n\n    For bandlimited interpolation of discrete-time signals, the ideal\n    interpolation kernel is proportional to the sinc function.\n\n    References\n    ----------\n    .. [1] Weisstein, Eric W. \"Sinc Function.\" From MathWorld--A Wolfram Web\n           Resource. https://mathworld.wolfram.com/SincFunction.html\n    .. [2] Wikipedia, \"Sinc function\",\n           https://en.wikipedia.org/wiki/Sinc_function\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> import matplotlib.pyplot as plt\n    >>> x = np.linspace(-4, 4, 41)\n    >>> np.sinc(x)\n     array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary\n            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n            6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n            8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n            3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n            7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n            9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n            2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n           -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n           -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n            1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n            -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,\n            -4.92362781e-02,  -3.89804309e-17])\n\n    >>> plt.plot(x, np.sinc(x))\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Sinc Function\")\n    Text(0.5, 1.0, 'Sinc Function')\n    >>> plt.ylabel(\"Amplitude\")\n    Text(0, 0.5, 'Amplitude')\n    >>> plt.xlabel(\"X\")\n    Text(0.5, 0, 'X')\n    >>> plt.show()\n\n    \"\"\"\n    x = np.asanyarray(x)\n    y = pi * where(x == 0, 1.0e-20, x)\n    return sin(y)/y\n\n\ndef _ureduce(a, func, keepdims=False, **kwargs):\n    \"\"\"\n    Internal Function.\n    Call `func` with `a` as first argument swapping the axes to use extended\n    axis on functions that don't support it natively.\n\n    Returns result and a.shape with axis dims set to 1.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    func : callable\n        Reduction function capable of receiving a single axis argument.\n        It is called with `a` as first argument followed by `kwargs`.\n    kwargs : keyword arguments\n        additional keyword arguments to pass to `func`.\n\n    Returns\n    -------\n    result : tuple\n        Result of func(a, **kwargs) and a.shape with axis dims set to 1\n        which can be used to reshape the result to the same shape a ufunc with\n        keepdims=True would produce.\n\n    \"\"\"\n    a = np.asanyarray(a)\n    axis = kwargs.get('axis', None)\n    out = kwargs.get('out', None)\n\n    if keepdims is np._NoValue:\n        keepdims = False\n\n    nd = a.ndim\n    if axis is not None:\n        axis = _nx.normalize_axis_tuple(axis, nd)\n\n        if keepdims:\n            if out is not None:\n                index_out = tuple(\n                    0 if i in axis else slice(None) for i in range(nd))\n                kwargs['out'] = out[(Ellipsis, ) + index_out]\n\n        if len(axis) == 1:\n            kwargs['axis'] = axis[0]\n        else:\n            keep = set(range(nd)) - set(axis)\n            nkeep = len(keep)\n            # swap axis that should not be reduced to front\n            for i, s in enumerate(sorted(keep)):\n                a = a.swapaxes(i, s)\n            # merge reduced axis\n            a = a.reshape(a.shape[:nkeep] + (-1,))\n            kwargs['axis'] = -1\n    else:\n        if keepdims:\n            if out is not None:\n                index_out = (0, ) * nd\n                kwargs['out'] = out[(Ellipsis, ) + index_out]\n\n    r = func(a, **kwargs)\n\n    if out is not None:\n        return out\n\n    if keepdims:\n        if axis is None:\n            index_r = (np.newaxis, ) * nd\n        else:\n            index_r = tuple(\n                np.newaxis if i in axis else slice(None)\n                for i in range(nd))\n        r = r[(Ellipsis, ) + index_r]\n\n    return r\n\n\ndef _median_dispatcher(\n        a, axis=None, out=None, overwrite_input=None, keepdims=None):\n    return (a, out)\n\n\n@array_function_dispatch(_median_dispatcher)\ndef median(a, axis=None, out=None, overwrite_input=False, keepdims=False):\n    \"\"\"\n    Compute the median along the specified axis.\n\n    Returns the median of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : {int, sequence of int, None}, optional\n        Axis or axes along which the medians are computed. The default,\n        axis=None, will compute the median along a flattened version of\n        the array. If a sequence of axes, the array is first flattened\n        along the given axes, then the median is computed along the\n        resulting flattened axis.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n       If True, then allow use of memory of input array `a` for\n       calculations. The input array will be modified by the call to\n       `median`. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted. Default is\n       False. If `overwrite_input` is ``True`` and `a` is not already an\n       `ndarray`, an error will be raised.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `arr`.\n\n    Returns\n    -------\n    median : ndarray\n        A new array holding the result. If the input contains integers\n        or floats smaller than ``float64``, then the output data-type is\n        ``np.float64``.  Otherwise, the data-type of the output is the\n        same as that of the input. If `out` is specified, that array is\n        returned instead.\n\n    See Also\n    --------\n    mean, percentile\n\n    Notes\n    -----\n    Given a vector ``V`` of length ``N``, the median of ``V`` is the\n    middle value of a sorted copy of ``V``, ``V_sorted`` - i\n    e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the\n    two middle values of ``V_sorted`` when ``N`` is even.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])\n    >>> np.median(a)\n    np.float64(3.5)\n    >>> np.median(a, axis=0)\n    array([6.5, 4.5, 2.5])\n    >>> np.median(a, axis=1)\n    array([7.,  2.])\n    >>> np.median(a, axis=(0, 1))\n    np.float64(3.5)\n    >>> m = np.median(a, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.median(a, axis=0, out=m)\n    array([6.5,  4.5,  2.5])\n    >>> m\n    array([6.5,  4.5,  2.5])\n    >>> b = a.copy()\n    >>> np.median(b, axis=1, overwrite_input=True)\n    array([7.,  2.])\n    >>> assert not np.all(a==b)\n    >>> b = a.copy()\n    >>> np.median(b, axis=None, overwrite_input=True)\n    np.float64(3.5)\n    >>> assert not np.all(a==b)\n\n    \"\"\"\n    return _ureduce(a, func=_median, keepdims=keepdims, axis=axis, out=out,\n                    overwrite_input=overwrite_input)\n\n\ndef _median(a, axis=None, out=None, overwrite_input=False):\n    # can't be reasonably be implemented in terms of percentile as we have to\n    # call mean to not break astropy\n    a = np.asanyarray(a)\n\n    # Set the partition indexes\n    if axis is None:\n        sz = a.size\n    else:\n        sz = a.shape[axis]\n    if sz % 2 == 0:\n        szh = sz // 2\n        kth = [szh - 1, szh]\n    else:\n        kth = [(sz - 1) // 2]\n\n    # We have to check for NaNs (as of writing 'M' doesn't actually work).\n    supports_nans = np.issubdtype(a.dtype, np.inexact) or a.dtype.kind in 'Mm'\n    if supports_nans:\n        kth.append(-1)\n\n    if overwrite_input:\n        if axis is None:\n            part = a.ravel()\n            part.partition(kth)\n        else:\n            a.partition(kth, axis=axis)\n            part = a\n    else:\n        part = partition(a, kth, axis=axis)\n\n    if part.shape == ():\n        # make 0-D arrays work\n        return part.item()\n    if axis is None:\n        axis = 0\n\n    indexer = [slice(None)] * part.ndim\n    index = part.shape[axis] // 2\n    if part.shape[axis] % 2 == 1:\n        # index with slice to allow mean (below) to work\n        indexer[axis] = slice(index, index+1)\n    else:\n        indexer[axis] = slice(index-1, index+1)\n    indexer = tuple(indexer)\n\n    # Use mean in both odd and even case to coerce data type,\n    # using out array if needed.\n    rout = mean(part[indexer], axis=axis, out=out)\n    if supports_nans and sz > 0:\n        # If nans are possible, warn and replace by nans like mean would.\n        rout = np.lib._utils_impl._median_nancheck(part, rout, axis)\n\n    return rout\n\n\ndef _percentile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,\n                           method=None, keepdims=None, *, weights=None,\n                           interpolation=None):\n    return (a, q, out, weights)\n\n\n@array_function_dispatch(_percentile_dispatcher)\ndef percentile(a,\n               q,\n               axis=None,\n               out=None,\n               overwrite_input=False,\n               method=\"linear\",\n               keepdims=False,\n               *,\n               weights=None,\n               interpolation=None):\n    \"\"\"\n    Compute the q-th percentile of the data along the specified axis.\n\n    Returns the q-th percentile(s) of the array elements.\n\n    Parameters\n    ----------\n    a : array_like of real numbers\n        Input array or object that can be converted to an array.\n    q : array_like of float\n        Percentage or sequence of percentages for the percentiles to compute.\n        Values must be between 0 and 100 inclusive.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the percentiles are computed. The\n        default is to compute the percentile(s) along a flattened\n        version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n        If True, then allow the input array `a` to be modified by intermediate\n        calculations, to save memory. In this case, the contents of the input\n        `a` after this function completes is undefined.\n    method : str, optional\n        This parameter specifies the method to use for estimating the\n        percentile.  There are many different methods, some unique to NumPy.\n        See the notes for explanation.  The options sorted by their R type\n        as summarized in the H&F paper [1]_ are:\n\n        1. 'inverted_cdf'\n        2. 'averaged_inverted_cdf'\n        3. 'closest_observation'\n        4. 'interpolated_inverted_cdf'\n        5. 'hazen'\n        6. 'weibull'\n        7. 'linear'  (default)\n        8. 'median_unbiased'\n        9. 'normal_unbiased'\n\n        The first three methods are discontinuous.  NumPy further defines the\n        following discontinuous variations of the default 'linear' (7.) option:\n\n        * 'lower'\n        * 'higher',\n        * 'midpoint'\n        * 'nearest'\n\n        .. versionchanged:: 1.22.0\n            This argument was previously called \"interpolation\" and only\n            offered the \"linear\" default and last four options.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left in\n        the result as dimensions with size one. With this option, the\n        result will broadcast correctly against the original array `a`.\n\n     weights : array_like, optional\n        An array of weights associated with the values in `a`. Each value in\n        `a` contributes to the percentile according to its associated weight.\n        The weights array can either be 1-D (in which case its length must be\n        the size of `a` along the given axis) or of the same shape as `a`.\n        If `weights=None`, then all data in `a` are assumed to have a\n        weight equal to one.\n        Only `method=\"inverted_cdf\"` supports weights.\n        See the notes for more details.\n\n        .. versionadded:: 2.0.0\n\n    interpolation : str, optional\n        Deprecated name for the method keyword argument.\n\n        .. deprecated:: 1.22.0\n\n    Returns\n    -------\n    percentile : scalar or ndarray\n        If `q` is a single percentile and `axis=None`, then the result\n        is a scalar. If multiple percentiles are given, first axis of\n        the result corresponds to the percentiles. The other axes are\n        the axes that remain after the reduction of `a`. If the input\n        contains integers or floats smaller than ``float64``, the output\n        data-type is ``float64``. Otherwise, the output data-type is the\n        same as that of the input. If `out` is specified, that array is\n        returned instead.\n\n    See Also\n    --------\n    mean\n    median : equivalent to ``percentile(..., 50)``\n    nanpercentile\n    quantile : equivalent to percentile, except q in the range [0, 1].\n\n    Notes\n    -----\n    The behavior of `numpy.percentile` with percentage `q` is\n    that of `numpy.quantile` with argument ``q/100``.\n    For more information, please see `numpy.quantile`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])\n    >>> np.percentile(a, 50)\n    3.5\n    >>> np.percentile(a, 50, axis=0)\n    array([6.5, 4.5, 2.5])\n    >>> np.percentile(a, 50, axis=1)\n    array([7.,  2.])\n    >>> np.percentile(a, 50, axis=1, keepdims=True)\n    array([[7.],\n           [2.]])\n\n    >>> m = np.percentile(a, 50, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.percentile(a, 50, axis=0, out=out)\n    array([6.5, 4.5, 2.5])\n    >>> m\n    array([6.5, 4.5, 2.5])\n\n    >>> b = a.copy()\n    >>> np.percentile(b, 50, axis=1, overwrite_input=True)\n    array([7.,  2.])\n    >>> assert not np.all(a == b)\n\n    The different methods can be visualized graphically:\n\n    .. plot::\n\n        import matplotlib.pyplot as plt\n\n        a = np.arange(4)\n        p = np.linspace(0, 100, 6001)\n        ax = plt.gca()\n        lines = [\n            ('linear', '-', 'C0'),\n            ('inverted_cdf', ':', 'C1'),\n            # Almost the same as `inverted_cdf`:\n            ('averaged_inverted_cdf', '-.', 'C1'),\n            ('closest_observation', ':', 'C2'),\n            ('interpolated_inverted_cdf', '--', 'C1'),\n            ('hazen', '--', 'C3'),\n            ('weibull', '-.', 'C4'),\n            ('median_unbiased', '--', 'C5'),\n            ('normal_unbiased', '-.', 'C6'),\n            ]\n        for method, style, color in lines:\n            ax.plot(\n                p, np.percentile(a, p, method=method),\n                label=method, linestyle=style, color=color)\n        ax.set(\n            title='Percentiles for different methods and data: ' + str(a),\n            xlabel='Percentile',\n            ylabel='Estimated percentile value',\n            yticks=a)\n        ax.legend(bbox_to_anchor=(1.03, 1))\n        plt.tight_layout()\n        plt.show()\n\n    References\n    ----------\n    .. [1] R. J. Hyndman and Y. Fan,\n       \"Sample quantiles in statistical packages,\"\n       The American Statistician, 50(4), pp. 361-365, 1996\n\n    \"\"\"\n    if interpolation is not None:\n        method = _check_interpolation_as_method(\n            method, interpolation, \"percentile\")\n\n    a = np.asanyarray(a)\n    if a.dtype.kind == \"c\":\n        raise TypeError(\"a must be an array of real numbers\")\n\n    # Use dtype of array if possible (e.g., if q is a python int or float)\n    # by making the divisor have the dtype of the data array.\n    q = np.true_divide(q, a.dtype.type(100) if a.dtype.kind == \"f\" else 100)\n    q = asanyarray(q)  # undo any decay that the ufunc performed (see gh-13105)\n    if not _quantile_is_valid(q):\n        raise ValueError(\"Percentiles must be in the range [0, 100]\")\n\n    if weights is not None:\n        if method != \"inverted_cdf\":\n            msg = (\"Only method 'inverted_cdf' supports weights. \"\n                   f\"Got: {method}.\")\n            raise ValueError(msg)\n        if axis is not None:\n            axis = _nx.normalize_axis_tuple(axis, a.ndim, argname=\"axis\")\n        weights = _weights_are_valid(weights=weights, a=a, axis=axis)\n        if np.any(weights < 0):\n            raise ValueError(\"Weights must be non-negative.\")\n\n    return _quantile_unchecked(\n        a, q, axis, out, overwrite_input, method, keepdims, weights)\n\n\ndef _quantile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,\n                         method=None, keepdims=None, *, weights=None,\n                         interpolation=None):\n    return (a, q, out, weights)\n\n\n@array_function_dispatch(_quantile_dispatcher)\ndef quantile(a,\n             q,\n             axis=None,\n             out=None,\n             overwrite_input=False,\n             method=\"linear\",\n             keepdims=False,\n             *,\n             weights=None,\n             interpolation=None):\n    \"\"\"\n    Compute the q-th quantile of the data along the specified axis.\n\n    Parameters\n    ----------\n    a : array_like of real numbers\n        Input array or object that can be converted to an array.\n    q : array_like of float\n        Probability or sequence of probabilities of the quantiles to compute.\n        Values must be between 0 and 1 inclusive.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the quantiles are computed. The default is\n        to compute the quantile(s) along a flattened version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape and buffer length as the expected output, but the\n        type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n        If True, then allow the input array `a` to be modified by\n        intermediate calculations, to save memory. In this case, the\n        contents of the input `a` after this function completes is\n        undefined.\n    method : str, optional\n        This parameter specifies the method to use for estimating the\n        quantile.  There are many different methods, some unique to NumPy.\n        The recommended options, numbered as they appear in [1]_, are:\n\n        1. 'inverted_cdf'\n        2. 'averaged_inverted_cdf'\n        3. 'closest_observation'\n        4. 'interpolated_inverted_cdf'\n        5. 'hazen'\n        6. 'weibull'\n        7. 'linear'  (default)\n        8. 'median_unbiased'\n        9. 'normal_unbiased'\n\n        The first three methods are discontinuous. For backward compatibility\n        with previous versions of NumPy, the following discontinuous variations\n        of the default 'linear' (7.) option are available:\n\n        * 'lower'\n        * 'higher',\n        * 'midpoint'\n        * 'nearest'\n\n        See Notes for details.\n\n        .. versionchanged:: 1.22.0\n            This argument was previously called \"interpolation\" and only\n            offered the \"linear\" default and last four options.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left in\n        the result as dimensions with size one. With this option, the\n        result will broadcast correctly against the original array `a`.\n\n    weights : array_like, optional\n        An array of weights associated with the values in `a`. Each value in\n        `a` contributes to the quantile according to its associated weight.\n        The weights array can either be 1-D (in which case its length must be\n        the size of `a` along the given axis) or of the same shape as `a`.\n        If `weights=None`, then all data in `a` are assumed to have a\n        weight equal to one.\n        Only `method=\"inverted_cdf\"` supports weights.\n        See the notes for more details.\n\n        .. versionadded:: 2.0.0\n\n    interpolation : str, optional\n        Deprecated name for the method keyword argument.\n\n        .. deprecated:: 1.22.0\n\n    Returns\n    -------\n    quantile : scalar or ndarray\n        If `q` is a single probability and `axis=None`, then the result\n        is a scalar. If multiple probability levels are given, first axis\n        of the result corresponds to the quantiles. The other axes are\n        the axes that remain after the reduction of `a`. If the input\n        contains integers or floats smaller than ``float64``, the output\n        data-type is ``float64``. Otherwise, the output data-type is the\n        same as that of the input. If `out` is specified, that array is\n        returned instead.\n\n    See Also\n    --------\n    mean\n    percentile : equivalent to quantile, but with q in the range [0, 100].\n    median : equivalent to ``quantile(..., 0.5)``\n    nanquantile\n\n    Notes\n    -----\n    Given a sample `a` from an underlying distribution, `quantile` provides a\n    nonparametric estimate of the inverse cumulative distribution function.\n\n    By default, this is done by interpolating between adjacent elements in\n    ``y``, a sorted copy of `a`::\n\n        (1-g)*y[j] + g*y[j+1]\n\n    where the index ``j`` and coefficient ``g`` are the integral and\n    fractional components of ``q * (n-1)``, and ``n`` is the number of\n    elements in the sample.\n\n    This is a special case of Equation 1 of H&F [1]_. More generally,\n\n    - ``j = (q*n + m - 1) // 1``, and\n    - ``g = (q*n + m - 1) % 1``,\n\n    where ``m`` may be defined according to several different conventions.\n    The preferred convention may be selected using the ``method`` parameter:\n\n    =============================== =============== ===============\n    ``method``                      number in H&F   ``m``\n    =============================== =============== ===============\n    ``interpolated_inverted_cdf``   4               ``0``\n    ``hazen``                       5               ``1/2``\n    ``weibull``                     6               ``q``\n    ``linear`` (default)            7               ``1 - q``\n    ``median_unbiased``             8               ``q/3 + 1/3``\n    ``normal_unbiased``             9               ``q/4 + 3/8``\n    =============================== =============== ===============\n\n    Note that indices ``j`` and ``j + 1`` are clipped to the range ``0`` to\n    ``n - 1`` when the results of the formula would be outside the allowed\n    range of non-negative indices. The ``- 1`` in the formulas for ``j`` and\n    ``g`` accounts for Python's 0-based indexing.\n\n    The table above includes only the estimators from H&F that are continuous\n    functions of probability `q` (estimators 4-9). NumPy also provides the\n    three discontinuous estimators from H&F (estimators 1-3), where ``j`` is\n    defined as above, ``m`` is defined as follows, and ``g`` is a function\n    of the real-valued ``index = q*n + m - 1`` and ``j``.\n\n    1. ``inverted_cdf``: ``m = 0`` and ``g = int(index - j > 0)``\n    2. ``averaged_inverted_cdf``: ``m = 0`` and\n       ``g = (1 + int(index - j > 0)) / 2``\n    3. ``closest_observation``: ``m = -1/2`` and\n       ``g = 1 - int((index == j) & (j%2 == 1))``\n\n    For backward compatibility with previous versions of NumPy, `quantile`\n    provides four additional discontinuous estimators. Like\n    ``method='linear'``, all have ``m = 1 - q`` so that ``j = q*(n-1) // 1``,\n    but ``g`` is defined as follows.\n\n    - ``lower``: ``g = 0``\n    - ``midpoint``: ``g = 0.5``\n    - ``higher``: ``g = 1``\n    - ``nearest``: ``g = (q*(n-1) % 1) > 0.5``\n\n    **Weighted quantiles:**\n    More formally, the quantile at probability level :math:`q` of a cumulative\n    distribution function :math:`F(y)=P(Y \\\\leq y)` with probability measure\n    :math:`P` is defined as any number :math:`x` that fulfills the\n    *coverage conditions*\n\n    .. math:: P(Y < x) \\\\leq q \\\\quad\\\\text{and}\\\\quad P(Y \\\\leq x) \\\\geq q\n\n    with random variable :math:`Y\\\\sim P`.\n    Sample quantiles, the result of `quantile`, provide nonparametric\n    estimation of the underlying population counterparts, represented by the\n    unknown :math:`F`, given a data vector `a` of length ``n``.\n\n    Some of the estimators above arise when one considers :math:`F` as the\n    empirical distribution function of the data, i.e.\n    :math:`F(y) = \\\\frac{1}{n} \\\\sum_i 1_{a_i \\\\leq y}`.\n    Then, different methods correspond to different choices of :math:`x` that\n    fulfill the above coverage conditions. Methods that follow this approach\n    are ``inverted_cdf`` and ``averaged_inverted_cdf``.\n\n    For weighted quantiles, the coverage conditions still hold. The\n    empirical cumulative distribution is simply replaced by its weighted\n    version, i.e.\n    :math:`P(Y \\\\leq t) = \\\\frac{1}{\\\\sum_i w_i} \\\\sum_i w_i 1_{x_i \\\\leq t}`.\n    Only ``method=\"inverted_cdf\"`` supports weights.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])\n    >>> np.quantile(a, 0.5)\n    3.5\n    >>> np.quantile(a, 0.5, axis=0)\n    array([6.5, 4.5, 2.5])\n    >>> np.quantile(a, 0.5, axis=1)\n    array([7.,  2.])\n    >>> np.quantile(a, 0.5, axis=1, keepdims=True)\n    array([[7.],\n           [2.]])\n    >>> m = np.quantile(a, 0.5, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.quantile(a, 0.5, axis=0, out=out)\n    array([6.5, 4.5, 2.5])\n    >>> m\n    array([6.5, 4.5, 2.5])\n    >>> b = a.copy()\n    >>> np.quantile(b, 0.5, axis=1, overwrite_input=True)\n    array([7.,  2.])\n    >>> assert not np.all(a == b)\n\n    See also `numpy.percentile` for a visualization of most methods.\n\n    References\n    ----------\n    .. [1] R. J. Hyndman and Y. Fan,\n       \"Sample quantiles in statistical packages,\"\n       The American Statistician, 50(4), pp. 361-365, 1996\n\n    \"\"\"\n    if interpolation is not None:\n        method = _check_interpolation_as_method(\n            method, interpolation, \"quantile\")\n\n    a = np.asanyarray(a)\n    if a.dtype.kind == \"c\":\n        raise TypeError(\"a must be an array of real numbers\")\n\n    # Use dtype of array if possible (e.g., if q is a python int or float).\n    if isinstance(q, (int, float)) and a.dtype.kind == \"f\":\n        q = np.asanyarray(q, dtype=a.dtype)\n    else:\n        q = np.asanyarray(q)\n\n    if not _quantile_is_valid(q):\n        raise ValueError(\"Quantiles must be in the range [0, 1]\")\n\n    if weights is not None:\n        if method != \"inverted_cdf\":\n            msg = (\"Only method 'inverted_cdf' supports weights. \"\n                   f\"Got: {method}.\")\n            raise ValueError(msg)\n        if axis is not None:\n            axis = _nx.normalize_axis_tuple(axis, a.ndim, argname=\"axis\")\n        weights = _weights_are_valid(weights=weights, a=a, axis=axis)\n        if np.any(weights < 0):\n            raise ValueError(\"Weights must be non-negative.\")\n\n    return _quantile_unchecked(\n        a, q, axis, out, overwrite_input, method, keepdims, weights)\n\n\ndef _quantile_unchecked(a,\n                        q,\n                        axis=None,\n                        out=None,\n                        overwrite_input=False,\n                        method=\"linear\",\n                        keepdims=False,\n                        weights=None):\n    \"\"\"Assumes that q is in [0, 1], and is an ndarray\"\"\"\n    return _ureduce(a,\n                    func=_quantile_ureduce_func,\n                    q=q,\n                    weights=weights,\n                    keepdims=keepdims,\n                    axis=axis,\n                    out=out,\n                    overwrite_input=overwrite_input,\n                    method=method)\n\n\ndef _quantile_is_valid(q):\n    # avoid expensive reductions, relevant for arrays with < O(1000) elements\n    if q.ndim == 1 and q.size < 10:\n        for i in range(q.size):\n            if not (0.0 <= q[i] <= 1.0):\n                return False\n    else:\n        if not (q.min() >= 0 and q.max() <= 1):\n            return False\n    return True\n\n\ndef _check_interpolation_as_method(method, interpolation, fname):\n    # Deprecated NumPy 1.22, 2021-11-08\n    warnings.warn(\n        f\"the `interpolation=` argument to {fname} was renamed to \"\n        \"`method=`, which has additional options.\\n\"\n        \"Users of the modes 'nearest', 'lower', 'higher', or \"\n        \"'midpoint' are encouraged to review the method they used. \"\n        \"(Deprecated NumPy 1.22)\",\n        DeprecationWarning, stacklevel=4)\n    if method != \"linear\":\n        # sanity check, we assume this basically never happens\n        raise TypeError(\n            \"You shall not pass both `method` and `interpolation`!\\n\"\n            \"(`interpolation` is Deprecated in favor of `method`)\")\n    return interpolation\n\n\ndef _compute_virtual_index(n, quantiles, alpha: float, beta: float):\n    \"\"\"\n    Compute the floating point indexes of an array for the linear\n    interpolation of quantiles.\n    n : array_like\n        The sample sizes.\n    quantiles : array_like\n        The quantiles values.\n    alpha : float\n        A constant used to correct the index computed.\n    beta : float\n        A constant used to correct the index computed.\n\n    alpha and beta values depend on the chosen method\n    (see quantile documentation)\n\n    Reference:\n    Hyndman&Fan paper \"Sample Quantiles in Statistical Packages\",\n    DOI: 10.1080/00031305.1996.10473566\n    \"\"\"\n    return n * quantiles + (\n            alpha + quantiles * (1 - alpha - beta)\n    ) - 1\n\n\ndef _get_gamma(virtual_indexes, previous_indexes, method):\n    \"\"\"\n    Compute gamma (a.k.a 'm' or 'weight') for the linear interpolation\n    of quantiles.\n\n    virtual_indexes : array_like\n        The indexes where the percentile is supposed to be found in the sorted\n        sample.\n    previous_indexes : array_like\n        The floor values of virtual_indexes.\n    interpolation : dict\n        The interpolation method chosen, which may have a specific rule\n        modifying gamma.\n\n    gamma is usually the fractional part of virtual_indexes but can be modified\n    by the interpolation method.\n    \"\"\"\n    gamma = np.asanyarray(virtual_indexes - previous_indexes)\n    gamma = method[\"fix_gamma\"](gamma, virtual_indexes)\n    # Ensure both that we have an array, and that we keep the dtype\n    # (which may have been matched to the input array).\n    return np.asanyarray(gamma, dtype=virtual_indexes.dtype)\n\n\ndef _lerp(a, b, t, out=None):\n    \"\"\"\n    Compute the linear interpolation weighted by gamma on each point of\n    two same shape array.\n\n    a : array_like\n        Left bound.\n    b : array_like\n        Right bound.\n    t : array_like\n        The interpolation weight.\n    out : array_like\n        Output array.\n    \"\"\"\n    diff_b_a = subtract(b, a)\n    # asanyarray is a stop-gap until gh-13105\n    lerp_interpolation = asanyarray(add(a, diff_b_a * t, out=out))\n    subtract(b, diff_b_a * (1 - t), out=lerp_interpolation, where=t >= 0.5,\n             casting='unsafe', dtype=type(lerp_interpolation.dtype))\n    if lerp_interpolation.ndim == 0 and out is None:\n        lerp_interpolation = lerp_interpolation[()]  # unpack 0d arrays\n    return lerp_interpolation\n\n\ndef _get_gamma_mask(shape, default_value, conditioned_value, where):\n    out = np.full(shape, default_value)\n    np.copyto(out, conditioned_value, where=where, casting=\"unsafe\")\n    return out\n\n\ndef _discrete_interpolation_to_boundaries(index, gamma_condition_fun):\n    previous = np.floor(index)\n    next = previous + 1\n    gamma = index - previous\n    res = _get_gamma_mask(shape=index.shape,\n                          default_value=next,\n                          conditioned_value=previous,\n                          where=gamma_condition_fun(gamma, index)\n                          ).astype(np.intp)\n    # Some methods can lead to out-of-bound integers, clip them:\n    res[res < 0] = 0\n    return res\n\n\ndef _closest_observation(n, quantiles):\n    # \"choose the nearest even order statistic at g=0\" (H&F (1996) pp. 362).\n    # Order is 1-based so for zero-based indexing round to nearest odd index.\n    gamma_fun = lambda gamma, index: (gamma == 0) & (np.floor(index) % 2 == 1)\n    return _discrete_interpolation_to_boundaries((n * quantiles) - 1 - 0.5,\n                                                 gamma_fun)\n\n\ndef _inverted_cdf(n, quantiles):\n    gamma_fun = lambda gamma, _: (gamma == 0)\n    return _discrete_interpolation_to_boundaries((n * quantiles) - 1,\n                                                 gamma_fun)\n\n\ndef _quantile_ureduce_func(\n        a: np.array,\n        q: np.array,\n        weights: np.array,\n        axis: int | None = None,\n        out=None,\n        overwrite_input: bool = False,\n        method=\"linear\",\n) -> np.array:\n    if q.ndim > 2:\n        # The code below works fine for nd, but it might not have useful\n        # semantics. For now, keep the supported dimensions the same as it was\n        # before.\n        raise ValueError(\"q must be a scalar or 1d\")\n    if overwrite_input:\n        if axis is None:\n            axis = 0\n            arr = a.ravel()\n            wgt = None if weights is None else weights.ravel()\n        else:\n            arr = a\n            wgt = weights\n    else:\n        if axis is None:\n            axis = 0\n            arr = a.flatten()\n            wgt = None if weights is None else weights.flatten()\n        else:\n            arr = a.copy()\n            wgt = weights\n    result = _quantile(arr,\n                       quantiles=q,\n                       axis=axis,\n                       method=method,\n                       out=out,\n                       weights=wgt)\n    return result\n\n\ndef _get_indexes(arr, virtual_indexes, valid_values_count):\n    \"\"\"\n    Get the valid indexes of arr neighbouring virtual_indexes.\n    Note\n    This is a companion function to linear interpolation of\n    Quantiles\n\n    Returns\n    -------\n    (previous_indexes, next_indexes): Tuple\n        A Tuple of virtual_indexes neighbouring indexes\n    \"\"\"\n    previous_indexes = np.asanyarray(np.floor(virtual_indexes))\n    next_indexes = np.asanyarray(previous_indexes + 1)\n    indexes_above_bounds = virtual_indexes >= valid_values_count - 1\n    # When indexes is above max index, take the max value of the array\n    if indexes_above_bounds.any():\n        previous_indexes[indexes_above_bounds] = -1\n        next_indexes[indexes_above_bounds] = -1\n    # When indexes is below min index, take the min value of the array\n    indexes_below_bounds = virtual_indexes < 0\n    if indexes_below_bounds.any():\n        previous_indexes[indexes_below_bounds] = 0\n        next_indexes[indexes_below_bounds] = 0\n    if np.issubdtype(arr.dtype, np.inexact):\n        # After the sort, slices having NaNs will have for last element a NaN\n        virtual_indexes_nans = np.isnan(virtual_indexes)\n        if virtual_indexes_nans.any():\n            previous_indexes[virtual_indexes_nans] = -1\n            next_indexes[virtual_indexes_nans] = -1\n    previous_indexes = previous_indexes.astype(np.intp)\n    next_indexes = next_indexes.astype(np.intp)\n    return previous_indexes, next_indexes\n\n\ndef _quantile(\n        arr: np.array,\n        quantiles: np.array,\n        axis: int = -1,\n        method=\"linear\",\n        out=None,\n        weights=None,\n):\n    \"\"\"\n    Private function that doesn't support extended axis or keepdims.\n    These methods are extended to this function using _ureduce\n    See nanpercentile for parameter usage\n    It computes the quantiles of the array for the given axis.\n    A linear interpolation is performed based on the `interpolation`.\n\n    By default, the method is \"linear\" where alpha == beta == 1 which\n    performs the 7th method of Hyndman&Fan.\n    With \"median_unbiased\" we get alpha == beta == 1/3\n    thus the 8th method of Hyndman&Fan.\n    \"\"\"\n    # --- Setup\n    arr = np.asanyarray(arr)\n    values_count = arr.shape[axis]\n    # The dimensions of `q` are prepended to the output shape, so we need the\n    # axis being sampled from `arr` to be last.\n    if axis != 0:  # But moveaxis is slow, so only call it if necessary.\n        arr = np.moveaxis(arr, axis, destination=0)\n    supports_nans = (\n        np.issubdtype(arr.dtype, np.inexact) or arr.dtype.kind in 'Mm'\n    )\n\n    if weights is None:\n        # --- Computation of indexes\n        # Index where to find the value in the sorted array.\n        # Virtual because it is a floating point value, not an valid index.\n        # The nearest neighbours are used for interpolation\n        try:\n            method_props = _QuantileMethods[method]\n        except KeyError:\n            raise ValueError(\n                f\"{method!r} is not a valid method. Use one of: \"\n                f\"{_QuantileMethods.keys()}\") from None\n        virtual_indexes = method_props[\"get_virtual_index\"](values_count,\n                                                            quantiles)\n        virtual_indexes = np.asanyarray(virtual_indexes)\n\n        if method_props[\"fix_gamma\"] is None:\n            supports_integers = True\n        else:\n            int_virtual_indices = np.issubdtype(virtual_indexes.dtype,\n                                                np.integer)\n            supports_integers = method == 'linear' and int_virtual_indices\n\n        if supports_integers:\n            # No interpolation needed, take the points along axis\n            if supports_nans:\n                # may contain nan, which would sort to the end\n                arr.partition(\n                    concatenate((virtual_indexes.ravel(), [-1])), axis=0,\n                )\n                slices_having_nans = np.isnan(arr[-1, ...])\n            else:\n                # cannot contain nan\n                arr.partition(virtual_indexes.ravel(), axis=0)\n                slices_having_nans = np.array(False, dtype=bool)\n            result = take(arr, virtual_indexes, axis=0, out=out)\n        else:\n            previous_indexes, next_indexes = _get_indexes(arr,\n                                                          virtual_indexes,\n                                                          values_count)\n            # --- Sorting\n            arr.partition(\n                np.unique(np.concatenate(([0, -1],\n                                          previous_indexes.ravel(),\n                                          next_indexes.ravel(),\n                                          ))),\n                axis=0)\n            if supports_nans:\n                slices_having_nans = np.isnan(arr[-1, ...])\n            else:\n                slices_having_nans = None\n            # --- Get values from indexes\n            previous = arr[previous_indexes]\n            next = arr[next_indexes]\n            # --- Linear interpolation\n            gamma = _get_gamma(virtual_indexes, previous_indexes, method_props)\n            result_shape = virtual_indexes.shape + (1,) * (arr.ndim - 1)\n            gamma = gamma.reshape(result_shape)\n            result = _lerp(previous,\n                        next,\n                        gamma,\n                        out=out)\n    else:\n        # Weighted case\n        # This implements method=\"inverted_cdf\", the only supported weighted\n        # method, which needs to sort anyway.\n        weights = np.asanyarray(weights)\n        if axis != 0:\n            weights = np.moveaxis(weights, axis, destination=0)\n        index_array = np.argsort(arr, axis=0, kind=\"stable\")\n\n        # arr = arr[index_array, ...]  # but this adds trailing dimensions of\n        # 1.\n        arr = np.take_along_axis(arr, index_array, axis=0)\n        if weights.shape == arr.shape:\n            weights = np.take_along_axis(weights, index_array, axis=0)\n        else:\n            # weights is 1d\n            weights = weights.reshape(-1)[index_array, ...]\n\n        if supports_nans:\n            # may contain nan, which would sort to the end\n            slices_having_nans = np.isnan(arr[-1, ...])\n        else:\n            # cannot contain nan\n            slices_having_nans = np.array(False, dtype=bool)\n\n        # We use the weights to calculate the empirical cumulative\n        # distribution function cdf\n        cdf = weights.cumsum(axis=0, dtype=np.float64)\n        cdf /= cdf[-1, ...]  # normalization to 1\n        # Search index i such that\n        #   sum(weights[j], j=0..i-1) < quantile <= sum(weights[j], j=0..i)\n        # is then equivalent to\n        #   cdf[i-1] < quantile <= cdf[i]\n        # Unfortunately, searchsorted only accepts 1-d arrays as first\n        # argument, so we will need to iterate over dimensions.\n\n        # Without the following cast, searchsorted can return surprising\n        # results, e.g.\n        #   np.searchsorted(np.array([0.2, 0.4, 0.6, 0.8, 1.]),\n        #                   np.array(0.4, dtype=np.float32), side=\"left\")\n        # returns 2 instead of 1 because 0.4 is not binary representable.\n        if quantiles.dtype.kind == \"f\":\n            cdf = cdf.astype(quantiles.dtype)\n        # Weights must be non-negative, so we might have zero weights at the\n        # beginning leading to some leading zeros in cdf. The call to\n        # np.searchsorted for quantiles=0 will then pick the first element,\n        # but should pick the first one larger than zero. We\n        # therefore simply set 0 values in cdf to -1.\n        if np.any(cdf[0, ...] == 0):\n            cdf[cdf == 0] = -1\n\n        def find_cdf_1d(arr, cdf):\n            indices = np.searchsorted(cdf, quantiles, side=\"left\")\n            # We might have reached the maximum with i = len(arr), e.g. for\n            # quantiles = 1, and need to cut it to len(arr) - 1.\n            indices = minimum(indices, values_count - 1)\n            result = take(arr, indices, axis=0)\n            return result\n\n        r_shape = arr.shape[1:]\n        if quantiles.ndim > 0:\n            r_shape = quantiles.shape + r_shape\n        if out is None:\n            result = np.empty_like(arr, shape=r_shape)\n        else:\n            if out.shape != r_shape:\n                msg = (f\"Wrong shape of argument 'out', shape={r_shape} is \"\n                       f\"required; got shape={out.shape}.\")\n                raise ValueError(msg)\n            result = out\n\n        # See apply_along_axis, which we do for axis=0. Note that Ni = (,)\n        # always, so we remove it here.\n        Nk = arr.shape[1:]\n        for kk in np.ndindex(Nk):\n            result[(...,) + kk] = find_cdf_1d(\n                arr[np.s_[:, ] + kk], cdf[np.s_[:, ] + kk]\n            )\n\n        # Make result the same as in unweighted inverted_cdf.\n        if result.shape == () and result.dtype == np.dtype(\"O\"):\n            result = result.item()\n\n    if np.any(slices_having_nans):\n        if result.ndim == 0 and out is None:\n            # can't write to a scalar, but indexing will be correct\n            result = arr[-1]\n        else:\n            np.copyto(result, arr[-1, ...], where=slices_having_nans)\n    return result\n\n\ndef _trapezoid_dispatcher(y, x=None, dx=None, axis=None):\n    return (y, x)\n\n\n@array_function_dispatch(_trapezoid_dispatcher)\ndef trapezoid(y, x=None, dx=1.0, axis=-1):\n    r\"\"\"\n    Integrate along the given axis using the composite trapezoidal rule.\n\n    If `x` is provided, the integration happens in sequence along its\n    elements - they are not sorted.\n\n    Integrate `y` (`x`) along each 1d slice on the given axis, compute\n    :math:`\\int y(x) dx`.\n    When `x` is specified, this integrates along the parametric curve,\n    computing :math:`\\int_t y(t) dt =\n    \\int_t y(t) \\left.\\frac{dx}{dt}\\right|_{x=x(t)} dt`.\n\n    .. versionadded:: 2.0.0\n\n    Parameters\n    ----------\n    y : array_like\n        Input array to integrate.\n    x : array_like, optional\n        The sample points corresponding to the `y` values. If `x` is None,\n        the sample points are assumed to be evenly spaced `dx` apart. The\n        default is None.\n    dx : scalar, optional\n        The spacing between sample points when `x` is None. The default is 1.\n    axis : int, optional\n        The axis along which to integrate.\n\n    Returns\n    -------\n    trapezoid : float or ndarray\n        Definite integral of `y` = n-dimensional array as approximated along\n        a single axis by the trapezoidal rule. If `y` is a 1-dimensional array,\n        then the result is a float. If `n` is greater than 1, then the result\n        is an `n`-1 dimensional array.\n\n    See Also\n    --------\n    sum, cumsum\n\n    Notes\n    -----\n    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points\n    will be taken from `y` array, by default x-axis distances between\n    points will be 1.0, alternatively they can be provided with `x` array\n    or with `dx` scalar.  Return value will be equal to combined area under\n    the red lines.\n\n\n    References\n    ----------\n    .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule\n\n    .. [2] Illustration image:\n           https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    Use the trapezoidal rule on evenly spaced points:\n\n    >>> np.trapezoid([1, 2, 3])\n    4.0\n\n    The spacing between sample points can be selected by either the\n    ``x`` or ``dx`` arguments:\n\n    >>> np.trapezoid([1, 2, 3], x=[4, 6, 8])\n    8.0\n    >>> np.trapezoid([1, 2, 3], dx=2)\n    8.0\n\n    Using a decreasing ``x`` corresponds to integrating in reverse:\n\n    >>> np.trapezoid([1, 2, 3], x=[8, 6, 4])\n    -8.0\n\n    More generally ``x`` is used to integrate along a parametric curve. We can\n    estimate the integral :math:`\\int_0^1 x^2 = 1/3` using:\n\n    >>> x = np.linspace(0, 1, num=50)\n    >>> y = x**2\n    >>> np.trapezoid(y, x)\n    0.33340274885464394\n\n    Or estimate the area of a circle, noting we repeat the sample which closes\n    the curve:\n\n    >>> theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True)\n    >>> np.trapezoid(np.cos(theta), x=np.sin(theta))\n    3.141571941375841\n\n    ``np.trapezoid`` can be applied along a specified axis to do multiple\n    computations in one call:\n\n    >>> a = np.arange(6).reshape(2, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.trapezoid(a, axis=0)\n    array([1.5, 2.5, 3.5])\n    >>> np.trapezoid(a, axis=1)\n    array([2.,  8.])\n    \"\"\"\n\n    y = asanyarray(y)\n    if x is None:\n        d = dx\n    else:\n        x = asanyarray(x)\n        if x.ndim == 1:\n            d = diff(x)\n            # reshape to correct shape\n            shape = [1]*y.ndim\n            shape[axis] = d.shape[0]\n            d = d.reshape(shape)\n        else:\n            d = diff(x, axis=axis)\n    nd = y.ndim\n    slice1 = [slice(None)]*nd\n    slice2 = [slice(None)]*nd\n    slice1[axis] = slice(1, None)\n    slice2[axis] = slice(None, -1)\n    try:\n        ret = (d * (y[tuple(slice1)] + y[tuple(slice2)]) / 2.0).sum(axis)\n    except ValueError:\n        # Operations didn't work, cast to ndarray\n        d = np.asarray(d)\n        y = np.asarray(y)\n        ret = add.reduce(d * (y[tuple(slice1)]+y[tuple(slice2)])/2.0, axis)\n    return ret\n\n\n@set_module('numpy')\ndef trapz(y, x=None, dx=1.0, axis=-1):\n    \"\"\"\n    `trapz` is deprecated in NumPy 2.0.\n\n    Please use `trapezoid` instead, or one of the numerical integration\n    functions in `scipy.integrate`.\n    \"\"\"\n    # Deprecated in NumPy 2.0, 2023-08-18\n    warnings.warn(\n        \"`trapz` is deprecated. Use `trapezoid` instead, or one of the \"\n        \"numerical integration functions in `scipy.integrate`.\",\n        DeprecationWarning,\n        stacklevel=2\n    )\n    return trapezoid(y, x=x, dx=dx, axis=axis)\n\n\ndef _meshgrid_dispatcher(*xi, copy=None, sparse=None, indexing=None):\n    return xi\n\n\n# Based on scitools meshgrid\n@array_function_dispatch(_meshgrid_dispatcher)\ndef meshgrid(*xi, copy=True, sparse=False, indexing='xy'):\n    \"\"\"\n    Return a tuple of coordinate matrices from coordinate vectors.\n\n    Make N-D coordinate arrays for vectorized evaluations of\n    N-D scalar/vector fields over N-D grids, given\n    one-dimensional coordinate arrays x1, x2,..., xn.\n\n    Parameters\n    ----------\n    x1, x2,..., xn : array_like\n        1-D arrays representing the coordinates of a grid.\n    indexing : {'xy', 'ij'}, optional\n        Cartesian ('xy', default) or matrix ('ij') indexing of output.\n        See Notes for more details.\n    sparse : bool, optional\n        If True the shape of the returned coordinate array for dimension *i*\n        is reduced from ``(N1, ..., Ni, ... Nn)`` to\n        ``(1, ..., 1, Ni, 1, ..., 1)``.  These sparse coordinate grids are\n        intended to be use with :ref:`basics.broadcasting`.  When all\n        coordinates are used in an expression, broadcasting still leads to a\n        fully-dimensonal result array.\n\n        Default is False.\n\n    copy : bool, optional\n        If False, a view into the original arrays are returned in order to\n        conserve memory.  Default is True.  Please note that\n        ``sparse=False, copy=False`` will likely return non-contiguous\n        arrays.  Furthermore, more than one element of a broadcast array\n        may refer to a single memory location.  If you need to write to the\n        arrays, make copies first.\n\n    Returns\n    -------\n    X1, X2,..., XN : tuple of ndarrays\n        For vectors `x1`, `x2`,..., `xn` with lengths ``Ni=len(xi)``,\n        returns ``(N1, N2, N3,..., Nn)`` shaped arrays if indexing='ij'\n        or ``(N2, N1, N3,..., Nn)`` shaped arrays if indexing='xy'\n        with the elements of `xi` repeated to fill the matrix along\n        the first dimension for `x1`, the second for `x2` and so on.\n\n    Notes\n    -----\n    This function supports both indexing conventions through the indexing\n    keyword argument.  Giving the string 'ij' returns a meshgrid with\n    matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing.\n    In the 2-D case with inputs of length M and N, the outputs are of shape\n    (N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case\n    with inputs of length M, N and P, outputs are of shape (N, M, P) for\n    'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is\n    illustrated by the following code snippet::\n\n        xv, yv = np.meshgrid(x, y, indexing='ij')\n        for i in range(nx):\n            for j in range(ny):\n                # treat xv[i,j], yv[i,j]\n\n        xv, yv = np.meshgrid(x, y, indexing='xy')\n        for i in range(nx):\n            for j in range(ny):\n                # treat xv[j,i], yv[j,i]\n\n    In the 1-D and 0-D case, the indexing and sparse keywords have no effect.\n\n    See Also\n    --------\n    mgrid : Construct a multi-dimensional \"meshgrid\" using indexing notation.\n    ogrid : Construct an open multi-dimensional \"meshgrid\" using indexing\n            notation.\n    :ref:`how-to-index`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> nx, ny = (3, 2)\n    >>> x = np.linspace(0, 1, nx)\n    >>> y = np.linspace(0, 1, ny)\n    >>> xv, yv = np.meshgrid(x, y)\n    >>> xv\n    array([[0. , 0.5, 1. ],\n           [0. , 0.5, 1. ]])\n    >>> yv\n    array([[0.,  0.,  0.],\n           [1.,  1.,  1.]])\n\n    The result of `meshgrid` is a coordinate grid:\n\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(xv, yv, marker='o', color='k', linestyle='none')\n    >>> plt.show()\n\n    You can create sparse output arrays to save memory and computation time.\n\n    >>> xv, yv = np.meshgrid(x, y, sparse=True)\n    >>> xv\n    array([[0. ,  0.5,  1. ]])\n    >>> yv\n    array([[0.],\n           [1.]])\n\n    `meshgrid` is very useful to evaluate functions on a grid. If the\n    function depends on all coordinates, both dense and sparse outputs can be\n    used.\n\n    >>> x = np.linspace(-5, 5, 101)\n    >>> y = np.linspace(-5, 5, 101)\n    >>> # full coordinate arrays\n    >>> xx, yy = np.meshgrid(x, y)\n    >>> zz = np.sqrt(xx**2 + yy**2)\n    >>> xx.shape, yy.shape, zz.shape\n    ((101, 101), (101, 101), (101, 101))\n    >>> # sparse coordinate arrays\n    >>> xs, ys = np.meshgrid(x, y, sparse=True)\n    >>> zs = np.sqrt(xs**2 + ys**2)\n    >>> xs.shape, ys.shape, zs.shape\n    ((1, 101), (101, 1), (101, 101))\n    >>> np.array_equal(zz, zs)\n    True\n\n    >>> h = plt.contourf(x, y, zs)\n    >>> plt.axis('scaled')\n    >>> plt.colorbar()\n    >>> plt.show()\n    \"\"\"\n    ndim = len(xi)\n\n    if indexing not in ['xy', 'ij']:\n        raise ValueError(\n            \"Valid values for `indexing` are 'xy' and 'ij'.\")\n\n    s0 = (1,) * ndim\n    output = [np.asanyarray(x).reshape(s0[:i] + (-1,) + s0[i + 1:])\n              for i, x in enumerate(xi)]\n\n    if indexing == 'xy' and ndim > 1:\n        # switch first and second axis\n        output[0].shape = (1, -1) + s0[2:]\n        output[1].shape = (-1, 1) + s0[2:]\n\n    if not sparse:\n        # Return the full N-D matrix (not only the 1-D vector)\n        output = np.broadcast_arrays(*output, subok=True)\n\n    if copy:\n        output = tuple(x.copy() for x in output)\n\n    return output\n\n\ndef _delete_dispatcher(arr, obj, axis=None):\n    return (arr, obj)\n\n\n@array_function_dispatch(_delete_dispatcher)\ndef delete(arr, obj, axis=None):\n    \"\"\"\n    Return a new array with sub-arrays along an axis deleted. For a one\n    dimensional array, this returns those entries not returned by\n    `arr[obj]`.\n\n    Parameters\n    ----------\n    arr : array_like\n        Input array.\n    obj : slice, int, array-like of ints or bools\n        Indicate indices of sub-arrays to remove along the specified axis.\n\n        .. versionchanged:: 1.19.0\n            Boolean indices are now treated as a mask of elements to remove,\n            rather than being cast to the integers 0 and 1.\n\n    axis : int, optional\n        The axis along which to delete the subarray defined by `obj`.\n        If `axis` is None, `obj` is applied to the flattened array.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with the elements specified by `obj` removed. Note\n        that `delete` does not occur in-place. If `axis` is None, `out` is\n        a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    append : Append elements at the end of an array.\n\n    Notes\n    -----\n    Often it is preferable to use a boolean mask. For example:\n\n    >>> arr = np.arange(12) + 1\n    >>> mask = np.ones(len(arr), dtype=bool)\n    >>> mask[[0,2,4]] = False\n    >>> result = arr[mask,...]\n\n    Is equivalent to ``np.delete(arr, [0,2,4], axis=0)``, but allows further\n    use of `mask`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\n    >>> arr\n    array([[ 1,  2,  3,  4],\n           [ 5,  6,  7,  8],\n           [ 9, 10, 11, 12]])\n    >>> np.delete(arr, 1, 0)\n    array([[ 1,  2,  3,  4],\n           [ 9, 10, 11, 12]])\n\n    >>> np.delete(arr, np.s_[::2], 1)\n    array([[ 2,  4],\n           [ 6,  8],\n           [10, 12]])\n    >>> np.delete(arr, [1,3,5], None)\n    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])\n\n    \"\"\"\n    conv = _array_converter(arr)\n    arr, = conv.as_arrays(subok=False)\n\n    ndim = arr.ndim\n    arrorder = 'F' if arr.flags.fnc else 'C'\n    if axis is None:\n        if ndim != 1:\n            arr = arr.ravel()\n        # needed for np.matrix, which is still not 1d after being ravelled\n        ndim = arr.ndim\n        axis = ndim - 1\n    else:\n        axis = normalize_axis_index(axis, ndim)\n\n    slobj = [slice(None)]*ndim\n    N = arr.shape[axis]\n    newshape = list(arr.shape)\n\n    if isinstance(obj, slice):\n        start, stop, step = obj.indices(N)\n        xr = range(start, stop, step)\n        numtodel = len(xr)\n\n        if numtodel <= 0:\n            return conv.wrap(arr.copy(order=arrorder), to_scalar=False)\n\n        # Invert if step is negative:\n        if step < 0:\n            step = -step\n            start = xr[-1]\n            stop = xr[0] + 1\n\n        newshape[axis] -= numtodel\n        new = empty(newshape, arr.dtype, arrorder)\n        # copy initial chunk\n        if start == 0:\n            pass\n        else:\n            slobj[axis] = slice(None, start)\n            new[tuple(slobj)] = arr[tuple(slobj)]\n        # copy end chunk\n        if stop == N:\n            pass\n        else:\n            slobj[axis] = slice(stop-numtodel, None)\n            slobj2 = [slice(None)]*ndim\n            slobj2[axis] = slice(stop, None)\n            new[tuple(slobj)] = arr[tuple(slobj2)]\n        # copy middle pieces\n        if step == 1:\n            pass\n        else:  # use array indexing.\n            keep = ones(stop-start, dtype=bool)\n            keep[:stop-start:step] = False\n            slobj[axis] = slice(start, stop-numtodel)\n            slobj2 = [slice(None)]*ndim\n            slobj2[axis] = slice(start, stop)\n            arr = arr[tuple(slobj2)]\n            slobj2[axis] = keep\n            new[tuple(slobj)] = arr[tuple(slobj2)]\n\n        return conv.wrap(new, to_scalar=False)\n\n    if isinstance(obj, (int, integer)) and not isinstance(obj, bool):\n        single_value = True\n    else:\n        single_value = False\n        _obj = obj\n        obj = np.asarray(obj)\n        # `size == 0` to allow empty lists similar to indexing, but (as there)\n        # is really too generic:\n        if obj.size == 0 and not isinstance(_obj, np.ndarray):\n            obj = obj.astype(intp)\n        elif obj.size == 1 and obj.dtype.kind in \"ui\":\n            # For a size 1 integer array we can use the single-value path\n            # (most dtypes, except boolean, should just fail later).\n            obj = obj.item()\n            single_value = True\n\n    if single_value:\n        # optimization for a single value\n        if (obj < -N or obj >= N):\n            raise IndexError(\n                \"index %i is out of bounds for axis %i with \"\n                \"size %i\" % (obj, axis, N))\n        if (obj < 0):\n            obj += N\n        newshape[axis] -= 1\n        new = empty(newshape, arr.dtype, arrorder)\n        slobj[axis] = slice(None, obj)\n        new[tuple(slobj)] = arr[tuple(slobj)]\n        slobj[axis] = slice(obj, None)\n        slobj2 = [slice(None)]*ndim\n        slobj2[axis] = slice(obj+1, None)\n        new[tuple(slobj)] = arr[tuple(slobj2)]\n    else:\n        if obj.dtype == bool:\n            if obj.shape != (N,):\n                raise ValueError('boolean array argument obj to delete '\n                                 'must be one dimensional and match the axis '\n                                 'length of {}'.format(N))\n\n            # optimization, the other branch is slower\n            keep = ~obj\n        else:\n            keep = ones(N, dtype=bool)\n            keep[obj,] = False\n\n        slobj[axis] = keep\n        new = arr[tuple(slobj)]\n\n    return conv.wrap(new, to_scalar=False)\n\n\ndef _insert_dispatcher(arr, obj, values, axis=None):\n    return (arr, obj, values)\n\n\n@array_function_dispatch(_insert_dispatcher)\ndef insert(arr, obj, values, axis=None):\n    \"\"\"\n    Insert values along the given axis before the given indices.\n\n    Parameters\n    ----------\n    arr : array_like\n        Input array.\n    obj : slice, int, array-like of ints or bools\n        Object that defines the index or indices before which `values` is\n        inserted.\n\n        .. versionchanged:: 2.1.2\n            Boolean indices are now treated as a mask of elements to insert,\n            rather than being cast to the integers 0 and 1.\n\n        Support for multiple insertions when `obj` is a single scalar or a\n        sequence with one element (similar to calling insert multiple\n        times).\n    values : array_like\n        Values to insert into `arr`. If the type of `values` is different\n        from that of `arr`, `values` is converted to the type of `arr`.\n        `values` should be shaped so that ``arr[...,obj,...] = values``\n        is legal.\n    axis : int, optional\n        Axis along which to insert `values`.  If `axis` is None then `arr`\n        is flattened first.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with `values` inserted.  Note that `insert`\n        does not occur in-place: a new array is returned. If\n        `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    append : Append elements at the end of an array.\n    concatenate : Join a sequence of arrays along an existing axis.\n    delete : Delete elements from an array.\n\n    Notes\n    -----\n    Note that for higher dimensional inserts ``obj=0`` behaves very different\n    from ``obj=[0]`` just like ``arr[:,0,:] = values`` is different from\n    ``arr[:,[0],:] = values``. This is because of the difference between basic\n    and advanced :ref:`indexing <basics.indexing>`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.arange(6).reshape(3, 2)\n    >>> a\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> np.insert(a, 1, 6)\n    array([0, 6, 1, 2, 3, 4, 5])\n    >>> np.insert(a, 1, 6, axis=1)\n    array([[0, 6, 1],\n           [2, 6, 3],\n           [4, 6, 5]])\n\n    Difference between sequence and scalars,\n    showing how ``obj=[1]`` behaves different from ``obj=1``:\n\n    >>> np.insert(a, [1], [[7],[8],[9]], axis=1)\n    array([[0, 7, 1],\n           [2, 8, 3],\n           [4, 9, 5]])\n    >>> np.insert(a, 1, [[7],[8],[9]], axis=1)\n    array([[0, 7, 8, 9, 1],\n           [2, 7, 8, 9, 3],\n           [4, 7, 8, 9, 5]])\n    >>> np.array_equal(np.insert(a, 1, [7, 8, 9], axis=1),\n    ...                np.insert(a, [1], [[7],[8],[9]], axis=1))\n    True\n\n    >>> b = a.flatten()\n    >>> b\n    array([0, 1, 2, 3, 4, 5])\n    >>> np.insert(b, [2, 2], [6, 7])\n    array([0, 1, 6, 7, 2, 3, 4, 5])\n\n    >>> np.insert(b, slice(2, 4), [7, 8])\n    array([0, 1, 7, 2, 8, 3, 4, 5])\n\n    >>> np.insert(b, [2, 2], [7.13, False]) # type casting\n    array([0, 1, 7, 0, 2, 3, 4, 5])\n\n    >>> x = np.arange(8).reshape(2, 4)\n    >>> idx = (1, 3)\n    >>> np.insert(x, idx, 999, axis=1)\n    array([[  0, 999,   1,   2, 999,   3],\n           [  4, 999,   5,   6, 999,   7]])\n\n    \"\"\"\n    conv = _array_converter(arr)\n    arr, = conv.as_arrays(subok=False)\n\n    ndim = arr.ndim\n    arrorder = 'F' if arr.flags.fnc else 'C'\n    if axis is None:\n        if ndim != 1:\n            arr = arr.ravel()\n        # needed for np.matrix, which is still not 1d after being ravelled\n        ndim = arr.ndim\n        axis = ndim - 1\n    else:\n        axis = normalize_axis_index(axis, ndim)\n    slobj = [slice(None)]*ndim\n    N = arr.shape[axis]\n    newshape = list(arr.shape)\n\n    if isinstance(obj, slice):\n        # turn it into a range object\n        indices = arange(*obj.indices(N), dtype=intp)\n    else:\n        # need to copy obj, because indices will be changed in-place\n        indices = np.array(obj)\n        if indices.dtype == bool:\n            if obj.ndim != 1:\n                raise ValueError('boolean array argument obj to insert '\n                                'must be one dimensional')\n            indices = np.flatnonzero(obj)\n        elif indices.ndim > 1:\n            raise ValueError(\n                \"index array argument obj to insert must be one dimensional \"\n                \"or scalar\")\n    if indices.size == 1:\n        index = indices.item()\n        if index < -N or index > N:\n            raise IndexError(f\"index {obj} is out of bounds for axis {axis} \"\n                             f\"with size {N}\")\n        if (index < 0):\n            index += N\n\n        # There are some object array corner cases here, but we cannot avoid\n        # that:\n        values = array(values, copy=None, ndmin=arr.ndim, dtype=arr.dtype)\n        if indices.ndim == 0:\n            # broadcasting is very different here, since a[:,0,:] = ... behaves\n            # very different from a[:,[0],:] = ...! This changes values so that\n            # it works likes the second case. (here a[:,0:1,:])\n            values = np.moveaxis(values, 0, axis)\n        numnew = values.shape[axis]\n        newshape[axis] += numnew\n        new = empty(newshape, arr.dtype, arrorder)\n        slobj[axis] = slice(None, index)\n        new[tuple(slobj)] = arr[tuple(slobj)]\n        slobj[axis] = slice(index, index+numnew)\n        new[tuple(slobj)] = values\n        slobj[axis] = slice(index+numnew, None)\n        slobj2 = [slice(None)] * ndim\n        slobj2[axis] = slice(index, None)\n        new[tuple(slobj)] = arr[tuple(slobj2)]\n\n        return conv.wrap(new, to_scalar=False)\n\n    elif indices.size == 0 and not isinstance(obj, np.ndarray):\n        # Can safely cast the empty list to intp\n        indices = indices.astype(intp)\n\n    indices[indices < 0] += N\n\n    numnew = len(indices)\n    order = indices.argsort(kind='mergesort')   # stable sort\n    indices[order] += np.arange(numnew)\n\n    newshape[axis] += numnew\n    old_mask = ones(newshape[axis], dtype=bool)\n    old_mask[indices] = False\n\n    new = empty(newshape, arr.dtype, arrorder)\n    slobj2 = [slice(None)]*ndim\n    slobj[axis] = indices\n    slobj2[axis] = old_mask\n    new[tuple(slobj)] = values\n    new[tuple(slobj2)] = arr\n\n    return conv.wrap(new, to_scalar=False)\n\n\ndef _append_dispatcher(arr, values, axis=None):\n    return (arr, values)\n\n\n@array_function_dispatch(_append_dispatcher)\ndef append(arr, values, axis=None):\n    \"\"\"\n    Append values to the end of an array.\n\n    Parameters\n    ----------\n    arr : array_like\n        Values are appended to a copy of this array.\n    values : array_like\n        These values are appended to a copy of `arr`.  It must be of the\n        correct shape (the same shape as `arr`, excluding `axis`).  If\n        `axis` is not specified, `values` can be any shape and will be\n        flattened before use.\n    axis : int, optional\n        The axis along which `values` are appended.  If `axis` is not\n        given, both `arr` and `values` are flattened before use.\n\n    Returns\n    -------\n    append : ndarray\n        A copy of `arr` with `values` appended to `axis`.  Note that\n        `append` does not occur in-place: a new array is allocated and\n        filled.  If `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    delete : Delete elements from an array.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\n    array([1, 2, 3, ..., 7, 8, 9])\n\n    When `axis` is specified, `values` must have the correct shape.\n\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)\n    array([[1, 2, 3],\n           [4, 5, 6],\n           [7, 8, 9]])\n\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: all the input arrays must have same number of dimensions, but\n    the array at index 0 has 2 dimension(s) and the array at index 1 has 1\n    dimension(s)\n\n    >>> a = np.array([1, 2], dtype=int)\n    >>> c = np.append(a, [])\n    >>> c\n    array([1., 2.])\n    >>> c.dtype\n    float64\n\n    Default dtype for empty ndarrays is `float64` thus making the output of dtype\n    `float64` when appended with dtype `int64`\n\n    \"\"\"\n    arr = asanyarray(arr)\n    if axis is None:\n        if arr.ndim != 1:\n            arr = arr.ravel()\n        values = ravel(values)\n        axis = arr.ndim-1\n    return concatenate((arr, values), axis=axis)\n\n\ndef _digitize_dispatcher(x, bins, right=None):\n    return (x, bins)\n\n\n@array_function_dispatch(_digitize_dispatcher)\ndef digitize(x, bins, right=False):\n    \"\"\"\n    Return the indices of the bins to which each value in input array belongs.\n\n    =========  =============  ============================\n    `right`    order of bins  returned index `i` satisfies\n    =========  =============  ============================\n    ``False``  increasing     ``bins[i-1] <= x < bins[i]``\n    ``True``   increasing     ``bins[i-1] < x <= bins[i]``\n    ``False``  decreasing     ``bins[i-1] > x >= bins[i]``\n    ``True``   decreasing     ``bins[i-1] >= x > bins[i]``\n    =========  =============  ============================\n\n    If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is\n    returned as appropriate.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array to be binned. Prior to NumPy 1.10.0, this array had to\n        be 1-dimensional, but can now have any shape.\n    bins : array_like\n        Array of bins. It has to be 1-dimensional and monotonic.\n    right : bool, optional\n        Indicating whether the intervals include the right or the left bin\n        edge. Default behavior is (right==False) indicating that the interval\n        does not include the right edge. The left bin end is open in this\n        case, i.e., bins[i-1] <= x < bins[i] is the default behavior for\n        monotonically increasing bins.\n\n    Returns\n    -------\n    indices : ndarray of ints\n        Output array of indices, of same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If `bins` is not monotonic.\n    TypeError\n        If the type of the input is complex.\n\n    See Also\n    --------\n    bincount, histogram, unique, searchsorted\n\n    Notes\n    -----\n    If values in `x` are such that they fall outside the bin range,\n    attempting to index `bins` with the indices that `digitize` returns\n    will result in an IndexError.\n\n    .. versionadded:: 1.10.0\n\n    `numpy.digitize` is  implemented in terms of `numpy.searchsorted`.\n    This means that a binary search is used to bin the values, which scales\n    much better for larger number of bins than the previous linear search.\n    It also removes the requirement for the input array to be 1-dimensional.\n\n    For monotonically *increasing* `bins`, the following are equivalent::\n\n        np.digitize(x, bins, right=True)\n        np.searchsorted(bins, x, side='left')\n\n    Note that as the order of the arguments are reversed, the side must be too.\n    The `searchsorted` call is marginally faster, as it does not do any\n    monotonicity checks. Perhaps more importantly, it supports all dtypes.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.array([0.2, 6.4, 3.0, 1.6])\n    >>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n    >>> inds = np.digitize(x, bins)\n    >>> inds\n    array([1, 4, 3, 2])\n    >>> for n in range(x.size):\n    ...   print(bins[inds[n]-1], \"<=\", x[n], \"<\", bins[inds[n]])\n    ...\n    0.0 <= 0.2 < 1.0\n    4.0 <= 6.4 < 10.0\n    2.5 <= 3.0 < 4.0\n    1.0 <= 1.6 < 2.5\n\n    >>> x = np.array([1.2, 10.0, 12.4, 15.5, 20.])\n    >>> bins = np.array([0, 5, 10, 15, 20])\n    >>> np.digitize(x,bins,right=True)\n    array([1, 2, 3, 4, 4])\n    >>> np.digitize(x,bins,right=False)\n    array([1, 3, 3, 4, 5])\n    \"\"\"\n    x = _nx.asarray(x)\n    bins = _nx.asarray(bins)\n\n    # here for compatibility, searchsorted below is happy to take this\n    if np.issubdtype(x.dtype, _nx.complexfloating):\n        raise TypeError(\"x may not be complex\")\n\n    mono = _monotonicity(bins)\n    if mono == 0:\n        raise ValueError(\"bins must be monotonically increasing or decreasing\")\n\n    # this is backwards because the arguments below are swapped\n    side = 'left' if right else 'right'\n    if mono == -1:\n        # reverse the bins, and invert the results\n        return len(bins) - _nx.searchsorted(bins[::-1], x, side=side)\n    else:\n        return _nx.searchsorted(bins, x, side=side)\n", 5827], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py": ["\"\"\"Module containing non-deprecated functions borrowed from Numeric.\n\n\"\"\"\nimport functools\nimport types\nimport warnings\n\nimport numpy as np\nfrom .._utils import set_module\nfrom . import multiarray as mu\nfrom . import overrides\nfrom . import umath as um\nfrom . import numerictypes as nt\nfrom .multiarray import asarray, array, asanyarray, concatenate\nfrom ._multiarray_umath import _array_converter\nfrom . import _methods\n\n_dt_ = nt.sctype2char\n\n# functions that are methods\n__all__ = [\n    'all', 'amax', 'amin', 'any', 'argmax',\n    'argmin', 'argpartition', 'argsort', 'around', 'choose', 'clip',\n    'compress', 'cumprod', 'cumsum', 'cumulative_prod', 'cumulative_sum',\n    'diagonal', 'mean', 'max', 'min', 'matrix_transpose',\n    'ndim', 'nonzero', 'partition', 'prod', 'ptp', 'put',\n    'ravel', 'repeat', 'reshape', 'resize', 'round',\n    'searchsorted', 'shape', 'size', 'sort', 'squeeze',\n    'std', 'sum', 'swapaxes', 'take', 'trace', 'transpose', 'var',\n]\n\n_gentype = types.GeneratorType\n# save away Python sum\n_sum_ = sum\n\narray_function_dispatch = functools.partial(\n    overrides.array_function_dispatch, module='numpy')\n\n\n# functions that are now methods\ndef _wrapit(obj, method, *args, **kwds):\n    conv = _array_converter(obj)\n    # As this already tried the method, subok is maybe quite reasonable here\n    # but this follows what was done before. TODO: revisit this.\n    arr, = conv.as_arrays(subok=False)\n    result = getattr(arr, method)(*args, **kwds)\n\n    return conv.wrap(result, to_scalar=False)\n\n\ndef _wrapfunc(obj, method, *args, **kwds):\n    bound = getattr(obj, method, None)\n    if bound is None:\n        return _wrapit(obj, method, *args, **kwds)\n\n    try:\n        return bound(*args, **kwds)\n    except TypeError:\n        # A TypeError occurs if the object does have such a method in its\n        # class, but its signature is not identical to that of NumPy's. This\n        # situation has occurred in the case of a downstream library like\n        # 'pandas'.\n        #\n        # Call _wrapit from within the except clause to ensure a potential\n        # exception has a traceback chain.\n        return _wrapit(obj, method, *args, **kwds)\n\n\ndef _wrapreduction(obj, ufunc, method, axis, dtype, out, **kwargs):\n    passkwargs = {k: v for k, v in kwargs.items()\n                  if v is not np._NoValue}\n\n    if type(obj) is not mu.ndarray:\n        try:\n            reduction = getattr(obj, method)\n        except AttributeError:\n            pass\n        else:\n            # This branch is needed for reductions like any which don't\n            # support a dtype.\n            if dtype is not None:\n                return reduction(axis=axis, dtype=dtype, out=out, **passkwargs)\n            else:\n                return reduction(axis=axis, out=out, **passkwargs)\n\n    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)\n\n\ndef _wrapreduction_any_all(obj, ufunc, method, axis, out, **kwargs):\n    # Same as above function, but dtype is always bool (but never passed on)\n    passkwargs = {k: v for k, v in kwargs.items()\n                  if v is not np._NoValue}\n\n    if type(obj) is not mu.ndarray:\n        try:\n            reduction = getattr(obj, method)\n        except AttributeError:\n            pass\n        else:\n            return reduction(axis=axis, out=out, **passkwargs)\n\n    return ufunc.reduce(obj, axis, bool, out, **passkwargs)\n\n\ndef _take_dispatcher(a, indices, axis=None, out=None, mode=None):\n    return (a, out)\n\n\n@array_function_dispatch(_take_dispatcher)\ndef take(a, indices, axis=None, out=None, mode='raise'):\n    \"\"\"\n    Take elements from an array along an axis.\n\n    When axis is not None, this function does the same thing as \"fancy\"\n    indexing (indexing arrays using arrays); however, it can be easier to use\n    if you need elements along a given axis. A call such as\n    ``np.take(arr, indices, axis=3)`` is equivalent to\n    ``arr[:,:,:,indices,...]``.\n\n    Explained without fancy indexing, this is equivalent to the following use\n    of `ndindex`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of\n    indices::\n\n        Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n        Nj = indices.shape\n        for ii in ndindex(Ni):\n            for jj in ndindex(Nj):\n                for kk in ndindex(Nk):\n                    out[ii + jj + kk] = a[ii + (indices[jj],) + kk]\n\n    Parameters\n    ----------\n    a : array_like (Ni..., M, Nk...)\n        The source array.\n    indices : array_like (Nj...)\n        The indices of the values to extract.\n        Also allow scalars for indices.\n    axis : int, optional\n        The axis over which to select values. By default, the flattened\n        input array is used.\n    out : ndarray, optional (Ni..., Nj..., Nk...)\n        If provided, the result will be placed in this array. It should\n        be of the appropriate shape and dtype. Note that `out` is always\n        buffered if `mode='raise'`; use other modes for better performance.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers.\n\n    Returns\n    -------\n    out : ndarray (Ni..., Nj..., Nk...)\n        The returned array has the same type as `a`.\n\n    See Also\n    --------\n    compress : Take elements using a boolean mask\n    ndarray.take : equivalent method\n    take_along_axis : Take elements by matching the array and the index arrays\n\n    Notes\n    -----\n    By eliminating the inner loop in the description above, and using `s_` to\n    build simple slice objects, `take` can be expressed  in terms of applying\n    fancy indexing to each 1-d slice::\n\n        Ni, Nk = a.shape[:axis], a.shape[axis+1:]\n        for ii in ndindex(Ni):\n            for kk in ndindex(Nj):\n                out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]\n\n    For this reason, it is equivalent to (but faster than) the following use\n    of `apply_along_axis`::\n\n        out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = [4, 3, 5, 7, 6, 8]\n    >>> indices = [0, 1, 4]\n    >>> np.take(a, indices)\n    array([4, 3, 6])\n\n    In this example if `a` is an ndarray, \"fancy\" indexing can be used.\n\n    >>> a = np.array(a)\n    >>> a[indices]\n    array([4, 3, 6])\n\n    If `indices` is not one dimensional, the output also has these dimensions.\n\n    >>> np.take(a, [[0, 1], [2, 3]])\n    array([[4, 3],\n           [5, 7]])\n    \"\"\"\n    return _wrapfunc(a, 'take', indices, axis=axis, out=out, mode=mode)\n\n\ndef _reshape_dispatcher(a, /, shape=None, order=None, *, newshape=None,\n                        copy=None):\n    return (a,)\n\n\n@array_function_dispatch(_reshape_dispatcher)\ndef reshape(a, /, shape=None, order='C', *, newshape=None, copy=None):\n    \"\"\"\n    Gives a new shape to an array without changing its data.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be reshaped.\n    shape : int or tuple of ints\n        The new shape should be compatible with the original shape. If\n        an integer, then the result will be a 1-D array of that length.\n        One shape dimension can be -1. In this case, the value is\n        inferred from the length of the array and remaining dimensions.\n    order : {'C', 'F', 'A'}, optional\n        Read the elements of ``a`` using this index order, and place the\n        elements into the reshaped array using this index order. 'C'\n        means to read / write the elements using C-like index order,\n        with the last axis index changing fastest, back to the first\n        axis index changing slowest. 'F' means to read / write the\n        elements using Fortran-like index order, with the first index\n        changing fastest, and the last index changing slowest. Note that\n        the 'C' and 'F' options take no account of the memory layout of\n        the underlying array, and only refer to the order of indexing.\n        'A' means to read / write the elements in Fortran-like index\n        order if ``a`` is Fortran *contiguous* in memory, C-like order\n        otherwise.\n    newshape : int or tuple of ints\n        .. deprecated:: 2.1\n            Replaced by ``shape`` argument. Retained for backward\n            compatibility.\n    copy : bool, optional\n        If ``True``, then the array data is copied. If ``None``, a copy will\n        only be made if it's required by ``order``. For ``False`` it raises\n        a ``ValueError`` if a copy cannot be avoided. Default: ``None``.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        This will be a new view object if possible; otherwise, it will\n        be a copy.  Note there is no guarantee of the *memory layout* (C- or\n        Fortran- contiguous) of the returned array.\n\n    See Also\n    --------\n    ndarray.reshape : Equivalent method.\n\n    Notes\n    -----\n    It is not always possible to change the shape of an array without copying\n    the data.\n\n    The ``order`` keyword gives the index ordering both for *fetching*\n    the values from ``a``, and then *placing* the values into the output\n    array. For example, let's say you have an array:\n\n    >>> a = np.arange(6).reshape((3, 2))\n    >>> a\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n\n    You can think of reshaping as first raveling the array (using the given\n    index order), then inserting the elements from the raveled array into the\n    new array using the same kind of index ordering as was used for the\n    raveling.\n\n    >>> np.reshape(a, (2, 3)) # C-like index ordering\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.reshape(a, (2, 3), order='F') # Fortran-like index ordering\n    array([[0, 4, 3],\n           [2, 1, 5]])\n    >>> np.reshape(np.ravel(a, order='F'), (2, 3), order='F')\n    array([[0, 4, 3],\n           [2, 1, 5]])\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> np.reshape(a, 6)\n    array([1, 2, 3, 4, 5, 6])\n    >>> np.reshape(a, 6, order='F')\n    array([1, 4, 2, 5, 3, 6])\n\n    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    \"\"\"\n    if newshape is None and shape is None:\n        raise TypeError(\n            \"reshape() missing 1 required positional argument: 'shape'\")\n    if newshape is not None:\n        if shape is not None:\n            raise TypeError(\n                \"You cannot specify 'newshape' and 'shape' arguments \"\n                \"at the same time.\")\n        # Deprecated in NumPy 2.1, 2024-04-18\n        warnings.warn(\n            \"`newshape` keyword argument is deprecated, \"\n            \"use `shape=...` or pass shape positionally instead. \"\n            \"(deprecated in NumPy 2.1)\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        shape = newshape\n    if copy is not None:\n        return _wrapfunc(a, 'reshape', shape, order=order, copy=copy)\n    return _wrapfunc(a, 'reshape', shape, order=order)\n\n\ndef _choose_dispatcher(a, choices, out=None, mode=None):\n    yield a\n    yield from choices\n    yield out\n\n\n@array_function_dispatch(_choose_dispatcher)\ndef choose(a, choices, out=None, mode='raise'):\n    \"\"\"\n    Construct an array from an index array and a list of arrays to choose from.\n\n    First of all, if confused or uncertain, definitely look at the Examples -\n    in its full generality, this function is less simple than it might\n    seem from the following code description::\n\n        np.choose(a,c) == np.array([c[a[I]][I] for I in np.ndindex(a.shape)])\n\n    But this omits some subtleties.  Here is a fully general summary:\n\n    Given an \"index\" array (`a`) of integers and a sequence of ``n`` arrays\n    (`choices`), `a` and each choice array are first broadcast, as necessary,\n    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =\n    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``\n    for each ``i``.  Then, a new array with shape ``Ba.shape`` is created as\n    follows:\n\n    * if ``mode='raise'`` (the default), then, first of all, each element of\n      ``a`` (and thus ``Ba``) must be in the range ``[0, n-1]``; now, suppose\n      that ``i`` (in that range) is the value at the ``(j0, j1, ..., jm)``\n      position in ``Ba`` - then the value at the same position in the new array\n      is the value in ``Bchoices[i]`` at that same position;\n\n    * if ``mode='wrap'``, values in `a` (and thus `Ba`) may be any (signed)\n      integer; modular arithmetic is used to map integers outside the range\n      `[0, n-1]` back into that range; and then the new array is constructed\n      as above;\n\n    * if ``mode='clip'``, values in `a` (and thus ``Ba``) may be any (signed)\n      integer; negative integers are mapped to 0; values greater than ``n-1``\n      are mapped to ``n-1``; and then the new array is constructed as above.\n\n    Parameters\n    ----------\n    a : int array\n        This array must contain integers in ``[0, n-1]``, where ``n`` is the\n        number of choices, unless ``mode=wrap`` or ``mode=clip``, in which\n        cases any integers are permissible.\n    choices : sequence of arrays\n        Choice arrays. `a` and all of the choices must be broadcastable to the\n        same shape.  If `choices` is itself an array (not recommended), then\n        its outermost dimension (i.e., the one corresponding to\n        ``choices.shape[0]``) is taken as defining the \"sequence\".\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype. Note that `out` is always\n        buffered if ``mode='raise'``; use other modes for better performance.\n    mode : {'raise' (default), 'wrap', 'clip'}, optional\n        Specifies how indices outside ``[0, n-1]`` will be treated:\n\n        * 'raise' : an exception is raised\n        * 'wrap' : value becomes value mod ``n``\n        * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1\n\n    Returns\n    -------\n    merged_array : array\n        The merged result.\n\n    Raises\n    ------\n    ValueError: shape mismatch\n        If `a` and each choice array are not all broadcastable to the same\n        shape.\n\n    See Also\n    --------\n    ndarray.choose : equivalent method\n    numpy.take_along_axis : Preferable if `choices` is an array\n\n    Notes\n    -----\n    To reduce the chance of misinterpretation, even though the following\n    \"abuse\" is nominally supported, `choices` should neither be, nor be\n    thought of as, a single array, i.e., the outermost sequence-like container\n    should be either a list or a tuple.\n\n    Examples\n    --------\n\n    >>> import numpy as np\n    >>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n    ...   [20, 21, 22, 23], [30, 31, 32, 33]]\n    >>> np.choose([2, 3, 1, 0], choices\n    ... # the first element of the result will be the first element of the\n    ... # third (2+1) \"array\" in choices, namely, 20; the second element\n    ... # will be the second element of the fourth (3+1) choice array, i.e.,\n    ... # 31, etc.\n    ... )\n    array([20, 31, 12,  3])\n    >>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)\n    array([20, 31, 12,  3])\n    >>> # because there are 4 choice arrays\n    >>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)\n    array([20,  1, 12,  3])\n    >>> # i.e., 0\n\n    A couple examples illustrating how choose broadcasts:\n\n    >>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    >>> choices = [-10, 10]\n    >>> np.choose(a, choices)\n    array([[ 10, -10,  10],\n           [-10,  10, -10],\n           [ 10, -10,  10]])\n\n    >>> # With thanks to Anne Archibald\n    >>> a = np.array([0, 1]).reshape((2,1,1))\n    >>> c1 = np.array([1, 2, 3]).reshape((1,3,1))\n    >>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))\n    >>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2\n    array([[[ 1,  1,  1,  1,  1],\n            [ 2,  2,  2,  2,  2],\n            [ 3,  3,  3,  3,  3]],\n           [[-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5]]])\n\n    \"\"\"\n    return _wrapfunc(a, 'choose', choices, out=out, mode=mode)\n\n\ndef _repeat_dispatcher(a, repeats, axis=None):\n    return (a,)\n\n\n@array_function_dispatch(_repeat_dispatcher)\ndef repeat(a, repeats, axis=None):\n    \"\"\"\n    Repeat each element of an array after themselves\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    repeats : int or array of ints\n        The number of repetitions for each element.  `repeats` is broadcasted\n        to fit the shape of the given axis.\n    axis : int, optional\n        The axis along which to repeat values.  By default, use the\n        flattened input array, and return a flat output array.\n\n    Returns\n    -------\n    repeated_array : ndarray\n        Output array which has the same shape as `a`, except along\n        the given axis.\n\n    See Also\n    --------\n    tile : Tile an array.\n    unique : Find the unique elements of an array.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.repeat(3, 4)\n    array([3, 3, 3, 3])\n    >>> x = np.array([[1,2],[3,4]])\n    >>> np.repeat(x, 2)\n    array([1, 1, 2, 2, 3, 3, 4, 4])\n    >>> np.repeat(x, 3, axis=1)\n    array([[1, 1, 1, 2, 2, 2],\n           [3, 3, 3, 4, 4, 4]])\n    >>> np.repeat(x, [1, 2], axis=0)\n    array([[1, 2],\n           [3, 4],\n           [3, 4]])\n\n    \"\"\"\n    return _wrapfunc(a, 'repeat', repeats, axis=axis)\n\n\ndef _put_dispatcher(a, ind, v, mode=None):\n    return (a, ind, v)\n\n\n@array_function_dispatch(_put_dispatcher)\ndef put(a, ind, v, mode='raise'):\n    \"\"\"\n    Replaces specified elements of an array with given values.\n\n    The indexing works on the flattened target array. `put` is roughly\n    equivalent to:\n\n    ::\n\n        a.flat[ind] = v\n\n    Parameters\n    ----------\n    a : ndarray\n        Target array.\n    ind : array_like\n        Target indices, interpreted as integers.\n    v : array_like\n        Values to place in `a` at target indices. If `v` is shorter than\n        `ind` it will be repeated as necessary.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers. In 'raise' mode,\n        if an exception occurs the target array may still be modified.\n\n    See Also\n    --------\n    putmask, place\n    put_along_axis : Put elements by matching the array and the index arrays\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.arange(5)\n    >>> np.put(a, [0, 2], [-44, -55])\n    >>> a\n    array([-44,   1, -55,   3,   4])\n\n    >>> a = np.arange(5)\n    >>> np.put(a, 22, -5, mode='clip')\n    >>> a\n    array([ 0,  1,  2,  3, -5])\n\n    \"\"\"\n    try:\n        put = a.put\n    except AttributeError as e:\n        raise TypeError(\"argument 1 must be numpy.ndarray, \"\n                        \"not {name}\".format(name=type(a).__name__)) from e\n\n    return put(ind, v, mode=mode)\n\n\ndef _swapaxes_dispatcher(a, axis1, axis2):\n    return (a,)\n\n\n@array_function_dispatch(_swapaxes_dispatcher)\ndef swapaxes(a, axis1, axis2):\n    \"\"\"\n    Interchange two axes of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis1 : int\n        First axis.\n    axis2 : int\n        Second axis.\n\n    Returns\n    -------\n    a_swapped : ndarray\n        For NumPy >= 1.10.0, if `a` is an ndarray, then a view of `a` is\n        returned; otherwise a new array is created. For earlier NumPy\n        versions a view of `a` is returned only if the order of the\n        axes is changed, otherwise the input array is returned.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.array([[1,2,3]])\n    >>> np.swapaxes(x,0,1)\n    array([[1],\n           [2],\n           [3]])\n\n    >>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])\n    >>> x\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n\n    >>> np.swapaxes(x,0,2)\n    array([[[0, 4],\n            [2, 6]],\n           [[1, 5],\n            [3, 7]]])\n\n    \"\"\"\n    return _wrapfunc(a, 'swapaxes', axis1, axis2)\n\n\ndef _transpose_dispatcher(a, axes=None):\n    return (a,)\n\n\n@array_function_dispatch(_transpose_dispatcher)\ndef transpose(a, axes=None):\n    \"\"\"\n    Returns an array with axes transposed.\n\n    For a 1-D array, this returns an unchanged view of the original array, as a\n    transposed vector is simply the same vector.\n    To convert a 1-D array into a 2-D column vector, an additional dimension\n    must be added, e.g., ``np.atleast_2d(a).T`` achieves this, as does\n    ``a[:, np.newaxis]``.\n    For a 2-D array, this is the standard matrix transpose.\n    For an n-D array, if axes are given, their order indicates how the\n    axes are permuted (see Examples). If axes are not provided, then\n    ``transpose(a).shape == a.shape[::-1]``.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axes : tuple or list of ints, optional\n        If specified, it must be a tuple or list which contains a permutation\n        of [0, 1, ..., N-1] where N is the number of axes of `a`. Negative\n        indices can also be used to specify axes. The i-th axis of the returned\n        array will correspond to the axis numbered ``axes[i]`` of the input.\n        If not specified, defaults to ``range(a.ndim)[::-1]``, which reverses\n        the order of the axes.\n\n    Returns\n    -------\n    p : ndarray\n        `a` with its axes permuted. A view is returned whenever possible.\n\n    See Also\n    --------\n    ndarray.transpose : Equivalent method.\n    moveaxis : Move axes of an array to new positions.\n    argsort : Return the indices that would sort an array.\n\n    Notes\n    -----\n    Use ``transpose(a, argsort(axes))`` to invert the transposition of tensors\n    when using the `axes` keyword argument.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> a\n    array([[1, 2],\n           [3, 4]])\n    >>> np.transpose(a)\n    array([[1, 3],\n           [2, 4]])\n\n    >>> a = np.array([1, 2, 3, 4])\n    >>> a\n    array([1, 2, 3, 4])\n    >>> np.transpose(a)\n    array([1, 2, 3, 4])\n\n    >>> a = np.ones((1, 2, 3))\n    >>> np.transpose(a, (1, 0, 2)).shape\n    (2, 1, 3)\n\n    >>> a = np.ones((2, 3, 4, 5))\n    >>> np.transpose(a).shape\n    (5, 4, 3, 2)\n\n    >>> a = np.arange(3*4*5).reshape((3, 4, 5))\n    >>> np.transpose(a, (-1, 0, -2)).shape\n    (5, 3, 4)\n\n    \"\"\"\n    return _wrapfunc(a, 'transpose', axes)\n\n\ndef _matrix_transpose_dispatcher(x):\n    return (x,)\n\n@array_function_dispatch(_matrix_transpose_dispatcher)\ndef matrix_transpose(x, /):\n    \"\"\"\n    Transposes a matrix (or a stack of matrices) ``x``.\n\n    This function is Array API compatible.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array having shape (..., M, N) and whose two innermost\n        dimensions form ``MxN`` matrices.\n\n    Returns\n    -------\n    out : ndarray\n        An array containing the transpose for each matrix and having shape\n        (..., N, M).\n\n    See Also\n    --------\n    transpose : Generic transpose method.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.matrix_transpose([[1, 2], [3, 4]])\n    array([[1, 3],\n           [2, 4]])\n\n    >>> np.matrix_transpose([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n    array([[[1, 3],\n            [2, 4]],\n           [[5, 7],\n            [6, 8]]])\n\n    \"\"\"\n    x = asanyarray(x)\n    if x.ndim < 2:\n        raise ValueError(\n            f\"Input array must be at least 2-dimensional, but it is {x.ndim}\"\n        )\n    return swapaxes(x, -1, -2)\n\n\ndef _partition_dispatcher(a, kth, axis=None, kind=None, order=None):\n    return (a,)\n\n\n@array_function_dispatch(_partition_dispatcher)\ndef partition(a, kth, axis=-1, kind='introselect', order=None):\n    \"\"\"\n    Return a partitioned copy of an array.\n\n    Creates a copy of the array and partially sorts it in such a way that\n    the value of the element in k-th position is in the position it would be\n    in a sorted array. In the output array, all elements smaller than the k-th\n    element are located to the left of this element and all equal or greater\n    are located to its right. The ordering of the elements in the two\n    partitions on the either side of the k-th element in the output array is\n    undefined.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n    kth : int or sequence of ints\n        Element index to partition by. The k-th value of the element\n        will be in its final sorted position and all smaller elements\n        will be moved before it and all equal or greater elements behind\n        it. The order of all elements in the partitions is undefined. If\n        provided with a sequence of k-th it will partition all elements\n        indexed by k-th  of them into their sorted position at once.\n\n        .. deprecated:: 1.22.0\n            Passing booleans as index is deprecated.\n    axis : int or None, optional\n        Axis along which to sort. If None, the array is flattened before\n        sorting. The default is -1, which sorts along the last axis.\n    kind : {'introselect'}, optional\n        Selection algorithm. Default is 'introselect'.\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument\n        specifies which fields to compare first, second, etc.  A single\n        field can be specified as a string.  Not all fields need be\n        specified, but unspecified fields will still be used, in the\n        order in which they come up in the dtype, to break ties.\n\n    Returns\n    -------\n    partitioned_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    ndarray.partition : Method to sort an array in-place.\n    argpartition : Indirect partition.\n    sort : Full sorting\n\n    Notes\n    -----\n    The various selection algorithms are characterized by their average\n    speed, worst case performance, work space size, and whether they are\n    stable. A stable sort keeps items with the same key in the same\n    relative order. The available algorithms have the following\n    properties:\n\n    ================= ======= ============= ============ =======\n       kind            speed   worst case    work space  stable\n    ================= ======= ============= ============ =======\n    'introselect'        1        O(n)           0         no\n    ================= ======= ============= ============ =======\n\n    All the partition algorithms make temporary copies of the data when\n    partitioning along any but the last axis.  Consequently,\n    partitioning along the last axis is faster and uses less space than\n    partitioning along any other axis.\n\n    The sort order for complex numbers is lexicographic. If both the\n    real and imaginary parts are non-nan then the order is determined by\n    the real parts except when they are equal, in which case the order\n    is determined by the imaginary parts.\n\n    The sort order of ``np.nan`` is bigger than ``np.inf``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([7, 1, 7, 7, 1, 5, 7, 2, 3, 2, 6, 2, 3, 0])\n    >>> p = np.partition(a, 4)\n    >>> p\n    array([0, 1, 2, 1, 2, 5, 2, 3, 3, 6, 7, 7, 7, 7]) # may vary\n\n    ``p[4]`` is 2;  all elements in ``p[:4]`` are less than or equal\n    to ``p[4]``, and all elements in ``p[5:]`` are greater than or\n    equal to ``p[4]``.  The partition is::\n\n        [0, 1, 2, 1], [2], [5, 2, 3, 3, 6, 7, 7, 7, 7]\n\n    The next example shows the use of multiple values passed to `kth`.\n\n    >>> p2 = np.partition(a, (4, 8))\n    >>> p2\n    array([0, 1, 2, 1, 2, 3, 3, 2, 5, 6, 7, 7, 7, 7])\n\n    ``p2[4]`` is 2  and ``p2[8]`` is 5.  All elements in ``p2[:4]``\n    are less than or equal to ``p2[4]``, all elements in ``p2[5:8]``\n    are greater than or equal to ``p2[4]`` and less than or equal to\n    ``p2[8]``, and all elements in ``p2[9:]`` are greater than or\n    equal to ``p2[8]``.  The partition is::\n\n        [0, 1, 2, 1], [2], [3, 3, 2], [5], [6, 7, 7, 7, 7]\n    \"\"\"\n    if axis is None:\n        # flatten returns (1, N) for np.matrix, so always use the last axis\n        a = asanyarray(a).flatten()\n        axis = -1\n    else:\n        a = asanyarray(a).copy(order=\"K\")\n    a.partition(kth, axis=axis, kind=kind, order=order)\n    return a\n\n\ndef _argpartition_dispatcher(a, kth, axis=None, kind=None, order=None):\n    return (a,)\n\n\n@array_function_dispatch(_argpartition_dispatcher)\ndef argpartition(a, kth, axis=-1, kind='introselect', order=None):\n    \"\"\"\n    Perform an indirect partition along the given axis using the\n    algorithm specified by the `kind` keyword. It returns an array of\n    indices of the same shape as `a` that index data along the given\n    axis in partitioned order.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to sort.\n    kth : int or sequence of ints\n        Element index to partition by. The k-th element will be in its\n        final sorted position and all smaller elements will be moved\n        before it and all larger elements behind it. The order of all\n        elements in the partitions is undefined. If provided with a\n        sequence of k-th it will partition all of them into their sorted\n        position at once.\n\n        .. deprecated:: 1.22.0\n            Passing booleans as index is deprecated.\n    axis : int or None, optional\n        Axis along which to sort. The default is -1 (the last axis). If\n        None, the flattened array is used.\n    kind : {'introselect'}, optional\n        Selection algorithm. Default is 'introselect'\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument\n        specifies which fields to compare first, second, etc. A single\n        field can be specified as a string, and not all fields need be\n        specified, but unspecified fields will still be used, in the\n        order in which they come up in the dtype, to break ties.\n\n    Returns\n    -------\n    index_array : ndarray, int\n        Array of indices that partition `a` along the specified axis.\n        If `a` is one-dimensional, ``a[index_array]`` yields a partitioned `a`.\n        More generally, ``np.take_along_axis(a, index_array, axis=axis)``\n        always yields the partitioned `a`, irrespective of dimensionality.\n\n    See Also\n    --------\n    partition : Describes partition algorithms used.\n    ndarray.partition : Inplace partition.\n    argsort : Full indirect sort.\n    take_along_axis : Apply ``index_array`` from argpartition\n                      to an array as if by calling partition.\n\n    Notes\n    -----\n    The returned indices are not guaranteed to be sorted according to\n    the values. Furthermore, the default selection algorithm ``introselect``\n    is unstable, and hence the returned indices are not guaranteed\n    to be the earliest/latest occurrence of the element.\n\n    `argpartition` works for real/complex inputs with nan values,\n    see `partition` for notes on the enhanced sort order and\n    different selection algorithms.\n\n    Examples\n    --------\n    One dimensional array:\n\n    >>> import numpy as np\n    >>> x = np.array([3, 4, 2, 1])\n    >>> x[np.argpartition(x, 3)]\n    array([2, 1, 3, 4]) # may vary\n    >>> x[np.argpartition(x, (1, 3))]\n    array([1, 2, 3, 4]) # may vary\n\n    >>> x = [3, 4, 2, 1]\n    >>> np.array(x)[np.argpartition(x, 3)]\n    array([2, 1, 3, 4]) # may vary\n\n    Multi-dimensional array:\n\n    >>> x = np.array([[3, 4, 2], [1, 3, 1]])\n    >>> index_array = np.argpartition(x, kth=1, axis=-1)\n    >>> # below is the same as np.partition(x, kth=1)\n    >>> np.take_along_axis(x, index_array, axis=-1)\n    array([[2, 3, 4],\n           [1, 1, 3]])\n\n    \"\"\"\n    return _wrapfunc(a, 'argpartition', kth, axis=axis, kind=kind, order=order)\n\n\ndef _sort_dispatcher(a, axis=None, kind=None, order=None, *, stable=None):\n    return (a,)\n\n\n@array_function_dispatch(_sort_dispatcher)\ndef sort(a, axis=-1, kind=None, order=None, *, stable=None):\n    \"\"\"\n    Return a sorted copy of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n    axis : int or None, optional\n        Axis along which to sort. If None, the array is flattened before\n        sorting. The default is -1, which sorts along the last axis.\n    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'\n        and 'mergesort' use timsort or radix sort under the covers and,\n        in general, the actual implementation will vary with data type.\n        The 'mergesort' option is retained for backwards compatibility.\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc.  A single field can\n        be specified as a string, and not all fields need be specified,\n        but unspecified fields will still be used, in the order in which\n        they come up in the dtype, to break ties.\n    stable : bool, optional\n        Sort stability. If ``True``, the returned array will maintain\n        the relative order of ``a`` values which compare as equal.\n        If ``False`` or ``None``, this is not guaranteed. Internally,\n        this option selects ``kind='stable'``. Default: ``None``.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    sorted_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    ndarray.sort : Method to sort an array in-place.\n    argsort : Indirect sort.\n    lexsort : Indirect stable sort on multiple keys.\n    searchsorted : Find elements in a sorted array.\n    partition : Partial sort.\n\n    Notes\n    -----\n    The various sorting algorithms are characterized by their average speed,\n    worst case performance, work space size, and whether they are stable. A\n    stable sort keeps items with the same key in the same relative\n    order. The four algorithms implemented in NumPy have the following\n    properties:\n\n    =========== ======= ============= ============ ========\n       kind      speed   worst case    work space   stable\n    =========== ======= ============= ============ ========\n    'quicksort'    1     O(n^2)            0          no\n    'heapsort'     3     O(n*log(n))       0          no\n    'mergesort'    2     O(n*log(n))      ~n/2        yes\n    'timsort'      2     O(n*log(n))      ~n/2        yes\n    =========== ======= ============= ============ ========\n\n    .. note:: The datatype determines which of 'mergesort' or 'timsort'\n       is actually used, even if 'mergesort' is specified. User selection\n       at a finer scale is not currently available.\n\n    For performance, ``sort`` makes a temporary copy if needed to make the data\n    `contiguous <https://numpy.org/doc/stable/glossary.html#term-contiguous>`_\n    in memory along the sort axis. For even better performance and reduced\n    memory consumption, ensure that the array is already contiguous along the\n    sort axis.\n\n    The sort order for complex numbers is lexicographic. If both the real\n    and imaginary parts are non-nan then the order is determined by the\n    real parts except when they are equal, in which case the order is\n    determined by the imaginary parts.\n\n    Previous to numpy 1.4.0 sorting real and complex arrays containing nan\n    values led to undefined behaviour. In numpy versions >= 1.4.0 nan\n    values are sorted to the end. The extended sort order is:\n\n      * Real: [R, nan]\n      * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]\n\n    where R is a non-nan real value. Complex values with the same nan\n    placements are sorted according to the non-nan part if it exists.\n    Non-nan values are sorted as before.\n\n    quicksort has been changed to:\n    `introsort <https://en.wikipedia.org/wiki/Introsort>`_.\n    When sorting does not make enough progress it switches to\n    `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_.\n    This implementation makes quicksort O(n*log(n)) in the worst case.\n\n    'stable' automatically chooses the best stable sorting algorithm\n    for the data type being sorted.\n    It, along with 'mergesort' is currently mapped to\n    `timsort <https://en.wikipedia.org/wiki/Timsort>`_\n    or `radix sort <https://en.wikipedia.org/wiki/Radix_sort>`_\n    depending on the data type.\n    API forward compatibility currently limits the\n    ability to select the implementation and it is hardwired for the different\n    data types.\n\n    Timsort is added for better performance on already or nearly\n    sorted data. On random data timsort is almost identical to\n    mergesort. It is now used for stable sort while quicksort is still the\n    default sort if none is chosen. For timsort details, refer to\n    `CPython listsort.txt\n    <https://github.com/python/cpython/blob/3.7/Objects/listsort.txt>`_\n    'mergesort' and 'stable' are mapped to radix sort for integer data types.\n    Radix sort is an O(n) sort instead of O(n log n).\n\n    NaT now sorts to the end of arrays for consistency with NaN.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[1,4],[3,1]])\n    >>> np.sort(a)                # sort along the last axis\n    array([[1, 4],\n           [1, 3]])\n    >>> np.sort(a, axis=None)     # sort the flattened array\n    array([1, 1, 3, 4])\n    >>> np.sort(a, axis=0)        # sort along the first axis\n    array([[1, 1],\n           [3, 4]])\n\n    Use the `order` keyword to specify a field to use when sorting a\n    structured array:\n\n    >>> dtype = [('name', 'S10'), ('height', float), ('age', int)]\n    >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),\n    ...           ('Galahad', 1.7, 38)]\n    >>> a = np.array(values, dtype=dtype)       # create a structured array\n    >>> np.sort(a, order='height')                        # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n           ('Lancelot', 1.8999999999999999, 38)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n\n    Sort by age, then height if ages are equal:\n\n    >>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),\n           ('Arthur', 1.8, 41)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n\n    \"\"\"\n    if axis is None:\n        # flatten returns (1, N) for np.matrix, so always use the last axis\n        a = asanyarray(a).flatten()\n        axis = -1\n    else:\n        a = asanyarray(a).copy(order=\"K\")\n    a.sort(axis=axis, kind=kind, order=order, stable=stable)\n    return a\n\n\ndef _argsort_dispatcher(a, axis=None, kind=None, order=None, *, stable=None):\n    return (a,)\n\n\n@array_function_dispatch(_argsort_dispatcher)\ndef argsort(a, axis=-1, kind=None, order=None, *, stable=None):\n    \"\"\"\n    Returns the indices that would sort an array.\n\n    Perform an indirect sort along the given axis using the algorithm specified\n    by the `kind` keyword. It returns an array of indices of the same shape as\n    `a` that index data along the given axis in sorted order.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to sort.\n    axis : int or None, optional\n        Axis along which to sort.  The default is -1 (the last axis). If None,\n        the flattened array is used.\n    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'\n        and 'mergesort' use timsort under the covers and, in general, the\n        actual implementation will vary with data type. The 'mergesort' option\n        is retained for backwards compatibility.\n    order : str or list of str, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc.  A single field can\n        be specified as a string, and not all fields need be specified,\n        but unspecified fields will still be used, in the order in which\n        they come up in the dtype, to break ties.\n    stable : bool, optional\n        Sort stability. If ``True``, the returned array will maintain\n        the relative order of ``a`` values which compare as equal.\n        If ``False`` or ``None``, this is not guaranteed. Internally,\n        this option selects ``kind='stable'``. Default: ``None``.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    index_array : ndarray, int\n        Array of indices that sort `a` along the specified `axis`.\n        If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.\n        More generally, ``np.take_along_axis(a, index_array, axis=axis)``\n        always yields the sorted `a`, irrespective of dimensionality.\n\n    See Also\n    --------\n    sort : Describes sorting algorithms used.\n    lexsort : Indirect stable sort with multiple keys.\n    ndarray.sort : Inplace sort.\n    argpartition : Indirect partial sort.\n    take_along_axis : Apply ``index_array`` from argsort\n                      to an array as if by calling sort.\n\n    Notes\n    -----\n    See `sort` for notes on the different sorting algorithms.\n\n    As of NumPy 1.4.0 `argsort` works with real/complex arrays containing\n    nan values. The enhanced sort order is documented in `sort`.\n\n    Examples\n    --------\n    One dimensional array:\n\n    >>> import numpy as np\n    >>> x = np.array([3, 1, 2])\n    >>> np.argsort(x)\n    array([1, 2, 0])\n\n    Two-dimensional array:\n\n    >>> x = np.array([[0, 3], [2, 2]])\n    >>> x\n    array([[0, 3],\n           [2, 2]])\n\n    >>> ind = np.argsort(x, axis=0)  # sorts along first axis (down)\n    >>> ind\n    array([[0, 1],\n           [1, 0]])\n    >>> np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)\n    array([[0, 2],\n           [2, 3]])\n\n    >>> ind = np.argsort(x, axis=1)  # sorts along last axis (across)\n    >>> ind\n    array([[0, 1],\n           [0, 1]])\n    >>> np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)\n    array([[0, 3],\n           [2, 2]])\n\n    Indices of the sorted elements of a N-dimensional array:\n\n    >>> ind = np.unravel_index(np.argsort(x, axis=None), x.shape)\n    >>> ind\n    (array([0, 1, 1, 0]), array([0, 0, 1, 1]))\n    >>> x[ind]  # same as np.sort(x, axis=None)\n    array([0, 2, 2, 3])\n\n    Sorting with keys:\n\n    >>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])\n    >>> x\n    array([(1, 0), (0, 1)],\n          dtype=[('x', '<i4'), ('y', '<i4')])\n\n    >>> np.argsort(x, order=('x','y'))\n    array([1, 0])\n\n    >>> np.argsort(x, order=('y','x'))\n    array([0, 1])\n\n    \"\"\"\n    return _wrapfunc(\n        a, 'argsort', axis=axis, kind=kind, order=order, stable=stable\n    )\n\ndef _argmax_dispatcher(a, axis=None, out=None, *, keepdims=np._NoValue):\n    return (a, out)\n\n\n@array_function_dispatch(_argmax_dispatcher)\ndef argmax(a, axis=None, out=None, *, keepdims=np._NoValue):\n    \"\"\"\n    Returns the indices of the maximum values along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        By default, the index is into the flattened array, otherwise\n        along the specified axis.\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the array.\n\n        .. versionadded:: 1.22.0\n\n    Returns\n    -------\n    index_array : ndarray of ints\n        Array of indices into the array. It has the same shape as ``a.shape``\n        with the dimension along `axis` removed. If `keepdims` is set to True,\n        then the size of `axis` will be 1 with the resulting array having same\n        shape as ``a.shape``.\n\n    See Also\n    --------\n    ndarray.argmax, argmin\n    amax : The maximum value along a given axis.\n    unravel_index : Convert a flat index into an index tuple.\n    take_along_axis : Apply ``np.expand_dims(index_array, axis)``\n                      from argmax to an array as if by calling max.\n\n    Notes\n    -----\n    In case of multiple occurrences of the maximum values, the indices\n    corresponding to the first occurrence are returned.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.arange(6).reshape(2,3) + 10\n    >>> a\n    array([[10, 11, 12],\n           [13, 14, 15]])\n    >>> np.argmax(a)\n    5\n    >>> np.argmax(a, axis=0)\n    array([1, 1, 1])\n    >>> np.argmax(a, axis=1)\n    array([2, 2])\n\n    Indexes of the maximal elements of a N-dimensional array:\n\n    >>> ind = np.unravel_index(np.argmax(a, axis=None), a.shape)\n    >>> ind\n    (1, 2)\n    >>> a[ind]\n    15\n\n    >>> b = np.arange(6)\n    >>> b[1] = 5\n    >>> b\n    array([0, 5, 2, 3, 4, 5])\n    >>> np.argmax(b)  # Only the first occurrence is returned.\n    1\n\n    >>> x = np.array([[4,2,3], [1,0,3]])\n    >>> index_array = np.argmax(x, axis=-1)\n    >>> # Same as np.amax(x, axis=-1, keepdims=True)\n    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)\n    array([[4],\n           [3]])\n    >>> # Same as np.amax(x, axis=-1)\n    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1),\n    ...     axis=-1).squeeze(axis=-1)\n    array([4, 3])\n\n    Setting `keepdims` to `True`,\n\n    >>> x = np.arange(24).reshape((2, 3, 4))\n    >>> res = np.argmax(x, axis=1, keepdims=True)\n    >>> res.shape\n    (2, 1, 4)\n    \"\"\"\n    kwds = {'keepdims': keepdims} if keepdims is not np._NoValue else {}\n    return _wrapfunc(a, 'argmax', axis=axis, out=out, **kwds)\n\n\ndef _argmin_dispatcher(a, axis=None, out=None, *, keepdims=np._NoValue):\n    return (a, out)\n\n\n@array_function_dispatch(_argmin_dispatcher)\ndef argmin(a, axis=None, out=None, *, keepdims=np._NoValue):\n    \"\"\"\n    Returns the indices of the minimum values along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        By default, the index is into the flattened array, otherwise\n        along the specified axis.\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the array.\n\n        .. versionadded:: 1.22.0\n\n    Returns\n    -------\n    index_array : ndarray of ints\n        Array of indices into the array. It has the same shape as `a.shape`\n        with the dimension along `axis` removed. If `keepdims` is set to True,\n        then the size of `axis` will be 1 with the resulting array having same\n        shape as `a.shape`.\n\n    See Also\n    --------\n    ndarray.argmin, argmax\n    amin : The minimum value along a given axis.\n    unravel_index : Convert a flat index into an index tuple.\n    take_along_axis : Apply ``np.expand_dims(index_array, axis)``\n                      from argmin to an array as if by calling min.\n\n    Notes\n    -----\n    In case of multiple occurrences of the minimum values, the indices\n    corresponding to the first occurrence are returned.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.arange(6).reshape(2,3) + 10\n    >>> a\n    array([[10, 11, 12],\n           [13, 14, 15]])\n    >>> np.argmin(a)\n    0\n    >>> np.argmin(a, axis=0)\n    array([0, 0, 0])\n    >>> np.argmin(a, axis=1)\n    array([0, 0])\n\n    Indices of the minimum elements of a N-dimensional array:\n\n    >>> ind = np.unravel_index(np.argmin(a, axis=None), a.shape)\n    >>> ind\n    (0, 0)\n    >>> a[ind]\n    10\n\n    >>> b = np.arange(6) + 10\n    >>> b[4] = 10\n    >>> b\n    array([10, 11, 12, 13, 10, 15])\n    >>> np.argmin(b)  # Only the first occurrence is returned.\n    0\n\n    >>> x = np.array([[4,2,3], [1,0,3]])\n    >>> index_array = np.argmin(x, axis=-1)\n    >>> # Same as np.amin(x, axis=-1, keepdims=True)\n    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)\n    array([[2],\n           [0]])\n    >>> # Same as np.amax(x, axis=-1)\n    >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1),\n    ...     axis=-1).squeeze(axis=-1)\n    array([2, 0])\n\n    Setting `keepdims` to `True`,\n\n    >>> x = np.arange(24).reshape((2, 3, 4))\n    >>> res = np.argmin(x, axis=1, keepdims=True)\n    >>> res.shape\n    (2, 1, 4)\n    \"\"\"\n    kwds = {'keepdims': keepdims} if keepdims is not np._NoValue else {}\n    return _wrapfunc(a, 'argmin', axis=axis, out=out, **kwds)\n\n\ndef _searchsorted_dispatcher(a, v, side=None, sorter=None):\n    return (a, v, sorter)\n\n\n@array_function_dispatch(_searchsorted_dispatcher)\ndef searchsorted(a, v, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `a` such that, if the\n    corresponding elements in `v` were inserted before the indices, the\n    order of `a` would be preserved.\n\n    Assuming that `a` is sorted:\n\n    ======  ============================\n    `side`  returned index `i` satisfies\n    ======  ============================\n    left    ``a[i-1] < v <= a[i]``\n    right   ``a[i-1] <= v < a[i]``\n    ======  ============================\n\n    Parameters\n    ----------\n    a : 1-D array_like\n        Input array. If `sorter` is None, then it must be sorted in\n        ascending order, otherwise `sorter` must be an array of indices\n        that sort it.\n    v : array_like\n        Values to insert into `a`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `a`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort array a into ascending\n        order. They are typically the result of argsort.\n\n    Returns\n    -------\n    indices : int or array of ints\n        Array of insertion points with the same shape as `v`,\n        or an integer if `v` is a scalar.\n\n    See Also\n    --------\n    sort : Return a sorted copy of an array.\n    histogram : Produce histogram from 1-D data.\n\n    Notes\n    -----\n    Binary search is used to find the required insertion points.\n\n    As of NumPy 1.4.0 `searchsorted` works with real/complex arrays containing\n    `nan` values. The enhanced sort order is documented in `sort`.\n\n    This function uses the same algorithm as the builtin python\n    `bisect.bisect_left` (``side='left'``) and `bisect.bisect_right`\n    (``side='right'``) functions, which is also vectorized\n    in the `v` argument.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.searchsorted([11,12,13,14,15], 13)\n    2\n    >>> np.searchsorted([11,12,13,14,15], 13, side='right')\n    3\n    >>> np.searchsorted([11,12,13,14,15], [-10, 20, 12, 13])\n    array([0, 5, 1, 2])\n\n    When `sorter` is used, the returned indices refer to the sorted\n    array of `a` and not `a` itself:\n\n    >>> a = np.array([40, 10, 20, 30])\n    >>> sorter = np.argsort(a)\n    >>> sorter\n    array([1, 2, 3, 0])  # Indices that would sort the array 'a'\n    >>> result = np.searchsorted(a, 25, sorter=sorter)\n    >>> result\n    2\n    >>> a[sorter[result]]\n    30  # The element at index 2 of the sorted array is 30.\n    \"\"\"\n    return _wrapfunc(a, 'searchsorted', v, side=side, sorter=sorter)\n\n\ndef _resize_dispatcher(a, new_shape):\n    return (a,)\n\n\n@array_function_dispatch(_resize_dispatcher)\ndef resize(a, new_shape):\n    \"\"\"\n    Return a new array with the specified shape.\n\n    If the new array is larger than the original array, then the new\n    array is filled with repeated copies of `a`.  Note that this behavior\n    is different from a.resize(new_shape) which fills with zeros instead\n    of repeated copies of `a`.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be resized.\n\n    new_shape : int or tuple of int\n        Shape of resized array.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        The new array is formed from the data in the old array, repeated\n        if necessary to fill out the required number of elements.  The\n        data are repeated iterating over the array in C-order.\n\n    See Also\n    --------\n    numpy.reshape : Reshape an array without changing the total size.\n    numpy.pad : Enlarge and pad an array.\n    numpy.repeat : Repeat elements of an array.\n    ndarray.resize : resize an array in-place.\n\n    Notes\n    -----\n    When the total size of the array does not change `~numpy.reshape` should\n    be used.  In most other cases either indexing (to reduce the size)\n    or padding (to increase the size) may be a more appropriate solution.\n\n    Warning: This functionality does **not** consider axes separately,\n    i.e. it does not apply interpolation/extrapolation.\n    It fills the return array with the required number of elements, iterating\n    over `a` in C-order, disregarding axes (and cycling back from the start if\n    the new shape is larger).  This functionality is therefore not suitable to\n    resize images, or data where each axis represents a separate and distinct\n    entity.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[0,1],[2,3]])\n    >>> np.resize(a,(2,3))\n    array([[0, 1, 2],\n           [3, 0, 1]])\n    >>> np.resize(a,(1,4))\n    array([[0, 1, 2, 3]])\n    >>> np.resize(a,(2,4))\n    array([[0, 1, 2, 3],\n           [0, 1, 2, 3]])\n\n    \"\"\"\n    if isinstance(new_shape, (int, nt.integer)):\n        new_shape = (new_shape,)\n\n    a = ravel(a)\n\n    new_size = 1\n    for dim_length in new_shape:\n        new_size *= dim_length\n        if dim_length < 0:\n            raise ValueError(\n                'all elements of `new_shape` must be non-negative'\n            )\n\n    if a.size == 0 or new_size == 0:\n        # First case must zero fill. The second would have repeats == 0.\n        return np.zeros_like(a, shape=new_shape)\n\n    repeats = -(-new_size // a.size)  # ceil division\n    a = concatenate((a,) * repeats)[:new_size]\n\n    return reshape(a, new_shape)\n\n\ndef _squeeze_dispatcher(a, axis=None):\n    return (a,)\n\n\n@array_function_dispatch(_squeeze_dispatcher)\ndef squeeze(a, axis=None):\n    \"\"\"\n    Remove axes of length one from `a`.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : None or int or tuple of ints, optional\n        Selects a subset of the entries of length one in the\n        shape. If an axis is selected with shape entry greater than\n        one, an error is raised.\n\n    Returns\n    -------\n    squeezed : ndarray\n        The input array, but with all or a subset of the\n        dimensions of length 1 removed. This is always `a` itself\n        or a view into `a`. Note that if all axes are squeezed,\n        the result is a 0d array and not a scalar.\n\n    Raises\n    ------\n    ValueError\n        If `axis` is not None, and an axis being squeezed is not of length 1\n\n    See Also\n    --------\n    expand_dims : The inverse operation, adding entries of length one\n    reshape : Insert, remove, and combine dimensions, and resize existing ones\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.array([[[0], [1], [2]]])\n    >>> x.shape\n    (1, 3, 1)\n    >>> np.squeeze(x).shape\n    (3,)\n    >>> np.squeeze(x, axis=0).shape\n    (3, 1)\n    >>> np.squeeze(x, axis=1).shape\n    Traceback (most recent call last):\n    ...\n    ValueError: cannot select an axis to squeeze out which has size\n    not equal to one\n    >>> np.squeeze(x, axis=2).shape\n    (1, 3)\n    >>> x = np.array([[1234]])\n    >>> x.shape\n    (1, 1)\n    >>> np.squeeze(x)\n    array(1234)  # 0d array\n    >>> np.squeeze(x).shape\n    ()\n    >>> np.squeeze(x)[()]\n    1234\n\n    \"\"\"\n    try:\n        squeeze = a.squeeze\n    except AttributeError:\n        return _wrapit(a, 'squeeze', axis=axis)\n    if axis is None:\n        return squeeze()\n    else:\n        return squeeze(axis=axis)\n\n\ndef _diagonal_dispatcher(a, offset=None, axis1=None, axis2=None):\n    return (a,)\n\n\n@array_function_dispatch(_diagonal_dispatcher)\ndef diagonal(a, offset=0, axis1=0, axis2=1):\n    \"\"\"\n    Return specified diagonals.\n\n    If `a` is 2-D, returns the diagonal of `a` with the given offset,\n    i.e., the collection of elements of the form ``a[i, i+offset]``.  If\n    `a` has more than two dimensions, then the axes specified by `axis1`\n    and `axis2` are used to determine the 2-D sub-array whose diagonal is\n    returned.  The shape of the resulting array can be determined by\n    removing `axis1` and `axis2` and appending an index to the right equal\n    to the size of the resulting diagonals.\n\n    In versions of NumPy prior to 1.7, this function always returned a new,\n    independent array containing a copy of the values in the diagonal.\n\n    In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,\n    but depending on this fact is deprecated. Writing to the resulting\n    array continues to work as it used to, but a FutureWarning is issued.\n\n    Starting in NumPy 1.9 it returns a read-only view on the original array.\n    Attempting to write to the resulting array will produce an error.\n\n    In some future release, it will return a read/write view and writing to\n    the returned array will alter your original array.  The returned array\n    will have the same type as the input array.\n\n    If you don't write to the array returned by this function, then you can\n    just ignore all of the above.\n\n    If you depend on the current behavior, then we suggest copying the\n    returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead\n    of just ``np.diagonal(a)``. This will work with both past and future\n    versions of NumPy.\n\n    Parameters\n    ----------\n    a : array_like\n        Array from which the diagonals are taken.\n    offset : int, optional\n        Offset of the diagonal from the main diagonal.  Can be positive or\n        negative.  Defaults to main diagonal (0).\n    axis1 : int, optional\n        Axis to be used as the first axis of the 2-D sub-arrays from which\n        the diagonals should be taken.  Defaults to first axis (0).\n    axis2 : int, optional\n        Axis to be used as the second axis of the 2-D sub-arrays from\n        which the diagonals should be taken. Defaults to second axis (1).\n\n    Returns\n    -------\n    array_of_diagonals : ndarray\n        If `a` is 2-D, then a 1-D array containing the diagonal and of the\n        same type as `a` is returned unless `a` is a `matrix`, in which case\n        a 1-D array rather than a (2-D) `matrix` is returned in order to\n        maintain backward compatibility.\n\n        If ``a.ndim > 2``, then the dimensions specified by `axis1` and `axis2`\n        are removed, and a new axis inserted at the end corresponding to the\n        diagonal.\n\n    Raises\n    ------\n    ValueError\n        If the dimension of `a` is less than 2.\n\n    See Also\n    --------\n    diag : MATLAB work-a-like for 1-D and 2-D arrays.\n    diagflat : Create diagonal arrays.\n    trace : Sum along diagonals.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.arange(4).reshape(2,2)\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> a.diagonal()\n    array([0, 3])\n    >>> a.diagonal(1)\n    array([1])\n\n    A 3-D example:\n\n    >>> a = np.arange(8).reshape(2,2,2); a\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n    >>> a.diagonal(0,  # Main diagonals of two arrays created by skipping\n    ...            0,  # across the outer(left)-most axis last and\n    ...            1)  # the \"middle\" (row) axis first.\n    array([[0, 6],\n           [1, 7]])\n\n    The sub-arrays whose main diagonals we just obtained; note that each\n    corresponds to fixing the right-most (column) axis, and that the\n    diagonals are \"packed\" in rows.\n\n    >>> a[:,:,0]  # main diagonal is [0 6]\n    array([[0, 2],\n           [4, 6]])\n    >>> a[:,:,1]  # main diagonal is [1 7]\n    array([[1, 3],\n           [5, 7]])\n\n    The anti-diagonal can be obtained by reversing the order of elements\n    using either `numpy.flipud` or `numpy.fliplr`.\n\n    >>> a = np.arange(9).reshape(3, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5],\n           [6, 7, 8]])\n    >>> np.fliplr(a).diagonal()  # Horizontal flip\n    array([2, 4, 6])\n    >>> np.flipud(a).diagonal()  # Vertical flip\n    array([6, 4, 2])\n\n    Note that the order in which the diagonal is retrieved varies depending\n    on the flip function.\n    \"\"\"\n    if isinstance(a, np.matrix):\n        # Make diagonal of matrix 1-D to preserve backward compatibility.\n        return asarray(a).diagonal(offset=offset, axis1=axis1, axis2=axis2)\n    else:\n        return asanyarray(a).diagonal(offset=offset, axis1=axis1, axis2=axis2)\n\n\ndef _trace_dispatcher(\n        a, offset=None, axis1=None, axis2=None, dtype=None, out=None):\n    return (a, out)\n\n\n@array_function_dispatch(_trace_dispatcher)\ndef trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):\n    \"\"\"\n    Return the sum along diagonals of the array.\n\n    If `a` is 2-D, the sum along its diagonal with the given offset\n    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.\n\n    If `a` has more than two dimensions, then the axes specified by axis1 and\n    axis2 are used to determine the 2-D sub-arrays whose traces are returned.\n    The shape of the resulting array is the same as that of `a` with `axis1`\n    and `axis2` removed.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, from which the diagonals are taken.\n    offset : int, optional\n        Offset of the diagonal from the main diagonal. Can be both positive\n        and negative. Defaults to 0.\n    axis1, axis2 : int, optional\n        Axes to be used as the first and second axis of the 2-D sub-arrays\n        from which the diagonals should be taken. Defaults are the first two\n        axes of `a`.\n    dtype : dtype, optional\n        Determines the data-type of the returned array and of the accumulator\n        where the elements are summed. If dtype has the value None and `a` is\n        of integer type of precision less than the default integer\n        precision, then the default integer precision is used. Otherwise,\n        the precision is the same as that of `a`.\n    out : ndarray, optional\n        Array into which the output is placed. Its type is preserved and\n        it must be of the right shape to hold the output.\n\n    Returns\n    -------\n    sum_along_diagonals : ndarray\n        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has\n        larger dimensions, then an array of sums along diagonals is returned.\n\n    See Also\n    --------\n    diag, diagonal, diagflat\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.trace(np.eye(3))\n    3.0\n    >>> a = np.arange(8).reshape((2,2,2))\n    >>> np.trace(a)\n    array([6, 8])\n\n    >>> a = np.arange(24).reshape((2,2,2,3))\n    >>> np.trace(a).shape\n    (2, 3)\n\n    \"\"\"\n    if isinstance(a, np.matrix):\n        # Get trace of matrix via an array to preserve backward compatibility.\n        return asarray(a).trace(\n            offset=offset, axis1=axis1, axis2=axis2, dtype=dtype, out=out\n        )\n    else:\n        return asanyarray(a).trace(\n            offset=offset, axis1=axis1, axis2=axis2, dtype=dtype, out=out\n        )\n\n\ndef _ravel_dispatcher(a, order=None):\n    return (a,)\n\n\n@array_function_dispatch(_ravel_dispatcher)\ndef ravel(a, order='C'):\n    \"\"\"Return a contiguous flattened array.\n\n    A 1-D array, containing the elements of the input, is returned.  A copy is\n    made only if needed.\n\n    As of NumPy 1.10, the returned array will have the same type as the input\n    array. (for example, a masked array will be returned for a masked array\n    input)\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  The elements in `a` are read in the order specified by\n        `order`, and packed as a 1-D array.\n    order : {'C','F', 'A', 'K'}, optional\n\n        The elements of `a` are read using this index order. 'C' means\n        to index the elements in row-major, C-style order,\n        with the last axis index changing fastest, back to the first\n        axis index changing slowest.  'F' means to index the elements\n        in column-major, Fortran-style order, with the\n        first index changing fastest, and the last index changing\n        slowest. Note that the 'C' and 'F' options take no account of\n        the memory layout of the underlying array, and only refer to\n        the order of axis indexing.  'A' means to read the elements in\n        Fortran-like index order if `a` is Fortran *contiguous* in\n        memory, C-like order otherwise.  'K' means to read the\n        elements in the order they occur in memory, except for\n        reversing the data when strides are negative.  By default, 'C'\n        index order is used.\n\n    Returns\n    -------\n    y : array_like\n        y is a contiguous 1-D array of the same subtype as `a`,\n        with shape ``(a.size,)``.\n        Note that matrices are special cased for backward compatibility,\n        if `a` is a matrix, then y is a 1-D ndarray.\n\n    See Also\n    --------\n    ndarray.flat : 1-D iterator over an array.\n    ndarray.flatten : 1-D array copy of the elements of an array\n                      in row-major order.\n    ndarray.reshape : Change the shape of an array without changing its data.\n\n    Notes\n    -----\n    In row-major, C-style order, in two dimensions, the row index\n    varies the slowest, and the column index the quickest.  This can\n    be generalized to multiple dimensions, where row-major order\n    implies that the index along the first axis varies slowest, and\n    the index along the last quickest.  The opposite holds for\n    column-major, Fortran-style index ordering.\n\n    When a view is desired in as many cases as possible, ``arr.reshape(-1)``\n    may be preferable. However, ``ravel`` supports ``K`` in the optional\n    ``order`` argument while ``reshape`` does not.\n\n    Examples\n    --------\n    It is equivalent to ``reshape(-1, order=order)``.\n\n    >>> import numpy as np\n    >>> x = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> np.ravel(x)\n    array([1, 2, 3, 4, 5, 6])\n\n    >>> x.reshape(-1)\n    array([1, 2, 3, 4, 5, 6])\n\n    >>> np.ravel(x, order='F')\n    array([1, 4, 2, 5, 3, 6])\n\n    When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:\n\n    >>> np.ravel(x.T)\n    array([1, 4, 2, 5, 3, 6])\n    >>> np.ravel(x.T, order='A')\n    array([1, 2, 3, 4, 5, 6])\n\n    When ``order`` is 'K', it will preserve orderings that are neither 'C'\n    nor 'F', but won't reverse axes:\n\n    >>> a = np.arange(3)[::-1]; a\n    array([2, 1, 0])\n    >>> a.ravel(order='C')\n    array([2, 1, 0])\n    >>> a.ravel(order='K')\n    array([2, 1, 0])\n\n    >>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a\n    array([[[ 0,  2,  4],\n            [ 1,  3,  5]],\n           [[ 6,  8, 10],\n            [ 7,  9, 11]]])\n    >>> a.ravel(order='C')\n    array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])\n    >>> a.ravel(order='K')\n    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n\n    \"\"\"\n    if isinstance(a, np.matrix):\n        return asarray(a).ravel(order=order)\n    else:\n        return asanyarray(a).ravel(order=order)\n\n\ndef _nonzero_dispatcher(a):\n    return (a,)\n\n\n@array_function_dispatch(_nonzero_dispatcher)\ndef nonzero(a):\n    \"\"\"\n    Return the indices of the elements that are non-zero.\n\n    Returns a tuple of arrays, one for each dimension of `a`,\n    containing the indices of the non-zero elements in that\n    dimension. The values in `a` are always tested and returned in\n    row-major, C-style order.\n\n    To group the indices by element, rather than dimension, use `argwhere`,\n    which returns a row for each non-zero element.\n\n    .. note::\n\n       When called on a zero-d array or scalar, ``nonzero(a)`` is treated\n       as ``nonzero(atleast_1d(a))``.\n\n       .. deprecated:: 1.17.0\n\n          Use `atleast_1d` explicitly if this behavior is deliberate.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n\n    Returns\n    -------\n    tuple_of_arrays : tuple\n        Indices of elements that are non-zero.\n\n    See Also\n    --------\n    flatnonzero :\n        Return indices that are non-zero in the flattened version of the input\n        array.\n    ndarray.nonzero :\n        Equivalent ndarray method.\n    count_nonzero :\n        Counts the number of non-zero elements in the input array.\n\n    Notes\n    -----\n    While the nonzero values can be obtained with ``a[nonzero(a)]``, it is\n    recommended to use ``x[x.astype(bool)]`` or ``x[x != 0]`` instead, which\n    will correctly handle 0-d arrays.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])\n    >>> x\n    array([[3, 0, 0],\n           [0, 4, 0],\n           [5, 6, 0]])\n    >>> np.nonzero(x)\n    (array([0, 1, 2, 2]), array([0, 1, 0, 1]))\n\n    >>> x[np.nonzero(x)]\n    array([3, 4, 5, 6])\n    >>> np.transpose(np.nonzero(x))\n    array([[0, 0],\n           [1, 1],\n           [2, 0],\n           [2, 1]])\n\n    A common use for ``nonzero`` is to find the indices of an array, where\n    a condition is True.  Given an array `a`, the condition `a` > 3 is a\n    boolean array and since False is interpreted as 0, np.nonzero(a > 3)\n    yields the indices of the `a` where the condition is true.\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> a > 3\n    array([[False, False, False],\n           [ True,  True,  True],\n           [ True,  True,  True]])\n    >>> np.nonzero(a > 3)\n    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n    Using this result to index `a` is equivalent to using the mask directly:\n\n    >>> a[np.nonzero(a > 3)]\n    array([4, 5, 6, 7, 8, 9])\n    >>> a[a > 3]  # prefer this spelling\n    array([4, 5, 6, 7, 8, 9])\n\n    ``nonzero`` can also be called as a method of the array.\n\n    >>> (a > 3).nonzero()\n    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n    \"\"\"\n    return _wrapfunc(a, 'nonzero')\n\n\ndef _shape_dispatcher(a):\n    return (a,)\n\n\n@array_function_dispatch(_shape_dispatcher)\ndef shape(a):\n    \"\"\"\n    Return the shape of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n\n    Returns\n    -------\n    shape : tuple of ints\n        The elements of the shape tuple give the lengths of the\n        corresponding array dimensions.\n\n    See Also\n    --------\n    len : ``len(a)`` is equivalent to ``np.shape(a)[0]`` for N-D arrays with\n          ``N>=1``.\n    ndarray.shape : Equivalent array method.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.shape(np.eye(3))\n    (3, 3)\n    >>> np.shape([[1, 3]])\n    (1, 2)\n    >>> np.shape([0])\n    (1,)\n    >>> np.shape(0)\n    ()\n\n    >>> a = np.array([(1, 2), (3, 4), (5, 6)],\n    ...              dtype=[('x', 'i4'), ('y', 'i4')])\n    >>> np.shape(a)\n    (3,)\n    >>> a.shape\n    (3,)\n\n    \"\"\"\n    try:\n        result = a.shape\n    except AttributeError:\n        result = asarray(a).shape\n    return result\n\n\ndef _compress_dispatcher(condition, a, axis=None, out=None):\n    return (condition, a, out)\n\n\n@array_function_dispatch(_compress_dispatcher)\ndef compress(condition, a, axis=None, out=None):\n    \"\"\"\n    Return selected slices of an array along given axis.\n\n    When working along a given axis, a slice along that axis is returned in\n    `output` for each index where `condition` evaluates to True. When\n    working on a 1-D array, `compress` is equivalent to `extract`.\n\n    Parameters\n    ----------\n    condition : 1-D array of bools\n        Array that selects which entries to return. If len(condition)\n        is less than the size of `a` along the given axis, then output is\n        truncated to the length of the condition array.\n    a : array_like\n        Array from which to extract a part.\n    axis : int, optional\n        Axis along which to take slices. If None (default), work on the\n        flattened array.\n    out : ndarray, optional\n        Output array.  Its type is preserved and it must be of the right\n        shape to hold the output.\n\n    Returns\n    -------\n    compressed_array : ndarray\n        A copy of `a` without the slices along axis for which `condition`\n        is false.\n\n    See Also\n    --------\n    take, choose, diag, diagonal, select\n    ndarray.compress : Equivalent method in ndarray\n    extract : Equivalent method when working on 1-D arrays\n    :ref:`ufuncs-output-type`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[1, 2], [3, 4], [5, 6]])\n    >>> a\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.compress([0, 1], a, axis=0)\n    array([[3, 4]])\n    >>> np.compress([False, True, True], a, axis=0)\n    array([[3, 4],\n           [5, 6]])\n    >>> np.compress([False, True], a, axis=1)\n    array([[2],\n           [4],\n           [6]])\n\n    Working on the flattened array does not return slices along an axis but\n    selects elements.\n\n    >>> np.compress([False, True], a)\n    array([2])\n\n    \"\"\"\n    return _wrapfunc(a, 'compress', condition, axis=axis, out=out)\n\n\ndef _clip_dispatcher(a, a_min=None, a_max=None, out=None, *, min=None,\n                     max=None, **kwargs):\n    return (a, a_min, a_max, out, min, max)\n\n\n@array_function_dispatch(_clip_dispatcher)\ndef clip(a, a_min=np._NoValue, a_max=np._NoValue, out=None, *,\n         min=np._NoValue, max=np._NoValue, **kwargs):\n    \"\"\"\n    Clip (limit) the values in an array.\n\n    Given an interval, values outside the interval are clipped to\n    the interval edges.  For example, if an interval of ``[0, 1]``\n    is specified, values smaller than 0 become 0, and values larger\n    than 1 become 1.\n\n    Equivalent to but faster than ``np.minimum(a_max, np.maximum(a, a_min))``.\n\n    No check is performed to ensure ``a_min < a_max``.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing elements to clip.\n    a_min, a_max : array_like or None\n        Minimum and maximum value. If ``None``, clipping is not performed on\n        the corresponding edge. If both ``a_min`` and ``a_max`` are ``None``,\n        the elements of the returned array stay the same. Both are broadcasted\n        against ``a``.\n    out : ndarray, optional\n        The results will be placed in this array. It may be the input\n        array for in-place clipping.  `out` must be of the right shape\n        to hold the output.  Its type is preserved.\n    min, max : array_like or None\n        Array API compatible alternatives for ``a_min`` and ``a_max``\n        arguments. Either ``a_min`` and ``a_max`` or ``min`` and ``max``\n        can be passed at the same time. Default: ``None``.\n\n        .. versionadded:: 2.1.0\n    **kwargs\n        For other keyword-only arguments, see the\n        :ref:`ufunc docs <ufuncs.kwargs>`.\n\n    Returns\n    -------\n    clipped_array : ndarray\n        An array with the elements of `a`, but where values\n        < `a_min` are replaced with `a_min`, and those > `a_max`\n        with `a_max`.\n\n    See Also\n    --------\n    :ref:`ufuncs-output-type`\n\n    Notes\n    -----\n    When `a_min` is greater than `a_max`, `clip` returns an\n    array in which all values are equal to `a_max`,\n    as shown in the second example.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.arange(10)\n    >>> a\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    >>> np.clip(a, 1, 8)\n    array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n    >>> np.clip(a, 8, 1)\n    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\n    >>> np.clip(a, 3, 6, out=a)\n    array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n    >>> a\n    array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n    >>> a = np.arange(10)\n    >>> a\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    >>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)\n    array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])\n\n    \"\"\"\n    if a_min is np._NoValue and a_max is np._NoValue:\n        a_min = None if min is np._NoValue else min\n        a_max = None if max is np._NoValue else max\n    elif a_min is np._NoValue:\n        raise TypeError(\"clip() missing 1 required positional \"\n                        \"argument: 'a_min'\")\n    elif a_max is np._NoValue:\n        raise TypeError(\"clip() missing 1 required positional \"\n                        \"argument: 'a_max'\")\n    elif min is not np._NoValue or max is not np._NoValue:\n        raise ValueError(\"Passing `min` or `max` keyword argument when \"\n                         \"`a_min` and `a_max` are provided is forbidden.\")\n\n    return _wrapfunc(a, 'clip', a_min, a_max, out=out, **kwargs)\n\n\ndef _sum_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None,\n                    initial=None, where=None):\n    return (a, out)\n\n\n@array_function_dispatch(_sum_dispatcher)\ndef sum(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,\n        initial=np._NoValue, where=np._NoValue):\n    \"\"\"\n    Sum of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Elements to sum.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which a sum is performed.  The default,\n        axis=None, will sum all of the elements of the input array.  If\n        axis is negative it counts from the last to the first axis. If\n        axis is a tuple of ints, a sum is performed on all of the axes\n        specified in the tuple instead of a single axis or all the axes as\n        before.\n    dtype : dtype, optional\n        The type of the returned array and of the accumulator in which the\n        elements are summed.  The dtype of `a` is used by default unless `a`\n        has an integer dtype of less precision than the default platform\n        integer.  In that case, if `a` is signed then the platform integer\n        is used while if `a` is unsigned then an unsigned integer of the\n        same precision as the platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the output\n        values will be cast if necessary.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `sum` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n    initial : scalar, optional\n        Starting value for the sum. See `~numpy.ufunc.reduce` for details.\n    where : array_like of bool, optional\n        Elements to include in the sum. See `~numpy.ufunc.reduce` for details.\n\n    Returns\n    -------\n    sum_along_axis : ndarray\n        An array with the same shape as `a`, with the specified\n        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar\n        is returned.  If an output array is specified, a reference to\n        `out` is returned.\n\n    See Also\n    --------\n    ndarray.sum : Equivalent method.\n    add: ``numpy.add.reduce`` equivalent function.\n    cumsum : Cumulative sum of array elements.\n    trapezoid : Integration of array values using composite trapezoidal rule.\n\n    mean, average\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    The sum of an empty array is the neutral element 0:\n\n    >>> np.sum([])\n    0.0\n\n    For floating point numbers the numerical precision of sum (and\n    ``np.add.reduce``) is in general limited by directly adding each number\n    individually to the result causing rounding errors in every step.\n    However, often numpy will use a  numerically better approach (partial\n    pairwise summation) leading to improved precision in many use-cases.\n    This improved precision is always provided when no ``axis`` is given.\n    When ``axis`` is given, it will depend on which axis is summed.\n    Technically, to provide the best speed possible, the improved precision\n    is only used when the summation is along the fast axis in memory.\n    Note that the exact precision may vary depending on other parameters.\n    In contrast to NumPy, Python's ``math.fsum`` function uses a slower but\n    more precise approach to summation.\n    Especially when summing a large number of lower precision floating point\n    numbers, such as ``float32``, numerical errors can become significant.\n    In such cases it can be advisable to use `dtype=\"float64\"` to use a higher\n    precision for the output.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.sum([0.5, 1.5])\n    2.0\n    >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n    np.int32(1)\n    >>> np.sum([[0, 1], [0, 5]])\n    6\n    >>> np.sum([[0, 1], [0, 5]], axis=0)\n    array([0, 6])\n    >>> np.sum([[0, 1], [0, 5]], axis=1)\n    array([1, 5])\n    >>> np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)\n    array([1., 5.])\n\n    If the accumulator is too small, overflow occurs:\n\n    >>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)\n    np.int8(-128)\n\n    You can also start the sum with a value other than zero:\n\n    >>> np.sum([10], initial=5)\n    15\n    \"\"\"\n    if isinstance(a, _gentype):\n        # 2018-02-25, 1.15.0\n        warnings.warn(\n            \"Calling np.sum(generator) is deprecated, and in the future will \"\n            \"give a different result. Use np.sum(np.fromiter(generator)) or \"\n            \"the python sum builtin instead.\",\n            DeprecationWarning, stacklevel=2\n        )\n\n        res = _sum_(a)\n        if out is not None:\n            out[...] = res\n            return out\n        return res\n\n    return _wrapreduction(\n        a, np.add, 'sum', axis, dtype, out,\n        keepdims=keepdims, initial=initial, where=where\n    )\n\n\ndef _any_dispatcher(a, axis=None, out=None, keepdims=None, *,\n                    where=np._NoValue):\n    return (a, where, out)\n\n\n@array_function_dispatch(_any_dispatcher)\ndef any(a, axis=None, out=None, keepdims=np._NoValue, *, where=np._NoValue):\n    \"\"\"\n    Test whether any array element along a given axis evaluates to True.\n\n    Returns single boolean if `axis` is ``None``\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which a logical OR reduction is performed.\n        The default (``axis=None``) is to perform a logical OR over all\n        the dimensions of the input array. `axis` may be negative, in\n        which case it counts from the last to the first axis. If this\n        is a tuple of ints, a reduction is performed on multiple\n        axes, instead of a single axis or all the axes as before.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output and its type is preserved\n        (e.g., if it is of type float, then it will remain so, returning\n        1.0 for True and 0.0 for False, regardless of the type of `a`).\n        See :ref:`ufuncs-output-type` for more details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `any` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    where : array_like of bool, optional\n        Elements to include in checking for any `True` values.\n        See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    any : bool or ndarray\n        A new boolean or `ndarray` is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.any : equivalent method\n\n    all : Test whether all elements along a given axis evaluate to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity evaluate\n    to `True` because these are not equal to zero.\n\n    .. versionchanged:: 2.0\n       Before NumPy 2.0, ``any`` did not return booleans for object dtype\n       input arrays.\n       This behavior is still available via ``np.logical_or.reduce``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.any([[True, False], [True, True]])\n    True\n\n    >>> np.any([[True,  False, True ],\n    ...         [False, False, False]], axis=0)\n    array([ True, False, True])\n\n    >>> np.any([-1, 0, 5])\n    True\n\n    >>> np.any([[np.nan], [np.inf]], axis=1, keepdims=True)\n    array([[ True],\n           [ True]])\n\n    >>> np.any([[True, False], [False, False]], where=[[False], [True]])\n    False\n\n    >>> a = np.array([[1, 0, 0],\n    ...               [0, 0, 1],\n    ...               [0, 0, 0]])\n    >>> np.any(a, axis=0)\n    array([ True, False,  True])\n    >>> np.any(a, axis=1)\n    array([ True,  True, False])\n\n    >>> o=np.array(False)\n    >>> z=np.any([-1, 4, 5], out=o)\n    >>> z, o\n    (array(True), array(True))\n    >>> # Check now that z is a reference to o\n    >>> z is o\n    True\n    >>> id(z), id(o) # identity of z and o              # doctest: +SKIP\n    (191614240, 191614240)\n\n    \"\"\"\n    return _wrapreduction_any_all(a, np.logical_or, 'any', axis, out,\n                                  keepdims=keepdims, where=where)\n\n\ndef _all_dispatcher(a, axis=None, out=None, keepdims=None, *,\n                    where=None):\n    return (a, where, out)\n\n\n@array_function_dispatch(_all_dispatcher)\ndef all(a, axis=None, out=None, keepdims=np._NoValue, *, where=np._NoValue):\n    \"\"\"\n    Test whether all array elements along a given axis evaluate to True.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which a logical AND reduction is performed.\n        The default (``axis=None``) is to perform a logical AND over all\n        the dimensions of the input array. `axis` may be negative, in\n        which case it counts from the last to the first axis. If this\n        is a tuple of ints, a reduction is performed on multiple\n        axes, instead of a single axis or all the axes as before.\n    out : ndarray, optional\n        Alternate output array in which to place the result.\n        It must have the same shape as the expected output and its\n        type is preserved (e.g., if ``dtype(out)`` is float, the result\n        will consist of 0.0's and 1.0's). See :ref:`ufuncs-output-type`\n        for more details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `all` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    where : array_like of bool, optional\n        Elements to include in checking for all `True` values.\n        See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    all : ndarray, bool\n        A new boolean or array is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.all : equivalent method\n\n    any : Test whether any element along a given axis evaluates to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to `True` because these are not equal to zero.\n\n    .. versionchanged:: 2.0\n       Before NumPy 2.0, ``all`` did not return booleans for object dtype\n       input arrays.\n       This behavior is still available via ``np.logical_and.reduce``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.all([[True,False],[True,True]])\n    False\n\n    >>> np.all([[True,False],[True,True]], axis=0)\n    array([ True, False])\n\n    >>> np.all([-1, 4, 5])\n    True\n\n    >>> np.all([1.0, np.nan])\n    True\n\n    >>> np.all([[True, True], [False, True]], where=[[True], [False]])\n    True\n\n    >>> o=np.array(False)\n    >>> z=np.all([-1, 4, 5], out=o)\n    >>> id(z), id(o), z\n    (28293632, 28293632, array(True)) # may vary\n\n    \"\"\"\n    return _wrapreduction_any_all(a, np.logical_and, 'all', axis, out,\n                                  keepdims=keepdims, where=where)\n\n\ndef _cumulative_func(x, func, axis, dtype, out, include_initial):\n    x = np.atleast_1d(x)\n    x_ndim = x.ndim\n    if axis is None:\n        if x_ndim >= 2:\n            raise ValueError(\"For arrays which have more than one dimension \"\n                            \"``axis`` argument is required.\")\n        axis = 0\n\n    if out is not None and include_initial:\n        item = [slice(None)] * x_ndim\n        item[axis] = slice(1, None)\n        func.accumulate(x, axis=axis, dtype=dtype, out=out[tuple(item)])\n        item[axis] = 0\n        out[tuple(item)] = func.identity\n        return out\n\n    res = func.accumulate(x, axis=axis, dtype=dtype, out=out)\n    if include_initial:\n        initial_shape = list(x.shape)\n        initial_shape[axis] = 1\n        res = np.concat(\n            [np.full_like(res, func.identity, shape=initial_shape), res],\n            axis=axis,\n        )\n\n    return res\n\n\ndef _cumulative_prod_dispatcher(x, /, *, axis=None, dtype=None, out=None,\n                                include_initial=None):\n    return (x, out)\n\n\n@array_function_dispatch(_cumulative_prod_dispatcher)\ndef cumulative_prod(x, /, *, axis=None, dtype=None, out=None,\n                    include_initial=False):\n    \"\"\"\n    Return the cumulative product of elements along a given axis.\n\n    This function is an Array API compatible alternative to `numpy.cumprod`.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative product is computed. The default\n        (None) is only allowed for one-dimensional arrays. For arrays\n        with more than one dimension ``axis`` is required.\n    dtype : dtype, optional\n        Type of the returned array, as well as of the accumulator in which\n        the elements are multiplied.  If ``dtype`` is not specified, it\n        defaults to the dtype of ``x``, unless ``x`` has an integer dtype\n        with a precision less than that of the default platform integer.\n        In that case, the default platform integer is used instead.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type of the resulting values will be cast if necessary.\n        See :ref:`ufuncs-output-type` for more details.\n    include_initial : bool, optional\n        Boolean indicating whether to include the initial value (ones) as\n        the first value in the output. With ``include_initial=True``\n        the shape of the output is different than the shape of the input.\n        Default: ``False``.\n\n    Returns\n    -------\n    cumulative_prod_along_axis : ndarray\n        A new array holding the result is returned unless ``out`` is\n        specified, in which case a reference to ``out`` is returned. The\n        result has the same shape as ``x`` if ``include_initial=False``.\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3])\n    >>> np.cumulative_prod(a)  # intermediate results 1, 1*2\n    ...                        # total product 1*2*3 = 6\n    array([1, 2, 6])\n    >>> a = np.array([1, 2, 3, 4, 5, 6])\n    >>> np.cumulative_prod(a, dtype=float) # specify type of output\n    array([   1.,    2.,    6.,   24.,  120.,  720.])\n\n    The cumulative product for each column (i.e., over the rows) of ``b``:\n\n    >>> b = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> np.cumulative_prod(b, axis=0)\n    array([[ 1,  2,  3],\n           [ 4, 10, 18]])\n\n    The cumulative product for each row (i.e. over the columns) of ``b``:\n\n    >>> np.cumulative_prod(b, axis=1)\n    array([[  1,   2,   6],\n           [  4,  20, 120]])\n\n    \"\"\"\n    return _cumulative_func(x, um.multiply, axis, dtype, out, include_initial)\n\n\ndef _cumulative_sum_dispatcher(x, /, *, axis=None, dtype=None, out=None,\n                               include_initial=None):\n    return (x, out)\n\n\n@array_function_dispatch(_cumulative_sum_dispatcher)\ndef cumulative_sum(x, /, *, axis=None, dtype=None, out=None,\n                   include_initial=False):\n    \"\"\"\n    Return the cumulative sum of the elements along a given axis.\n\n    This function is an Array API compatible alternative to `numpy.cumsum`.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative sum is computed. The default\n        (None) is only allowed for one-dimensional arrays. For arrays\n        with more than one dimension ``axis`` is required.\n    dtype : dtype, optional\n        Type of the returned array and of the accumulator in which the\n        elements are summed.  If ``dtype`` is not specified, it defaults\n        to the dtype of ``x``, unless ``x`` has an integer dtype with\n        a precision less than that of the default platform integer.\n        In that case, the default platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary. See :ref:`ufuncs-output-type`\n        for more details.\n    include_initial : bool, optional\n        Boolean indicating whether to include the initial value (zeros) as\n        the first value in the output. With ``include_initial=True``\n        the shape of the output is different than the shape of the input.\n        Default: ``False``.\n\n    Returns\n    -------\n    cumulative_sum_along_axis : ndarray\n        A new array holding the result is returned unless ``out`` is\n        specified, in which case a reference to ``out`` is returned. The\n        result has the same shape as ``x`` if ``include_initial=False``.\n\n    See Also\n    --------\n    sum : Sum array elements.\n    trapezoid : Integration of array values using composite trapezoidal rule.\n    diff : Calculate the n-th discrete difference along given axis.\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    ``cumulative_sum(a)[-1]`` may not be equal to ``sum(a)`` for\n    floating-point values since ``sum`` may use a pairwise summation routine,\n    reducing the roundoff-error. See `sum` for more information.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3, 4, 5, 6])\n    >>> a\n    array([1, 2, 3, 4, 5, 6])\n    >>> np.cumulative_sum(a)\n    array([ 1,  3,  6, 10, 15, 21])\n    >>> np.cumulative_sum(a, dtype=float)  # specifies type of output value(s)\n    array([  1.,   3.,   6.,  10.,  15.,  21.])\n\n    >>> b = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> np.cumulative_sum(b,axis=0)  # sum over rows for each of the 3 columns\n    array([[1, 2, 3],\n           [5, 7, 9]])\n    >>> np.cumulative_sum(b,axis=1)  # sum over columns for each of the 2 rows\n    array([[ 1,  3,  6],\n           [ 4,  9, 15]])\n\n    ``cumulative_sum(c)[-1]`` may not be equal to ``sum(c)``\n\n    >>> c = np.array([1, 2e-9, 3e-9] * 1000000)\n    >>> np.cumulative_sum(c)[-1]\n    1000000.0050045159\n    >>> c.sum()\n    1000000.0050000029\n\n    \"\"\"\n    return _cumulative_func(x, um.add, axis, dtype, out, include_initial)\n\n\ndef _cumsum_dispatcher(a, axis=None, dtype=None, out=None):\n    return (a, out)\n\n\n@array_function_dispatch(_cumsum_dispatcher)\ndef cumsum(a, axis=None, dtype=None, out=None):\n    \"\"\"\n    Return the cumulative sum of the elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative sum is computed. The default\n        (None) is to compute the cumsum over the flattened array.\n    dtype : dtype, optional\n        Type of the returned array and of the accumulator in which the\n        elements are summed.  If `dtype` is not specified, it defaults\n        to the dtype of `a`, unless `a` has an integer dtype with a\n        precision less than that of the default platform integer.  In\n        that case, the default platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary. See :ref:`ufuncs-output-type`\n        for more details.\n\n    Returns\n    -------\n    cumsum_along_axis : ndarray.\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to `out` is returned. The\n        result has the same size as `a`, and the same shape as `a` if\n        `axis` is not None or `a` is a 1-d array.\n\n    See Also\n    --------\n    cumulative_sum : Array API compatible alternative for ``cumsum``.\n    sum : Sum array elements.\n    trapezoid : Integration of array values using composite trapezoidal rule.\n    diff : Calculate the n-th discrete difference along given axis.\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    ``cumsum(a)[-1]`` may not be equal to ``sum(a)`` for floating-point\n    values since ``sum`` may use a pairwise summation routine, reducing\n    the roundoff-error. See `sum` for more information.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.cumsum(a)\n    array([ 1,  3,  6, 10, 15, 21])\n    >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)\n    array([  1.,   3.,   6.,  10.,  15.,  21.])\n\n    >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns\n    array([[1, 2, 3],\n           [5, 7, 9]])\n    >>> np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows\n    array([[ 1,  3,  6],\n           [ 4,  9, 15]])\n\n    ``cumsum(b)[-1]`` may not be equal to ``sum(b)``\n\n    >>> b = np.array([1, 2e-9, 3e-9] * 1000000)\n    >>> b.cumsum()[-1]\n    1000000.0050045159\n    >>> b.sum()\n    1000000.0050000029\n\n    \"\"\"\n    return _wrapfunc(a, 'cumsum', axis=axis, dtype=dtype, out=out)\n\n\ndef _ptp_dispatcher(a, axis=None, out=None, keepdims=None):\n    return (a, out)\n\n\n@array_function_dispatch(_ptp_dispatcher)\ndef ptp(a, axis=None, out=None, keepdims=np._NoValue):\n    \"\"\"\n    Range of values (maximum - minimum) along an axis.\n\n    The name of the function comes from the acronym for 'peak to peak'.\n\n    .. warning::\n        `ptp` preserves the data type of the array. This means the\n        return value for an input of signed integers with n bits\n        (e.g. `numpy.int8`, `numpy.int16`, etc) is also a signed integer\n        with n bits.  In that case, peak-to-peak values greater than\n        ``2**(n-1)-1`` will be returned as negative values. An example\n        with a work-around is shown below.\n\n    Parameters\n    ----------\n    a : array_like\n        Input values.\n    axis : None or int or tuple of ints, optional\n        Axis along which to find the peaks.  By default, flatten the\n        array.  `axis` may be negative, in\n        which case it counts from the last to the first axis.\n        If this is a tuple of ints, a reduction is performed on multiple\n        axes, instead of a single axis or all the axes as before.\n    out : array_like\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type of the output values will be cast if necessary.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `ptp` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    Returns\n    -------\n    ptp : ndarray or scalar\n        The range of a given array - `scalar` if array is one-dimensional\n        or a new array holding the result along the given axis\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.array([[4, 9, 2, 10],\n    ...               [6, 9, 7, 12]])\n\n    >>> np.ptp(x, axis=1)\n    array([8, 6])\n\n    >>> np.ptp(x, axis=0)\n    array([2, 0, 5, 2])\n\n    >>> np.ptp(x)\n    10\n\n    This example shows that a negative value can be returned when\n    the input is an array of signed integers.\n\n    >>> y = np.array([[1, 127],\n    ...               [0, 127],\n    ...               [-1, 127],\n    ...               [-2, 127]], dtype=np.int8)\n    >>> np.ptp(y, axis=1)\n    array([ 126,  127, -128, -127], dtype=int8)\n\n    A work-around is to use the `view()` method to view the result as\n    unsigned integers with the same bit width:\n\n    >>> np.ptp(y, axis=1).view(np.uint8)\n    array([126, 127, 128, 129], dtype=uint8)\n\n    \"\"\"\n    kwargs = {}\n    if keepdims is not np._NoValue:\n        kwargs['keepdims'] = keepdims\n    return _methods._ptp(a, axis=axis, out=out, **kwargs)\n\n\ndef _max_dispatcher(a, axis=None, out=None, keepdims=None, initial=None,\n                    where=None):\n    return (a, out)\n\n\n@array_function_dispatch(_max_dispatcher)\n@set_module('numpy')\ndef max(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,\n         where=np._NoValue):\n    \"\"\"\n    Return the maximum of an array or maximum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which to operate.  By default, flattened input is\n        used. If this is a tuple of ints, the maximum is selected over\n        multiple axes, instead of a single axis or all the axes as before.\n\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See :ref:`ufuncs-output-type` for more details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the ``max`` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    initial : scalar, optional\n        The minimum value of an output element. Must be present to allow\n        computation on empty slice. See `~numpy.ufunc.reduce` for details.\n\n    where : array_like of bool, optional\n        Elements to compare for the maximum. See `~numpy.ufunc.reduce`\n        for details.\n\n    Returns\n    -------\n    max : ndarray or scalar\n        Maximum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is an int, the result is an array of dimension\n        ``a.ndim - 1``. If `axis` is a tuple, the result is an array of\n        dimension ``a.ndim - len(axis)``.\n\n    See Also\n    --------\n    amin :\n        The minimum value of an array along a given axis, propagating any NaNs.\n    nanmax :\n        The maximum value of an array along a given axis, ignoring any NaNs.\n    maximum :\n        Element-wise maximum of two arrays, propagating any NaNs.\n    fmax :\n        Element-wise maximum of two arrays, ignoring any NaNs.\n    argmax :\n        Return the indices of the maximum values.\n\n    nanmin, minimum, fmin\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding max value will be NaN as well. To ignore NaN values\n    (MATLAB behavior), please use nanmax.\n\n    Don't use `~numpy.max` for element-wise comparison of 2 arrays; when\n    ``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than\n    ``max(a, axis=0)``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.max(a)           # Maximum of the flattened array\n    3\n    >>> np.max(a, axis=0)   # Maxima along the first axis\n    array([2, 3])\n    >>> np.max(a, axis=1)   # Maxima along the second axis\n    array([1, 3])\n    >>> np.max(a, where=[False, True], initial=-1, axis=0)\n    array([-1,  3])\n    >>> b = np.arange(5, dtype=float)\n    >>> b[2] = np.nan\n    >>> np.max(b)\n    np.float64(nan)\n    >>> np.max(b, where=~np.isnan(b), initial=-1)\n    4.0\n    >>> np.nanmax(b)\n    4.0\n\n    You can use an initial value to compute the maximum of an empty slice, or\n    to initialize it to a different value:\n\n    >>> np.max([[-50], [10]], axis=-1, initial=0)\n    array([ 0, 10])\n\n    Notice that the initial value is used as one of the elements for which the\n    maximum is determined, unlike for the default argument Python's max\n    function, which is only used for empty iterables.\n\n    >>> np.max([5], initial=6)\n    6\n    >>> max([5], default=6)\n    5\n    \"\"\"\n    return _wrapreduction(a, np.maximum, 'max', axis, None, out,\n                          keepdims=keepdims, initial=initial, where=where)\n\n\n@array_function_dispatch(_max_dispatcher)\ndef amax(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,\n         where=np._NoValue):\n    \"\"\"\n    Return the maximum of an array or maximum along an axis.\n\n    `amax` is an alias of `~numpy.max`.\n\n    See Also\n    --------\n    max : alias of this function\n    ndarray.max : equivalent method\n    \"\"\"\n    return _wrapreduction(a, np.maximum, 'max', axis, None, out,\n                          keepdims=keepdims, initial=initial, where=where)\n\n\ndef _min_dispatcher(a, axis=None, out=None, keepdims=None, initial=None,\n                    where=None):\n    return (a, out)\n\n\n@array_function_dispatch(_min_dispatcher)\ndef min(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,\n        where=np._NoValue):\n    \"\"\"\n    Return the minimum of an array or minimum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which to operate.  By default, flattened input is\n        used.\n\n        If this is a tuple of ints, the minimum is selected over multiple axes,\n        instead of a single axis or all the axes as before.\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See :ref:`ufuncs-output-type` for more details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the ``min`` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    initial : scalar, optional\n        The maximum value of an output element. Must be present to allow\n        computation on empty slice. See `~numpy.ufunc.reduce` for details.\n\n    where : array_like of bool, optional\n        Elements to compare for the minimum. See `~numpy.ufunc.reduce`\n        for details.\n\n    Returns\n    -------\n    min : ndarray or scalar\n        Minimum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is an int, the result is an array of dimension\n        ``a.ndim - 1``.  If `axis` is a tuple, the result is an array of\n        dimension ``a.ndim - len(axis)``.\n\n    See Also\n    --------\n    amax :\n        The maximum value of an array along a given axis, propagating any NaNs.\n    nanmin :\n        The minimum value of an array along a given axis, ignoring any NaNs.\n    minimum :\n        Element-wise minimum of two arrays, propagating any NaNs.\n    fmin :\n        Element-wise minimum of two arrays, ignoring any NaNs.\n    argmin :\n        Return the indices of the minimum values.\n\n    nanmax, maximum, fmax\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding min value will be NaN as well. To ignore NaN values\n    (MATLAB behavior), please use nanmin.\n\n    Don't use `~numpy.min` for element-wise comparison of 2 arrays; when\n    ``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than\n    ``min(a, axis=0)``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.min(a)           # Minimum of the flattened array\n    0\n    >>> np.min(a, axis=0)   # Minima along the first axis\n    array([0, 1])\n    >>> np.min(a, axis=1)   # Minima along the second axis\n    array([0, 2])\n    >>> np.min(a, where=[False, True], initial=10, axis=0)\n    array([10,  1])\n\n    >>> b = np.arange(5, dtype=float)\n    >>> b[2] = np.nan\n    >>> np.min(b)\n    np.float64(nan)\n    >>> np.min(b, where=~np.isnan(b), initial=10)\n    0.0\n    >>> np.nanmin(b)\n    0.0\n\n    >>> np.min([[-50], [10]], axis=-1, initial=0)\n    array([-50,   0])\n\n    Notice that the initial value is used as one of the elements for which the\n    minimum is determined, unlike for the default argument Python's max\n    function, which is only used for empty iterables.\n\n    Notice that this isn't the same as Python's ``default`` argument.\n\n    >>> np.min([6], initial=5)\n    5\n    >>> min([6], default=5)\n    6\n    \"\"\"\n    return _wrapreduction(a, np.minimum, 'min', axis, None, out,\n                          keepdims=keepdims, initial=initial, where=where)\n\n\n@array_function_dispatch(_min_dispatcher)\ndef amin(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,\n         where=np._NoValue):\n    \"\"\"\n    Return the minimum of an array or minimum along an axis.\n\n    `amin` is an alias of `~numpy.min`.\n\n    See Also\n    --------\n    min : alias of this function\n    ndarray.min : equivalent method\n    \"\"\"\n    return _wrapreduction(a, np.minimum, 'min', axis, None, out,\n                          keepdims=keepdims, initial=initial, where=where)\n\n\ndef _prod_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None,\n                     initial=None, where=None):\n    return (a, out)\n\n\n@array_function_dispatch(_prod_dispatcher)\ndef prod(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,\n         initial=np._NoValue, where=np._NoValue):\n    \"\"\"\n    Return the product of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which a product is performed.  The default,\n        axis=None, will calculate the product of all the elements in the\n        input array. If axis is negative it counts from the last to the\n        first axis.\n\n        If axis is a tuple of ints, a product is performed on all of the\n        axes specified in the tuple instead of a single axis or all the\n        axes as before.\n    dtype : dtype, optional\n        The type of the returned array, as well as of the accumulator in\n        which the elements are multiplied.  The dtype of `a` is used by\n        default unless `a` has an integer dtype of less precision than the\n        default platform integer.  In that case, if `a` is signed then the\n        platform integer is used while if `a` is unsigned then an unsigned\n        integer of the same precision as the platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the output\n        values will be cast if necessary.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left in the\n        result as dimensions with size one. With this option, the result\n        will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `prod` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n    initial : scalar, optional\n        The starting value for this product. See `~numpy.ufunc.reduce`\n        for details.\n    where : array_like of bool, optional\n        Elements to include in the product. See `~numpy.ufunc.reduce`\n        for details.\n\n    Returns\n    -------\n    product_along_axis : ndarray, see `dtype` parameter above.\n        An array shaped as `a` but with the specified axis removed.\n        Returns a reference to `out` if specified.\n\n    See Also\n    --------\n    ndarray.prod : equivalent method\n    :ref:`ufuncs-output-type`\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.  That means that, on a 32-bit platform:\n\n    >>> x = np.array([536870910, 536870910, 536870910, 536870910])\n    >>> np.prod(x)\n    16 # may vary\n\n    The product of an empty array is the neutral element 1:\n\n    >>> np.prod([])\n    1.0\n\n    Examples\n    --------\n    By default, calculate the product of all elements:\n\n    >>> import numpy as np\n    >>> np.prod([1.,2.])\n    2.0\n\n    Even when the input array is two-dimensional:\n\n    >>> a = np.array([[1., 2.], [3., 4.]])\n    >>> np.prod(a)\n    24.0\n\n    But we can also specify the axis over which to multiply:\n\n    >>> np.prod(a, axis=1)\n    array([  2.,  12.])\n    >>> np.prod(a, axis=0)\n    array([3., 8.])\n\n    Or select specific elements to include:\n\n    >>> np.prod([1., np.nan, 3.], where=[True, False, True])\n    3.0\n\n    If the type of `x` is unsigned, then the output type is\n    the unsigned platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.uint8)\n    >>> np.prod(x).dtype == np.uint\n    True\n\n    If `x` is of a signed integer type, then the output type\n    is the default platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.int8)\n    >>> np.prod(x).dtype == int\n    True\n\n    You can also start the product with a value other than one:\n\n    >>> np.prod([1, 2], initial=5)\n    10\n    \"\"\"\n    return _wrapreduction(a, np.multiply, 'prod', axis, dtype, out,\n                          keepdims=keepdims, initial=initial, where=where)\n\n\ndef _cumprod_dispatcher(a, axis=None, dtype=None, out=None):\n    return (a, out)\n\n\n@array_function_dispatch(_cumprod_dispatcher)\ndef cumprod(a, axis=None, dtype=None, out=None):\n    \"\"\"\n    Return the cumulative product of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative product is computed.  By default\n        the input is flattened.\n    dtype : dtype, optional\n        Type of the returned array, as well as of the accumulator in which\n        the elements are multiplied.  If *dtype* is not specified, it\n        defaults to the dtype of `a`, unless `a` has an integer dtype with\n        a precision less than that of the default platform integer.  In\n        that case, the default platform integer is used instead.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type of the resulting values will be cast if necessary.\n\n    Returns\n    -------\n    cumprod : ndarray\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to out is returned.\n\n    See Also\n    --------\n    cumulative_prod : Array API compatible alternative for ``cumprod``.\n    :ref:`ufuncs-output-type`\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([1,2,3])\n    >>> np.cumprod(a) # intermediate results 1, 1*2\n    ...               # total product 1*2*3 = 6\n    array([1, 2, 6])\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> np.cumprod(a, dtype=float) # specify type of output\n    array([   1.,    2.,    6.,   24.,  120.,  720.])\n\n    The cumulative product for each column (i.e., over the rows) of `a`:\n\n    >>> np.cumprod(a, axis=0)\n    array([[ 1,  2,  3],\n           [ 4, 10, 18]])\n\n    The cumulative product for each row (i.e. over the columns) of `a`:\n\n    >>> np.cumprod(a,axis=1)\n    array([[  1,   2,   6],\n           [  4,  20, 120]])\n\n    \"\"\"\n    return _wrapfunc(a, 'cumprod', axis=axis, dtype=dtype, out=out)\n\n\ndef _ndim_dispatcher(a):\n    return (a,)\n\n\n@array_function_dispatch(_ndim_dispatcher)\ndef ndim(a):\n    \"\"\"\n    Return the number of dimensions of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  If it is not already an ndarray, a conversion is\n        attempted.\n\n    Returns\n    -------\n    number_of_dimensions : int\n        The number of dimensions in `a`.  Scalars are zero-dimensional.\n\n    See Also\n    --------\n    ndarray.ndim : equivalent method\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.ndim([[1,2,3],[4,5,6]])\n    2\n    >>> np.ndim(np.array([[1,2,3],[4,5,6]]))\n    2\n    >>> np.ndim(1)\n    0\n\n    \"\"\"\n    try:\n        return a.ndim\n    except AttributeError:\n        return asarray(a).ndim\n\n\ndef _size_dispatcher(a, axis=None):\n    return (a,)\n\n\n@array_function_dispatch(_size_dispatcher)\ndef size(a, axis=None):\n    \"\"\"\n    Return the number of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which the elements are counted.  By default, give\n        the total number of elements.\n\n    Returns\n    -------\n    element_count : int\n        Number of elements along the specified axis.\n\n    See Also\n    --------\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n    ndarray.size : number of elements in array\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[1,2,3],[4,5,6]])\n    >>> np.size(a)\n    6\n    >>> np.size(a,1)\n    3\n    >>> np.size(a,0)\n    2\n\n    \"\"\"\n    if axis is None:\n        try:\n            return a.size\n        except AttributeError:\n            return asarray(a).size\n    else:\n        try:\n            return a.shape[axis]\n        except AttributeError:\n            return asarray(a).shape[axis]\n\n\ndef _round_dispatcher(a, decimals=None, out=None):\n    return (a, out)\n\n\n@array_function_dispatch(_round_dispatcher)\ndef round(a, decimals=0, out=None):\n    \"\"\"\n    Evenly round to the given number of decimals.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    decimals : int, optional\n        Number of decimal places to round to (default: 0).  If\n        decimals is negative, it specifies the number of positions to\n        the left of the decimal point.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the output\n        values will be cast if necessary. See :ref:`ufuncs-output-type`\n        for more details.\n\n    Returns\n    -------\n    rounded_array : ndarray\n        An array of the same type as `a`, containing the rounded values.\n        Unless `out` was specified, a new array is created.  A reference to\n        the result is returned.\n\n        The real and imaginary parts of complex numbers are rounded\n        separately.  The result of rounding a float is a float.\n\n    See Also\n    --------\n    ndarray.round : equivalent method\n    around : an alias for this function\n    ceil, fix, floor, rint, trunc\n\n\n    Notes\n    -----\n    For values exactly halfway between rounded decimal values, NumPy\n    rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,\n    -0.5 and 0.5 round to 0.0, etc.\n\n    ``np.round`` uses a fast but sometimes inexact algorithm to round\n    floating-point datatypes. For positive `decimals` it is equivalent to\n    ``np.true_divide(np.rint(a * 10**decimals), 10**decimals)``, which has\n    error due to the inexact representation of decimal fractions in the IEEE\n    floating point standard [1]_ and errors introduced when scaling by powers\n    of ten. For instance, note the extra \"1\" in the following:\n\n        >>> np.round(56294995342131.5, 3)\n        56294995342131.51\n\n    If your goal is to print such values with a fixed number of decimals, it is\n    preferable to use numpy's float printing routines to limit the number of\n    printed decimals:\n\n        >>> np.format_float_positional(56294995342131.5, precision=3)\n        '56294995342131.5'\n\n    The float printing routines use an accurate but much more computationally\n    demanding algorithm to compute the number of digits after the decimal\n    point.\n\n    Alternatively, Python's builtin `round` function uses a more accurate\n    but slower algorithm for 64-bit floating point values:\n\n        >>> round(56294995342131.5, 3)\n        56294995342131.5\n        >>> np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997\n        (16.06, 16.05)\n\n\n    References\n    ----------\n    .. [1] \"Lecture Notes on the Status of IEEE 754\", William Kahan,\n           https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.round([0.37, 1.64])\n    array([0., 2.])\n    >>> np.round([0.37, 1.64], decimals=1)\n    array([0.4, 1.6])\n    >>> np.round([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value\n    array([0., 2., 2., 4., 4.])\n    >>> np.round([1,2,3,11], decimals=1) # ndarray of ints is returned\n    array([ 1,  2,  3, 11])\n    >>> np.round([1,2,3,11], decimals=-1)\n    array([ 0,  0,  0, 10])\n\n    \"\"\"\n    return _wrapfunc(a, 'round', decimals=decimals, out=out)\n\n\n@array_function_dispatch(_round_dispatcher)\ndef around(a, decimals=0, out=None):\n    \"\"\"\n    Round an array to the given number of decimals.\n\n    `around` is an alias of `~numpy.round`.\n\n    See Also\n    --------\n    ndarray.round : equivalent method\n    round : alias for this function\n    ceil, fix, floor, rint, trunc\n\n    \"\"\"\n    return _wrapfunc(a, 'round', decimals=decimals, out=out)\n\n\ndef _mean_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None, *,\n                     where=None):\n    return (a, where, out)\n\n\n@array_function_dispatch(_mean_dispatcher)\ndef mean(a, axis=None, dtype=None, out=None, keepdims=np._NoValue, *,\n         where=np._NoValue):\n    \"\"\"\n    Compute the arithmetic mean along the specified axis.\n\n    Returns the average of the array elements.  The average is taken over\n    the flattened array by default, otherwise over the specified axis.\n    `float64` intermediate and return values are used for integer inputs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose mean is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which the means are computed. The default is to\n        compute the mean of the flattened array.\n\n        If this is a tuple of ints, a mean is performed over multiple axes,\n        instead of a single axis or all the axes as before.\n    dtype : data-type, optional\n        Type to use in computing the mean.  For integer inputs, the default\n        is `float64`; for floating point inputs, it is the same as the\n        input dtype.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary.\n        See :ref:`ufuncs-output-type` for more details.\n        See :ref:`ufuncs-output-type` for more details.\n\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `mean` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n\n    where : array_like of bool, optional\n        Elements to include in the mean. See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    m : ndarray, see dtype parameter above\n        If `out=None`, returns a new array containing the mean values,\n        otherwise a reference to the output array is returned.\n\n    See Also\n    --------\n    average : Weighted average\n    std, var, nanmean, nanstd, nanvar\n\n    Notes\n    -----\n    The arithmetic mean is the sum of the elements along the axis divided\n    by the number of elements.\n\n    Note that for floating-point input, the mean is computed using the\n    same precision the input has.  Depending on the input data, this can\n    cause the results to be inaccurate, especially for `float32` (see\n    example below).  Specifying a higher-precision accumulator using the\n    `dtype` keyword can alleviate this issue.\n\n    By default, `float16` results are computed using `float32` intermediates\n    for extra precision.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.mean(a)\n    2.5\n    >>> np.mean(a, axis=0)\n    array([2., 3.])\n    >>> np.mean(a, axis=1)\n    array([1.5, 3.5])\n\n    In single precision, `mean` can be inaccurate:\n\n    >>> a = np.zeros((2, 512*512), dtype=np.float32)\n    >>> a[0, :] = 1.0\n    >>> a[1, :] = 0.1\n    >>> np.mean(a)\n    np.float32(0.54999924)\n\n    Computing the mean in float64 is more accurate:\n\n    >>> np.mean(a, dtype=np.float64)\n    0.55000000074505806 # may vary\n\n    Computing the mean in timedelta64 is available:\n\n    >>> b = np.array([1, 3], dtype=\"timedelta64[D]\")\n    >>> np.mean(b)\n    np.timedelta64(2,'D')\n\n    Specifying a where argument:\n\n    >>> a = np.array([[5, 9, 13], [14, 10, 12], [11, 15, 19]])\n    >>> np.mean(a)\n    12.0\n    >>> np.mean(a, where=[[True], [False], [False]])\n    9.0\n\n    \"\"\"\n    kwargs = {}\n    if keepdims is not np._NoValue:\n        kwargs['keepdims'] = keepdims\n    if where is not np._NoValue:\n        kwargs['where'] = where\n    if type(a) is not mu.ndarray:\n        try:\n            mean = a.mean\n        except AttributeError:\n            pass\n        else:\n            return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n\n    return _methods._mean(a, axis=axis, dtype=dtype,\n                          out=out, **kwargs)\n\n\ndef _std_dispatcher(a, axis=None, dtype=None, out=None, ddof=None,\n                    keepdims=None, *, where=None, mean=None, correction=None):\n    return (a, where, out, mean)\n\n\n@array_function_dispatch(_std_dispatcher)\ndef std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue, *,\n        where=np._NoValue, mean=np._NoValue, correction=np._NoValue):\n    r\"\"\"\n    Compute the standard deviation along the specified axis.\n\n    Returns the standard deviation, a measure of the spread of a distribution,\n    of the array elements. The standard deviation is computed for the\n    flattened array by default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Calculate the standard deviation of these values.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which the standard deviation is computed. The\n        default is to compute the standard deviation of the flattened array.\n        If this is a tuple of ints, a standard deviation is performed over\n        multiple axes, instead of a single axis or all the axes as before.\n    dtype : dtype, optional\n        Type to use in computing the standard deviation. For arrays of\n        integer type the default is float64, for arrays of float types it is\n        the same as the array type.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output but the type (of the calculated\n        values) will be cast if necessary.\n        See :ref:`ufuncs-output-type` for more details.\n    ddof : {int, float}, optional\n        Means Delta Degrees of Freedom.  The divisor used in calculations\n        is ``N - ddof``, where ``N`` represents the number of elements.\n        By default `ddof` is zero. See Notes for details about use of `ddof`.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `std` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n    where : array_like of bool, optional\n        Elements to include in the standard deviation.\n        See `~numpy.ufunc.reduce` for details.\n\n        .. versionadded:: 1.20.0\n\n    mean : array_like, optional\n        Provide the mean to prevent its recalculation. The mean should have\n        a shape as if it was calculated with ``keepdims=True``.\n        The axis for the calculation of the mean should be the same as used in\n        the call to this std function.\n\n        .. versionadded:: 2.0.0\n\n    correction : {int, float}, optional\n        Array API compatible name for the ``ddof`` parameter. Only one of them\n        can be provided at the same time.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    standard_deviation : ndarray, see dtype parameter above.\n        If `out` is None, return a new array containing the standard deviation,\n        otherwise return a reference to the output array.\n\n    See Also\n    --------\n    var, mean, nanmean, nanstd, nanvar\n    :ref:`ufuncs-output-type`\n\n    Notes\n    -----\n    There are several common variants of the array standard deviation\n    calculation. Assuming the input `a` is a one-dimensional NumPy array\n    and ``mean`` is either provided as an argument or computed as\n    ``a.mean()``, NumPy computes the standard deviation of an array as::\n\n        N = len(a)\n        d2 = abs(a - mean)**2  # abs is for complex `a`\n        var = d2.sum() / (N - ddof)  # note use of `ddof`\n        std = var**0.5\n\n    Different values of the argument `ddof` are useful in different\n    contexts. NumPy's default ``ddof=0`` corresponds with the expression:\n\n    .. math::\n\n        \\sqrt{\\frac{\\sum_i{|a_i - \\bar{a}|^2 }}{N}}\n\n    which is sometimes called the \"population standard deviation\" in the field\n    of statistics because it applies the definition of standard deviation to\n    `a` as if `a` were a complete population of possible observations.\n\n    Many other libraries define the standard deviation of an array\n    differently, e.g.:\n\n    .. math::\n\n        \\sqrt{\\frac{\\sum_i{|a_i - \\bar{a}|^2 }}{N - 1}}\n\n    In statistics, the resulting quantity is sometimes called the \"sample\n    standard deviation\" because if `a` is a random sample from a larger\n    population, this calculation provides the square root of an unbiased\n    estimate of the variance of the population. The use of :math:`N-1` in the\n    denominator is often called \"Bessel's correction\" because it corrects for\n    bias (toward lower values) in the variance estimate introduced when the\n    sample mean of `a` is used in place of the true mean of the population.\n    The resulting estimate of the standard deviation is still biased, but less\n    than it would have been without the correction. For this quantity, use\n    ``ddof=1``.\n\n    Note that, for complex numbers, `std` takes the absolute\n    value before squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the standard deviation is computed using the same\n    precision the input has. Depending on the input data, this can cause\n    the results to be inaccurate, especially for float32 (see example below).\n    Specifying a higher-accuracy accumulator using the `dtype` keyword can\n    alleviate this issue.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.std(a)\n    1.1180339887498949 # may vary\n    >>> np.std(a, axis=0)\n    array([1.,  1.])\n    >>> np.std(a, axis=1)\n    array([0.5,  0.5])\n\n    In single precision, std() can be inaccurate:\n\n    >>> a = np.zeros((2, 512*512), dtype=np.float32)\n    >>> a[0, :] = 1.0\n    >>> a[1, :] = 0.1\n    >>> np.std(a)\n    np.float32(0.45000005)\n\n    Computing the standard deviation in float64 is more accurate:\n\n    >>> np.std(a, dtype=np.float64)\n    0.44999999925494177 # may vary\n\n    Specifying a where argument:\n\n    >>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n    >>> np.std(a)\n    2.614064523559687 # may vary\n    >>> np.std(a, where=[[True], [True], [False]])\n    2.0\n\n    Using the mean keyword to save computation time:\n\n    >>> import numpy as np\n    >>> from timeit import timeit\n    >>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n    >>> mean = np.mean(a, axis=1, keepdims=True)\n    >>>\n    >>> g = globals()\n    >>> n = 10000\n    >>> t1 = timeit(\"std = np.std(a, axis=1, mean=mean)\", globals=g, number=n)\n    >>> t2 = timeit(\"std = np.std(a, axis=1)\", globals=g, number=n)\n    >>> print(f'Percentage execution time saved {100*(t2-t1)/t2:.0f}%')\n    #doctest: +SKIP\n    Percentage execution time saved 30%\n\n    \"\"\"\n    kwargs = {}\n    if keepdims is not np._NoValue:\n        kwargs['keepdims'] = keepdims\n    if where is not np._NoValue:\n        kwargs['where'] = where\n    if mean is not np._NoValue:\n        kwargs['mean'] = mean\n\n    if correction != np._NoValue:\n        if ddof != 0:\n            raise ValueError(\n                \"ddof and correction can't be provided simultaneously.\"\n            )\n        else:\n            ddof = correction\n\n    if type(a) is not mu.ndarray:\n        try:\n            std = a.std\n        except AttributeError:\n            pass\n        else:\n            return std(axis=axis, dtype=dtype, out=out, ddof=ddof, **kwargs)\n\n    return _methods._std(a, axis=axis, dtype=dtype, out=out, ddof=ddof,\n                         **kwargs)\n\n\ndef _var_dispatcher(a, axis=None, dtype=None, out=None, ddof=None,\n                    keepdims=None, *, where=None, mean=None, correction=None):\n    return (a, where, out, mean)\n\n\n@array_function_dispatch(_var_dispatcher)\ndef var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue, *,\n        where=np._NoValue, mean=np._NoValue, correction=np._NoValue):\n    r\"\"\"\n    Compute the variance along the specified axis.\n\n    Returns the variance of the array elements, a measure of the spread of a\n    distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose variance is desired.  If `a` is not an\n        array, a conversion is attempted.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which the variance is computed.  The default is to\n        compute the variance of the flattened array.\n        If this is a tuple of ints, a variance is performed over multiple axes,\n        instead of a single axis or all the axes as before.\n    dtype : data-type, optional\n        Type to use in computing the variance.  For arrays of integer type\n        the default is `float64`; for arrays of float types it is the same as\n        the array type.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary.\n    ddof : {int, float}, optional\n        \"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of elements. By\n        default `ddof` is zero. See notes for details about use of `ddof`.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        If the default value is passed, then `keepdims` will not be\n        passed through to the `var` method of sub-classes of\n        `ndarray`, however any non-default value will be.  If the\n        sub-class' method does not implement `keepdims` any\n        exceptions will be raised.\n    where : array_like of bool, optional\n        Elements to include in the variance. See `~numpy.ufunc.reduce` for\n        details.\n\n        .. versionadded:: 1.20.0\n\n    mean : array like, optional\n        Provide the mean to prevent its recalculation. The mean should have\n        a shape as if it was calculated with ``keepdims=True``.\n        The axis for the calculation of the mean should be the same as used in\n        the call to this var function.\n\n        .. versionadded:: 2.0.0\n\n    correction : {int, float}, optional\n        Array API compatible name for the ``ddof`` parameter. Only one of them\n        can be provided at the same time.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    variance : ndarray, see dtype parameter above\n        If ``out=None``, returns a new array containing the variance;\n        otherwise, a reference to the output array is returned.\n\n    See Also\n    --------\n    std, mean, nanmean, nanstd, nanvar\n    :ref:`ufuncs-output-type`\n\n    Notes\n    -----\n    There are several common variants of the array variance calculation.\n    Assuming the input `a` is a one-dimensional NumPy array and ``mean`` is\n    either provided as an argument or computed as ``a.mean()``, NumPy\n    computes the variance of an array as::\n\n        N = len(a)\n        d2 = abs(a - mean)**2  # abs is for complex `a`\n        var = d2.sum() / (N - ddof)  # note use of `ddof`\n\n    Different values of the argument `ddof` are useful in different\n    contexts. NumPy's default ``ddof=0`` corresponds with the expression:\n\n    .. math::\n\n        \\frac{\\sum_i{|a_i - \\bar{a}|^2 }}{N}\n\n    which is sometimes called the \"population variance\" in the field of\n    statistics because it applies the definition of variance to `a` as if `a`\n    were a complete population of possible observations.\n\n    Many other libraries define the variance of an array differently, e.g.:\n\n    .. math::\n\n        \\frac{\\sum_i{|a_i - \\bar{a}|^2}}{N - 1}\n\n    In statistics, the resulting quantity is sometimes called the \"sample\n    variance\" because if `a` is a random sample from a larger population,\n    this calculation provides an unbiased estimate of the variance of the\n    population.  The use of :math:`N-1` in the denominator is often called\n    \"Bessel's correction\" because it corrects for bias (toward lower values)\n    in the variance estimate introduced when the sample mean of `a` is used\n    in place of the true mean of the population. For this quantity, use\n    ``ddof=1``.\n\n    Note that for complex numbers, the absolute value is taken before\n    squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the variance is computed using the same\n    precision the input has.  Depending on the input data, this can cause\n    the results to be inaccurate, especially for `float32` (see example\n    below).  Specifying a higher-accuracy accumulator using the ``dtype``\n    keyword can alleviate this issue.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.var(a)\n    1.25\n    >>> np.var(a, axis=0)\n    array([1.,  1.])\n    >>> np.var(a, axis=1)\n    array([0.25,  0.25])\n\n    In single precision, var() can be inaccurate:\n\n    >>> a = np.zeros((2, 512*512), dtype=np.float32)\n    >>> a[0, :] = 1.0\n    >>> a[1, :] = 0.1\n    >>> np.var(a)\n    np.float32(0.20250003)\n\n    Computing the variance in float64 is more accurate:\n\n    >>> np.var(a, dtype=np.float64)\n    0.20249999932944759 # may vary\n    >>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n    0.2025\n\n    Specifying a where argument:\n\n    >>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n    >>> np.var(a)\n    6.833333333333333 # may vary\n    >>> np.var(a, where=[[True], [True], [False]])\n    4.0\n\n    Using the mean keyword to save computation time:\n\n    >>> import numpy as np\n    >>> from timeit import timeit\n    >>>\n    >>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])\n    >>> mean = np.mean(a, axis=1, keepdims=True)\n    >>>\n    >>> g = globals()\n    >>> n = 10000\n    >>> t1 = timeit(\"var = np.var(a, axis=1, mean=mean)\", globals=g, number=n)\n    >>> t2 = timeit(\"var = np.var(a, axis=1)\", globals=g, number=n)\n    >>> print(f'Percentage execution time saved {100*(t2-t1)/t2:.0f}%')\n    #doctest: +SKIP\n    Percentage execution time saved 32%\n\n    \"\"\"\n    kwargs = {}\n    if keepdims is not np._NoValue:\n        kwargs['keepdims'] = keepdims\n    if where is not np._NoValue:\n        kwargs['where'] = where\n    if mean is not np._NoValue:\n        kwargs['mean'] = mean\n\n    if correction != np._NoValue:\n        if ddof != 0:\n            raise ValueError(\n                \"ddof and correction can't be provided simultaneously.\"\n            )\n        else:\n            ddof = correction\n\n    if type(a) is not mu.ndarray:\n        try:\n            var = a.var\n\n        except AttributeError:\n            pass\n        else:\n            return var(axis=axis, dtype=dtype, out=out, ddof=ddof, **kwargs)\n\n    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,\n                         **kwargs)\n", 4269], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py": ["\"\"\"\nArray methods which are called by both the C-code for the method\nand the Python code for the NumPy-namespace function\n\n\"\"\"\nimport os\nimport pickle\nimport warnings\nfrom contextlib import nullcontext\n\nimport numpy as np\nfrom numpy._core import multiarray as mu\nfrom numpy._core import umath as um\nfrom numpy._core.multiarray import asanyarray\nfrom numpy._core import numerictypes as nt\nfrom numpy._core import _exceptions\nfrom numpy._globals import _NoValue\n\n# save those O(100) nanoseconds!\nbool_dt = mu.dtype(\"bool\")\numr_maximum = um.maximum.reduce\numr_minimum = um.minimum.reduce\numr_sum = um.add.reduce\numr_prod = um.multiply.reduce\numr_bitwise_count = um.bitwise_count\numr_any = um.logical_or.reduce\numr_all = um.logical_and.reduce\n\n# Complex types to -> (2,)float view for fast-path computation in _var()\n_complex_to_float = {\n    nt.dtype(nt.csingle) : nt.dtype(nt.single),\n    nt.dtype(nt.cdouble) : nt.dtype(nt.double),\n}\n# Special case for windows: ensure double takes precedence\nif nt.dtype(nt.longdouble) != nt.dtype(nt.double):\n    _complex_to_float.update({\n        nt.dtype(nt.clongdouble) : nt.dtype(nt.longdouble),\n    })\n\n# avoid keyword arguments to speed up parsing, saves about 15%-20% for very\n# small reductions\ndef _amax(a, axis=None, out=None, keepdims=False,\n          initial=_NoValue, where=True):\n    return umr_maximum(a, axis, None, out, keepdims, initial, where)\n\ndef _amin(a, axis=None, out=None, keepdims=False,\n          initial=_NoValue, where=True):\n    return umr_minimum(a, axis, None, out, keepdims, initial, where)\n\ndef _sum(a, axis=None, dtype=None, out=None, keepdims=False,\n         initial=_NoValue, where=True):\n    return umr_sum(a, axis, dtype, out, keepdims, initial, where)\n\ndef _prod(a, axis=None, dtype=None, out=None, keepdims=False,\n          initial=_NoValue, where=True):\n    return umr_prod(a, axis, dtype, out, keepdims, initial, where)\n\ndef _any(a, axis=None, dtype=None, out=None, keepdims=False, *, where=True):\n    # By default, return a boolean for any and all\n    if dtype is None:\n        dtype = bool_dt\n    # Parsing keyword arguments is currently fairly slow, so avoid it for now\n    if where is True:\n        return umr_any(a, axis, dtype, out, keepdims)\n    return umr_any(a, axis, dtype, out, keepdims, where=where)\n\ndef _all(a, axis=None, dtype=None, out=None, keepdims=False, *, where=True):\n    # By default, return a boolean for any and all\n    if dtype is None:\n        dtype = bool_dt\n    # Parsing keyword arguments is currently fairly slow, so avoid it for now\n    if where is True:\n        return umr_all(a, axis, dtype, out, keepdims)\n    return umr_all(a, axis, dtype, out, keepdims, where=where)\n\ndef _count_reduce_items(arr, axis, keepdims=False, where=True):\n    # fast-path for the default case\n    if where is True:\n        # no boolean mask given, calculate items according to axis\n        if axis is None:\n            axis = tuple(range(arr.ndim))\n        elif not isinstance(axis, tuple):\n            axis = (axis,)\n        items = 1\n        for ax in axis:\n            items *= arr.shape[mu.normalize_axis_index(ax, arr.ndim)]\n        items = nt.intp(items)\n    else:\n        # TODO: Optimize case when `where` is broadcast along a non-reduction\n        # axis and full sum is more excessive than needed.\n\n        # guarded to protect circular imports\n        from numpy.lib._stride_tricks_impl import broadcast_to\n        # count True values in (potentially broadcasted) boolean mask\n        items = umr_sum(broadcast_to(where, arr.shape), axis, nt.intp, None,\n                        keepdims)\n    return items\n\ndef _clip(a, min=None, max=None, out=None, **kwargs):\n    if a.dtype.kind in \"iu\":\n        # If min/max is a Python integer, deal with out-of-bound values here.\n        # (This enforces NEP 50 rules as no value based promotion is done.)\n        if type(min) is int and min <= np.iinfo(a.dtype).min:\n            min = None\n        if type(max) is int and max >= np.iinfo(a.dtype).max:\n            max = None\n\n    if min is None and max is None:\n        # return identity\n        return um.positive(a, out=out, **kwargs)\n    elif min is None:\n        return um.minimum(a, max, out=out, **kwargs)\n    elif max is None:\n        return um.maximum(a, min, out=out, **kwargs)\n    else:\n        return um.clip(a, min, max, out=out, **kwargs)\n\ndef _mean(a, axis=None, dtype=None, out=None, keepdims=False, *, where=True):\n    arr = asanyarray(a)\n\n    is_float16_result = False\n\n    rcount = _count_reduce_items(arr, axis, keepdims=keepdims, where=where)\n    if rcount == 0 if where is True else umr_any(rcount == 0, axis=None):\n        warnings.warn(\"Mean of empty slice.\", RuntimeWarning, stacklevel=2)\n\n    # Cast bool, unsigned int, and int to float64 by default\n    if dtype is None:\n        if issubclass(arr.dtype.type, (nt.integer, nt.bool)):\n            dtype = mu.dtype('f8')\n        elif issubclass(arr.dtype.type, nt.float16):\n            dtype = mu.dtype('f4')\n            is_float16_result = True\n\n    ret = umr_sum(arr, axis, dtype, out, keepdims, where=where)\n    if isinstance(ret, mu.ndarray):\n        ret = um.true_divide(\n                ret, rcount, out=ret, casting='unsafe', subok=False)\n        if is_float16_result and out is None:\n            ret = arr.dtype.type(ret)\n    elif hasattr(ret, 'dtype'):\n        if is_float16_result:\n            ret = arr.dtype.type(ret / rcount)\n        else:\n            ret = ret.dtype.type(ret / rcount)\n    else:\n        ret = ret / rcount\n\n    return ret\n\ndef _var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *,\n         where=True, mean=None):\n    arr = asanyarray(a)\n\n    rcount = _count_reduce_items(arr, axis, keepdims=keepdims, where=where)\n    # Make this warning show up on top.\n    if ddof >= rcount if where is True else umr_any(ddof >= rcount, axis=None):\n        warnings.warn(\"Degrees of freedom <= 0 for slice\", RuntimeWarning,\n                      stacklevel=2)\n\n    # Cast bool, unsigned int, and int to float64 by default\n    if dtype is None and issubclass(arr.dtype.type, (nt.integer, nt.bool)):\n        dtype = mu.dtype('f8')\n\n    if mean is not None:\n        arrmean = mean\n    else:\n        # Compute the mean.\n        # Note that if dtype is not of inexact type then arraymean will\n        # not be either.\n        arrmean = umr_sum(arr, axis, dtype, keepdims=True, where=where)\n        # The shape of rcount has to match arrmean to not change the shape of\n        # out in broadcasting. Otherwise, it cannot be stored back to arrmean.\n        if rcount.ndim == 0:\n            # fast-path for default case when where is True\n            div = rcount\n        else:\n            # matching rcount to arrmean when where is specified as array\n            div = rcount.reshape(arrmean.shape)\n        if isinstance(arrmean, mu.ndarray):\n            arrmean = um.true_divide(arrmean, div, out=arrmean,\n                                     casting='unsafe', subok=False)\n        elif hasattr(arrmean, \"dtype\"):\n            arrmean = arrmean.dtype.type(arrmean / rcount)\n        else:\n            arrmean = arrmean / rcount\n\n    # Compute sum of squared deviations from mean\n    # Note that x may not be inexact and that we need it to be an array,\n    # not a scalar.\n    x = asanyarray(arr - arrmean)\n\n    if issubclass(arr.dtype.type, (nt.floating, nt.integer)):\n        x = um.multiply(x, x, out=x)\n    # Fast-paths for built-in complex types\n    elif x.dtype in _complex_to_float:\n        xv = x.view(dtype=(_complex_to_float[x.dtype], (2,)))\n        um.multiply(xv, xv, out=xv)\n        x = um.add(xv[..., 0], xv[..., 1], out=x.real).real\n    # Most general case; includes handling object arrays containing imaginary\n    # numbers and complex types with non-native byteorder\n    else:\n        x = um.multiply(x, um.conjugate(x), out=x).real\n\n    ret = umr_sum(x, axis, dtype, out, keepdims=keepdims, where=where)\n\n    # Compute degrees of freedom and make sure it is not negative.\n    rcount = um.maximum(rcount - ddof, 0)\n\n    # divide by degrees of freedom\n    if isinstance(ret, mu.ndarray):\n        ret = um.true_divide(\n                ret, rcount, out=ret, casting='unsafe', subok=False)\n    elif hasattr(ret, 'dtype'):\n        ret = ret.dtype.type(ret / rcount)\n    else:\n        ret = ret / rcount\n\n    return ret\n\ndef _std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *,\n         where=True, mean=None):\n    ret = _var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,\n               keepdims=keepdims, where=where, mean=mean)\n\n    if isinstance(ret, mu.ndarray):\n        ret = um.sqrt(ret, out=ret)\n    elif hasattr(ret, 'dtype'):\n        ret = ret.dtype.type(um.sqrt(ret))\n    else:\n        ret = um.sqrt(ret)\n\n    return ret\n\ndef _ptp(a, axis=None, out=None, keepdims=False):\n    return um.subtract(\n        umr_maximum(a, axis, None, out, keepdims),\n        umr_minimum(a, axis, None, None, keepdims),\n        out\n    )\n\ndef _dump(self, file, protocol=2):\n    if hasattr(file, 'write'):\n        ctx = nullcontext(file)\n    else:\n        ctx = open(os.fspath(file), \"wb\")\n    with ctx as f:\n        pickle.dump(self, f, protocol=protocol)\n\ndef _dumps(self, protocol=2):\n    return pickle.dumps(self, protocol=protocol)\n\ndef _bitwise_count(a, out=None, *, where=True, casting='same_kind',\n          order='K', dtype=None, subok=True):\n    return umr_bitwise_count(a, out, where=where, casting=casting,\n            order=order, dtype=dtype, subok=subok)\n", 256], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py": ["#__docformat__ = \"restructuredtext en\"\n# ******NOTICE***************\n# optimize.py module by Travis E. Oliphant\n#\n# You may copy and use this module as you see fit with no\n# guarantee implied provided you keep this notice in all copies.\n# *****END NOTICE************\n\n# A collection of optimization algorithms. Version 0.5\n# CHANGES\n#  Added fminbound (July 2001)\n#  Added brute (Aug. 2002)\n#  Finished line search satisfying strong Wolfe conditions (Mar. 2004)\n#  Updated strong Wolfe conditions line search to use\n#  cubic-interpolation (Mar. 2004)\n\n\n# Minimization routines\n\n__all__ = ['fmin', 'fmin_powell', 'fmin_bfgs', 'fmin_ncg', 'fmin_cg',\n           'fminbound', 'brent', 'golden', 'bracket', 'rosen', 'rosen_der',\n           'rosen_hess', 'rosen_hess_prod', 'brute', 'approx_fprime',\n           'line_search', 'check_grad', 'OptimizeResult', 'show_options',\n           'OptimizeWarning']\n\n__docformat__ = \"restructuredtext en\"\n\nimport math\nimport warnings\nimport sys\nimport inspect\nfrom numpy import eye, argmin, zeros, shape, asarray, sqrt\nimport numpy as np\nfrom scipy.linalg import cholesky, issymmetric, LinAlgError\nfrom scipy.sparse.linalg import LinearOperator\nfrom ._linesearch import (line_search_wolfe1, line_search_wolfe2,\n                          line_search_wolfe2 as line_search,\n                          LineSearchWarning)\nfrom ._numdiff import approx_derivative\nfrom scipy._lib._util import getfullargspec_no_self as _getfullargspec\nfrom scipy._lib._util import (MapWrapper, check_random_state, _RichResult,\n                              _call_callback_maybe_halt, _transition_to_rng)\nfrom scipy.optimize._differentiable_functions import ScalarFunction, FD_METHODS\nfrom scipy._lib._array_api import array_namespace\nfrom scipy._lib import array_api_extra as xpx\n\n\n# standard status messages of optimizers\n_status_message = {'success': 'Optimization terminated successfully.',\n                   'maxfev': 'Maximum number of function evaluations has '\n                              'been exceeded.',\n                   'maxiter': 'Maximum number of iterations has been '\n                              'exceeded.',\n                   'pr_loss': 'Desired error not necessarily achieved due '\n                              'to precision loss.',\n                   'nan': 'NaN result encountered.',\n                   'out_of_bounds': 'The result is outside of the provided '\n                                    'bounds.'}\n\n\nclass MemoizeJac:\n    \"\"\"Decorator that caches the return values of a function returning ``(fun, grad)``\n    each time it is called.\"\"\"\n\n    def __init__(self, fun):\n        self.fun = fun\n        self.jac = None\n        self._value = None\n        self.x = None\n\n    def _compute_if_needed(self, x, *args):\n        if not np.all(x == self.x) or self._value is None or self.jac is None:\n            self.x = np.asarray(x).copy()\n            fg = self.fun(x, *args)\n            self.jac = fg[1]\n            self._value = fg[0]\n\n    def __call__(self, x, *args):\n        \"\"\" returns the function value \"\"\"\n        self._compute_if_needed(x, *args)\n        return self._value\n\n    def derivative(self, x, *args):\n        self._compute_if_needed(x, *args)\n        return self.jac\n\n\ndef _wrap_callback(callback, method=None):\n    \"\"\"Wrap a user-provided callback so that attributes can be attached.\"\"\"\n    if callback is None or method in {'tnc', 'slsqp', 'cobyla', 'cobyqa'}:\n        return callback  # don't wrap\n\n    sig = inspect.signature(callback)\n\n    if set(sig.parameters) == {'intermediate_result'}:\n        def wrapped_callback(res):\n            return callback(intermediate_result=res)\n    elif method == 'trust-constr':\n        def wrapped_callback(res):\n            return callback(np.copy(res.x), res)\n    elif method == 'differential_evolution':\n        def wrapped_callback(res):\n            return callback(np.copy(res.x), res.convergence)\n    else:\n        def wrapped_callback(res):\n            return callback(np.copy(res.x))\n\n    wrapped_callback.stop_iteration = False\n    return wrapped_callback\n\n\nclass OptimizeResult(_RichResult):\n    \"\"\"\n    Represents the optimization result.\n\n    Attributes\n    ----------\n    x : ndarray\n        The solution of the optimization.\n    success : bool\n        Whether or not the optimizer exited successfully.\n    status : int\n        Termination status of the optimizer. Its value depends on the\n        underlying solver. Refer to `message` for details.\n    message : str\n        Description of the cause of the termination.\n    fun : float\n        Value of objective function at `x`.\n    jac, hess : ndarray\n        Values of objective function's Jacobian and its Hessian at `x` (if\n        available). The Hessian may be an approximation, see the documentation\n        of the function in question.\n    hess_inv : object\n        Inverse of the objective function's Hessian; may be an approximation.\n        Not available for all solvers. The type of this attribute may be\n        either np.ndarray or scipy.sparse.linalg.LinearOperator.\n    nfev, njev, nhev : int\n        Number of evaluations of the objective functions and of its\n        Jacobian and Hessian.\n    nit : int\n        Number of iterations performed by the optimizer.\n    maxcv : float\n        The maximum constraint violation.\n\n    Notes\n    -----\n    Depending on the specific solver being used, `OptimizeResult` may\n    not have all attributes listed here, and they may have additional\n    attributes not listed here. Since this class is essentially a\n    subclass of dict with attribute accessors, one can see which\n    attributes are available using the `OptimizeResult.keys` method.\n\n    \"\"\"\n    pass\n\n\nclass OptimizeWarning(UserWarning):\n    pass\n\ndef _check_positive_definite(Hk):\n    def is_pos_def(A):\n        if issymmetric(A):\n            try:\n                cholesky(A)\n                return True\n            except LinAlgError:\n                return False\n        else:\n            return False\n    if Hk is not None:\n        if not is_pos_def(Hk):\n            raise ValueError(\"'hess_inv0' matrix isn't positive definite.\")\n\n\ndef _check_unknown_options(unknown_options):\n    if unknown_options:\n        msg = \", \".join(map(str, unknown_options.keys()))\n        # Stack level 4: this is called from _minimize_*, which is\n        # called from another function in SciPy. Level 4 is the first\n        # level in user code.\n        warnings.warn(f\"Unknown solver options: {msg}\", OptimizeWarning, stacklevel=4)\n\n\ndef is_finite_scalar(x):\n    \"\"\"Test whether `x` is either a finite scalar or a finite array scalar.\n\n    \"\"\"\n    return np.size(x) == 1 and np.isfinite(x)\n\n\n_epsilon = sqrt(np.finfo(float).eps)\n\n\ndef vecnorm(x, ord=2):\n    if ord == np.inf:\n        return np.amax(np.abs(x))\n    elif ord == -np.inf:\n        return np.amin(np.abs(x))\n    else:\n        return np.sum(np.abs(x)**ord, axis=0)**(1.0 / ord)\n\n\ndef _prepare_scalar_function(fun, x0, jac=None, args=(), bounds=None,\n                             epsilon=None, finite_diff_rel_step=None,\n                             hess=None):\n    \"\"\"\n    Creates a ScalarFunction object for use with scalar minimizers\n    (BFGS/LBFGSB/SLSQP/TNC/CG/etc).\n\n    Parameters\n    ----------\n    fun : callable\n        The objective function to be minimized.\n\n            ``fun(x, *args) -> float``\n\n        where ``x`` is an 1-D array with shape (n,) and ``args``\n        is a tuple of the fixed parameters needed to completely\n        specify the function.\n    x0 : ndarray, shape (n,)\n        Initial guess. Array of real elements of size (n,),\n        where 'n' is the number of independent variables.\n    jac : {callable,  '2-point', '3-point', 'cs', None}, optional\n        Method for computing the gradient vector. If it is a callable, it\n        should be a function that returns the gradient vector:\n\n            ``jac(x, *args) -> array_like, shape (n,)``\n\n        If one of `{'2-point', '3-point', 'cs'}` is selected then the gradient\n        is calculated with a relative step for finite differences. If `None`,\n        then two-point finite differences with an absolute step is used.\n    args : tuple, optional\n        Extra arguments passed to the objective function and its\n        derivatives (`fun`, `jac` functions).\n    bounds : sequence, optional\n        Bounds on variables. 'new-style' bounds are required.\n    eps : float or ndarray\n        If ``jac is None`` the absolute step size used for numerical\n        approximation of the jacobian via forward differences.\n    finite_diff_rel_step : None or array_like, optional\n        If ``jac in ['2-point', '3-point', 'cs']`` the relative step size to\n        use for numerical approximation of the jacobian. The absolute step\n        size is computed as ``h = rel_step * sign(x0) * max(1, abs(x0))``,\n        possibly adjusted to fit into the bounds. For ``jac='3-point'``\n        the sign of `h` is ignored. If None (default) then step is selected\n        automatically.\n    hess : {callable,  '2-point', '3-point', 'cs', None}\n        Computes the Hessian matrix. If it is callable, it should return the\n        Hessian matrix:\n\n            ``hess(x, *args) -> {LinearOperator, spmatrix, array}, (n, n)``\n\n        Alternatively, the keywords {'2-point', '3-point', 'cs'} select a\n        finite difference scheme for numerical estimation.\n        Whenever the gradient is estimated via finite-differences, the Hessian\n        cannot be estimated with options {'2-point', '3-point', 'cs'} and needs\n        to be estimated using one of the quasi-Newton strategies.\n\n    Returns\n    -------\n    sf : ScalarFunction\n    \"\"\"\n    if callable(jac):\n        grad = jac\n    elif jac in FD_METHODS:\n        # epsilon is set to None so that ScalarFunction is made to use\n        # rel_step\n        epsilon = None\n        grad = jac\n    else:\n        # default (jac is None) is to do 2-point finite differences with\n        # absolute step size. ScalarFunction has to be provided an\n        # epsilon value that is not None to use absolute steps. This is\n        # normally the case from most _minimize* methods.\n        grad = '2-point'\n        epsilon = epsilon\n\n    if hess is None:\n        # ScalarFunction requires something for hess, so we give a dummy\n        # implementation here if nothing is provided, return a value of None\n        # so that downstream minimisers halt. The results of `fun.hess`\n        # should not be used.\n        def hess(x, *args):\n            return None\n\n    if bounds is None:\n        bounds = (-np.inf, np.inf)\n\n    # ScalarFunction caches. Reuse of fun(x) during grad\n    # calculation reduces overall function evaluations.\n    sf = ScalarFunction(fun, x0, args, grad, hess,\n                        finite_diff_rel_step, bounds, epsilon=epsilon)\n\n    return sf\n\n\ndef _clip_x_for_func(func, bounds):\n    # ensures that x values sent to func are clipped to bounds\n\n    # this is used as a mitigation for gh11403, slsqp/tnc sometimes\n    # suggest a move that is outside the limits by 1 or 2 ULP. This\n    # unclean fix makes sure x is strictly within bounds.\n    def eval(x):\n        x = _check_clip_x(x, bounds)\n        return func(x)\n\n    return eval\n\n\ndef _check_clip_x(x, bounds):\n    if (x < bounds[0]).any() or (x > bounds[1]).any():\n        warnings.warn(\"Values in x were outside bounds during a \"\n                      \"minimize step, clipping to bounds\",\n                      RuntimeWarning, stacklevel=3)\n        x = np.clip(x, bounds[0], bounds[1])\n        return x\n\n    return x\n\n\ndef rosen(x):\n    \"\"\"\n    The Rosenbrock function.\n\n    The function computed is::\n\n        sum(100.0*(x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0)\n\n    Parameters\n    ----------\n    x : array_like\n        1-D array of points at which the Rosenbrock function is to be computed.\n\n    Returns\n    -------\n    f : float\n        The value of the Rosenbrock function.\n\n    See Also\n    --------\n    rosen_der, rosen_hess, rosen_hess_prod\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.optimize import rosen\n    >>> X = 0.1 * np.arange(10)\n    >>> rosen(X)\n    76.56\n\n    For higher-dimensional input ``rosen`` broadcasts.\n    In the following example, we use this to plot a 2D landscape.\n    Note that ``rosen_hess`` does not broadcast in this manner.\n\n    >>> import matplotlib.pyplot as plt\n    >>> from mpl_toolkits.mplot3d import Axes3D\n    >>> x = np.linspace(-1, 1, 50)\n    >>> X, Y = np.meshgrid(x, x)\n    >>> ax = plt.subplot(111, projection='3d')\n    >>> ax.plot_surface(X, Y, rosen([X, Y]))\n    >>> plt.show()\n    \"\"\"\n    xp = array_namespace(x)\n    x = xp.asarray(x)\n    if xp.isdtype(x.dtype, 'integral'):\n        x = xp.astype(x, xp.asarray(1.).dtype)\n    r = xp.sum(100.0 * (x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0,\n               axis=0, dtype=x.dtype)\n    return r\n\n\ndef rosen_der(x):\n    \"\"\"\n    The derivative (i.e. gradient) of the Rosenbrock function.\n\n    Parameters\n    ----------\n    x : array_like\n        1-D array of points at which the derivative is to be computed.\n\n    Returns\n    -------\n    rosen_der : (N,) ndarray\n        The gradient of the Rosenbrock function at `x`.\n\n    See Also\n    --------\n    rosen, rosen_hess, rosen_hess_prod\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.optimize import rosen_der\n    >>> X = 0.1 * np.arange(9)\n    >>> rosen_der(X)\n    array([ -2. ,  10.6,  15.6,  13.4,   6.4,  -3. , -12.4, -19.4,  62. ])\n\n    \"\"\"\n    xp = array_namespace(x)\n    x = xp.asarray(x)\n    if xp.isdtype(x.dtype, 'integral'):\n        x = xp.astype(x, xp.asarray(1.).dtype)\n    xm = x[1:-1]\n    xm_m1 = x[:-2]\n    xm_p1 = x[2:]\n    der = xp.zeros_like(x)\n    der[1:-1] = (200 * (xm - xm_m1**2) -\n                 400 * (xm_p1 - xm**2) * xm - 2 * (1 - xm))\n    der[0] = -400 * x[0] * (x[1] - x[0]**2) - 2 * (1 - x[0])\n    der[-1] = 200 * (x[-1] - x[-2]**2)\n    return der\n\n\ndef rosen_hess(x):\n    \"\"\"\n    The Hessian matrix of the Rosenbrock function.\n\n    Parameters\n    ----------\n    x : array_like\n        1-D array of points at which the Hessian matrix is to be computed.\n\n    Returns\n    -------\n    rosen_hess : ndarray\n        The Hessian matrix of the Rosenbrock function at `x`.\n\n    See Also\n    --------\n    rosen, rosen_der, rosen_hess_prod\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.optimize import rosen_hess\n    >>> X = 0.1 * np.arange(4)\n    >>> rosen_hess(X)\n    array([[-38.,   0.,   0.,   0.],\n           [  0., 134., -40.,   0.],\n           [  0., -40., 130., -80.],\n           [  0.,   0., -80., 200.]])\n\n    \"\"\"\n    xp = array_namespace(x)\n    x = xpx.atleast_nd(x, ndim=1, xp=xp)\n    if xp.isdtype(x.dtype, 'integral'):\n        x = xp.astype(x, xp.asarray(1.).dtype)\n    H = (xpx.create_diagonal(-400 * x[:-1], offset=1, xp=xp) \n         - xpx.create_diagonal(400 * x[:-1], offset=-1, xp=xp))\n    diagonal = xp.zeros(x.shape[0], dtype=x.dtype)\n    diagonal[0] = 1200 * x[0]**2 - 400 * x[1] + 2\n    diagonal[-1] = 200\n    diagonal[1:-1] = 202 + 1200 * x[1:-1]**2 - 400 * x[2:]\n    return H + xpx.create_diagonal(diagonal, xp=xp)\n\n\ndef rosen_hess_prod(x, p):\n    \"\"\"\n    Product of the Hessian matrix of the Rosenbrock function with a vector.\n\n    Parameters\n    ----------\n    x : array_like\n        1-D array of points at which the Hessian matrix is to be computed.\n    p : array_like\n        1-D array, the vector to be multiplied by the Hessian matrix.\n\n    Returns\n    -------\n    rosen_hess_prod : ndarray\n        The Hessian matrix of the Rosenbrock function at `x` multiplied\n        by the vector `p`.\n\n    See Also\n    --------\n    rosen, rosen_der, rosen_hess\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.optimize import rosen_hess_prod\n    >>> X = 0.1 * np.arange(9)\n    >>> p = 0.5 * np.arange(9)\n    >>> rosen_hess_prod(X, p)\n    array([  -0.,   27.,  -10.,  -95., -192., -265., -278., -195., -180.])\n\n    \"\"\"\n    xp = array_namespace(x, p)\n    x = xpx.atleast_nd(x, ndim=1, xp=xp)\n    if xp.isdtype(x.dtype, 'integral'):\n        x = xp.astype(x, xp.asarray(1.).dtype)\n    p = xp.asarray(p, dtype=x.dtype)\n    Hp = xp.zeros(x.shape[0], dtype=x.dtype)\n    Hp[0] = (1200 * x[0]**2 - 400 * x[1] + 2) * p[0] - 400 * x[0] * p[1]\n    Hp[1:-1] = (-400 * x[:-2] * p[:-2] +\n                (202 + 1200 * x[1:-1]**2 - 400 * x[2:]) * p[1:-1] -\n                400 * x[1:-1] * p[2:])\n    Hp[-1] = -400 * x[-2] * p[-2] + 200*p[-1]\n    return Hp\n\n\ndef _wrap_scalar_function(function, args):\n    # wraps a minimizer function to count number of evaluations\n    # and to easily provide an args kwd.\n    ncalls = [0]\n    if function is None:\n        return ncalls, None\n\n    def function_wrapper(x, *wrapper_args):\n        ncalls[0] += 1\n        # A copy of x is sent to the user function (gh13740)\n        fx = function(np.copy(x), *(wrapper_args + args))\n        # Ideally, we'd like to a have a true scalar returned from f(x). For\n        # backwards-compatibility, also allow np.array([1.3]), np.array([[1.3]]) etc.\n        if not np.isscalar(fx):\n            try:\n                fx = np.asarray(fx).item()\n            except (TypeError, ValueError) as e:\n                raise ValueError(\"The user-provided objective function \"\n                                 \"must return a scalar value.\") from e\n        return fx\n\n    return ncalls, function_wrapper\n\n\nclass _MaxFuncCallError(RuntimeError):\n    pass\n\n\ndef _wrap_scalar_function_maxfun_validation(function, args, maxfun):\n    # wraps a minimizer function to count number of evaluations\n    # and to easily provide an args kwd.\n    ncalls = [0]\n    if function is None:\n        return ncalls, None\n\n    def function_wrapper(x, *wrapper_args):\n        if ncalls[0] >= maxfun:\n            raise _MaxFuncCallError(\"Too many function calls\")\n        ncalls[0] += 1\n        # A copy of x is sent to the user function (gh13740)\n        fx = function(np.copy(x), *(wrapper_args + args))\n        # Ideally, we'd like to a have a true scalar returned from f(x). For\n        # backwards-compatibility, also allow np.array([1.3]),\n        # np.array([[1.3]]) etc.\n        if not np.isscalar(fx):\n            try:\n                fx = np.asarray(fx).item()\n            except (TypeError, ValueError) as e:\n                raise ValueError(\"The user-provided objective function \"\n                                 \"must return a scalar value.\") from e\n        return fx\n\n    return ncalls, function_wrapper\n\n\ndef fmin(func, x0, args=(), xtol=1e-4, ftol=1e-4, maxiter=None, maxfun=None,\n         full_output=0, disp=1, retall=0, callback=None, initial_simplex=None):\n    \"\"\"\n    Minimize a function using the downhill simplex algorithm.\n\n    This algorithm only uses function values, not derivatives or second\n    derivatives.\n\n    Parameters\n    ----------\n    func : callable func(x,*args)\n        The objective function to be minimized.\n    x0 : ndarray\n        Initial guess.\n    args : tuple, optional\n        Extra arguments passed to func, i.e., ``f(x,*args)``.\n    xtol : float, optional\n        Absolute error in xopt between iterations that is acceptable for\n        convergence.\n    ftol : number, optional\n        Absolute error in func(xopt) between iterations that is acceptable for\n        convergence.\n    maxiter : int, optional\n        Maximum number of iterations to perform.\n    maxfun : number, optional\n        Maximum number of function evaluations to make.\n    full_output : bool, optional\n        Set to True if fopt and warnflag outputs are desired.\n    disp : bool, optional\n        Set to True to print convergence messages.\n    retall : bool, optional\n        Set to True to return list of solutions at each iteration.\n    callback : callable, optional\n        Called after each iteration, as callback(xk), where xk is the\n        current parameter vector.\n    initial_simplex : array_like of shape (N + 1, N), optional\n        Initial simplex. If given, overrides `x0`.\n        ``initial_simplex[j,:]`` should contain the coordinates of\n        the jth vertex of the ``N+1`` vertices in the simplex, where\n        ``N`` is the dimension.\n\n    Returns\n    -------\n    xopt : ndarray\n        Parameter that minimizes function.\n    fopt : float\n        Value of function at minimum: ``fopt = func(xopt)``.\n    iter : int\n        Number of iterations performed.\n    funcalls : int\n        Number of function calls made.\n    warnflag : int\n        1 : Maximum number of function evaluations made.\n        2 : Maximum number of iterations reached.\n    allvecs : list\n        Solution at each iteration.\n\n    See also\n    --------\n    minimize: Interface to minimization algorithms for multivariate\n        functions. See the 'Nelder-Mead' `method` in particular.\n\n    Notes\n    -----\n    Uses a Nelder-Mead simplex algorithm to find the minimum of function of\n    one or more variables.\n\n    This algorithm has a long history of successful use in applications.\n    But it will usually be slower than an algorithm that uses first or\n    second derivative information. In practice, it can have poor\n    performance in high-dimensional problems and is not robust to\n    minimizing complicated functions. Additionally, there currently is no\n    complete theory describing when the algorithm will successfully\n    converge to the minimum, or how fast it will if it does. Both the ftol and\n    xtol criteria must be met for convergence.\n\n    Examples\n    --------\n    >>> def f(x):\n    ...     return x**2\n\n    >>> from scipy import optimize\n\n    >>> minimum = optimize.fmin(f, 1)\n    Optimization terminated successfully.\n             Current function value: 0.000000\n             Iterations: 17\n             Function evaluations: 34\n    >>> minimum[0]\n    -8.8817841970012523e-16\n\n    References\n    ----------\n    .. [1] Nelder, J.A. and Mead, R. (1965), \"A simplex method for function\n           minimization\", The Computer Journal, 7, pp. 308-313\n\n    .. [2] Wright, M.H. (1996), \"Direct Search Methods: Once Scorned, Now\n           Respectable\", in Numerical Analysis 1995, Proceedings of the\n           1995 Dundee Biennial Conference in Numerical Analysis, D.F.\n           Griffiths and G.A. Watson (Eds.), Addison Wesley Longman,\n           Harlow, UK, pp. 191-208.\n\n    \"\"\"\n    opts = {'xatol': xtol,\n            'fatol': ftol,\n            'maxiter': maxiter,\n            'maxfev': maxfun,\n            'disp': disp,\n            'return_all': retall,\n            'initial_simplex': initial_simplex}\n\n    callback = _wrap_callback(callback)\n    res = _minimize_neldermead(func, x0, args, callback=callback, **opts)\n    if full_output:\n        retlist = res['x'], res['fun'], res['nit'], res['nfev'], res['status']\n        if retall:\n            retlist += (res['allvecs'], )\n        return retlist\n    else:\n        if retall:\n            return res['x'], res['allvecs']\n        else:\n            return res['x']\n\n\ndef _minimize_neldermead(func, x0, args=(), callback=None,\n                         maxiter=None, maxfev=None, disp=False,\n                         return_all=False, initial_simplex=None,\n                         xatol=1e-4, fatol=1e-4, adaptive=False, bounds=None,\n                         **unknown_options):\n    \"\"\"\n    Minimization of scalar function of one or more variables using the\n    Nelder-Mead algorithm.\n\n    Options\n    -------\n    disp : bool\n        Set to True to print convergence messages.\n    maxiter, maxfev : int\n        Maximum allowed number of iterations and function evaluations.\n        Will default to ``N*200``, where ``N`` is the number of\n        variables, if neither `maxiter` or `maxfev` is set. If both\n        `maxiter` and `maxfev` are set, minimization will stop at the\n        first reached.\n    return_all : bool, optional\n        Set to True to return a list of the best solution at each of the\n        iterations.\n    initial_simplex : array_like of shape (N + 1, N)\n        Initial simplex. If given, overrides `x0`.\n        ``initial_simplex[j,:]`` should contain the coordinates of\n        the jth vertex of the ``N+1`` vertices in the simplex, where\n        ``N`` is the dimension.\n    xatol : float, optional\n        Absolute error in xopt between iterations that is acceptable for\n        convergence.\n    fatol : number, optional\n        Absolute error in func(xopt) between iterations that is acceptable for\n        convergence.\n    adaptive : bool, optional\n        Adapt algorithm parameters to dimensionality of problem. Useful for\n        high-dimensional minimization [1]_.\n    bounds : sequence or `Bounds`, optional\n        Bounds on variables. There are two ways to specify the bounds:\n\n        1. Instance of `Bounds` class.\n        2. Sequence of ``(min, max)`` pairs for each element in `x`. None\n           is used to specify no bound.\n\n        Note that this just clips all vertices in simplex based on\n        the bounds.\n\n    References\n    ----------\n    .. [1] Gao, F. and Han, L.\n       Implementing the Nelder-Mead simplex algorithm with adaptive\n       parameters. 2012. Computational Optimization and Applications.\n       51:1, pp. 259-277\n\n    \"\"\"\n    _check_unknown_options(unknown_options)\n    maxfun = maxfev\n    retall = return_all\n\n    x0 = np.atleast_1d(x0).flatten()\n    dtype = x0.dtype if np.issubdtype(x0.dtype, np.inexact) else np.float64\n    x0 = np.asarray(x0, dtype=dtype)\n\n    if adaptive:\n        dim = float(len(x0))\n        rho = 1\n        chi = 1 + 2/dim\n        psi = 0.75 - 1/(2*dim)\n        sigma = 1 - 1/dim\n    else:\n        rho = 1\n        chi = 2\n        psi = 0.5\n        sigma = 0.5\n\n    nonzdelt = 0.05\n    zdelt = 0.00025\n\n    if bounds is not None:\n        lower_bound, upper_bound = bounds.lb, bounds.ub\n        # check bounds\n        if (lower_bound > upper_bound).any():\n            raise ValueError(\"Nelder Mead - one of the lower bounds \"\n                             \"is greater than an upper bound.\")\n        if np.any(lower_bound > x0) or np.any(x0 > upper_bound):\n            warnings.warn(\"Initial guess is not within the specified bounds\",\n                          OptimizeWarning, stacklevel=3)\n\n    if bounds is not None:\n        x0 = np.clip(x0, lower_bound, upper_bound)\n\n    if initial_simplex is None:\n        N = len(x0)\n\n        sim = np.empty((N + 1, N), dtype=x0.dtype)\n        sim[0] = x0\n        for k in range(N):\n            y = np.array(x0, copy=True)\n            if y[k] != 0:\n                y[k] = (1 + nonzdelt)*y[k]\n            else:\n                y[k] = zdelt\n            sim[k + 1] = y\n    else:\n        sim = np.atleast_2d(initial_simplex).copy()\n        dtype = sim.dtype if np.issubdtype(sim.dtype, np.inexact) else np.float64\n        sim = np.asarray(sim, dtype=dtype)\n        if sim.ndim != 2 or sim.shape[0] != sim.shape[1] + 1:\n            raise ValueError(\"`initial_simplex` should be an array of shape (N+1,N)\")\n        if len(x0) != sim.shape[1]:\n            raise ValueError(\"Size of `initial_simplex` is not consistent with `x0`\")\n        N = sim.shape[1]\n\n    if retall:\n        allvecs = [sim[0]]\n\n    # If neither are set, then set both to default\n    if maxiter is None and maxfun is None:\n        maxiter = N * 200\n        maxfun = N * 200\n    elif maxiter is None:\n        # Convert remaining Nones, to np.inf, unless the other is np.inf, in\n        # which case use the default to avoid unbounded iteration\n        if maxfun == np.inf:\n            maxiter = N * 200\n        else:\n            maxiter = np.inf\n    elif maxfun is None:\n        if maxiter == np.inf:\n            maxfun = N * 200\n        else:\n            maxfun = np.inf\n\n    if bounds is not None:\n        # The default simplex construction may make all entries (for a given\n        # parameter) greater than an upper bound if x0 is very close to the\n        # upper bound. If one simply clips the simplex to the bounds this could\n        # make the simplex entries degenerate. If that occurs reflect into the\n        # interior.\n        msk = sim > upper_bound\n        # reflect into the interior\n        sim = np.where(msk, 2*upper_bound - sim, sim)\n        # but make sure the reflection is no less than the lower_bound\n        sim = np.clip(sim, lower_bound, upper_bound)\n\n    one2np1 = list(range(1, N + 1))\n    fsim = np.full((N + 1,), np.inf, dtype=float)\n\n    fcalls, func = _wrap_scalar_function_maxfun_validation(func, args, maxfun)\n\n    try:\n        for k in range(N + 1):\n            fsim[k] = func(sim[k])\n    except _MaxFuncCallError:\n        pass\n    finally:\n        ind = np.argsort(fsim)\n        sim = np.take(sim, ind, 0)\n        fsim = np.take(fsim, ind, 0)\n\n    ind = np.argsort(fsim)\n    fsim = np.take(fsim, ind, 0)\n    # sort so sim[0,:] has the lowest function value\n    sim = np.take(sim, ind, 0)\n\n    iterations = 1\n\n    while (fcalls[0] < maxfun and iterations < maxiter):\n        try:\n            if (np.max(np.ravel(np.abs(sim[1:] - sim[0]))) <= xatol and\n                    np.max(np.abs(fsim[0] - fsim[1:])) <= fatol):\n                break\n\n            xbar = np.add.reduce(sim[:-1], 0) / N\n            xr = (1 + rho) * xbar - rho * sim[-1]\n            if bounds is not None:\n                xr = np.clip(xr, lower_bound, upper_bound)\n            fxr = func(xr)\n            doshrink = 0\n\n            if fxr < fsim[0]:\n                xe = (1 + rho * chi) * xbar - rho * chi * sim[-1]\n                if bounds is not None:\n                    xe = np.clip(xe, lower_bound, upper_bound)\n                fxe = func(xe)\n\n                if fxe < fxr:\n                    sim[-1] = xe\n                    fsim[-1] = fxe\n                else:\n                    sim[-1] = xr\n                    fsim[-1] = fxr\n            else:  # fsim[0] <= fxr\n                if fxr < fsim[-2]:\n                    sim[-1] = xr\n                    fsim[-1] = fxr\n                else:  # fxr >= fsim[-2]\n                    # Perform contraction\n                    if fxr < fsim[-1]:\n                        xc = (1 + psi * rho) * xbar - psi * rho * sim[-1]\n                        if bounds is not None:\n                            xc = np.clip(xc, lower_bound, upper_bound)\n                        fxc = func(xc)\n\n                        if fxc <= fxr:\n                            sim[-1] = xc\n                            fsim[-1] = fxc\n                        else:\n                            doshrink = 1\n                    else:\n                        # Perform an inside contraction\n                        xcc = (1 - psi) * xbar + psi * sim[-1]\n                        if bounds is not None:\n                            xcc = np.clip(xcc, lower_bound, upper_bound)\n                        fxcc = func(xcc)\n\n                        if fxcc < fsim[-1]:\n                            sim[-1] = xcc\n                            fsim[-1] = fxcc\n                        else:\n                            doshrink = 1\n\n                    if doshrink:\n                        for j in one2np1:\n                            sim[j] = sim[0] + sigma * (sim[j] - sim[0])\n                            if bounds is not None:\n                                sim[j] = np.clip(\n                                    sim[j], lower_bound, upper_bound)\n                            fsim[j] = func(sim[j])\n            iterations += 1\n        except _MaxFuncCallError:\n            pass\n        finally:\n            ind = np.argsort(fsim)\n            sim = np.take(sim, ind, 0)\n            fsim = np.take(fsim, ind, 0)\n            if retall:\n                allvecs.append(sim[0])\n            intermediate_result = OptimizeResult(x=sim[0], fun=fsim[0])\n            if _call_callback_maybe_halt(callback, intermediate_result):\n                break\n\n    x = sim[0]\n    fval = np.min(fsim)\n    warnflag = 0\n\n    if fcalls[0] >= maxfun:\n        warnflag = 1\n        msg = _status_message['maxfev']\n        if disp:\n            warnings.warn(msg, RuntimeWarning, stacklevel=3)\n    elif iterations >= maxiter:\n        warnflag = 2\n        msg = _status_message['maxiter']\n        if disp:\n            warnings.warn(msg, RuntimeWarning, stacklevel=3)\n    else:\n        msg = _status_message['success']\n        if disp:\n            print(msg)\n            print(f\"         Current function value: {fval:f}\")\n            print(\"         Iterations: %d\" % iterations)\n            print(\"         Function evaluations: %d\" % fcalls[0])\n\n    result = OptimizeResult(fun=fval, nit=iterations, nfev=fcalls[0],\n                            status=warnflag, success=(warnflag == 0),\n                            message=msg, x=x, final_simplex=(sim, fsim))\n    if retall:\n        result['allvecs'] = allvecs\n    return result\n\n\ndef approx_fprime(xk, f, epsilon=_epsilon, *args):\n    \"\"\"Finite difference approximation of the derivatives of a\n    scalar or vector-valued function.\n\n    If a function maps from :math:`R^n` to :math:`R^m`, its derivatives form\n    an m-by-n matrix\n    called the Jacobian, where an element :math:`(i, j)` is a partial\n    derivative of f[i] with respect to ``xk[j]``.\n\n    Parameters\n    ----------\n    xk : array_like\n        The coordinate vector at which to determine the gradient of `f`.\n    f : callable\n        Function of which to estimate the derivatives of. Has the signature\n        ``f(xk, *args)`` where `xk` is the argument in the form of a 1-D array\n        and `args` is a tuple of any additional fixed parameters needed to\n        completely specify the function. The argument `xk` passed to this\n        function is an ndarray of shape (n,) (never a scalar even if n=1).\n        It must return a 1-D array_like of shape (m,) or a scalar.\n\n        Suppose the callable has signature ``f0(x, *my_args, **my_kwargs)``, where\n        ``my_args`` and ``my_kwargs`` are required positional and keyword arguments.\n        Rather than passing ``f0`` as the callable, wrap it to accept\n        only ``x``; e.g., pass ``fun=lambda x: f0(x, *my_args, **my_kwargs)`` as the\n        callable, where ``my_args`` (tuple) and ``my_kwargs`` (dict) have been\n        gathered before invoking this function.\n\n        .. versionchanged:: 1.9.0\n            `f` is now able to return a 1-D array-like, with the :math:`(m, n)`\n            Jacobian being estimated.\n\n    epsilon : {float, array_like}, optional\n        Increment to `xk` to use for determining the function gradient.\n        If a scalar, uses the same finite difference delta for all partial\n        derivatives. If an array, should contain one value per element of\n        `xk`. Defaults to ``sqrt(np.finfo(float).eps)``, which is approximately\n        1.49e-08.\n    \\\\*args : args, optional\n        Any other arguments that are to be passed to `f`.\n\n    Returns\n    -------\n    jac : ndarray\n        The partial derivatives of `f` to `xk`.\n\n    See Also\n    --------\n    check_grad : Check correctness of gradient function against approx_fprime.\n\n    Notes\n    -----\n    The function gradient is determined by the forward finite difference\n    formula::\n\n                 f(xk[i] + epsilon[i]) - f(xk[i])\n        f'[i] = ---------------------------------\n                            epsilon[i]\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy import optimize\n    >>> def func(x, c0, c1):\n    ...     \"Coordinate vector `x` should be an array of size two.\"\n    ...     return c0 * x[0]**2 + c1*x[1]**2\n\n    >>> x = np.ones(2)\n    >>> c0, c1 = (1, 200)\n    >>> eps = np.sqrt(np.finfo(float).eps)\n    >>> optimize.approx_fprime(x, func, [eps, np.sqrt(200) * eps], c0, c1)\n    array([   2.        ,  400.00004208])\n\n    \"\"\"\n    xk = np.asarray(xk, float)\n    f0 = f(xk, *args)\n\n    return approx_derivative(f, xk, method='2-point', abs_step=epsilon,\n                             args=args, f0=f0)\n\n\n@_transition_to_rng(\"seed\", position_num=6)\ndef check_grad(func, grad, x0, *args, epsilon=_epsilon,\n                direction='all', rng=None):\n    r\"\"\"Check the correctness of a gradient function by comparing it against a\n    (forward) finite-difference approximation of the gradient.\n\n    Parameters\n    ----------\n    func : callable ``func(x0, *args)``\n        Function whose derivative is to be checked.\n    grad : callable ``grad(x0, *args)``\n        Jacobian of `func`.\n    x0 : ndarray\n        Points to check `grad` against forward difference approximation of grad\n        using `func`.\n    args : \\\\*args, optional\n        Extra arguments passed to `func` and `grad`.\n    epsilon : float, optional\n        Step size used for the finite difference approximation. It defaults to\n        ``sqrt(np.finfo(float).eps)``, which is approximately 1.49e-08.\n    direction : str, optional\n        If set to ``'random'``, then gradients along a random vector\n        are used to check `grad` against forward difference approximation\n        using `func`. By default it is ``'all'``, in which case, all\n        the one hot direction vectors are considered to check `grad`.\n        If `func` is a vector valued function then only ``'all'`` can be used.\n    rng : `numpy.random.Generator`, optional\n        Pseudorandom number generator state. When `rng` is None, a new\n        `numpy.random.Generator` is created using entropy from the\n        operating system. Types other than `numpy.random.Generator` are\n        passed to `numpy.random.default_rng` to instantiate a ``Generator``.\n\n        The random numbers generated affect the random vector along which gradients\n        are computed to check ``grad``. Note that `rng` is only used when `direction`\n        argument is set to `'random'`.\n\n    Returns\n    -------\n    err : float\n        The square root of the sum of squares (i.e., the 2-norm) of the\n        difference between ``grad(x0, *args)`` and the finite difference\n        approximation of `grad` using func at the points `x0`.\n\n    See Also\n    --------\n    approx_fprime\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> def func(x):\n    ...     return x[0]**2 - 0.5 * x[1]**3\n    >>> def grad(x):\n    ...     return [2 * x[0], -1.5 * x[1]**2]\n    >>> from scipy.optimize import check_grad\n    >>> check_grad(func, grad, [1.5, -1.5])\n    2.9802322387695312e-08  # may vary\n    >>> rng = np.random.default_rng()\n    >>> check_grad(func, grad, [1.5, -1.5],\n    ...             direction='random', seed=rng)\n    2.9802322387695312e-08\n\n    \"\"\"\n    step = epsilon\n    x0 = np.asarray(x0)\n\n    def g(w, func, x0, v, *args):\n        return func(x0 + w*v, *args)\n\n    if direction == 'random':\n        _grad = np.asanyarray(grad(x0, *args))\n        if _grad.ndim > 1:\n            raise ValueError(\"'random' can only be used with scalar valued\"\n                             \" func\")\n        rng_gen = check_random_state(rng)\n        v = rng_gen.standard_normal(size=(x0.shape))\n        _args = (func, x0, v) + args\n        _func = g\n        vars = np.zeros((1,))\n        analytical_grad = np.dot(_grad, v)\n    elif direction == 'all':\n        _args = args\n        _func = func\n        vars = x0\n        analytical_grad = grad(x0, *args)\n    else:\n        raise ValueError(f\"{direction} is not a valid string for \"\n                         \"``direction`` argument\")\n\n    return np.sqrt(np.sum(np.abs(\n        (analytical_grad - approx_fprime(vars, _func, step, *_args))**2\n    )))\n\n\ndef approx_fhess_p(x0, p, fprime, epsilon, *args):\n    # calculate fprime(x0) first, as this may be cached by ScalarFunction\n    f1 = fprime(*((x0,) + args))\n    f2 = fprime(*((x0 + epsilon*p,) + args))\n    return (f2 - f1) / epsilon\n\n\nclass _LineSearchError(RuntimeError):\n    pass\n\n\ndef _line_search_wolfe12(f, fprime, xk, pk, gfk, old_fval, old_old_fval,\n                         **kwargs):\n    \"\"\"\n    Same as line_search_wolfe1, but fall back to line_search_wolfe2 if\n    suitable step length is not found, and raise an exception if a\n    suitable step length is not found.\n\n    Raises\n    ------\n    _LineSearchError\n        If no suitable step size is found\n\n    \"\"\"\n\n    extra_condition = kwargs.pop('extra_condition', None)\n\n    ret = line_search_wolfe1(f, fprime, xk, pk, gfk,\n                             old_fval, old_old_fval,\n                             **kwargs)\n\n    if ret[0] is not None and extra_condition is not None:\n        xp1 = xk + ret[0] * pk\n        if not extra_condition(ret[0], xp1, ret[3], ret[5]):\n            # Reject step if extra_condition fails\n            ret = (None,)\n\n    if ret[0] is None:\n        # line search failed: try different one.\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', LineSearchWarning)\n            kwargs2 = {}\n            for key in ('c1', 'c2', 'amax'):\n                if key in kwargs:\n                    kwargs2[key] = kwargs[key]\n            ret = line_search_wolfe2(f, fprime, xk, pk, gfk,\n                                     old_fval, old_old_fval,\n                                     extra_condition=extra_condition,\n                                     **kwargs2)\n\n    if ret[0] is None:\n        raise _LineSearchError()\n\n    return ret\n\n\ndef fmin_bfgs(f, x0, fprime=None, args=(), gtol=1e-5, norm=np.inf,\n              epsilon=_epsilon, maxiter=None, full_output=0, disp=1,\n              retall=0, callback=None, xrtol=0, c1=1e-4, c2=0.9,\n              hess_inv0=None):\n    \"\"\"\n    Minimize a function using the BFGS algorithm.\n\n    Parameters\n    ----------\n    f : callable ``f(x,*args)``\n        Objective function to be minimized.\n    x0 : ndarray\n        Initial guess, shape (n,)\n    fprime : callable ``f'(x,*args)``, optional\n        Gradient of f.\n    args : tuple, optional\n        Extra arguments passed to f and fprime.\n    gtol : float, optional\n        Terminate successfully if gradient norm is less than `gtol`\n    norm : float, optional\n        Order of norm (Inf is max, -Inf is min)\n    epsilon : int or ndarray, optional\n        If `fprime` is approximated, use this value for the step size.\n    callback : callable, optional\n        An optional user-supplied function to call after each\n        iteration. Called as ``callback(xk)``, where ``xk`` is the\n        current parameter vector.\n    maxiter : int, optional\n        Maximum number of iterations to perform.\n    full_output : bool, optional\n        If True, return ``fopt``, ``func_calls``, ``grad_calls``, and\n        ``warnflag`` in addition to ``xopt``.\n    disp : bool, optional\n        Print convergence message if True.\n    retall : bool, optional\n        Return a list of results at each iteration if True.\n    xrtol : float, default: 0\n        Relative tolerance for `x`. Terminate successfully if step\n        size is less than ``xk * xrtol`` where ``xk`` is the current\n        parameter vector.\n    c1 : float, default: 1e-4\n        Parameter for Armijo condition rule.\n    c2 : float, default: 0.9\n        Parameter for curvature condition rule.\n    hess_inv0 : None or ndarray, optional``\n        Initial inverse hessian estimate, shape (n, n). If None (default) then\n        the identity matrix is used.\n\n    Returns\n    -------\n    xopt : ndarray\n        Parameters which minimize f, i.e., ``f(xopt) == fopt``.\n    fopt : float\n        Minimum value.\n    gopt : ndarray\n        Value of gradient at minimum, f'(xopt), which should be near 0.\n    Bopt : ndarray\n        Value of 1/f''(xopt), i.e., the inverse Hessian matrix.\n    func_calls : int\n        Number of function_calls made.\n    grad_calls : int\n        Number of gradient calls made.\n    warnflag : integer\n        1 : Maximum number of iterations exceeded.\n        2 : Gradient and/or function calls not changing.\n        3 : NaN result encountered.\n    allvecs : list\n        The value of `xopt` at each iteration. Only returned if `retall` is\n        True.\n\n    Notes\n    -----\n    Optimize the function, `f`, whose gradient is given by `fprime`\n    using the quasi-Newton method of Broyden, Fletcher, Goldfarb,\n    and Shanno (BFGS).\n\n    Parameters `c1` and `c2` must satisfy ``0 < c1 < c2 < 1``.\n\n    See Also\n    --------\n    minimize: Interface to minimization algorithms for multivariate\n        functions. See ``method='BFGS'`` in particular.\n\n    References\n    ----------\n    Wright, and Nocedal 'Numerical Optimization', 1999, p. 198.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.optimize import fmin_bfgs\n    >>> def quadratic_cost(x, Q):\n    ...     return x @ Q @ x\n    ...\n    >>> x0 = np.array([-3, -4])\n    >>> cost_weight =  np.diag([1., 10.])\n    >>> # Note that a trailing comma is necessary for a tuple with single element\n    >>> fmin_bfgs(quadratic_cost, x0, args=(cost_weight,))\n    Optimization terminated successfully.\n            Current function value: 0.000000\n            Iterations: 7                   # may vary\n            Function evaluations: 24        # may vary\n            Gradient evaluations: 8         # may vary\n    array([ 2.85169950e-06, -4.61820139e-07])\n\n    >>> def quadratic_cost_grad(x, Q):\n    ...     return 2 * Q @ x\n    ...\n    >>> fmin_bfgs(quadratic_cost, x0, quadratic_cost_grad, args=(cost_weight,))\n    Optimization terminated successfully.\n            Current function value: 0.000000\n            Iterations: 7\n            Function evaluations: 8\n            Gradient evaluations: 8\n    array([ 2.85916637e-06, -4.54371951e-07])\n\n    \"\"\"\n    opts = {'gtol': gtol,\n            'norm': norm,\n            'eps': epsilon,\n            'disp': disp,\n            'maxiter': maxiter,\n            'return_all': retall,\n            'xrtol': xrtol,\n            'c1': c1,\n            'c2': c2,\n            'hess_inv0': hess_inv0}\n\n    callback = _wrap_callback(callback)\n    res = _minimize_bfgs(f, x0, args, fprime, callback=callback, **opts)\n\n    if full_output:\n        retlist = (res['x'], res['fun'], res['jac'], res['hess_inv'],\n                   res['nfev'], res['njev'], res['status'])\n        if retall:\n            retlist += (res['allvecs'], )\n        return retlist\n    else:\n        if retall:\n            return res['x'], res['allvecs']\n        else:\n            return res['x']\n\n\ndef _minimize_bfgs(fun, x0, args=(), jac=None, callback=None,\n                   gtol=1e-5, norm=np.inf, eps=_epsilon, maxiter=None,\n                   disp=False, return_all=False, finite_diff_rel_step=None,\n                   xrtol=0, c1=1e-4, c2=0.9,\n                   hess_inv0=None, **unknown_options):\n    \"\"\"\n    Minimization of scalar function of one or more variables using the\n    BFGS algorithm.\n\n    Options\n    -------\n    disp : bool\n        Set to True to print convergence messages.\n    maxiter : int\n        Maximum number of iterations to perform.\n    gtol : float\n        Terminate successfully if gradient norm is less than `gtol`.\n    norm : float\n        Order of norm (Inf is max, -Inf is min).\n    eps : float or ndarray\n        If `jac is None` the absolute step size used for numerical\n        approximation of the jacobian via forward differences.\n    return_all : bool, optional\n        Set to True to return a list of the best solution at each of the\n        iterations.\n    finite_diff_rel_step : None or array_like, optional\n        If ``jac in ['2-point', '3-point', 'cs']`` the relative step size to\n        use for numerical approximation of the jacobian. The absolute step\n        size is computed as ``h = rel_step * sign(x) * max(1, abs(x))``,\n        possibly adjusted to fit into the bounds. For ``jac='3-point'``\n        the sign of `h` is ignored. If None (default) then step is selected\n        automatically.\n    xrtol : float, default: 0\n        Relative tolerance for `x`. Terminate successfully if step size is\n        less than ``xk * xrtol`` where ``xk`` is the current parameter vector.\n    c1 : float, default: 1e-4\n        Parameter for Armijo condition rule.\n    c2 : float, default: 0.9\n        Parameter for curvature condition rule.\n    hess_inv0 : None or ndarray, optional\n        Initial inverse hessian estimate, shape (n, n). If None (default) then\n        the identity matrix is used.\n\n    Notes\n    -----\n    Parameters `c1` and `c2` must satisfy ``0 < c1 < c2 < 1``.\n\n    If minimization doesn't complete successfully, with an error message of\n    ``Desired error not necessarily achieved due to precision loss``, then\n    consider setting `gtol` to a higher value. This precision loss typically\n    occurs when the (finite difference) numerical differentiation cannot provide\n    sufficient precision to satisfy the `gtol` termination criterion.\n    This can happen when working in single precision and a callable jac is not\n    provided. For single precision problems a `gtol` of 1e-3 seems to work.\n    \"\"\"\n    _check_unknown_options(unknown_options)\n    _check_positive_definite(hess_inv0)\n    retall = return_all\n\n    x0 = asarray(x0).flatten()\n    if x0.ndim == 0:\n        x0.shape = (1,)\n    if maxiter is None:\n        maxiter = len(x0) * 200\n\n    sf = _prepare_scalar_function(fun, x0, jac, args=args, epsilon=eps,\n                                  finite_diff_rel_step=finite_diff_rel_step)\n\n    f = sf.fun\n    myfprime = sf.grad\n\n    old_fval = f(x0)\n    gfk = myfprime(x0)\n\n    k = 0\n    N = len(x0)\n    I = np.eye(N, dtype=int)\n    Hk = I if hess_inv0 is None else hess_inv0\n\n    # Sets the initial step guess to dx ~ 1\n    old_old_fval = old_fval + np.linalg.norm(gfk) / 2\n\n    xk = x0\n    if retall:\n        allvecs = [x0]\n    warnflag = 0\n    gnorm = vecnorm(gfk, ord=norm)\n    while (gnorm > gtol) and (k < maxiter):\n        pk = -np.dot(Hk, gfk)\n        try:\n            alpha_k, fc, gc, old_fval, old_old_fval, gfkp1 = \\\n                     _line_search_wolfe12(f, myfprime, xk, pk, gfk,\n                                          old_fval, old_old_fval, amin=1e-100,\n                                          amax=1e100, c1=c1, c2=c2)\n        except _LineSearchError:\n            # Line search failed to find a better solution.\n            warnflag = 2\n            break\n\n        sk = alpha_k * pk\n        xkp1 = xk + sk\n\n        if retall:\n            allvecs.append(xkp1)\n        xk = xkp1\n        if gfkp1 is None:\n            gfkp1 = myfprime(xkp1)\n\n        yk = gfkp1 - gfk\n        gfk = gfkp1\n        k += 1\n        intermediate_result = OptimizeResult(x=xk, fun=old_fval)\n        if _call_callback_maybe_halt(callback, intermediate_result):\n            break\n        gnorm = vecnorm(gfk, ord=norm)\n        if (gnorm <= gtol):\n            break\n\n        #  See Chapter 5 in  P.E. Frandsen, K. Jonasson, H.B. Nielsen,\n        #  O. Tingleff: \"Unconstrained Optimization\", IMM, DTU.  1999.\n        #  These notes are available here:\n        #  http://www2.imm.dtu.dk/documents/ftp/publlec.html\n        if (alpha_k*vecnorm(pk) <= xrtol*(xrtol + vecnorm(xk))):\n            break\n\n        if not np.isfinite(old_fval):\n            # We correctly found +-Inf as optimal value, or something went\n            # wrong.\n            warnflag = 2\n            break\n\n        rhok_inv = np.dot(yk, sk)\n        # this was handled in numeric, let it remains for more safety\n        # Cryptic comment above is preserved for posterity. Future reader:\n        # consider change to condition below proposed in gh-1261/gh-17345.\n        if rhok_inv == 0.:\n            rhok = 1000.0\n            if disp:\n                msg = \"Divide-by-zero encountered: rhok assumed large\"\n                _print_success_message_or_warn(True, msg)\n        else:\n            rhok = 1. / rhok_inv\n\n        A1 = I - sk[:, np.newaxis] * yk[np.newaxis, :] * rhok\n        A2 = I - yk[:, np.newaxis] * sk[np.newaxis, :] * rhok\n        Hk = np.dot(A1, np.dot(Hk, A2)) + (rhok * sk[:, np.newaxis] *\n                                                 sk[np.newaxis, :])\n\n    fval = old_fval\n\n    if warnflag == 2:\n        msg = _status_message['pr_loss']\n    elif k >= maxiter:\n        warnflag = 1\n        msg = _status_message['maxiter']\n    elif np.isnan(gnorm) or np.isnan(fval) or np.isnan(xk).any():\n        warnflag = 3\n        msg = _status_message['nan']\n    else:\n        msg = _status_message['success']\n\n    if disp:\n        _print_success_message_or_warn(warnflag, msg)\n        print(f\"         Current function value: {fval:f}\")\n        print(\"         Iterations: %d\" % k)\n        print(\"         Function evaluations: %d\" % sf.nfev)\n        print(\"         Gradient evaluations: %d\" % sf.ngev)\n\n    result = OptimizeResult(fun=fval, jac=gfk, hess_inv=Hk, nfev=sf.nfev,\n                            njev=sf.ngev, status=warnflag,\n                            success=(warnflag == 0), message=msg, x=xk,\n                            nit=k)\n    if retall:\n        result['allvecs'] = allvecs\n    return result\n\n\ndef _print_success_message_or_warn(warnflag, message, warntype=None):\n    if not warnflag:\n        print(message)\n    else:\n        warnings.warn(message, warntype or OptimizeWarning, stacklevel=3)\n\n\ndef fmin_cg(f, x0, fprime=None, args=(), gtol=1e-5, norm=np.inf,\n            epsilon=_epsilon, maxiter=None, full_output=0, disp=1, retall=0,\n            callback=None, c1=1e-4, c2=0.4):\n    \"\"\"\n    Minimize a function using a nonlinear conjugate gradient algorithm.\n\n    Parameters\n    ----------\n    f : callable, ``f(x, *args)``\n        Objective function to be minimized. Here `x` must be a 1-D array of\n        the variables that are to be changed in the search for a minimum, and\n        `args` are the other (fixed) parameters of `f`.\n    x0 : ndarray\n        A user-supplied initial estimate of `xopt`, the optimal value of `x`.\n        It must be a 1-D array of values.\n    fprime : callable, ``fprime(x, *args)``, optional\n        A function that returns the gradient of `f` at `x`. Here `x` and `args`\n        are as described above for `f`. The returned value must be a 1-D array.\n        Defaults to None, in which case the gradient is approximated\n        numerically (see `epsilon`, below).\n    args : tuple, optional\n        Parameter values passed to `f` and `fprime`. Must be supplied whenever\n        additional fixed parameters are needed to completely specify the\n        functions `f` and `fprime`.\n    gtol : float, optional\n        Stop when the norm of the gradient is less than `gtol`.\n    norm : float, optional\n        Order to use for the norm of the gradient\n        (``-np.inf`` is min, ``np.inf`` is max).\n    epsilon : float or ndarray, optional\n        Step size(s) to use when `fprime` is approximated numerically. Can be a\n        scalar or a 1-D array. Defaults to ``sqrt(eps)``, with eps the\n        floating point machine precision.  Usually ``sqrt(eps)`` is about\n        1.5e-8.\n    maxiter : int, optional\n        Maximum number of iterations to perform. Default is ``200 * len(x0)``.\n    full_output : bool, optional\n        If True, return `fopt`, `func_calls`, `grad_calls`, and `warnflag` in\n        addition to `xopt`.  See the Returns section below for additional\n        information on optional return values.\n    disp : bool, optional\n        If True, return a convergence message, followed by `xopt`.\n    retall : bool, optional\n        If True, add to the returned values the results of each iteration.\n    callback : callable, optional\n        An optional user-supplied function, called after each iteration.\n        Called as ``callback(xk)``, where ``xk`` is the current value of `x0`.\n    c1 : float, default: 1e-4\n        Parameter for Armijo condition rule.\n    c2 : float, default: 0.4\n        Parameter for curvature condition rule.\n\n    Returns\n    -------\n    xopt : ndarray\n        Parameters which minimize f, i.e., ``f(xopt) == fopt``.\n    fopt : float, optional\n        Minimum value found, f(xopt). Only returned if `full_output` is True.\n    func_calls : int, optional\n        The number of function_calls made. Only returned if `full_output`\n        is True.\n    grad_calls : int, optional\n        The number of gradient calls made. Only returned if `full_output` is\n        True.\n    warnflag : int, optional\n        Integer value with warning status, only returned if `full_output` is\n        True.\n\n        0 : Success.\n\n        1 : The maximum number of iterations was exceeded.\n\n        2 : Gradient and/or function calls were not changing. May indicate\n            that precision was lost, i.e., the routine did not converge.\n\n        3 : NaN result encountered.\n\n    allvecs : list of ndarray, optional\n        List of arrays, containing the results at each iteration.\n        Only returned if `retall` is True.\n\n    See Also\n    --------\n    minimize : common interface to all `scipy.optimize` algorithms for\n               unconstrained and constrained minimization of multivariate\n               functions. It provides an alternative way to call\n               ``fmin_cg``, by specifying ``method='CG'``.\n\n    Notes\n    -----\n    This conjugate gradient algorithm is based on that of Polak and Ribiere\n    [1]_.\n\n    Conjugate gradient methods tend to work better when:\n\n    1. `f` has a unique global minimizing point, and no local minima or\n       other stationary points,\n    2. `f` is, at least locally, reasonably well approximated by a\n       quadratic function of the variables,\n    3. `f` is continuous and has a continuous gradient,\n    4. `fprime` is not too large, e.g., has a norm less than 1000,\n    5. The initial guess, `x0`, is reasonably close to `f` 's global\n       minimizing point, `xopt`.\n\n    Parameters `c1` and `c2` must satisfy ``0 < c1 < c2 < 1``.\n\n    References\n    ----------\n    .. [1] Wright & Nocedal, \"Numerical Optimization\", 1999, pp. 120-122.\n\n    Examples\n    --------\n    Example 1: seek the minimum value of the expression\n    ``a*u**2 + b*u*v + c*v**2 + d*u + e*v + f`` for given values\n    of the parameters and an initial guess ``(u, v) = (0, 0)``.\n\n    >>> import numpy as np\n    >>> args = (2, 3, 7, 8, 9, 10)  # parameter values\n    >>> def f(x, *args):\n    ...     u, v = x\n    ...     a, b, c, d, e, f = args\n    ...     return a*u**2 + b*u*v + c*v**2 + d*u + e*v + f\n    >>> def gradf(x, *args):\n    ...     u, v = x\n    ...     a, b, c, d, e, f = args\n    ...     gu = 2*a*u + b*v + d     # u-component of the gradient\n    ...     gv = b*u + 2*c*v + e     # v-component of the gradient\n    ...     return np.asarray((gu, gv))\n    >>> x0 = np.asarray((0, 0))  # Initial guess.\n    >>> from scipy import optimize\n    >>> res1 = optimize.fmin_cg(f, x0, fprime=gradf, args=args)\n    Optimization terminated successfully.\n             Current function value: 1.617021\n             Iterations: 4\n             Function evaluations: 8\n             Gradient evaluations: 8\n    >>> res1\n    array([-1.80851064, -0.25531915])\n\n    Example 2: solve the same problem using the `minimize` function.\n    (This `myopts` dictionary shows all of the available options,\n    although in practice only non-default values would be needed.\n    The returned value will be a dictionary.)\n\n    >>> opts = {'maxiter' : None,    # default value.\n    ...         'disp' : True,    # non-default value.\n    ...         'gtol' : 1e-5,    # default value.\n    ...         'norm' : np.inf,  # default value.\n    ...         'eps' : 1.4901161193847656e-08}  # default value.\n    >>> res2 = optimize.minimize(f, x0, jac=gradf, args=args,\n    ...                          method='CG', options=opts)\n    Optimization terminated successfully.\n            Current function value: 1.617021\n            Iterations: 4\n            Function evaluations: 8\n            Gradient evaluations: 8\n    >>> res2.x  # minimum found\n    array([-1.80851064, -0.25531915])\n\n    \"\"\"\n    opts = {'gtol': gtol,\n            'norm': norm,\n            'eps': epsilon,\n            'disp': disp,\n            'maxiter': maxiter,\n            'return_all': retall}\n\n    callback = _wrap_callback(callback)\n    res = _minimize_cg(f, x0, args, fprime, callback=callback, c1=c1, c2=c2,\n                       **opts)\n\n    if full_output:\n        retlist = res['x'], res['fun'], res['nfev'], res['njev'], res['status']\n        if retall:\n            retlist += (res['allvecs'], )\n        return retlist\n    else:\n        if retall:\n            return res['x'], res['allvecs']\n        else:\n            return res['x']\n\n\ndef _minimize_cg(fun, x0, args=(), jac=None, callback=None,\n                 gtol=1e-5, norm=np.inf, eps=_epsilon, maxiter=None,\n                 disp=False, return_all=False, finite_diff_rel_step=None,\n                 c1=1e-4, c2=0.4, **unknown_options):\n    \"\"\"\n    Minimization of scalar function of one or more variables using the\n    conjugate gradient algorithm.\n\n    Options\n    -------\n    disp : bool\n        Set to True to print convergence messages.\n    maxiter : int\n        Maximum number of iterations to perform.\n    gtol : float\n        Gradient norm must be less than `gtol` before successful\n        termination.\n    norm : float\n        Order of norm (Inf is max, -Inf is min).\n    eps : float or ndarray\n        If `jac is None` the absolute step size used for numerical\n        approximation of the jacobian via forward differences.\n    return_all : bool, optional\n        Set to True to return a list of the best solution at each of the\n        iterations.\n    finite_diff_rel_step : None or array_like, optional\n        If ``jac in ['2-point', '3-point', 'cs']`` the relative step size to\n        use for numerical approximation of the jacobian. The absolute step\n        size is computed as ``h = rel_step * sign(x) * max(1, abs(x))``,\n        possibly adjusted to fit into the bounds. For ``jac='3-point'``\n        the sign of `h` is ignored. If None (default) then step is selected\n        automatically.\n    c1 : float, default: 1e-4\n        Parameter for Armijo condition rule.\n    c2 : float, default: 0.4\n        Parameter for curvature condition rule.\n\n    Notes\n    -----\n    Parameters `c1` and `c2` must satisfy ``0 < c1 < c2 < 1``.\n    \"\"\"\n    _check_unknown_options(unknown_options)\n\n    retall = return_all\n\n    x0 = asarray(x0).flatten()\n    if maxiter is None:\n        maxiter = len(x0) * 200\n\n    sf = _prepare_scalar_function(fun, x0, jac=jac, args=args, epsilon=eps,\n                                  finite_diff_rel_step=finite_diff_rel_step)\n\n    f = sf.fun\n    myfprime = sf.grad\n\n    old_fval = f(x0)\n    gfk = myfprime(x0)\n\n    k = 0\n    xk = x0\n    # Sets the initial step guess to dx ~ 1\n    old_old_fval = old_fval + np.linalg.norm(gfk) / 2\n\n    if retall:\n        allvecs = [xk]\n    warnflag = 0\n    pk = -gfk\n    gnorm = vecnorm(gfk, ord=norm)\n\n    sigma_3 = 0.01\n\n    while (gnorm > gtol) and (k < maxiter):\n        deltak = np.dot(gfk, gfk)\n\n        cached_step = [None]\n\n        def polak_ribiere_powell_step(alpha, gfkp1=None):\n            xkp1 = xk + alpha * pk\n            if gfkp1 is None:\n                gfkp1 = myfprime(xkp1)\n            yk = gfkp1 - gfk\n            beta_k = max(0, np.dot(yk, gfkp1) / deltak)\n            pkp1 = -gfkp1 + beta_k * pk\n            gnorm = vecnorm(gfkp1, ord=norm)\n            return (alpha, xkp1, pkp1, gfkp1, gnorm)\n\n        def descent_condition(alpha, xkp1, fp1, gfkp1):\n            # Polak-Ribiere+ needs an explicit check of a sufficient\n            # descent condition, which is not guaranteed by strong Wolfe.\n            #\n            # See Gilbert & Nocedal, \"Global convergence properties of\n            # conjugate gradient methods for optimization\",\n            # SIAM J. Optimization 2, 21 (1992).\n            cached_step[:] = polak_ribiere_powell_step(alpha, gfkp1)\n            alpha, xk, pk, gfk, gnorm = cached_step\n\n            # Accept step if it leads to convergence.\n            if gnorm <= gtol:\n                return True\n\n            # Accept step if sufficient descent condition applies.\n            return np.dot(pk, gfk) <= -sigma_3 * np.dot(gfk, gfk)\n\n        try:\n            alpha_k, fc, gc, old_fval, old_old_fval, gfkp1 = \\\n                     _line_search_wolfe12(f, myfprime, xk, pk, gfk, old_fval,\n                                          old_old_fval, c1=c1, c2=c2, amin=1e-100,\n                                          amax=1e100, extra_condition=descent_condition)\n        except _LineSearchError:\n            # Line search failed to find a better solution.\n            warnflag = 2\n            break\n\n        # Reuse already computed results if possible\n        if alpha_k == cached_step[0]:\n            alpha_k, xk, pk, gfk, gnorm = cached_step\n        else:\n            alpha_k, xk, pk, gfk, gnorm = polak_ribiere_powell_step(alpha_k, gfkp1)\n\n        if retall:\n            allvecs.append(xk)\n        k += 1\n        intermediate_result = OptimizeResult(x=xk, fun=old_fval)\n        if _call_callback_maybe_halt(callback, intermediate_result):\n            break\n\n    fval = old_fval\n    if warnflag == 2:\n        msg = _status_message['pr_loss']\n    elif k >= maxiter:\n        warnflag = 1\n        msg = _status_message['maxiter']\n    elif np.isnan(gnorm) or np.isnan(fval) or np.isnan(xk).any():\n        warnflag = 3\n        msg = _status_message['nan']\n    else:\n        msg = _status_message['success']\n\n    if disp:\n        _print_success_message_or_warn(warnflag, msg)\n        print(f\"         Current function value: {fval:f}\")\n        print(\"         Iterations: %d\" % k)\n        print(\"         Function evaluations: %d\" % sf.nfev)\n        print(\"         Gradient evaluations: %d\" % sf.ngev)\n\n    result = OptimizeResult(fun=fval, jac=gfk, nfev=sf.nfev,\n                            njev=sf.ngev, status=warnflag,\n                            success=(warnflag == 0), message=msg, x=xk,\n                            nit=k)\n    if retall:\n        result['allvecs'] = allvecs\n    return result\n\n\ndef fmin_ncg(f, x0, fprime, fhess_p=None, fhess=None, args=(), avextol=1e-5,\n             epsilon=_epsilon, maxiter=None, full_output=0, disp=1, retall=0,\n             callback=None, c1=1e-4, c2=0.9):\n    \"\"\"\n    Unconstrained minimization of a function using the Newton-CG method.\n\n    Parameters\n    ----------\n    f : callable ``f(x, *args)``\n        Objective function to be minimized.\n    x0 : ndarray\n        Initial guess.\n    fprime : callable ``f'(x, *args)``\n        Gradient of f.\n    fhess_p : callable ``fhess_p(x, p, *args)``, optional\n        Function which computes the Hessian of f times an\n        arbitrary vector, p.\n    fhess : callable ``fhess(x, *args)``, optional\n        Function to compute the Hessian matrix of f.\n    args : tuple, optional\n        Extra arguments passed to f, fprime, fhess_p, and fhess\n        (the same set of extra arguments is supplied to all of\n        these functions).\n    epsilon : float or ndarray, optional\n        If fhess is approximated, use this value for the step size.\n    callback : callable, optional\n        An optional user-supplied function which is called after\n        each iteration. Called as callback(xk), where xk is the\n        current parameter vector.\n    avextol : float, optional\n        Convergence is assumed when the average relative error in\n        the minimizer falls below this amount.\n    maxiter : int, optional\n        Maximum number of iterations to perform.\n    full_output : bool, optional\n        If True, return the optional outputs.\n    disp : bool, optional\n        If True, print convergence message.\n    retall : bool, optional\n        If True, return a list of results at each iteration.\n    c1 : float, default: 1e-4\n        Parameter for Armijo condition rule.\n    c2 : float, default: 0.9\n        Parameter for curvature condition rule\n\n    Returns\n    -------\n    xopt : ndarray\n        Parameters which minimize f, i.e., ``f(xopt) == fopt``.\n    fopt : float\n        Value of the function at xopt, i.e., ``fopt = f(xopt)``.\n    fcalls : int\n        Number of function calls made.\n    gcalls : int\n        Number of gradient calls made.\n    hcalls : int\n        Number of Hessian calls made.\n    warnflag : int\n        Warnings generated by the algorithm.\n        1 : Maximum number of iterations exceeded.\n        2 : Line search failure (precision loss).\n        3 : NaN result encountered.\n    allvecs : list\n        The result at each iteration, if retall is True (see below).\n\n    See also\n    --------\n    minimize: Interface to minimization algorithms for multivariate\n        functions. See the 'Newton-CG' `method` in particular.\n\n    Notes\n    -----\n    Only one of `fhess_p` or `fhess` need to be given.  If `fhess`\n    is provided, then `fhess_p` will be ignored. If neither `fhess`\n    nor `fhess_p` is provided, then the hessian product will be\n    approximated using finite differences on `fprime`. `fhess_p`\n    must compute the hessian times an arbitrary vector. If it is not\n    given, finite-differences on `fprime` are used to compute\n    it.\n\n    Newton-CG methods are also called truncated Newton methods. This\n    function differs from scipy.optimize.fmin_tnc because\n\n    1. scipy.optimize.fmin_ncg is written purely in Python using NumPy\n        and scipy while scipy.optimize.fmin_tnc calls a C function.\n    2. scipy.optimize.fmin_ncg is only for unconstrained minimization\n        while scipy.optimize.fmin_tnc is for unconstrained minimization\n        or box constrained minimization. (Box constraints give\n        lower and upper bounds for each variable separately.)\n\n    Parameters `c1` and `c2` must satisfy ``0 < c1 < c2 < 1``.\n\n    References\n    ----------\n    Wright & Nocedal, 'Numerical Optimization', 1999, p. 140.\n\n    \"\"\"\n    opts = {'xtol': avextol,\n            'eps': epsilon,\n            'maxiter': maxiter,\n            'disp': disp,\n            'return_all': retall}\n\n    callback = _wrap_callback(callback)\n    res = _minimize_newtoncg(f, x0, args, fprime, fhess, fhess_p,\n                             callback=callback, c1=c1, c2=c2, **opts)\n\n    if full_output:\n        retlist = (res['x'], res['fun'], res['nfev'], res['njev'],\n                   res['nhev'], res['status'])\n        if retall:\n            retlist += (res['allvecs'], )\n        return retlist\n    else:\n        if retall:\n            return res['x'], res['allvecs']\n        else:\n            return res['x']\n\n\ndef _minimize_newtoncg(fun, x0, args=(), jac=None, hess=None, hessp=None,\n                       callback=None, xtol=1e-5, eps=_epsilon, maxiter=None,\n                       disp=False, return_all=False, c1=1e-4, c2=0.9,\n                       **unknown_options):\n    \"\"\"\n    Minimization of scalar function of one or more variables using the\n    Newton-CG algorithm.\n\n    Note that the `jac` parameter (Jacobian) is required.\n\n    Options\n    -------\n    disp : bool\n        Set to True to print convergence messages.\n    xtol : float\n        Average relative error in solution `xopt` acceptable for\n        convergence.\n    maxiter : int\n        Maximum number of iterations to perform.\n    eps : float or ndarray\n        If `hessp` is approximated, use this value for the step size.\n    return_all : bool, optional\n        Set to True to return a list of the best solution at each of the\n        iterations.\n    c1 : float, default: 1e-4\n        Parameter for Armijo condition rule.\n    c2 : float, default: 0.9\n        Parameter for curvature condition rule.\n\n    Notes\n    -----\n    Parameters `c1` and `c2` must satisfy ``0 < c1 < c2 < 1``.\n    \"\"\"\n    _check_unknown_options(unknown_options)\n    if jac is None:\n        raise ValueError('Jacobian is required for Newton-CG method')\n    fhess_p = hessp\n    fhess = hess\n    avextol = xtol\n    epsilon = eps\n    retall = return_all\n\n    x0 = asarray(x0).flatten()\n    # TODO: add hessp (callable or FD) to ScalarFunction?\n    sf = _prepare_scalar_function(\n        fun, x0, jac, args=args, epsilon=eps, hess=hess\n    )\n    f = sf.fun\n    fprime = sf.grad\n    _h = sf.hess(x0)\n\n    # Logic for hess/hessp\n    # - If a callable(hess) is provided, then use that\n    # - If hess is a FD_METHOD, or the output from hess(x) is a LinearOperator\n    #   then create a hessp function using those.\n    # - If hess is None but you have callable(hessp) then use the hessp.\n    # - If hess and hessp are None then approximate hessp using the grad/jac.\n\n    if (hess in FD_METHODS or isinstance(_h, LinearOperator)):\n        fhess = None\n\n        def _hessp(x, p, *args):\n            return sf.hess(x).dot(p)\n\n        fhess_p = _hessp\n\n    def terminate(warnflag, msg):\n        if disp:\n            _print_success_message_or_warn(warnflag, msg)\n            print(f\"         Current function value: {old_fval:f}\")\n            print(\"         Iterations: %d\" % k)\n            print(\"         Function evaluations: %d\" % sf.nfev)\n            print(\"         Gradient evaluations: %d\" % sf.ngev)\n            print(\"         Hessian evaluations: %d\" % hcalls)\n        fval = old_fval\n        result = OptimizeResult(fun=fval, jac=gfk, nfev=sf.nfev,\n                                njev=sf.ngev, nhev=hcalls, status=warnflag,\n                                success=(warnflag == 0), message=msg, x=xk,\n                                nit=k)\n        if retall:\n            result['allvecs'] = allvecs\n        return result\n\n    hcalls = 0\n    if maxiter is None:\n        maxiter = len(x0)*200\n    cg_maxiter = 20*len(x0)\n\n    xtol = len(x0) * avextol\n    # Make sure we enter the while loop.\n    update_l1norm = np.finfo(float).max\n    xk = np.copy(x0)\n    if retall:\n        allvecs = [xk]\n    k = 0\n    gfk = None\n    old_fval = f(x0)\n    old_old_fval = None\n    float64eps = np.finfo(np.float64).eps\n    while update_l1norm > xtol:\n        if k >= maxiter:\n            msg = \"Warning: \" + _status_message['maxiter']\n            return terminate(1, msg)\n        # Compute a search direction pk by applying the CG method to\n        #  del2 f(xk) p = - grad f(xk) starting from 0.\n        b = -fprime(xk)\n        maggrad = np.linalg.norm(b, ord=1)\n        eta = min(0.5, math.sqrt(maggrad))\n        termcond = eta * maggrad\n        xsupi = zeros(len(x0), dtype=x0.dtype)\n        ri = -b\n        psupi = -ri\n        i = 0\n        dri0 = np.dot(ri, ri)\n\n        if fhess is not None:             # you want to compute hessian once.\n            A = sf.hess(xk)\n            hcalls += 1\n\n        for k2 in range(cg_maxiter):\n            if np.add.reduce(np.abs(ri)) <= termcond:\n                break\n            if fhess is None:\n                if fhess_p is None:\n                    Ap = approx_fhess_p(xk, psupi, fprime, epsilon)\n                else:\n                    Ap = fhess_p(xk, psupi, *args)\n                    hcalls += 1\n            else:\n                # hess was supplied as a callable or hessian update strategy, so\n                # A is a dense numpy array or sparse matrix\n                Ap = A.dot(psupi)\n            # check curvature\n            Ap = asarray(Ap).squeeze()  # get rid of matrices...\n            curv = np.dot(psupi, Ap)\n            if 0 <= curv <= 3 * float64eps:\n                break\n            elif curv < 0:\n                if (i > 0):\n                    break\n                else:\n                    # fall back to steepest descent direction\n                    xsupi = dri0 / (-curv) * b\n                    break\n            alphai = dri0 / curv\n            xsupi += alphai * psupi\n            ri += alphai * Ap\n            dri1 = np.dot(ri, ri)\n            betai = dri1 / dri0\n            psupi = -ri + betai * psupi\n            i += 1\n            dri0 = dri1          # update np.dot(ri,ri) for next time.\n        else:\n            # curvature keeps increasing, bail out\n            msg = (\"Warning: CG iterations didn't converge. The Hessian is not \"\n                   \"positive definite.\")\n            return terminate(3, msg)\n\n        pk = xsupi  # search direction is solution to system.\n        gfk = -b    # gradient at xk\n\n        try:\n            alphak, fc, gc, old_fval, old_old_fval, gfkp1 = \\\n                     _line_search_wolfe12(f, fprime, xk, pk, gfk,\n                                          old_fval, old_old_fval, c1=c1, c2=c2)\n        except _LineSearchError:\n            # Line search failed to find a better solution.\n            msg = \"Warning: \" + _status_message['pr_loss']\n            return terminate(2, msg)\n\n        update = alphak * pk\n        xk += update        # upcast if necessary\n        if retall:\n            allvecs.append(xk)\n        k += 1\n        intermediate_result = OptimizeResult(x=xk, fun=old_fval)\n        if _call_callback_maybe_halt(callback, intermediate_result):\n            return terminate(5, \"\")\n        update_l1norm = np.linalg.norm(update, ord=1)\n\n    else:\n        if np.isnan(old_fval) or np.isnan(update_l1norm):\n            return terminate(3, _status_message['nan'])\n\n        msg = _status_message['success']\n        return terminate(0, msg)\n\n\ndef fminbound(func, x1, x2, args=(), xtol=1e-5, maxfun=500,\n              full_output=0, disp=1):\n    \"\"\"Bounded minimization for scalar functions.\n\n    Parameters\n    ----------\n    func : callable f(x,*args)\n        Objective function to be minimized (must accept and return scalars).\n    x1, x2 : float or array scalar\n        Finite optimization bounds.\n    args : tuple, optional\n        Extra arguments passed to function.\n    xtol : float, optional\n        The convergence tolerance.\n    maxfun : int, optional\n        Maximum number of function evaluations allowed.\n    full_output : bool, optional\n        If True, return optional outputs.\n    disp: int, optional\n        If non-zero, print messages.\n\n        ``0`` : no message printing.\n\n        ``1`` : non-convergence notification messages only.\n\n        ``2`` : print a message on convergence too.\n\n        ``3`` : print iteration results.\n\n    Returns\n    -------\n    xopt : ndarray\n        Parameters (over given interval) which minimize the\n        objective function.\n    fval : number\n        (Optional output) The function value evaluated at the minimizer.\n    ierr : int\n        (Optional output) An error flag (0 if converged, 1 if maximum number of\n        function calls reached).\n    numfunc : int\n        (Optional output) The number of function calls made.\n\n    See also\n    --------\n    minimize_scalar: Interface to minimization algorithms for scalar\n        univariate functions. See the 'Bounded' `method` in particular.\n\n    Notes\n    -----\n    Finds a local minimizer of the scalar function `func` in the\n    interval x1 < xopt < x2 using Brent's method. (See `brent`\n    for auto-bracketing.)\n\n    References\n    ----------\n    .. [1] Forsythe, G.E., M. A. Malcolm, and C. B. Moler. \"Computer Methods\n           for Mathematical Computations.\" Prentice-Hall Series in Automatic\n           Computation 259 (1977).\n    .. [2] Brent, Richard P. Algorithms for Minimization Without Derivatives.\n           Courier Corporation, 2013.\n\n    Examples\n    --------\n    `fminbound` finds the minimizer of the function in the given range.\n    The following examples illustrate this.\n\n    >>> from scipy import optimize\n    >>> def f(x):\n    ...     return (x-1)**2\n    >>> minimizer = optimize.fminbound(f, -4, 4)\n    >>> minimizer\n    1.0\n    >>> minimum = f(minimizer)\n    >>> minimum\n    0.0\n    >>> res = optimize.fminbound(f, 3, 4, full_output=True)\n    >>> minimizer, fval, ierr, numfunc = res\n    >>> minimizer\n    3.000005960860986\n    >>> minimum = f(minimizer)\n    >>> minimum, fval\n    (4.000023843479476, 4.000023843479476)\n    \"\"\"\n    options = {'xatol': xtol,\n               'maxiter': maxfun,\n               'disp': disp}\n\n    res = _minimize_scalar_bounded(func, (x1, x2), args, **options)\n    if full_output:\n        return res['x'], res['fun'], res['status'], res['nfev']\n    else:\n        return res['x']\n\n\ndef _minimize_scalar_bounded(func, bounds, args=(),\n                             xatol=1e-5, maxiter=500, disp=0,\n                             **unknown_options):\n    \"\"\"\n    Options\n    -------\n    maxiter : int\n        Maximum number of iterations to perform.\n    disp: int, optional\n        If non-zero, print messages.\n\n        ``0`` : no message printing.\n\n        ``1`` : non-convergence notification messages only.\n\n        ``2`` : print a message on convergence too.\n\n        ``3`` : print iteration results.\n\n    xatol : float\n        Absolute error in solution `xopt` acceptable for convergence.\n\n    \"\"\"\n    _check_unknown_options(unknown_options)\n    maxfun = maxiter\n    # Test bounds are of correct form\n    if len(bounds) != 2:\n        raise ValueError('bounds must have two elements.')\n    x1, x2 = bounds\n\n    if not (is_finite_scalar(x1) and is_finite_scalar(x2)):\n        raise ValueError(\"Optimization bounds must be finite scalars.\")\n\n    if x1 > x2:\n        raise ValueError(\"The lower bound exceeds the upper bound.\")\n\n    flag = 0\n    header = ' Func-count     x          f(x)          Procedure'\n    step = '       initial'\n\n    sqrt_eps = sqrt(2.2e-16)\n    golden_mean = 0.5 * (3.0 - sqrt(5.0))\n    a, b = x1, x2\n    fulc = a + golden_mean * (b - a)\n    nfc, xf = fulc, fulc\n    rat = e = 0.0\n    x = xf\n    fx = func(x, *args)\n    num = 1\n    fmin_data = (1, xf, fx)\n    fu = np.inf\n\n    ffulc = fnfc = fx\n    xm = 0.5 * (a + b)\n    tol1 = sqrt_eps * np.abs(xf) + xatol / 3.0\n    tol2 = 2.0 * tol1\n\n    if disp > 2:\n        print(\" \")\n        print(header)\n        print(\"%5.0f   %12.6g %12.6g %s\" % (fmin_data + (step,)))\n\n    while (np.abs(xf - xm) > (tol2 - 0.5 * (b - a))):\n        golden = 1\n        # Check for parabolic fit\n        if np.abs(e) > tol1:\n            golden = 0\n            r = (xf - nfc) * (fx - ffulc)\n            q = (xf - fulc) * (fx - fnfc)\n            p = (xf - fulc) * q - (xf - nfc) * r\n            q = 2.0 * (q - r)\n            if q > 0.0:\n                p = -p\n            q = np.abs(q)\n            r = e\n            e = rat\n\n            # Check for acceptability of parabola\n            if ((np.abs(p) < np.abs(0.5*q*r)) and (p > q*(a - xf)) and\n                    (p < q * (b - xf))):\n                rat = (p + 0.0) / q\n                x = xf + rat\n                step = '       parabolic'\n\n                if ((x - a) < tol2) or ((b - x) < tol2):\n                    si = np.sign(xm - xf) + ((xm - xf) == 0)\n                    rat = tol1 * si\n            else:      # do a golden-section step\n                golden = 1\n\n        if golden:  # do a golden-section step\n            if xf >= xm:\n                e = a - xf\n            else:\n                e = b - xf\n            rat = golden_mean*e\n            step = '       golden'\n\n        si = np.sign(rat) + (rat == 0)\n        x = xf + si * np.maximum(np.abs(rat), tol1)\n        fu = func(x, *args)\n        num += 1\n        fmin_data = (num, x, fu)\n        if disp > 2:\n            print(\"%5.0f   %12.6g %12.6g %s\" % (fmin_data + (step,)))\n\n        if fu <= fx:\n            if x >= xf:\n                a = xf\n            else:\n                b = xf\n            fulc, ffulc = nfc, fnfc\n            nfc, fnfc = xf, fx\n            xf, fx = x, fu\n        else:\n            if x < xf:\n                a = x\n            else:\n                b = x\n            if (fu <= fnfc) or (nfc == xf):\n                fulc, ffulc = nfc, fnfc\n                nfc, fnfc = x, fu\n            elif (fu <= ffulc) or (fulc == xf) or (fulc == nfc):\n                fulc, ffulc = x, fu\n\n        xm = 0.5 * (a + b)\n        tol1 = sqrt_eps * np.abs(xf) + xatol / 3.0\n        tol2 = 2.0 * tol1\n\n        if num >= maxfun:\n            flag = 1\n            break\n\n    if np.isnan(xf) or np.isnan(fx) or np.isnan(fu):\n        flag = 2\n\n    fval = fx\n    if disp > 0:\n        _endprint(x, flag, fval, maxfun, xatol, disp)\n\n    result = OptimizeResult(fun=fval, status=flag, success=(flag == 0),\n                            message={0: 'Solution found.',\n                                     1: 'Maximum number of function calls '\n                                        'reached.',\n                                     2: _status_message['nan']}.get(flag, ''),\n                            x=xf, nfev=num, nit=num)\n\n    return result\n\n\nclass Brent:\n    #need to rethink design of __init__\n    def __init__(self, func, args=(), tol=1.48e-8, maxiter=500,\n                 full_output=0, disp=0):\n        self.func = func\n        self.args = args\n        self.tol = tol\n        self.maxiter = maxiter\n        self._mintol = 1.0e-11\n        self._cg = 0.3819660\n        self.xmin = None\n        self.fval = None\n        self.iter = 0\n        self.funcalls = 0\n        self.disp = disp\n\n    # need to rethink design of set_bracket (new options, etc.)\n    def set_bracket(self, brack=None):\n        self.brack = brack\n\n    def get_bracket_info(self):\n        #set up\n        func = self.func\n        args = self.args\n        brack = self.brack\n        ### BEGIN core bracket_info code ###\n        ### carefully DOCUMENT any CHANGES in core ##\n        if brack is None:\n            xa, xb, xc, fa, fb, fc, funcalls = bracket(func, args=args)\n        elif len(brack) == 2:\n            xa, xb, xc, fa, fb, fc, funcalls = bracket(func, xa=brack[0],\n                                                       xb=brack[1], args=args)\n        elif len(brack) == 3:\n            xa, xb, xc = brack\n            if (xa > xc):  # swap so xa < xc can be assumed\n                xc, xa = xa, xc\n            if not ((xa < xb) and (xb < xc)):\n                raise ValueError(\n                    \"Bracketing values (xa, xb, xc) do not\"\n                    \" fulfill this requirement: (xa < xb) and (xb < xc)\"\n                )\n            fa = func(*((xa,) + args))\n            fb = func(*((xb,) + args))\n            fc = func(*((xc,) + args))\n            if not ((fb < fa) and (fb < fc)):\n                raise ValueError(\n                    \"Bracketing values (xa, xb, xc) do not fulfill\"\n                    \" this requirement: (f(xb) < f(xa)) and (f(xb) < f(xc))\"\n                )\n\n            funcalls = 3\n        else:\n            raise ValueError(\"Bracketing interval must be \"\n                             \"length 2 or 3 sequence.\")\n        ### END core bracket_info code ###\n\n        return xa, xb, xc, fa, fb, fc, funcalls\n\n    def optimize(self):\n        # set up for optimization\n        func = self.func\n        xa, xb, xc, fa, fb, fc, funcalls = self.get_bracket_info()\n        _mintol = self._mintol\n        _cg = self._cg\n        #################################\n        #BEGIN CORE ALGORITHM\n        #################################\n        x = w = v = xb\n        fw = fv = fx = fb\n        if (xa < xc):\n            a = xa\n            b = xc\n        else:\n            a = xc\n            b = xa\n        deltax = 0.0\n        iter = 0\n\n        if self.disp > 2:\n            print(\" \")\n            print(f\"{'Func-count':^12} {'x':^12} {'f(x)': ^12}\")\n            print(f\"{funcalls:^12g} {x:^12.6g} {fx:^12.6g}\")\n\n        while (iter < self.maxiter):\n            tol1 = self.tol * np.abs(x) + _mintol\n            tol2 = 2.0 * tol1\n            xmid = 0.5 * (a + b)\n            # check for convergence\n            if np.abs(x - xmid) < (tol2 - 0.5 * (b - a)):\n                break\n            # XXX In the first iteration, rat is only bound in the true case\n            # of this conditional. This used to cause an UnboundLocalError\n            # (gh-4140). It should be set before the if (but to what?).\n            if (np.abs(deltax) <= tol1):\n                if (x >= xmid):\n                    deltax = a - x       # do a golden section step\n                else:\n                    deltax = b - x\n                rat = _cg * deltax\n            else:                              # do a parabolic step\n                tmp1 = (x - w) * (fx - fv)\n                tmp2 = (x - v) * (fx - fw)\n                p = (x - v) * tmp2 - (x - w) * tmp1\n                tmp2 = 2.0 * (tmp2 - tmp1)\n                if (tmp2 > 0.0):\n                    p = -p\n                tmp2 = np.abs(tmp2)\n                dx_temp = deltax\n                deltax = rat\n                # check parabolic fit\n                if ((p > tmp2 * (a - x)) and (p < tmp2 * (b - x)) and\n                        (np.abs(p) < np.abs(0.5 * tmp2 * dx_temp))):\n                    rat = p * 1.0 / tmp2        # if parabolic step is useful.\n                    u = x + rat\n                    if ((u - a) < tol2 or (b - u) < tol2):\n                        if xmid - x >= 0:\n                            rat = tol1\n                        else:\n                            rat = -tol1\n                else:\n                    if (x >= xmid):\n                        deltax = a - x  # if it's not do a golden section step\n                    else:\n                        deltax = b - x\n                    rat = _cg * deltax\n\n            if (np.abs(rat) < tol1):            # update by at least tol1\n                if rat >= 0:\n                    u = x + tol1\n                else:\n                    u = x - tol1\n            else:\n                u = x + rat\n            fu = func(*((u,) + self.args))      # calculate new output value\n            funcalls += 1\n\n            if (fu > fx):                 # if it's bigger than current\n                if (u < x):\n                    a = u\n                else:\n                    b = u\n                if (fu <= fw) or (w == x):\n                    v = w\n                    w = u\n                    fv = fw\n                    fw = fu\n                elif (fu <= fv) or (v == x) or (v == w):\n                    v = u\n                    fv = fu\n            else:\n                if (u >= x):\n                    a = x\n                else:\n                    b = x\n                v = w\n                w = x\n                x = u\n                fv = fw\n                fw = fx\n                fx = fu\n\n            if self.disp > 2:\n                print(f\"{funcalls:^12g} {x:^12.6g} {fx:^12.6g}\")\n\n            iter += 1\n        #################################\n        #END CORE ALGORITHM\n        #################################\n\n        self.xmin = x\n        self.fval = fx\n        self.iter = iter\n        self.funcalls = funcalls\n\n    def get_result(self, full_output=False):\n        if full_output:\n            return self.xmin, self.fval, self.iter, self.funcalls\n        else:\n            return self.xmin\n\n\ndef brent(func, args=(), brack=None, tol=1.48e-8, full_output=0, maxiter=500):\n    \"\"\"\n    Given a function of one variable and a possible bracket, return\n    a local minimizer of the function isolated to a fractional precision\n    of tol.\n\n    Parameters\n    ----------\n    func : callable f(x,*args)\n        Objective function.\n    args : tuple, optional\n        Additional arguments (if present).\n    brack : tuple, optional\n        Either a triple ``(xa, xb, xc)`` satisfying ``xa < xb < xc`` and\n        ``func(xb) < func(xa) and  func(xb) < func(xc)``, or a pair\n        ``(xa, xb)`` to be used as initial points for a downhill bracket search\n        (see `scipy.optimize.bracket`).\n        The minimizer ``x`` will not necessarily satisfy ``xa <= x <= xb``.\n    tol : float, optional\n        Relative error in solution `xopt` acceptable for convergence.\n    full_output : bool, optional\n        If True, return all output args (xmin, fval, iter,\n        funcalls).\n    maxiter : int, optional\n        Maximum number of iterations in solution.\n\n    Returns\n    -------\n    xmin : ndarray\n        Optimum point.\n    fval : float\n        (Optional output) Optimum function value.\n    iter : int\n        (Optional output) Number of iterations.\n    funcalls : int\n        (Optional output) Number of objective function evaluations made.\n\n    See also\n    --------\n    minimize_scalar: Interface to minimization algorithms for scalar\n        univariate functions. See the 'Brent' `method` in particular.\n\n    Notes\n    -----\n    Uses inverse parabolic interpolation when possible to speed up\n    convergence of golden section method.\n\n    Does not ensure that the minimum lies in the range specified by\n    `brack`. See `scipy.optimize.fminbound`.\n\n    Examples\n    --------\n    We illustrate the behaviour of the function when `brack` is of\n    size 2 and 3 respectively. In the case where `brack` is of the\n    form ``(xa, xb)``, we can see for the given values, the output does\n    not necessarily lie in the range ``(xa, xb)``.\n\n    >>> def f(x):\n    ...     return (x-1)**2\n\n    >>> from scipy import optimize\n\n    >>> minimizer = optimize.brent(f, brack=(1, 2))\n    >>> minimizer\n    1\n    >>> res = optimize.brent(f, brack=(-1, 0.5, 2), full_output=True)\n    >>> xmin, fval, iter, funcalls = res\n    >>> f(xmin), fval\n    (0.0, 0.0)\n\n    \"\"\"\n    options = {'xtol': tol,\n               'maxiter': maxiter}\n    res = _minimize_scalar_brent(func, brack, args, **options)\n    if full_output:\n        return res['x'], res['fun'], res['nit'], res['nfev']\n    else:\n        return res['x']\n\n\ndef _minimize_scalar_brent(func, brack=None, args=(), xtol=1.48e-8,\n                           maxiter=500, disp=0,\n                           **unknown_options):\n    \"\"\"\n    Options\n    -------\n    maxiter : int\n        Maximum number of iterations to perform.\n    xtol : float\n        Relative error in solution `xopt` acceptable for convergence.\n    disp : int, optional\n        If non-zero, print messages.\n\n        ``0`` : no message printing.\n\n        ``1`` : non-convergence notification messages only.\n\n        ``2`` : print a message on convergence too.\n\n        ``3`` : print iteration results.\n\n    Notes\n    -----\n    Uses inverse parabolic interpolation when possible to speed up\n    convergence of golden section method.\n\n    \"\"\"\n    _check_unknown_options(unknown_options)\n    tol = xtol\n    if tol < 0:\n        raise ValueError(f'tolerance should be >= 0, got {tol!r}')\n\n    brent = Brent(func=func, args=args, tol=tol,\n                  full_output=True, maxiter=maxiter, disp=disp)\n    brent.set_bracket(brack)\n    brent.optimize()\n    x, fval, nit, nfev = brent.get_result(full_output=True)\n\n    success = nit < maxiter and not (np.isnan(x) or np.isnan(fval))\n\n    if success:\n        message = (\"\\nOptimization terminated successfully;\\n\"\n                   \"The returned value satisfies the termination criteria\\n\"\n                   f\"(using xtol = {xtol} )\")\n    else:\n        if nit >= maxiter:\n            message = \"\\nMaximum number of iterations exceeded\"\n        if np.isnan(x) or np.isnan(fval):\n            message = f\"{_status_message['nan']}\"\n\n    if disp:\n        _print_success_message_or_warn(not success, message)\n\n    return OptimizeResult(fun=fval, x=x, nit=nit, nfev=nfev,\n                          success=success, message=message)\n\n\ndef golden(func, args=(), brack=None, tol=_epsilon,\n           full_output=0, maxiter=5000):\n    \"\"\"\n    Return the minimizer of a function of one variable using the golden section\n    method.\n\n    Given a function of one variable and a possible bracketing interval,\n    return a minimizer of the function isolated to a fractional precision of\n    tol.\n\n    Parameters\n    ----------\n    func : callable func(x,*args)\n        Objective function to minimize.\n    args : tuple, optional\n        Additional arguments (if present), passed to func.\n    brack : tuple, optional\n        Either a triple ``(xa, xb, xc)`` where ``xa < xb < xc`` and\n        ``func(xb) < func(xa) and  func(xb) < func(xc)``, or a pair (xa, xb)\n        to be used as initial points for a downhill bracket search (see\n        `scipy.optimize.bracket`).\n        The minimizer ``x`` will not necessarily satisfy ``xa <= x <= xb``.\n    tol : float, optional\n        x tolerance stop criterion\n    full_output : bool, optional\n        If True, return optional outputs.\n    maxiter : int\n        Maximum number of iterations to perform.\n\n    Returns\n    -------\n    xmin : ndarray\n        Optimum point.\n    fval : float\n        (Optional output) Optimum function value.\n    funcalls : int\n        (Optional output) Number of objective function evaluations made.\n\n    See also\n    --------\n    minimize_scalar: Interface to minimization algorithms for scalar\n        univariate functions. See the 'Golden' `method` in particular.\n\n    Notes\n    -----\n    Uses analog of bisection method to decrease the bracketed\n    interval.\n\n    Examples\n    --------\n    We illustrate the behaviour of the function when `brack` is of\n    size 2 and 3, respectively. In the case where `brack` is of the\n    form (xa,xb), we can see for the given values, the output need\n    not necessarily lie in the range ``(xa, xb)``.\n\n    >>> def f(x):\n    ...     return (x-1)**2\n\n    >>> from scipy import optimize\n\n    >>> minimizer = optimize.golden(f, brack=(1, 2))\n    >>> minimizer\n    1\n    >>> res = optimize.golden(f, brack=(-1, 0.5, 2), full_output=True)\n    >>> xmin, fval, funcalls = res\n    >>> f(xmin), fval\n    (9.925165290385052e-18, 9.925165290385052e-18)\n\n    \"\"\"\n    options = {'xtol': tol, 'maxiter': maxiter}\n    res = _minimize_scalar_golden(func, brack, args, **options)\n    if full_output:\n        return res['x'], res['fun'], res['nfev']\n    else:\n        return res['x']\n\n\ndef _minimize_scalar_golden(func, brack=None, args=(),\n                            xtol=_epsilon, maxiter=5000, disp=0,\n                            **unknown_options):\n    \"\"\"\n    Options\n    -------\n    xtol : float\n        Relative error in solution `xopt` acceptable for convergence.\n    maxiter : int\n        Maximum number of iterations to perform.\n    disp: int, optional\n        If non-zero, print messages.\n\n        ``0`` : no message printing.\n\n        ``1`` : non-convergence notification messages only.\n\n        ``2`` : print a message on convergence too.\n\n        ``3`` : print iteration results.\n    \"\"\"\n    _check_unknown_options(unknown_options)\n    tol = xtol\n    if brack is None:\n        xa, xb, xc, fa, fb, fc, funcalls = bracket(func, args=args)\n    elif len(brack) == 2:\n        xa, xb, xc, fa, fb, fc, funcalls = bracket(func, xa=brack[0],\n                                                   xb=brack[1], args=args)\n    elif len(brack) == 3:\n        xa, xb, xc = brack\n        if (xa > xc):  # swap so xa < xc can be assumed\n            xc, xa = xa, xc\n        if not ((xa < xb) and (xb < xc)):\n            raise ValueError(\n                \"Bracketing values (xa, xb, xc) do not\"\n                \" fulfill this requirement: (xa < xb) and (xb < xc)\"\n            )\n        fa = func(*((xa,) + args))\n        fb = func(*((xb,) + args))\n        fc = func(*((xc,) + args))\n        if not ((fb < fa) and (fb < fc)):\n            raise ValueError(\n                \"Bracketing values (xa, xb, xc) do not fulfill\"\n                \" this requirement: (f(xb) < f(xa)) and (f(xb) < f(xc))\"\n            )\n        funcalls = 3\n    else:\n        raise ValueError(\"Bracketing interval must be length 2 or 3 sequence.\")\n\n    _gR = 0.61803399  # golden ratio conjugate: 2.0/(1.0+sqrt(5.0))\n    _gC = 1.0 - _gR\n    x3 = xc\n    x0 = xa\n    if (np.abs(xc - xb) > np.abs(xb - xa)):\n        x1 = xb\n        x2 = xb + _gC * (xc - xb)\n    else:\n        x2 = xb\n        x1 = xb - _gC * (xb - xa)\n    f1 = func(*((x1,) + args))\n    f2 = func(*((x2,) + args))\n    funcalls += 2\n    nit = 0\n\n    if disp > 2:\n        print(\" \")\n        print(f\"{'Func-count':^12} {'x':^12} {'f(x)': ^12}\")\n\n    for i in range(maxiter):\n        if np.abs(x3 - x0) <= tol * (np.abs(x1) + np.abs(x2)):\n            break\n        if (f2 < f1):\n            x0 = x1\n            x1 = x2\n            x2 = _gR * x1 + _gC * x3\n            f1 = f2\n            f2 = func(*((x2,) + args))\n        else:\n            x3 = x2\n            x2 = x1\n            x1 = _gR * x2 + _gC * x0\n            f2 = f1\n            f1 = func(*((x1,) + args))\n        funcalls += 1\n        if disp > 2:\n            if (f1 < f2):\n                xmin, fval = x1, f1\n            else:\n                xmin, fval = x2, f2\n            print(f\"{funcalls:^12g} {xmin:^12.6g} {fval:^12.6g}\")\n\n        nit += 1\n    # end of iteration loop\n\n    if (f1 < f2):\n        xmin = x1\n        fval = f1\n    else:\n        xmin = x2\n        fval = f2\n\n    success = nit < maxiter and not (np.isnan(fval) or np.isnan(xmin))\n\n    if success:\n        message = (\"\\nOptimization terminated successfully;\\n\"\n                   \"The returned value satisfies the termination criteria\\n\"\n                   f\"(using xtol = {xtol} )\")\n    else:\n        if nit >= maxiter:\n            message = \"\\nMaximum number of iterations exceeded\"\n        if np.isnan(xmin) or np.isnan(fval):\n            message = f\"{_status_message['nan']}\"\n\n    if disp:\n        _print_success_message_or_warn(not success, message)\n\n    return OptimizeResult(fun=fval, nfev=funcalls, x=xmin, nit=nit,\n                          success=success, message=message)\n\n\ndef bracket(func, xa=0.0, xb=1.0, args=(), grow_limit=110.0, maxiter=1000):\n    \"\"\"\n    Bracket the minimum of a function.\n\n    Given a function and distinct initial points, search in the\n    downhill direction (as defined by the initial points) and return\n    three points that bracket the minimum of the function.\n\n    Parameters\n    ----------\n    func : callable f(x,*args)\n        Objective function to minimize.\n    xa, xb : float, optional\n        Initial points. Defaults `xa` to 0.0, and `xb` to 1.0.\n        A local minimum need not be contained within this interval.\n    args : tuple, optional\n        Additional arguments (if present), passed to `func`.\n    grow_limit : float, optional\n        Maximum grow limit.  Defaults to 110.0\n    maxiter : int, optional\n        Maximum number of iterations to perform. Defaults to 1000.\n\n    Returns\n    -------\n    xa, xb, xc : float\n        Final points of the bracket.\n    fa, fb, fc : float\n        Objective function values at the bracket points.\n    funcalls : int\n        Number of function evaluations made.\n\n    Raises\n    ------\n    BracketError\n        If no valid bracket is found before the algorithm terminates.\n        See notes for conditions of a valid bracket.\n\n    Notes\n    -----\n    The algorithm attempts to find three strictly ordered points (i.e.\n    :math:`x_a < x_b < x_c` or :math:`x_c < x_b < x_a`) satisfying\n    :math:`f(x_b) \u2264 f(x_a)` and :math:`f(x_b) \u2264 f(x_c)`, where one of the\n    inequalities must be satisfied strictly and all :math:`x_i` must be\n    finite.\n\n    Examples\n    --------\n    This function can find a downward convex region of a function:\n\n    >>> import numpy as np\n    >>> import matplotlib.pyplot as plt\n    >>> from scipy.optimize import bracket\n    >>> def f(x):\n    ...     return 10*x**2 + 3*x + 5\n    >>> x = np.linspace(-2, 2)\n    >>> y = f(x)\n    >>> init_xa, init_xb = 0.1, 1\n    >>> xa, xb, xc, fa, fb, fc, funcalls = bracket(f, xa=init_xa, xb=init_xb)\n    >>> plt.axvline(x=init_xa, color=\"k\", linestyle=\"--\")\n    >>> plt.axvline(x=init_xb, color=\"k\", linestyle=\"--\")\n    >>> plt.plot(x, y, \"-k\")\n    >>> plt.plot(xa, fa, \"bx\")\n    >>> plt.plot(xb, fb, \"rx\")\n    >>> plt.plot(xc, fc, \"bx\")\n    >>> plt.show()\n\n    Note that both initial points were to the right of the minimum, and the\n    third point was found in the \"downhill\" direction: the direction\n    in which the function appeared to be decreasing (to the left).\n    The final points are strictly ordered, and the function value\n    at the middle point is less than the function values at the endpoints;\n    it follows that a minimum must lie within the bracket.\n\n    \"\"\"\n    _gold = 1.618034  # golden ratio: (1.0+sqrt(5.0))/2.0\n    _verysmall_num = 1e-21\n    # convert to numpy floats if not already\n    xa, xb = np.asarray([xa, xb])\n    fa = func(*(xa,) + args)\n    fb = func(*(xb,) + args)\n    if (fa < fb):                      # Switch so fa > fb\n        xa, xb = xb, xa\n        fa, fb = fb, fa\n    xc = xb + _gold * (xb - xa)\n    fc = func(*((xc,) + args))\n    funcalls = 3\n    iter = 0\n    while (fc < fb):\n        tmp1 = (xb - xa) * (fb - fc)\n        tmp2 = (xb - xc) * (fb - fa)\n        val = tmp2 - tmp1\n        if np.abs(val) < _verysmall_num:\n            denom = 2.0 * _verysmall_num\n        else:\n            denom = 2.0 * val\n        w = xb - ((xb - xc) * tmp2 - (xb - xa) * tmp1) / denom\n        wlim = xb + grow_limit * (xc - xb)\n        msg = (\"No valid bracket was found before the iteration limit was \"\n               \"reached. Consider trying different initial points or \"\n               \"increasing `maxiter`.\")\n        if iter > maxiter:\n            raise RuntimeError(msg)\n        iter += 1\n        if (w - xc) * (xb - w) > 0.0:\n            fw = func(*((w,) + args))\n            funcalls += 1\n            if (fw < fc):\n                xa = xb\n                xb = w\n                fa = fb\n                fb = fw\n                break\n            elif (fw > fb):\n                xc = w\n                fc = fw\n                break\n            w = xc + _gold * (xc - xb)\n            fw = func(*((w,) + args))\n            funcalls += 1\n        elif (w - wlim)*(wlim - xc) >= 0.0:\n            w = wlim\n            fw = func(*((w,) + args))\n            funcalls += 1\n        elif (w - wlim)*(xc - w) > 0.0:\n            fw = func(*((w,) + args))\n            funcalls += 1\n            if (fw < fc):\n                xb = xc\n                xc = w\n                w = xc + _gold * (xc - xb)\n                fb = fc\n                fc = fw\n                fw = func(*((w,) + args))\n                funcalls += 1\n        else:\n            w = xc + _gold * (xc - xb)\n            fw = func(*((w,) + args))\n            funcalls += 1\n        xa = xb\n        xb = xc\n        xc = w\n        fa = fb\n        fb = fc\n        fc = fw\n\n    # three conditions for a valid bracket\n    cond1 = (fb < fc and fb <= fa) or (fb < fa and fb <= fc)\n    cond2 = (xa < xb < xc or xc < xb < xa)\n    cond3 = np.isfinite(xa) and np.isfinite(xb) and np.isfinite(xc)\n    msg = (\"The algorithm terminated without finding a valid bracket. \"\n           \"Consider trying different initial points.\")\n    if not (cond1 and cond2 and cond3):\n        e = BracketError(msg)\n        e.data = (xa, xb, xc, fa, fb, fc, funcalls)\n        raise e\n\n    return xa, xb, xc, fa, fb, fc, funcalls\n\n\nclass BracketError(RuntimeError):\n    pass\n\n\ndef _recover_from_bracket_error(solver, fun, bracket, args, **options):\n    # `bracket` was originally written without checking whether the resulting\n    # bracket is valid. `brent` and `golden` built on top of it without\n    # checking the returned bracket for validity, and their output can be\n    # incorrect without warning/error if the original bracket is invalid.\n    # gh-14858 noticed the problem, and the following is the desired\n    # behavior:\n    # - `scipy.optimize.bracket`, `scipy.optimize.brent`, and\n    #   `scipy.optimize.golden` should raise an error if the bracket is\n    #   invalid, as opposed to silently returning garbage\n    # - `scipy.optimize.minimize_scalar` should return with `success=False`\n    #   and other information\n    # The changes that would be required to achieve this the traditional\n    # way (`return`ing all the required information from bracket all the way\n    # up to `minimizer_scalar`) are extensive and invasive. (See a6aa40d.)\n    # We can achieve the same thing by raising the error in `bracket`, but\n    # storing the information needed by `minimize_scalar` in the error object,\n    # and intercepting it here.\n    try:\n        res = solver(fun, bracket, args, **options)\n    except BracketError as e:\n        msg = str(e)\n        xa, xb, xc, fa, fb, fc, funcalls = e.data\n        xs, fs = [xa, xb, xc], [fa, fb, fc]\n        if np.any(np.isnan([xs, fs])):\n            x, fun = np.nan, np.nan\n        else:\n            imin = np.argmin(fs)\n            x, fun = xs[imin], fs[imin]\n        return OptimizeResult(fun=fun, nfev=funcalls, x=x,\n                              nit=0, success=False, message=msg)\n    return res\n\n\ndef _line_for_search(x0, alpha, lower_bound, upper_bound):\n    \"\"\"\n    Given a parameter vector ``x0`` with length ``n`` and a direction\n    vector ``alpha`` with length ``n``, and lower and upper bounds on\n    each of the ``n`` parameters, what are the bounds on a scalar\n    ``l`` such that ``lower_bound <= x0 + alpha * l <= upper_bound``.\n\n\n    Parameters\n    ----------\n    x0 : np.array.\n        The vector representing the current location.\n        Note ``np.shape(x0) == (n,)``.\n    alpha : np.array.\n        The vector representing the direction.\n        Note ``np.shape(alpha) == (n,)``.\n    lower_bound : np.array.\n        The lower bounds for each parameter in ``x0``. If the ``i``th\n        parameter in ``x0`` is unbounded below, then ``lower_bound[i]``\n        should be ``-np.inf``.\n        Note ``np.shape(lower_bound) == (n,)``.\n    upper_bound : np.array.\n        The upper bounds for each parameter in ``x0``. If the ``i``th\n        parameter in ``x0`` is unbounded above, then ``upper_bound[i]``\n        should be ``np.inf``.\n        Note ``np.shape(upper_bound) == (n,)``.\n\n    Returns\n    -------\n    res : tuple ``(lmin, lmax)``\n        The bounds for ``l`` such that\n            ``lower_bound[i] <= x0[i] + alpha[i] * l <= upper_bound[i]``\n        for all ``i``.\n\n    \"\"\"\n    # get nonzero indices of alpha so we don't get any zero division errors.\n    # alpha will not be all zero, since it is called from _linesearch_powell\n    # where we have a check for this.\n    nonzero, = alpha.nonzero()\n    lower_bound, upper_bound = lower_bound[nonzero], upper_bound[nonzero]\n    x0, alpha = x0[nonzero], alpha[nonzero]\n    low = (lower_bound - x0) / alpha\n    high = (upper_bound - x0) / alpha\n\n    # positive and negative indices\n    pos = alpha > 0\n\n    lmin_pos = np.where(pos, low, 0)\n    lmin_neg = np.where(pos, 0, high)\n    lmax_pos = np.where(pos, high, 0)\n    lmax_neg = np.where(pos, 0, low)\n\n    lmin = np.max(lmin_pos + lmin_neg)\n    lmax = np.min(lmax_pos + lmax_neg)\n\n    # if x0 is outside the bounds, then it is possible that there is\n    # no way to get back in the bounds for the parameters being updated\n    # with the current direction alpha.\n    # when this happens, lmax < lmin.\n    # If this is the case, then we can just return (0, 0)\n    return (lmin, lmax) if lmax >= lmin else (0, 0)\n\n\ndef _linesearch_powell(func, p, xi, tol=1e-3,\n                       lower_bound=None, upper_bound=None, fval=None):\n    \"\"\"Line-search algorithm using fminbound.\n\n    Find the minimum of the function ``func(x0 + alpha*direc)``.\n\n    lower_bound : np.array.\n        The lower bounds for each parameter in ``x0``. If the ``i``th\n        parameter in ``x0`` is unbounded below, then ``lower_bound[i]``\n        should be ``-np.inf``.\n        Note ``np.shape(lower_bound) == (n,)``.\n    upper_bound : np.array.\n        The upper bounds for each parameter in ``x0``. If the ``i``th\n        parameter in ``x0`` is unbounded above, then ``upper_bound[i]``\n        should be ``np.inf``.\n        Note ``np.shape(upper_bound) == (n,)``.\n    fval : number.\n        ``fval`` is equal to ``func(p)``, the idea is just to avoid\n        recomputing it so we can limit the ``fevals``.\n\n    \"\"\"\n    def myfunc(alpha):\n        return func(p + alpha*xi)\n\n    # if xi is zero, then don't optimize\n    if not np.any(xi):\n        return ((fval, p, xi) if fval is not None else (func(p), p, xi))\n    elif lower_bound is None and upper_bound is None:\n        # non-bounded minimization\n        res = _recover_from_bracket_error(_minimize_scalar_brent,\n                                          myfunc, None, tuple(), xtol=tol)\n        alpha_min, fret = res.x, res.fun\n        xi = alpha_min * xi\n        return fret, p + xi, xi\n    else:\n        bound = _line_for_search(p, xi, lower_bound, upper_bound)\n        if np.isneginf(bound[0]) and np.isposinf(bound[1]):\n            # equivalent to unbounded\n            return _linesearch_powell(func, p, xi, fval=fval, tol=tol)\n        elif not np.isneginf(bound[0]) and not np.isposinf(bound[1]):\n            # we can use a bounded scalar minimization\n            res = _minimize_scalar_bounded(myfunc, bound, xatol=tol / 100)\n            xi = res.x * xi\n            return res.fun, p + xi, xi\n        else:\n            # only bounded on one side. use the tangent function to convert\n            # the infinity bound to a finite bound. The new bounded region\n            # is a subregion of the region bounded by -np.pi/2 and np.pi/2.\n            bound = np.arctan(bound[0]), np.arctan(bound[1])\n            res = _minimize_scalar_bounded(\n                lambda x: myfunc(np.tan(x)),\n                bound,\n                xatol=tol / 100)\n            xi = np.tan(res.x) * xi\n            return res.fun, p + xi, xi\n\n\ndef fmin_powell(func, x0, args=(), xtol=1e-4, ftol=1e-4, maxiter=None,\n                maxfun=None, full_output=0, disp=1, retall=0, callback=None,\n                direc=None):\n    \"\"\"\n    Minimize a function using modified Powell's method.\n\n    This method only uses function values, not derivatives.\n\n    Parameters\n    ----------\n    func : callable f(x,*args)\n        Objective function to be minimized.\n    x0 : ndarray\n        Initial guess.\n    args : tuple, optional\n        Extra arguments passed to func.\n    xtol : float, optional\n        Line-search error tolerance.\n    ftol : float, optional\n        Relative error in ``func(xopt)`` acceptable for convergence.\n    maxiter : int, optional\n        Maximum number of iterations to perform.\n    maxfun : int, optional\n        Maximum number of function evaluations to make.\n    full_output : bool, optional\n        If True, ``fopt``, ``xi``, ``direc``, ``iter``, ``funcalls``, and\n        ``warnflag`` are returned.\n    disp : bool, optional\n        If True, print convergence messages.\n    retall : bool, optional\n        If True, return a list of the solution at each iteration.\n    callback : callable, optional\n        An optional user-supplied function, called after each\n        iteration.  Called as ``callback(xk)``, where ``xk`` is the\n        current parameter vector.\n    direc : ndarray, optional\n        Initial fitting step and parameter order set as an (N, N) array, where N\n        is the number of fitting parameters in `x0`. Defaults to step size 1.0\n        fitting all parameters simultaneously (``np.eye((N, N))``). To\n        prevent initial consideration of values in a step or to change initial\n        step size, set to 0 or desired step size in the Jth position in the Mth\n        block, where J is the position in `x0` and M is the desired evaluation\n        step, with steps being evaluated in index order. Step size and ordering\n        will change freely as minimization proceeds.\n\n    Returns\n    -------\n    xopt : ndarray\n        Parameter which minimizes `func`.\n    fopt : number\n        Value of function at minimum: ``fopt = func(xopt)``.\n    direc : ndarray\n        Current direction set.\n    iter : int\n        Number of iterations.\n    funcalls : int\n        Number of function calls made.\n    warnflag : int\n        Integer warning flag:\n            1 : Maximum number of function evaluations.\n            2 : Maximum number of iterations.\n            3 : NaN result encountered.\n            4 : The result is out of the provided bounds.\n    allvecs : list\n        List of solutions at each iteration.\n\n    See also\n    --------\n    minimize: Interface to unconstrained minimization algorithms for\n        multivariate functions. See the 'Powell' method in particular.\n\n    Notes\n    -----\n    Uses a modification of Powell's method to find the minimum of\n    a function of N variables. Powell's method is a conjugate\n    direction method.\n\n    The algorithm has two loops. The outer loop merely iterates over the inner\n    loop. The inner loop minimizes over each current direction in the direction\n    set. At the end of the inner loop, if certain conditions are met, the\n    direction that gave the largest decrease is dropped and replaced with the\n    difference between the current estimated x and the estimated x from the\n    beginning of the inner-loop.\n\n    The technical conditions for replacing the direction of greatest\n    increase amount to checking that\n\n    1. No further gain can be made along the direction of greatest increase\n       from that iteration.\n    2. The direction of greatest increase accounted for a large sufficient\n       fraction of the decrease in the function value from that iteration of\n       the inner loop.\n\n    References\n    ----------\n    Powell M.J.D. (1964) An efficient method for finding the minimum of a\n    function of several variables without calculating derivatives,\n    Computer Journal, 7 (2):155-162.\n\n    Press W., Teukolsky S.A., Vetterling W.T., and Flannery B.P.:\n    Numerical Recipes (any edition), Cambridge University Press\n\n    Examples\n    --------\n    >>> def f(x):\n    ...     return x**2\n\n    >>> from scipy import optimize\n\n    >>> minimum = optimize.fmin_powell(f, -1)\n    Optimization terminated successfully.\n             Current function value: 0.000000\n             Iterations: 2\n             Function evaluations: 16\n    >>> minimum\n    array(0.0)\n\n    \"\"\"\n    opts = {'xtol': xtol,\n            'ftol': ftol,\n            'maxiter': maxiter,\n            'maxfev': maxfun,\n            'disp': disp,\n            'direc': direc,\n            'return_all': retall}\n\n    callback = _wrap_callback(callback)\n    res = _minimize_powell(func, x0, args, callback=callback, **opts)\n\n    if full_output:\n        retlist = (res['x'], res['fun'], res['direc'], res['nit'],\n                   res['nfev'], res['status'])\n        if retall:\n            retlist += (res['allvecs'], )\n        return retlist\n    else:\n        if retall:\n            return res['x'], res['allvecs']\n        else:\n            return res['x']\n\n\ndef _minimize_powell(func, x0, args=(), callback=None, bounds=None,\n                     xtol=1e-4, ftol=1e-4, maxiter=None, maxfev=None,\n                     disp=False, direc=None, return_all=False,\n                     **unknown_options):\n    \"\"\"\n    Minimization of scalar function of one or more variables using the\n    modified Powell algorithm.\n\n    Parameters\n    ----------\n    fun : callable\n        The objective function to be minimized::\n\n            fun(x, *args) -> float\n\n        where ``x`` is a 1-D array with shape (n,) and ``args``\n        is a tuple of the fixed parameters needed to completely\n        specify the function.\n    x0 : ndarray, shape (n,)\n        Initial guess. Array of real elements of size (n,),\n        where ``n`` is the number of independent variables.\n    args : tuple, optional\n        Extra arguments passed to the objective function and its\n        derivatives (`fun`, `jac` and `hess` functions).\n    method : str or callable, optional\n        The present documentation is specific to ``method='powell'``, but other\n        options are available. See documentation for `scipy.optimize.minimize`.\n    bounds : sequence or `Bounds`, optional\n        Bounds on decision variables. There are two ways to specify the bounds:\n\n        1. Instance of `Bounds` class.\n        2. Sequence of ``(min, max)`` pairs for each element in `x`. None\n           is used to specify no bound.\n\n        If bounds are not provided, then an unbounded line search will be used.\n        If bounds are provided and the initial guess is within the bounds, then\n        every function evaluation throughout the minimization procedure will be\n        within the bounds. If bounds are provided, the initial guess is outside\n        the bounds, and `direc` is full rank (or left to default), then some\n        function evaluations during the first iteration may be outside the\n        bounds, but every function evaluation after the first iteration will be\n        within the bounds. If `direc` is not full rank, then some parameters\n        may not be optimized and the solution is not guaranteed to be within\n        the bounds.\n\n    options : dict, optional\n        A dictionary of solver options. All methods accept the following\n        generic options:\n\n        maxiter : int\n            Maximum number of iterations to perform. Depending on the\n            method each iteration may use several function evaluations.\n        disp : bool\n            Set to True to print convergence messages.\n\n        See method-specific options for ``method='powell'`` below.\n    callback : callable, optional\n        Called after each iteration. The signature is::\n\n            callback(xk)\n\n        where ``xk`` is the current parameter vector.\n\n    Returns\n    -------\n    res : OptimizeResult\n        The optimization result represented as a ``OptimizeResult`` object.\n        Important attributes are: ``x`` the solution array, ``success`` a\n        Boolean flag indicating if the optimizer exited successfully and\n        ``message`` which describes the cause of the termination. See\n        `OptimizeResult` for a description of other attributes.\n\n    Options\n    -------\n    disp : bool\n        Set to True to print convergence messages.\n    xtol : float\n        Relative error in solution `xopt` acceptable for convergence.\n    ftol : float\n        Relative error in ``fun(xopt)`` acceptable for convergence.\n    maxiter, maxfev : int\n        Maximum allowed number of iterations and function evaluations.\n        Will default to ``N*1000``, where ``N`` is the number of\n        variables, if neither `maxiter` or `maxfev` is set. If both\n        `maxiter` and `maxfev` are set, minimization will stop at the\n        first reached.\n    direc : ndarray\n        Initial set of direction vectors for the Powell method.\n    return_all : bool, optional\n        Set to True to return a list of the best solution at each of the\n        iterations.\n    \"\"\"\n    _check_unknown_options(unknown_options)\n    maxfun = maxfev\n    retall = return_all\n\n    x = asarray(x0).flatten()\n    if retall:\n        allvecs = [x]\n    N = len(x)\n    # If neither are set, then set both to default\n    if maxiter is None and maxfun is None:\n        maxiter = N * 1000\n        maxfun = N * 1000\n    elif maxiter is None:\n        # Convert remaining Nones, to np.inf, unless the other is np.inf, in\n        # which case use the default to avoid unbounded iteration\n        if maxfun == np.inf:\n            maxiter = N * 1000\n        else:\n            maxiter = np.inf\n    elif maxfun is None:\n        if maxiter == np.inf:\n            maxfun = N * 1000\n        else:\n            maxfun = np.inf\n\n    # we need to use a mutable object here that we can update in the\n    # wrapper function\n    fcalls, func = _wrap_scalar_function_maxfun_validation(func, args, maxfun)\n\n    if direc is None:\n        direc = eye(N, dtype=float)\n    else:\n        direc = asarray(direc, dtype=float)\n        if np.linalg.matrix_rank(direc) != direc.shape[0]:\n            warnings.warn(\"direc input is not full rank, some parameters may \"\n                          \"not be optimized\",\n                          OptimizeWarning, stacklevel=3)\n\n    if bounds is None:\n        # don't make these arrays of all +/- inf. because\n        # _linesearch_powell will do an unnecessary check of all the elements.\n        # just keep them None, _linesearch_powell will not have to check\n        # all the elements.\n        lower_bound, upper_bound = None, None\n    else:\n        # bounds is standardized in _minimize.py.\n        lower_bound, upper_bound = bounds.lb, bounds.ub\n        if np.any(lower_bound > x0) or np.any(x0 > upper_bound):\n            warnings.warn(\"Initial guess is not within the specified bounds\",\n                          OptimizeWarning, stacklevel=3)\n\n    fval = func(x)\n    x1 = x.copy()\n    iter = 0\n    while True:\n        try:\n            fx = fval\n            bigind = 0\n            delta = 0.0\n            for i in range(N):\n                direc1 = direc[i]\n                fx2 = fval\n                fval, x, direc1 = _linesearch_powell(func, x, direc1,\n                                                     tol=xtol * 100,\n                                                     lower_bound=lower_bound,\n                                                     upper_bound=upper_bound,\n                                                     fval=fval)\n                if (fx2 - fval) > delta:\n                    delta = fx2 - fval\n                    bigind = i\n            iter += 1\n            if retall:\n                allvecs.append(x)\n            intermediate_result = OptimizeResult(x=x, fun=fval)\n            if _call_callback_maybe_halt(callback, intermediate_result):\n                break\n            bnd = ftol * (np.abs(fx) + np.abs(fval)) + 1e-20\n            if 2.0 * (fx - fval) <= bnd:\n                break\n            if fcalls[0] >= maxfun:\n                break\n            if iter >= maxiter:\n                break\n            if np.isnan(fx) and np.isnan(fval):\n                # Ended up in a nan-region: bail out\n                break\n\n            # Construct the extrapolated point\n            direc1 = x - x1\n            x1 = x.copy()\n            # make sure that we don't go outside the bounds when extrapolating\n            if lower_bound is None and upper_bound is None:\n                lmax = 1\n            else:\n                _, lmax = _line_for_search(x, direc1, lower_bound, upper_bound)\n            x2 = x + min(lmax, 1) * direc1\n            fx2 = func(x2)\n\n            if (fx > fx2):\n                t = 2.0*(fx + fx2 - 2.0*fval)\n                temp = (fx - fval - delta)\n                t *= temp*temp\n                temp = fx - fx2\n                t -= delta*temp*temp\n                if t < 0.0:\n                    fval, x, direc1 = _linesearch_powell(\n                        func, x, direc1,\n                        tol=xtol * 100,\n                        lower_bound=lower_bound,\n                        upper_bound=upper_bound,\n                        fval=fval\n                    )\n                    if np.any(direc1):\n                        direc[bigind] = direc[-1]\n                        direc[-1] = direc1\n        except _MaxFuncCallError:\n            break\n\n    warnflag = 0\n    msg = _status_message['success']\n    # out of bounds is more urgent than exceeding function evals or iters,\n    # but I don't want to cause inconsistencies by changing the\n    # established warning flags for maxfev and maxiter, so the out of bounds\n    # warning flag becomes 3, but is checked for first.\n    if bounds and (np.any(lower_bound > x) or np.any(x > upper_bound)):\n        warnflag = 4\n        msg = _status_message['out_of_bounds']\n    elif fcalls[0] >= maxfun:\n        warnflag = 1\n        msg = _status_message['maxfev']\n    elif iter >= maxiter:\n        warnflag = 2\n        msg = _status_message['maxiter']\n    elif np.isnan(fval) or np.isnan(x).any():\n        warnflag = 3\n        msg = _status_message['nan']\n\n    if disp:\n        _print_success_message_or_warn(warnflag, msg, RuntimeWarning)\n        print(f\"         Current function value: {fval:f}\")\n        print(\"         Iterations: %d\" % iter)\n        print(\"         Function evaluations: %d\" % fcalls[0])\n    result = OptimizeResult(fun=fval, direc=direc, nit=iter, nfev=fcalls[0],\n                            status=warnflag, success=(warnflag == 0),\n                            message=msg, x=x)\n    if retall:\n        result['allvecs'] = allvecs\n    return result\n\n\ndef _endprint(x, flag, fval, maxfun, xtol, disp):\n    if flag == 0:\n        if disp > 1:\n            print(\"\\nOptimization terminated successfully;\\n\"\n                  \"The returned value satisfies the termination criteria\\n\"\n                  \"(using xtol = \", xtol, \")\")\n        return\n\n    if flag == 1:\n        msg = (\"\\nMaximum number of function evaluations exceeded --- \"\n               \"increase maxfun argument.\\n\")\n    elif flag == 2:\n        msg = f\"\\n{_status_message['nan']}\"\n\n    _print_success_message_or_warn(flag, msg)\n    return\n\n\ndef brute(func, ranges, args=(), Ns=20, full_output=0, finish=fmin,\n          disp=False, workers=1):\n    \"\"\"Minimize a function over a given range by brute force.\n\n    Uses the \"brute force\" method, i.e., computes the function's value\n    at each point of a multidimensional grid of points, to find the global\n    minimum of the function.\n\n    The function is evaluated everywhere in the range with the datatype of the\n    first call to the function, as enforced by the ``vectorize`` NumPy\n    function. The value and type of the function evaluation returned when\n    ``full_output=True`` are affected in addition by the ``finish`` argument\n    (see Notes).\n\n    The brute force approach is inefficient because the number of grid points\n    increases exponentially - the number of grid points to evaluate is\n    ``Ns ** len(x)``. Consequently, even with coarse grid spacing, even\n    moderately sized problems can take a long time to run, and/or run into\n    memory limitations.\n\n    Parameters\n    ----------\n    func : callable\n        The objective function to be minimized. Must be in the\n        form ``f(x, *args)``, where ``x`` is the argument in\n        the form of a 1-D array and ``args`` is a tuple of any\n        additional fixed parameters needed to completely specify\n        the function.\n    ranges : tuple\n        Each component of the `ranges` tuple must be either a\n        \"slice object\" or a range tuple of the form ``(low, high)``.\n        The program uses these to create the grid of points on which\n        the objective function will be computed. See `Note 2` for\n        more detail.\n    args : tuple, optional\n        Any additional fixed parameters needed to completely specify\n        the function.\n    Ns : int, optional\n        Number of grid points along the axes, if not otherwise\n        specified. See `Note2`.\n    full_output : bool, optional\n        If True, return the evaluation grid and the objective function's\n        values on it.\n    finish : callable, optional\n        An optimization function that is called with the result of brute force\n        minimization as initial guess. `finish` should take `func` and\n        the initial guess as positional arguments, and take `args` as\n        keyword arguments. It may additionally take `full_output`\n        and/or `disp` as keyword arguments. Use None if no \"polishing\"\n        function is to be used. See Notes for more details.\n    disp : bool, optional\n        Set to True to print convergence messages from the `finish` callable.\n    workers : int or map-like callable, optional\n        If `workers` is an int the grid is subdivided into `workers`\n        sections and evaluated in parallel (uses\n        `multiprocessing.Pool <multiprocessing>`).\n        Supply `-1` to use all cores available to the Process.\n        Alternatively supply a map-like callable, such as\n        `multiprocessing.Pool.map` for evaluating the grid in parallel.\n        This evaluation is carried out as ``workers(func, iterable)``.\n        Requires that `func` be pickleable.\n\n        .. versionadded:: 1.3.0\n\n    Returns\n    -------\n    x0 : ndarray\n        A 1-D array containing the coordinates of a point at which the\n        objective function had its minimum value. (See `Note 1` for\n        which point is returned.)\n    fval : float\n        Function value at the point `x0`. (Returned when `full_output` is\n        True.)\n    grid : tuple\n        Representation of the evaluation grid. It has the same\n        length as `x0`. (Returned when `full_output` is True.)\n    Jout : ndarray\n        Function values at each point of the evaluation\n        grid, i.e., ``Jout = func(*grid)``. (Returned\n        when `full_output` is True.)\n\n    See Also\n    --------\n    basinhopping, differential_evolution\n\n    Notes\n    -----\n    *Note 1*: The program finds the gridpoint at which the lowest value\n    of the objective function occurs. If `finish` is None, that is the\n    point returned. When the global minimum occurs within (or not very far\n    outside) the grid's boundaries, and the grid is fine enough, that\n    point will be in the neighborhood of the global minimum.\n\n    However, users often employ some other optimization program to\n    \"polish\" the gridpoint values, i.e., to seek a more precise\n    (local) minimum near `brute's` best gridpoint.\n    The `brute` function's `finish` option provides a convenient way to do\n    that. Any polishing program used must take `brute's` output as its\n    initial guess as a positional argument, and take `brute's` input values\n    for `args` as keyword arguments, otherwise an error will be raised.\n    It may additionally take `full_output` and/or `disp` as keyword arguments.\n\n    `brute` assumes that the `finish` function returns either an\n    `OptimizeResult` object or a tuple in the form:\n    ``(xmin, Jmin, ... , statuscode)``, where ``xmin`` is the minimizing\n    value of the argument, ``Jmin`` is the minimum value of the objective\n    function, \"...\" may be some other returned values (which are not used\n    by `brute`), and ``statuscode`` is the status code of the `finish` program.\n\n    Note that when `finish` is not None, the values returned are those\n    of the `finish` program, *not* the gridpoint ones. Consequently,\n    while `brute` confines its search to the input grid points,\n    the `finish` program's results usually will not coincide with any\n    gridpoint, and may fall outside the grid's boundary. Thus, if a\n    minimum only needs to be found over the provided grid points, make\n    sure to pass in ``finish=None``.\n\n    *Note 2*: The grid of points is a `numpy.mgrid` object.\n    For `brute` the `ranges` and `Ns` inputs have the following effect.\n    Each component of the `ranges` tuple can be either a slice object or a\n    two-tuple giving a range of values, such as (0, 5). If the component is a\n    slice object, `brute` uses it directly. If the component is a two-tuple\n    range, `brute` internally converts it to a slice object that interpolates\n    `Ns` points from its low-value to its high-value, inclusive.\n\n    Examples\n    --------\n    We illustrate the use of `brute` to seek the global minimum of a function\n    of two variables that is given as the sum of a positive-definite\n    quadratic and two deep \"Gaussian-shaped\" craters. Specifically, define\n    the objective function `f` as the sum of three other functions,\n    ``f = f1 + f2 + f3``. We suppose each of these has a signature\n    ``(z, *params)``, where ``z = (x, y)``,  and ``params`` and the functions\n    are as defined below.\n\n    >>> import numpy as np\n    >>> params = (2, 3, 7, 8, 9, 10, 44, -1, 2, 26, 1, -2, 0.5)\n    >>> def f1(z, *params):\n    ...     x, y = z\n    ...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params\n    ...     return (a * x**2 + b * x * y + c * y**2 + d*x + e*y + f)\n\n    >>> def f2(z, *params):\n    ...     x, y = z\n    ...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params\n    ...     return (-g*np.exp(-((x-h)**2 + (y-i)**2) / scale))\n\n    >>> def f3(z, *params):\n    ...     x, y = z\n    ...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params\n    ...     return (-j*np.exp(-((x-k)**2 + (y-l)**2) / scale))\n\n    >>> def f(z, *params):\n    ...     return f1(z, *params) + f2(z, *params) + f3(z, *params)\n\n    Thus, the objective function may have local minima near the minimum\n    of each of the three functions of which it is composed. To\n    use `fmin` to polish its gridpoint result, we may then continue as\n    follows:\n\n    >>> rranges = (slice(-4, 4, 0.25), slice(-4, 4, 0.25))\n    >>> from scipy import optimize\n    >>> resbrute = optimize.brute(f, rranges, args=params, full_output=True,\n    ...                           finish=optimize.fmin)\n    >>> resbrute[0]  # global minimum\n    array([-1.05665192,  1.80834843])\n    >>> resbrute[1]  # function value at global minimum\n    -3.4085818767\n\n    Note that if `finish` had been set to None, we would have gotten the\n    gridpoint [-1.0 1.75] where the rounded function value is -2.892.\n\n    \"\"\"\n    N = len(ranges)\n    if N > 40:\n        raise ValueError(\"Brute Force not possible with more \"\n                         \"than 40 variables.\")\n    lrange = list(ranges)\n    for k in range(N):\n        if not isinstance(lrange[k], slice):\n            if len(lrange[k]) < 3:\n                lrange[k] = tuple(lrange[k]) + (complex(Ns),)\n            lrange[k] = slice(*lrange[k])\n    if (N == 1):\n        lrange = lrange[0]\n\n    grid = np.mgrid[lrange]\n\n    # obtain an array of parameters that is iterable by a map-like callable\n    inpt_shape = grid.shape\n    if (N > 1):\n        grid = np.reshape(grid, (inpt_shape[0], np.prod(inpt_shape[1:]))).T\n\n    if not np.iterable(args):\n        args = (args,)\n\n    wrapped_func = _Brute_Wrapper(func, args)\n\n    # iterate over input arrays, possibly in parallel\n    with MapWrapper(pool=workers) as mapper:\n        Jout = np.array(list(mapper(wrapped_func, grid)))\n        if (N == 1):\n            grid = (grid,)\n            Jout = np.squeeze(Jout)\n        elif (N > 1):\n            Jout = np.reshape(Jout, inpt_shape[1:])\n            grid = np.reshape(grid.T, inpt_shape)\n\n    Nshape = shape(Jout)\n\n    indx = argmin(Jout.ravel(), axis=-1)\n    Nindx = np.empty(N, int)\n    xmin = np.empty(N, float)\n    for k in range(N - 1, -1, -1):\n        thisN = Nshape[k]\n        Nindx[k] = indx % Nshape[k]\n        indx = indx // thisN\n    for k in range(N):\n        xmin[k] = grid[k][tuple(Nindx)]\n\n    Jmin = Jout[tuple(Nindx)]\n    if (N == 1):\n        grid = grid[0]\n        xmin = xmin[0]\n\n    if callable(finish):\n        # set up kwargs for `finish` function\n        finish_args = _getfullargspec(finish).args\n        finish_kwargs = dict()\n        if 'full_output' in finish_args:\n            finish_kwargs['full_output'] = 1\n        if 'disp' in finish_args:\n            finish_kwargs['disp'] = disp\n        elif 'options' in finish_args:\n            # pass 'disp' as `options`\n            # (e.g., if `finish` is `minimize`)\n            finish_kwargs['options'] = {'disp': disp}\n\n        # run minimizer\n        res = finish(func, xmin, args=args, **finish_kwargs)\n\n        if isinstance(res, OptimizeResult):\n            xmin = res.x\n            Jmin = res.fun\n            success = res.success\n        else:\n            xmin = res[0]\n            Jmin = res[1]\n            success = res[-1] == 0\n        if not success:\n            if disp:\n                warnings.warn(\"Either final optimization did not succeed or `finish` \"\n                              \"does not return `statuscode` as its last argument.\",\n                              RuntimeWarning, stacklevel=2)\n\n    if full_output:\n        return xmin, Jmin, grid, Jout\n    else:\n        return xmin\n\n\nclass _Brute_Wrapper:\n    \"\"\"\n    Object to wrap user cost function for optimize.brute, allowing picklability\n    \"\"\"\n\n    def __init__(self, f, args):\n        self.f = f\n        self.args = [] if args is None else args\n\n    def __call__(self, x):\n        # flatten needed for one dimensional case.\n        return self.f(np.asarray(x).flatten(), *self.args)\n\n\ndef show_options(solver=None, method=None, disp=True):\n    \"\"\"\n    Show documentation for additional options of optimization solvers.\n\n    These are method-specific options that can be supplied through the\n    ``options`` dict.\n\n    Parameters\n    ----------\n    solver : str\n        Type of optimization solver. One of 'minimize', 'minimize_scalar',\n        'root', 'root_scalar', 'linprog', or 'quadratic_assignment'.\n    method : str, optional\n        If not given, shows all methods of the specified solver. Otherwise,\n        show only the options for the specified method. Valid values\n        corresponds to methods' names of respective solver (e.g., 'BFGS' for\n        'minimize').\n    disp : bool, optional\n        Whether to print the result rather than returning it.\n\n    Returns\n    -------\n    text\n        Either None (for disp=True) or the text string (disp=False)\n\n    Notes\n    -----\n    The solver-specific methods are:\n\n    `scipy.optimize.minimize`\n\n    - :ref:`Nelder-Mead <optimize.minimize-neldermead>`\n    - :ref:`Powell      <optimize.minimize-powell>`\n    - :ref:`CG          <optimize.minimize-cg>`\n    - :ref:`BFGS        <optimize.minimize-bfgs>`\n    - :ref:`Newton-CG   <optimize.minimize-newtoncg>`\n    - :ref:`L-BFGS-B    <optimize.minimize-lbfgsb>`\n    - :ref:`TNC         <optimize.minimize-tnc>`\n    - :ref:`COBYLA      <optimize.minimize-cobyla>`\n    - :ref:`COBYQA      <optimize.minimize-cobyqa>`\n    - :ref:`SLSQP       <optimize.minimize-slsqp>`\n    - :ref:`dogleg      <optimize.minimize-dogleg>`\n    - :ref:`trust-ncg   <optimize.minimize-trustncg>`\n\n    `scipy.optimize.root`\n\n    - :ref:`hybr              <optimize.root-hybr>`\n    - :ref:`lm                <optimize.root-lm>`\n    - :ref:`broyden1          <optimize.root-broyden1>`\n    - :ref:`broyden2          <optimize.root-broyden2>`\n    - :ref:`anderson          <optimize.root-anderson>`\n    - :ref:`linearmixing      <optimize.root-linearmixing>`\n    - :ref:`diagbroyden       <optimize.root-diagbroyden>`\n    - :ref:`excitingmixing    <optimize.root-excitingmixing>`\n    - :ref:`krylov            <optimize.root-krylov>`\n    - :ref:`df-sane           <optimize.root-dfsane>`\n\n    `scipy.optimize.minimize_scalar`\n\n    - :ref:`brent       <optimize.minimize_scalar-brent>`\n    - :ref:`golden      <optimize.minimize_scalar-golden>`\n    - :ref:`bounded     <optimize.minimize_scalar-bounded>`\n\n    `scipy.optimize.root_scalar`\n\n    - :ref:`bisect  <optimize.root_scalar-bisect>`\n    - :ref:`brentq  <optimize.root_scalar-brentq>`\n    - :ref:`brenth  <optimize.root_scalar-brenth>`\n    - :ref:`ridder  <optimize.root_scalar-ridder>`\n    - :ref:`toms748 <optimize.root_scalar-toms748>`\n    - :ref:`newton  <optimize.root_scalar-newton>`\n    - :ref:`secant  <optimize.root_scalar-secant>`\n    - :ref:`halley  <optimize.root_scalar-halley>`\n\n    `scipy.optimize.linprog`\n\n    - :ref:`simplex           <optimize.linprog-simplex>`\n    - :ref:`interior-point    <optimize.linprog-interior-point>`\n    - :ref:`revised simplex   <optimize.linprog-revised_simplex>`\n    - :ref:`highs             <optimize.linprog-highs>`\n    - :ref:`highs-ds          <optimize.linprog-highs-ds>`\n    - :ref:`highs-ipm         <optimize.linprog-highs-ipm>`\n\n    `scipy.optimize.quadratic_assignment`\n\n    - :ref:`faq             <optimize.qap-faq>`\n    - :ref:`2opt            <optimize.qap-2opt>`\n\n    Examples\n    --------\n    We can print documentations of a solver in stdout:\n\n    >>> from scipy.optimize import show_options\n    >>> show_options(solver=\"minimize\")\n    ...\n\n    Specifying a method is possible:\n\n    >>> show_options(solver=\"minimize\", method=\"Nelder-Mead\")\n    ...\n\n    We can also get the documentations as a string:\n\n    >>> show_options(solver=\"minimize\", method=\"Nelder-Mead\", disp=False)\n    Minimization of scalar function of one or more variables using the ...\n\n    \"\"\"\n    import textwrap\n\n    doc_routines = {\n        'minimize': (\n            ('bfgs', 'scipy.optimize._optimize._minimize_bfgs'),\n            ('cg', 'scipy.optimize._optimize._minimize_cg'),\n            ('cobyla', 'scipy.optimize._cobyla_py._minimize_cobyla'),\n            ('cobyqa', 'scipy.optimize._cobyqa_py._minimize_cobyqa'),\n            ('dogleg', 'scipy.optimize._trustregion_dogleg._minimize_dogleg'),\n            ('l-bfgs-b', 'scipy.optimize._lbfgsb_py._minimize_lbfgsb'),\n            ('nelder-mead', 'scipy.optimize._optimize._minimize_neldermead'),\n            ('newton-cg', 'scipy.optimize._optimize._minimize_newtoncg'),\n            ('powell', 'scipy.optimize._optimize._minimize_powell'),\n            ('slsqp', 'scipy.optimize._slsqp_py._minimize_slsqp'),\n            ('tnc', 'scipy.optimize._tnc._minimize_tnc'),\n            ('trust-ncg',\n             'scipy.optimize._trustregion_ncg._minimize_trust_ncg'),\n            ('trust-constr',\n             'scipy.optimize._trustregion_constr.'\n             '_minimize_trustregion_constr'),\n            ('trust-exact',\n             'scipy.optimize._trustregion_exact._minimize_trustregion_exact'),\n            ('trust-krylov',\n             'scipy.optimize._trustregion_krylov._minimize_trust_krylov'),\n        ),\n        'root': (\n            ('hybr', 'scipy.optimize._minpack_py._root_hybr'),\n            ('lm', 'scipy.optimize._root._root_leastsq'),\n            ('broyden1', 'scipy.optimize._root._root_broyden1_doc'),\n            ('broyden2', 'scipy.optimize._root._root_broyden2_doc'),\n            ('anderson', 'scipy.optimize._root._root_anderson_doc'),\n            ('diagbroyden', 'scipy.optimize._root._root_diagbroyden_doc'),\n            ('excitingmixing', 'scipy.optimize._root._root_excitingmixing_doc'),\n            ('linearmixing', 'scipy.optimize._root._root_linearmixing_doc'),\n            ('krylov', 'scipy.optimize._root._root_krylov_doc'),\n            ('df-sane', 'scipy.optimize._spectral._root_df_sane'),\n        ),\n        'root_scalar': (\n            ('bisect', 'scipy.optimize._root_scalar._root_scalar_bisect_doc'),\n            ('brentq', 'scipy.optimize._root_scalar._root_scalar_brentq_doc'),\n            ('brenth', 'scipy.optimize._root_scalar._root_scalar_brenth_doc'),\n            ('ridder', 'scipy.optimize._root_scalar._root_scalar_ridder_doc'),\n            ('toms748', 'scipy.optimize._root_scalar._root_scalar_toms748_doc'),\n            ('secant', 'scipy.optimize._root_scalar._root_scalar_secant_doc'),\n            ('newton', 'scipy.optimize._root_scalar._root_scalar_newton_doc'),\n            ('halley', 'scipy.optimize._root_scalar._root_scalar_halley_doc'),\n        ),\n        'linprog': (\n            ('simplex', 'scipy.optimize._linprog._linprog_simplex_doc'),\n            ('interior-point', 'scipy.optimize._linprog._linprog_ip_doc'),\n            ('revised simplex', 'scipy.optimize._linprog._linprog_rs_doc'),\n            ('highs-ipm', 'scipy.optimize._linprog._linprog_highs_ipm_doc'),\n            ('highs-ds', 'scipy.optimize._linprog._linprog_highs_ds_doc'),\n            ('highs', 'scipy.optimize._linprog._linprog_highs_doc'),\n        ),\n        'quadratic_assignment': (\n            ('faq', 'scipy.optimize._qap._quadratic_assignment_faq'),\n            ('2opt', 'scipy.optimize._qap._quadratic_assignment_2opt'),\n        ),\n        'minimize_scalar': (\n            ('brent', 'scipy.optimize._optimize._minimize_scalar_brent'),\n            ('bounded', 'scipy.optimize._optimize._minimize_scalar_bounded'),\n            ('golden', 'scipy.optimize._optimize._minimize_scalar_golden'),\n        ),\n    }\n\n    if solver is None:\n        text = [\"\\n\\n\\n========\\n\", \"minimize\\n\", \"========\\n\"]\n        text.append(show_options('minimize', disp=False))\n        text.extend([\"\\n\\n===============\\n\", \"minimize_scalar\\n\",\n                     \"===============\\n\"])\n        text.append(show_options('minimize_scalar', disp=False))\n        text.extend([\"\\n\\n\\n====\\n\", \"root\\n\",\n                     \"====\\n\"])\n        text.append(show_options('root', disp=False))\n        text.extend(['\\n\\n\\n=======\\n', 'linprog\\n',\n                     '=======\\n'])\n        text.append(show_options('linprog', disp=False))\n        text = \"\".join(text)\n    else:\n        solver = solver.lower()\n        if solver not in doc_routines:\n            raise ValueError(f'Unknown solver {solver!r}')\n\n        if method is None:\n            text = []\n            for name, _ in doc_routines[solver]:\n                text.extend([\"\\n\\n\" + name, \"\\n\" + \"=\"*len(name) + \"\\n\\n\"])\n                text.append(show_options(solver, name, disp=False))\n            text = \"\".join(text)\n        else:\n            method = method.lower()\n            methods = dict(doc_routines[solver])\n            if method not in methods:\n                raise ValueError(f\"Unknown method {method!r}\")\n            name = methods[method]\n\n            # Import function object\n            parts = name.split('.')\n            mod_name = \".\".join(parts[:-1])\n            __import__(mod_name)\n            obj = getattr(sys.modules[mod_name], parts[-1])\n\n            # Get doc\n            doc = obj.__doc__\n            if doc is not None:\n                text = textwrap.dedent(doc).strip()\n            else:\n                text = \"\"\n\n    if disp:\n        print(text)\n        return\n    else:\n        return text\n", 4131], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py": ["\"\"\"Utility functions to use Python Array API compatible libraries.\n\nFor the context about the Array API see:\nhttps://data-apis.org/array-api/latest/purpose_and_scope.html\n\nThe SciPy use case of the Array API is described on the following page:\nhttps://data-apis.org/array-api/latest/use_cases.html#use-case-scipy\n\"\"\"\nimport os\n\nfrom types import ModuleType\nfrom typing import Any, Literal, TypeAlias\n\nimport numpy as np\nimport numpy.typing as npt\n\nfrom scipy._lib import array_api_compat\nfrom scipy._lib.array_api_compat import (\n    is_array_api_obj,\n    size as xp_size,\n    numpy as np_compat,\n    device as xp_device,\n    is_numpy_namespace as is_numpy,\n    is_cupy_namespace as is_cupy,\n    is_torch_namespace as is_torch,\n    is_jax_namespace as is_jax,\n    is_array_api_strict_namespace as is_array_api_strict\n)\n\n__all__ = [\n    '_asarray', 'array_namespace', 'assert_almost_equal', 'assert_array_almost_equal',\n    'get_xp_devices',\n    'is_array_api_strict', 'is_complex', 'is_cupy', 'is_jax', 'is_numpy', 'is_torch', \n    'SCIPY_ARRAY_API', 'SCIPY_DEVICE', 'scipy_namespace_for',\n    'xp_assert_close', 'xp_assert_equal', 'xp_assert_less',\n    'xp_copy', 'xp_copysign', 'xp_device',\n    'xp_moveaxis_to_end', 'xp_ravel', 'xp_real', 'xp_sign', 'xp_size',\n    'xp_take_along_axis', 'xp_unsupported_param_msg', 'xp_vector_norm',\n]\n\n\n# To enable array API and strict array-like input validation\nSCIPY_ARRAY_API: str | bool = os.environ.get(\"SCIPY_ARRAY_API\", False)\n# To control the default device - for use in the test suite only\nSCIPY_DEVICE = os.environ.get(\"SCIPY_DEVICE\", \"cpu\")\n\n_GLOBAL_CONFIG = {\n    \"SCIPY_ARRAY_API\": SCIPY_ARRAY_API,\n    \"SCIPY_DEVICE\": SCIPY_DEVICE,\n}\n\n\nArray: TypeAlias = Any  # To be changed to a Protocol later (see array-api#589)\nArrayLike: TypeAlias = Array | npt.ArrayLike\n\n\ndef _compliance_scipy(arrays):\n    \"\"\"Raise exceptions on known-bad subclasses.\n\n    The following subclasses are not supported and raise and error:\n    - `numpy.ma.MaskedArray`\n    - `numpy.matrix`\n    - NumPy arrays which do not have a boolean or numerical dtype\n    - Any array-like which is neither array API compatible nor coercible by NumPy\n    - Any array-like which is coerced by NumPy to an unsupported dtype\n    \"\"\"\n    for i in range(len(arrays)):\n        array = arrays[i]\n\n        from scipy.sparse import issparse\n        # this comes from `_util._asarray_validated`\n        if issparse(array):\n            msg = ('Sparse arrays/matrices are not supported by this function. '\n                   'Perhaps one of the `scipy.sparse.linalg` functions '\n                   'would work instead.')\n            raise ValueError(msg)\n\n        if isinstance(array, np.ma.MaskedArray):\n            raise TypeError(\"Inputs of type `numpy.ma.MaskedArray` are not supported.\")\n        elif isinstance(array, np.matrix):\n            raise TypeError(\"Inputs of type `numpy.matrix` are not supported.\")\n        if isinstance(array, np.ndarray | np.generic):\n            dtype = array.dtype\n            if not (np.issubdtype(dtype, np.number) or np.issubdtype(dtype, np.bool_)):\n                raise TypeError(f\"An argument has dtype `{dtype!r}`; \"\n                                f\"only boolean and numerical dtypes are supported.\")\n        elif not is_array_api_obj(array):\n            try:\n                array = np.asanyarray(array)\n            except TypeError:\n                raise TypeError(\"An argument is neither array API compatible nor \"\n                                \"coercible by NumPy.\")\n            dtype = array.dtype\n            if not (np.issubdtype(dtype, np.number) or np.issubdtype(dtype, np.bool_)):\n                message = (\n                    f\"An argument was coerced to an unsupported dtype `{dtype!r}`; \"\n                    f\"only boolean and numerical dtypes are supported.\"\n                )\n                raise TypeError(message)\n            arrays[i] = array\n    return arrays\n\n\ndef _check_finite(array: Array, xp: ModuleType) -> None:\n    \"\"\"Check for NaNs or Infs.\"\"\"\n    msg = \"array must not contain infs or NaNs\"\n    try:\n        if not xp.all(xp.isfinite(array)):\n            raise ValueError(msg)\n    except TypeError:\n        raise ValueError(msg)\n\n\ndef array_namespace(*arrays: Array) -> ModuleType:\n    \"\"\"Get the array API compatible namespace for the arrays xs.\n\n    Parameters\n    ----------\n    *arrays : sequence of array_like\n        Arrays used to infer the common namespace.\n\n    Returns\n    -------\n    namespace : module\n        Common namespace.\n\n    Notes\n    -----\n    Thin wrapper around `array_api_compat.array_namespace`.\n\n    1. Check for the global switch: SCIPY_ARRAY_API. This can also be accessed\n       dynamically through ``_GLOBAL_CONFIG['SCIPY_ARRAY_API']``.\n    2. `_compliance_scipy` raise exceptions on known-bad subclasses. See\n       its definition for more details.\n\n    When the global switch is False, it defaults to the `numpy` namespace.\n    In that case, there is no compliance check. This is a convenience to\n    ease the adoption. Otherwise, arrays must comply with the new rules.\n    \"\"\"\n    if not _GLOBAL_CONFIG[\"SCIPY_ARRAY_API\"]:\n        # here we could wrap the namespace if needed\n        return np_compat\n\n    _arrays = [array for array in arrays if array is not None]\n\n    _arrays = _compliance_scipy(_arrays)\n\n    return array_api_compat.array_namespace(*_arrays)\n\n\ndef _asarray(\n        array: ArrayLike,\n        dtype: Any = None,\n        order: Literal['K', 'A', 'C', 'F'] | None = None,\n        copy: bool | None = None,\n        *,\n        xp: ModuleType | None = None,\n        check_finite: bool = False,\n        subok: bool = False,\n    ) -> Array:\n    \"\"\"SciPy-specific replacement for `np.asarray` with `order`, `check_finite`, and\n    `subok`.\n\n    Memory layout parameter `order` is not exposed in the Array API standard.\n    `order` is only enforced if the input array implementation\n    is NumPy based, otherwise `order` is just silently ignored.\n\n    `check_finite` is also not a keyword in the array API standard; included\n    here for convenience rather than that having to be a separate function\n    call inside SciPy functions.\n\n    `subok` is included to allow this function to preserve the behaviour of\n    `np.asanyarray` for NumPy based inputs.\n    \"\"\"\n    if xp is None:\n        xp = array_namespace(array)\n    if is_numpy(xp):\n        # Use NumPy API to support order\n        if copy is True:\n            array = np.array(array, order=order, dtype=dtype, subok=subok)\n        elif subok:\n            array = np.asanyarray(array, order=order, dtype=dtype)\n        else:\n            array = np.asarray(array, order=order, dtype=dtype)\n    else:\n        try:\n            array = xp.asarray(array, dtype=dtype, copy=copy)\n        except TypeError:\n            coerced_xp = array_namespace(xp.asarray(3))\n            array = coerced_xp.asarray(array, dtype=dtype, copy=copy)\n\n    if check_finite:\n        _check_finite(array, xp)\n\n    return array\n\n\ndef xp_copy(x: Array, *, xp: ModuleType | None = None) -> Array:\n    \"\"\"\n    Copies an array.\n\n    Parameters\n    ----------\n    x : array\n\n    xp : array_namespace\n\n    Returns\n    -------\n    copy : array\n        Copied array\n\n    Notes\n    -----\n    This copy function does not offer all the semantics of `np.copy`, i.e. the\n    `subok` and `order` keywords are not used.\n    \"\"\"\n    # Note: for older NumPy versions, `np.asarray` did not support the `copy` kwarg,\n    # so this uses our other helper `_asarray`.\n    if xp is None:\n        xp = array_namespace(x)\n\n    return _asarray(x, copy=True, xp=xp)\n\n\ndef _strict_check(actual, desired, xp, *,\n                  check_namespace=True, check_dtype=True, check_shape=True,\n                  check_0d=True):\n    __tracebackhide__ = True  # Hide traceback for py.test\n    if check_namespace:\n        _assert_matching_namespace(actual, desired)\n\n    # only NumPy distinguishes between scalars and arrays; we do if check_0d=True.\n    # do this first so we can then cast to array (and thus use the array API) below.\n    if is_numpy(xp) and check_0d:\n        _msg = (\"Array-ness does not match:\\n Actual: \"\n                f\"{type(actual)}\\n Desired: {type(desired)}\")\n        assert ((xp.isscalar(actual) and xp.isscalar(desired))\n                or (not xp.isscalar(actual) and not xp.isscalar(desired))), _msg\n\n    actual = xp.asarray(actual)\n    desired = xp.asarray(desired)\n\n    if check_dtype:\n        _msg = f\"dtypes do not match.\\nActual: {actual.dtype}\\nDesired: {desired.dtype}\"\n        assert actual.dtype == desired.dtype, _msg\n\n    if check_shape:\n        _msg = f\"Shapes do not match.\\nActual: {actual.shape}\\nDesired: {desired.shape}\"\n        assert actual.shape == desired.shape, _msg\n\n    desired = xp.broadcast_to(desired, actual.shape)\n    return actual, desired\n\n\ndef _assert_matching_namespace(actual, desired):\n    __tracebackhide__ = True  # Hide traceback for py.test\n    actual = actual if isinstance(actual, tuple) else (actual,)\n    desired_space = array_namespace(desired)\n    for arr in actual:\n        arr_space = array_namespace(arr)\n        _msg = (f\"Namespaces do not match.\\n\"\n                f\"Actual: {arr_space.__name__}\\n\"\n                f\"Desired: {desired_space.__name__}\")\n        assert arr_space == desired_space, _msg\n\n\ndef xp_assert_equal(actual, desired, *, check_namespace=True, check_dtype=True,\n                    check_shape=True, check_0d=True, err_msg='', xp=None):\n    __tracebackhide__ = True  # Hide traceback for py.test\n    if xp is None:\n        xp = array_namespace(actual)\n\n    actual, desired = _strict_check(\n        actual, desired, xp, check_namespace=check_namespace,\n        check_dtype=check_dtype, check_shape=check_shape,\n        check_0d=check_0d\n    )\n\n    if is_cupy(xp):\n        return xp.testing.assert_array_equal(actual, desired, err_msg=err_msg)\n    elif is_torch(xp):\n        # PyTorch recommends using `rtol=0, atol=0` like this\n        # to test for exact equality\n        err_msg = None if err_msg == '' else err_msg\n        return xp.testing.assert_close(actual, desired, rtol=0, atol=0, equal_nan=True,\n                                       check_dtype=False, msg=err_msg)\n    # JAX uses `np.testing`\n    return np.testing.assert_array_equal(actual, desired, err_msg=err_msg)\n\n\ndef xp_assert_close(actual, desired, *, rtol=None, atol=0, check_namespace=True,\n                    check_dtype=True, check_shape=True, check_0d=True,\n                    err_msg='', xp=None):\n    __tracebackhide__ = True  # Hide traceback for py.test\n    if xp is None:\n        xp = array_namespace(actual)\n\n    actual, desired = _strict_check(\n        actual, desired, xp,\n        check_namespace=check_namespace, check_dtype=check_dtype,\n        check_shape=check_shape, check_0d=check_0d\n    )\n\n    floating = xp.isdtype(actual.dtype, ('real floating', 'complex floating'))\n    if rtol is None and floating:\n        # multiplier of 4 is used as for `np.float64` this puts the default `rtol`\n        # roughly half way between sqrt(eps) and the default for\n        # `numpy.testing.assert_allclose`, 1e-7\n        rtol = xp.finfo(actual.dtype).eps**0.5 * 4\n    elif rtol is None:\n        rtol = 1e-7\n\n    if is_cupy(xp):\n        return xp.testing.assert_allclose(actual, desired, rtol=rtol,\n                                          atol=atol, err_msg=err_msg)\n    elif is_torch(xp):\n        err_msg = None if err_msg == '' else err_msg\n        return xp.testing.assert_close(actual, desired, rtol=rtol, atol=atol,\n                                       equal_nan=True, check_dtype=False, msg=err_msg)\n    # JAX uses `np.testing`\n    return np.testing.assert_allclose(actual, desired, rtol=rtol,\n                                      atol=atol, err_msg=err_msg)\n\n\ndef xp_assert_less(actual, desired, *, check_namespace=True, check_dtype=True,\n                   check_shape=True, check_0d=True, err_msg='', verbose=True, xp=None):\n    __tracebackhide__ = True  # Hide traceback for py.test\n    if xp is None:\n        xp = array_namespace(actual)\n\n    actual, desired = _strict_check(\n        actual, desired, xp, check_namespace=check_namespace,\n        check_dtype=check_dtype, check_shape=check_shape,\n        check_0d=check_0d\n    )\n\n    if is_cupy(xp):\n        return xp.testing.assert_array_less(actual, desired,\n                                            err_msg=err_msg, verbose=verbose)\n    elif is_torch(xp):\n        if actual.device.type != 'cpu':\n            actual = actual.cpu()\n        if desired.device.type != 'cpu':\n            desired = desired.cpu()\n    # JAX uses `np.testing`\n    return np.testing.assert_array_less(actual, desired,\n                                        err_msg=err_msg, verbose=verbose)\n\n\ndef assert_array_almost_equal(actual, desired, decimal=6, *args, **kwds):\n    \"\"\"Backwards compatible replacement. In new code, use xp_assert_close instead.\n    \"\"\"\n    rtol, atol = 0, 1.5*10**(-decimal)\n    return xp_assert_close(actual, desired,\n                           atol=atol, rtol=rtol, check_dtype=False, check_shape=False,\n                           *args, **kwds)\n\n\ndef assert_almost_equal(actual, desired, decimal=7, *args, **kwds):\n    \"\"\"Backwards compatible replacement. In new code, use xp_assert_close instead.\n    \"\"\"\n    rtol, atol = 0, 1.5*10**(-decimal)\n    return xp_assert_close(actual, desired,\n                           atol=atol, rtol=rtol, check_dtype=False, check_shape=False,\n                           *args, **kwds)\n\n\ndef xp_unsupported_param_msg(param: Any) -> str:\n    return f'Providing {param!r} is only supported for numpy arrays.'\n\n\ndef is_complex(x: Array, xp: ModuleType) -> bool:\n    return xp.isdtype(x.dtype, 'complex floating')\n\n\ndef get_xp_devices(xp: ModuleType) -> list[str] | list[None]:\n    \"\"\"Returns a list of available devices for the given namespace.\"\"\"\n    devices: list[str] = []\n    if is_torch(xp):\n        devices += ['cpu']\n        import torch # type: ignore[import]\n        num_cuda = torch.cuda.device_count()\n        for i in range(0, num_cuda):\n            devices += [f'cuda:{i}']\n        if torch.backends.mps.is_available():\n            devices += ['mps']\n        return devices\n    elif is_cupy(xp):\n        import cupy # type: ignore[import]\n        num_cuda = cupy.cuda.runtime.getDeviceCount()\n        for i in range(0, num_cuda):\n            devices += [f'cuda:{i}']\n        return devices\n    elif is_jax(xp):\n        import jax # type: ignore[import]\n        num_cpu = jax.device_count(backend='cpu')\n        for i in range(0, num_cpu):\n            devices += [f'cpu:{i}']\n        num_gpu = jax.device_count(backend='gpu')\n        for i in range(0, num_gpu):\n            devices += [f'gpu:{i}']\n        num_tpu = jax.device_count(backend='tpu')\n        for i in range(0, num_tpu):\n            devices += [f'tpu:{i}']\n        return devices\n\n    # given namespace is not known to have a list of available devices;\n    # return `[None]` so that one can use this in tests for `device=None`.\n    return [None]\n\n\ndef scipy_namespace_for(xp: ModuleType) -> ModuleType | None:\n    \"\"\"Return the `scipy`-like namespace of a non-NumPy backend\n\n    That is, return the namespace corresponding with backend `xp` that contains\n    `scipy` sub-namespaces like `linalg` and `special`. If no such namespace\n    exists, return ``None``. Useful for dispatching.\n    \"\"\"\n\n    if is_cupy(xp):\n        import cupyx  # type: ignore[import-not-found,import-untyped]\n        return cupyx.scipy\n\n    if is_jax(xp):\n        import jax  # type: ignore[import-not-found]\n        return jax.scipy\n\n    if is_torch(xp):\n        return xp\n\n    return None\n\n\n# temporary substitute for xp.moveaxis, which is not yet in all backends\n# or covered by array_api_compat.\ndef xp_moveaxis_to_end(\n        x: Array,\n        source: int,\n        /, *,\n        xp: ModuleType | None = None) -> Array:\n    xp = array_namespace(xp) if xp is None else xp\n    axes = list(range(x.ndim))\n    temp = axes.pop(source)\n    axes = axes + [temp]\n    return xp.permute_dims(x, axes)\n\n\n# temporary substitute for xp.copysign, which is not yet in all backends\n# or covered by array_api_compat.\ndef xp_copysign(x1: Array, x2: Array, /, *, xp: ModuleType | None = None) -> Array:\n    # no attempt to account for special cases\n    xp = array_namespace(x1, x2) if xp is None else xp\n    abs_x1 = xp.abs(x1)\n    return xp.where(x2 >= 0, abs_x1, -abs_x1)\n\n\n# partial substitute for xp.sign, which does not cover the NaN special case\n# that I need. (https://github.com/data-apis/array-api-compat/issues/136)\ndef xp_sign(x: Array, /, *, xp: ModuleType | None = None) -> Array:\n    xp = array_namespace(x) if xp is None else xp\n    if is_numpy(xp):  # only NumPy implements the special cases correctly\n        return xp.sign(x)\n    sign = xp.zeros_like(x)\n    one = xp.asarray(1, dtype=x.dtype)\n    sign = xp.where(x > 0, one, sign)\n    sign = xp.where(x < 0, -one, sign)\n    sign = xp.where(xp.isnan(x), xp.nan*one, sign)\n    return sign\n\n# maybe use `scipy.linalg` if/when array API support is added\ndef xp_vector_norm(x: Array, /, *,\n                   axis: int | tuple[int] | None = None,\n                   keepdims: bool = False,\n                   ord: int | float = 2,\n                   xp: ModuleType | None = None) -> Array:\n    xp = array_namespace(x) if xp is None else xp\n\n    if SCIPY_ARRAY_API:\n        # check for optional `linalg` extension\n        if hasattr(xp, 'linalg'):\n            return xp.linalg.vector_norm(x, axis=axis, keepdims=keepdims, ord=ord)\n        else:\n            if ord != 2:\n                raise ValueError(\n                    \"only the Euclidean norm (`ord=2`) is currently supported in \"\n                    \"`xp_vector_norm` for backends not implementing the `linalg` \"\n                    \"extension.\"\n                )\n            # return (x @ x)**0.5\n            # or to get the right behavior with nd, complex arrays\n            return xp.sum(xp.conj(x) * x, axis=axis, keepdims=keepdims)**0.5\n    else:\n        # to maintain backwards compatibility\n        return np.linalg.norm(x, ord=ord, axis=axis, keepdims=keepdims)\n\n\ndef xp_ravel(x: Array, /, *, xp: ModuleType | None = None) -> Array:\n    # Equivalent of np.ravel written in terms of array API\n    # Even though it's one line, it comes up so often that it's worth having\n    # this function for readability\n    xp = array_namespace(x) if xp is None else xp\n    return xp.reshape(x, (-1,))\n\n\ndef xp_real(x: Array, /, *, xp: ModuleType | None = None) -> Array:\n    # Convenience wrapper of xp.real that allows non-complex input;\n    # see data-apis/array-api#824\n    xp = array_namespace(x) if xp is None else xp\n    return xp.real(x) if xp.isdtype(x.dtype, 'complex floating') else x\n\n\ndef xp_take_along_axis(arr: Array,\n                       indices: Array, /, *,\n                       axis: int = -1,\n                       xp: ModuleType | None = None) -> Array:\n    # Dispatcher for np.take_along_axis for backends that support it;\n    # see data-apis/array-api/pull#816\n    xp = array_namespace(arr) if xp is None else xp\n    if is_torch(xp):\n        return xp.take_along_dim(arr, indices, dim=axis)\n    elif is_array_api_strict(xp):\n        raise NotImplementedError(\"Array API standard does not define take_along_axis\")\n    else:\n        return xp.take_along_axis(arr, indices, axis)\n\n\n# utility to broadcast arrays and promote to common dtype\ndef xp_broadcast_promote(*args, ensure_writeable=False, force_floating=False, xp=None):\n    xp = array_namespace(*args) if xp is None else xp\n\n    args = [(_asarray(arg, subok=True) if arg is not None else arg) for arg in args]\n    args_not_none = [arg for arg in args if arg is not None]\n\n    # determine minimum dtype\n    default_float = xp.asarray(1.).dtype\n    dtypes = [arg.dtype for arg in args_not_none]\n    try:  # follow library's prefered mixed promotion rules\n        dtype = xp.result_type(*dtypes)\n        if force_floating and xp.isdtype(dtype, 'integral'):\n            # If we were to add `default_float` before checking whether the result\n            # type is otherwise integral, we risk promotion from lower float.\n            dtype = xp.result_type(dtype, default_float)\n    except TypeError:  # mixed type promotion isn't defined\n        float_dtypes = [dtype for dtype in dtypes\n                        if not xp.isdtype(dtype, 'integral')]\n        if float_dtypes:\n            dtype = xp.result_type(*float_dtypes, default_float)\n        elif force_floating:\n            dtype = default_float\n        else:\n            dtype = xp.result_type(*dtypes)\n\n    # determine result shape\n    shapes = {arg.shape for arg in args_not_none}\n    try:\n        shape = (np.broadcast_shapes(*shapes) if len(shapes) != 1\n                 else args_not_none[0].shape)\n    except ValueError as e:\n        message = \"Array shapes are incompatible for broadcasting.\"\n        raise ValueError(message) from e\n\n    out = []\n    for arg in args:\n        if arg is None:\n            out.append(arg)\n            continue\n\n        # broadcast only if needed\n        # Even if two arguments need broadcasting, this is faster than\n        # `broadcast_arrays`, especially since we've already determined `shape`\n        if arg.shape != shape:\n            kwargs = {'subok': True} if is_numpy(xp) else {}\n            arg = xp.broadcast_to(arg, shape, **kwargs)\n\n        # convert dtype/copy only if needed\n        if (arg.dtype != dtype) or ensure_writeable:\n            arg = xp.astype(arg, dtype, copy=True)\n        out.append(arg)\n\n    return out\n\n\ndef xp_float_to_complex(arr: Array, xp: ModuleType | None = None) -> Array:\n    xp = array_namespace(arr) if xp is None else xp\n    arr_dtype = arr.dtype\n    # The standard float dtypes are float32 and float64.\n    # Convert float32 to complex64,\n    # and float64 (and non-standard real dtypes) to complex128\n    if xp.isdtype(arr_dtype, xp.float32):\n        arr = xp.astype(arr, xp.complex64)\n    elif xp.isdtype(arr_dtype, 'real floating'):\n        arr = xp.astype(arr, xp.complex128)\n\n    return arr\n\n\ndef xp_default_dtype(xp):\n    \"\"\"Query the namespace-dependent default floating-point dtype.\n    \"\"\"\n    if is_torch(xp):\n        # historically, we allow pytorch to keep its default of float32\n        return xp.get_default_dtype()\n    else:\n        # we default to float64\n        return xp.float64\n", 606], "/usr/lib/python3.11/enum.py": ["import sys\nimport builtins as bltns\nfrom types import MappingProxyType, DynamicClassAttribute\nfrom operator import or_ as _or_\nfrom functools import reduce\n\n\n__all__ = [\n        'EnumType', 'EnumMeta',\n        'Enum', 'IntEnum', 'StrEnum', 'Flag', 'IntFlag', 'ReprEnum',\n        'auto', 'unique', 'property', 'verify', 'member', 'nonmember',\n        'FlagBoundary', 'STRICT', 'CONFORM', 'EJECT', 'KEEP',\n        'global_flag_repr', 'global_enum_repr', 'global_str', 'global_enum',\n        'EnumCheck', 'CONTINUOUS', 'NAMED_FLAGS', 'UNIQUE',\n        'pickle_by_global_name', 'pickle_by_enum_name',\n        ]\n\n\n# Dummy value for Enum and Flag as there are explicit checks for them\n# before they have been created.\n# This is also why there are checks in EnumType like `if Enum is not None`\nEnum = Flag = EJECT = _stdlib_enums = ReprEnum = None\n\nclass nonmember(object):\n    \"\"\"\n    Protects item from becoming an Enum member during class creation.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n\nclass member(object):\n    \"\"\"\n    Forces item to become an Enum member during class creation.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n\ndef _is_descriptor(obj):\n    \"\"\"\n    Returns True if obj is a descriptor, False otherwise.\n    \"\"\"\n    return (\n            hasattr(obj, '__get__') or\n            hasattr(obj, '__set__') or\n            hasattr(obj, '__delete__')\n            )\n\ndef _is_dunder(name):\n    \"\"\"\n    Returns True if a __dunder__ name, False otherwise.\n    \"\"\"\n    return (\n            len(name) > 4 and\n            name[:2] == name[-2:] == '__' and\n            name[2] != '_' and\n            name[-3] != '_'\n            )\n\ndef _is_sunder(name):\n    \"\"\"\n    Returns True if a _sunder_ name, False otherwise.\n    \"\"\"\n    return (\n            len(name) > 2 and\n            name[0] == name[-1] == '_' and\n            name[1:2] != '_' and\n            name[-2:-1] != '_'\n            )\n\ndef _is_internal_class(cls_name, obj):\n    # do not use `re` as `re` imports `enum`\n    if not isinstance(obj, type):\n        return False\n    qualname = getattr(obj, '__qualname__', '')\n    s_pattern = cls_name + '.' + getattr(obj, '__name__', '')\n    e_pattern = '.' + s_pattern\n    return qualname == s_pattern or qualname.endswith(e_pattern)\n\ndef _is_private(cls_name, name):\n    # do not use `re` as `re` imports `enum`\n    pattern = '_%s__' % (cls_name, )\n    pat_len = len(pattern)\n    if (\n            len(name) > pat_len\n            and name.startswith(pattern)\n            and name[pat_len:pat_len+1] != ['_']\n            and (name[-1] != '_' or name[-2] != '_')\n        ):\n        return True\n    else:\n        return False\n\ndef _is_single_bit(num):\n    \"\"\"\n    True if only one bit set in num (should be an int)\n    \"\"\"\n    if num == 0:\n        return False\n    num &= num - 1\n    return num == 0\n\ndef _make_class_unpicklable(obj):\n    \"\"\"\n    Make the given obj un-picklable.\n\n    obj should be either a dictionary, or an Enum\n    \"\"\"\n    def _break_on_call_reduce(self, proto):\n        raise TypeError('%r cannot be pickled' % self)\n    if isinstance(obj, dict):\n        obj['__reduce_ex__'] = _break_on_call_reduce\n        obj['__module__'] = '<unknown>'\n    else:\n        setattr(obj, '__reduce_ex__', _break_on_call_reduce)\n        setattr(obj, '__module__', '<unknown>')\n\ndef _iter_bits_lsb(num):\n    # num must be a positive integer\n    original = num\n    if isinstance(num, Enum):\n        num = num.value\n    if num < 0:\n        raise ValueError('%r is not a positive integer' % original)\n    while num:\n        b = num & (~num + 1)\n        yield b\n        num ^= b\n\ndef show_flag_values(value):\n    return list(_iter_bits_lsb(value))\n\ndef bin(num, max_bits=None):\n    \"\"\"\n    Like built-in bin(), except negative values are represented in\n    twos-compliment, and the leading bit always indicates sign\n    (0=positive, 1=negative).\n\n    >>> bin(10)\n    '0b0 1010'\n    >>> bin(~10)   # ~10 is -11\n    '0b1 0101'\n    \"\"\"\n\n    ceiling = 2 ** (num).bit_length()\n    if num >= 0:\n        s = bltns.bin(num + ceiling).replace('1', '0', 1)\n    else:\n        s = bltns.bin(~num ^ (ceiling - 1) + ceiling)\n    sign = s[:3]\n    digits = s[3:]\n    if max_bits is not None:\n        if len(digits) < max_bits:\n            digits = (sign[-1] * max_bits + digits)[-max_bits:]\n    return \"%s %s\" % (sign, digits)\n\ndef _dedent(text):\n    \"\"\"\n    Like textwrap.dedent.  Rewritten because we cannot import textwrap.\n    \"\"\"\n    lines = text.split('\\n')\n    blanks = 0\n    for i, ch in enumerate(lines[0]):\n        if ch != ' ':\n            break\n    for j, l in enumerate(lines):\n        lines[j] = l[i:]\n    return '\\n'.join(lines)\n\nclass _auto_null:\n    def __repr__(self):\n        return '_auto_null'\n_auto_null = _auto_null()\n\nclass auto:\n    \"\"\"\n    Instances are replaced with an appropriate value in Enum class suites.\n    \"\"\"\n    def __init__(self, value=_auto_null):\n        self.value = value\n\n    def __repr__(self):\n        return \"auto(%r)\" % self.value\n\nclass property(DynamicClassAttribute):\n    \"\"\"\n    This is a descriptor, used to define attributes that act differently\n    when accessed through an enum member and through an enum class.\n    Instance access is the same as property(), but access to an attribute\n    through the enum class will instead look in the class' _member_map_ for\n    a corresponding enum member.\n    \"\"\"\n\n    def __get__(self, instance, ownerclass=None):\n        if instance is None:\n            try:\n                return ownerclass._member_map_[self.name]\n            except KeyError:\n                raise AttributeError(\n                        '%r has no attribute %r' % (ownerclass, self.name)\n                        )\n        else:\n            if self.fget is None:\n                # look for a member by this name.\n                try:\n                    return ownerclass._member_map_[self.name]\n                except KeyError:\n                    raise AttributeError(\n                            '%r has no attribute %r' % (ownerclass, self.name)\n                            ) from None\n            else:\n                return self.fget(instance)\n\n    def __set__(self, instance, value):\n        if self.fset is None:\n            raise AttributeError(\n                    \"<enum %r> cannot set attribute %r\" % (self.clsname, self.name)\n                    )\n        else:\n            return self.fset(instance, value)\n\n    def __delete__(self, instance):\n        if self.fdel is None:\n            raise AttributeError(\n                    \"<enum %r> cannot delete attribute %r\" % (self.clsname, self.name)\n                    )\n        else:\n            return self.fdel(instance)\n\n    def __set_name__(self, ownerclass, name):\n        self.name = name\n        self.clsname = ownerclass.__name__\n\n\nclass _proto_member:\n    \"\"\"\n    intermediate step for enum members between class execution and final creation\n    \"\"\"\n\n    def __init__(self, value):\n        self.value = value\n\n    def __set_name__(self, enum_class, member_name):\n        \"\"\"\n        convert each quasi-member into an instance of the new enum class\n        \"\"\"\n        # first step: remove ourself from enum_class\n        delattr(enum_class, member_name)\n        # second step: create member based on enum_class\n        value = self.value\n        if not isinstance(value, tuple):\n            args = (value, )\n        else:\n            args = value\n        if enum_class._member_type_ is tuple:   # special case for tuple enums\n            args = (args, )     # wrap it one more time\n        if not enum_class._use_args_:\n            enum_member = enum_class._new_member_(enum_class)\n        else:\n            enum_member = enum_class._new_member_(enum_class, *args)\n        if not hasattr(enum_member, '_value_'):\n            if enum_class._member_type_ is object:\n                enum_member._value_ = value\n            else:\n                try:\n                    enum_member._value_ = enum_class._member_type_(*args)\n                except Exception as exc:\n                    new_exc = TypeError(\n                            '_value_ not set in __new__, unable to create it'\n                            )\n                    new_exc.__cause__ = exc\n                    raise new_exc\n        value = enum_member._value_\n        enum_member._name_ = member_name\n        enum_member.__objclass__ = enum_class\n        enum_member.__init__(*args)\n        enum_member._sort_order_ = len(enum_class._member_names_)\n\n        if Flag is not None and issubclass(enum_class, Flag):\n            if isinstance(value, int):\n                enum_class._flag_mask_ |= value\n                if _is_single_bit(value):\n                    enum_class._singles_mask_ |= value\n            enum_class._all_bits_ = 2 ** ((enum_class._flag_mask_).bit_length()) - 1\n\n        # If another member with the same value was already defined, the\n        # new member becomes an alias to the existing one.\n        try:\n            try:\n                # try to do a fast lookup to avoid the quadratic loop\n                enum_member = enum_class._value2member_map_[value]\n            except TypeError:\n                for name, canonical_member in enum_class._member_map_.items():\n                    if canonical_member._value_ == value:\n                        enum_member = canonical_member\n                        break\n                else:\n                    raise KeyError\n        except KeyError:\n            # this could still be an alias if the value is multi-bit and the\n            # class is a flag class\n            if (\n                    Flag is None\n                    or not issubclass(enum_class, Flag)\n                ):\n                # no other instances found, record this member in _member_names_\n                enum_class._member_names_.append(member_name)\n            elif (\n                    Flag is not None\n                    and issubclass(enum_class, Flag)\n                    and isinstance(value, int)\n                    and _is_single_bit(value)\n                ):\n                # no other instances found, record this member in _member_names_\n                enum_class._member_names_.append(member_name)\n        # if necessary, get redirect in place and then add it to _member_map_\n        found_descriptor = None\n        for base in enum_class.__mro__[1:]:\n            descriptor = base.__dict__.get(member_name)\n            if descriptor is not None:\n                if isinstance(descriptor, (property, DynamicClassAttribute)):\n                    found_descriptor = descriptor\n                    break\n                elif (\n                        hasattr(descriptor, 'fget') and\n                        hasattr(descriptor, 'fset') and\n                        hasattr(descriptor, 'fdel')\n                    ):\n                    found_descriptor = descriptor\n                    continue\n        if found_descriptor:\n            redirect = property()\n            redirect.member = enum_member\n            redirect.__set_name__(enum_class, member_name)\n            # earlier descriptor found; copy fget, fset, fdel to this one.\n            redirect.fget = found_descriptor.fget\n            redirect.fset = found_descriptor.fset\n            redirect.fdel = found_descriptor.fdel\n            setattr(enum_class, member_name, redirect)\n        else:\n            setattr(enum_class, member_name, enum_member)\n        # now add to _member_map_ (even aliases)\n        enum_class._member_map_[member_name] = enum_member\n        try:\n            # This may fail if value is not hashable. We can't add the value\n            # to the map, and by-value lookups for this value will be\n            # linear.\n            enum_class._value2member_map_.setdefault(value, enum_member)\n        except TypeError:\n            # keep track of the value in a list so containment checks are quick\n            enum_class._unhashable_values_.append(value)\n\n\nclass _EnumDict(dict):\n    \"\"\"\n    Track enum member order and ensure member names are not reused.\n\n    EnumType will use the names found in self._member_names as the\n    enumeration member names.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._member_names = {} # use a dict to keep insertion order\n        self._last_values = []\n        self._ignore = []\n        self._auto_called = False\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Changes anything not dundered or not a descriptor.\n\n        If an enum member name is used twice, an error is raised; duplicate\n        values are not checked for.\n\n        Single underscore (sunder) names are reserved.\n        \"\"\"\n        if _is_internal_class(self._cls_name, value):\n            import warnings\n            warnings.warn(\n                    \"In 3.13 classes created inside an enum will not become a member.  \"\n                    \"Use the `member` decorator to keep the current behavior.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                    )\n        if _is_private(self._cls_name, key):\n            # also do nothing, name will be a normal attribute\n            pass\n        elif _is_sunder(key):\n            if key not in (\n                    '_order_',\n                    '_generate_next_value_', '_numeric_repr_', '_missing_', '_ignore_',\n                    '_iter_member_', '_iter_member_by_value_', '_iter_member_by_def_',\n                    ):\n                raise ValueError(\n                        '_sunder_ names, such as %r, are reserved for future Enum use'\n                        % (key, )\n                        )\n            if key == '_generate_next_value_':\n                # check if members already defined as auto()\n                if self._auto_called:\n                    raise TypeError(\"_generate_next_value_ must be defined before members\")\n                _gnv = value.__func__ if isinstance(value, staticmethod) else value\n                setattr(self, '_generate_next_value', _gnv)\n            elif key == '_ignore_':\n                if isinstance(value, str):\n                    value = value.replace(',',' ').split()\n                else:\n                    value = list(value)\n                self._ignore = value\n                already = set(value) & set(self._member_names)\n                if already:\n                    raise ValueError(\n                            '_ignore_ cannot specify already set names: %r'\n                            % (already, )\n                            )\n        elif _is_dunder(key):\n            if key == '__order__':\n                key = '_order_'\n        elif key in self._member_names:\n            # descriptor overwriting an enum?\n            raise TypeError('%r already defined as %r' % (key, self[key]))\n        elif key in self._ignore:\n            pass\n        elif isinstance(value, nonmember):\n            # unwrap value here; it won't be processed by the below `else`\n            value = value.value\n        elif _is_descriptor(value):\n            pass\n        # TODO: uncomment next three lines in 3.13\n        # elif _is_internal_class(self._cls_name, value):\n        #     # do nothing, name will be a normal attribute\n        #     pass\n        else:\n            if key in self:\n                # enum overwriting a descriptor?\n                raise TypeError('%r already defined as %r' % (key, self[key]))\n            elif isinstance(value, member):\n                # unwrap value here -- it will become a member\n                value = value.value\n            non_auto_store = True\n            single = False\n            if isinstance(value, auto):\n                single = True\n                value = (value, )\n            if type(value) is tuple and any(isinstance(v, auto) for v in value):\n                # insist on an actual tuple, no subclasses, in keeping with only supporting\n                # top-level auto() usage (not contained in any other data structure)\n                auto_valued = []\n                for v in value:\n                    if isinstance(v, auto):\n                        non_auto_store = False\n                        if v.value == _auto_null:\n                            v.value = self._generate_next_value(\n                                    key, 1, len(self._member_names), self._last_values[:],\n                                    )\n                            self._auto_called = True\n                        v = v.value\n                        self._last_values.append(v)\n                    auto_valued.append(v)\n                if single:\n                    value = auto_valued[0]\n                else:\n                    value = tuple(auto_valued)\n            self._member_names[key] = None\n            if non_auto_store:\n                self._last_values.append(value)\n        super().__setitem__(key, value)\n\n    def update(self, members, **more_members):\n        try:\n            for name in members.keys():\n                self[name] = members[name]\n        except AttributeError:\n            for name, value in members:\n                self[name] = value\n        for name, value in more_members.items():\n            self[name] = value\n\n\nclass EnumType(type):\n    \"\"\"\n    Metaclass for Enum\n    \"\"\"\n\n    @classmethod\n    def __prepare__(metacls, cls, bases, **kwds):\n        # check that previous enum members do not exist\n        metacls._check_for_existing_members_(cls, bases)\n        # create the namespace dict\n        enum_dict = _EnumDict()\n        enum_dict._cls_name = cls\n        # inherit previous flags and _generate_next_value_ function\n        member_type, first_enum = metacls._get_mixins_(cls, bases)\n        if first_enum is not None:\n            enum_dict['_generate_next_value_'] = getattr(\n                    first_enum, '_generate_next_value_', None,\n                    )\n        return enum_dict\n\n    def __new__(metacls, cls, bases, classdict, *, boundary=None, _simple=False, **kwds):\n        # an Enum class is final once enumeration items have been defined; it\n        # cannot be mixed with other types (int, float, etc.) if it has an\n        # inherited __new__ unless a new __new__ is defined (or the resulting\n        # class will fail).\n        #\n        if _simple:\n            return super().__new__(metacls, cls, bases, classdict, **kwds)\n        #\n        # remove any keys listed in _ignore_\n        classdict.setdefault('_ignore_', []).append('_ignore_')\n        ignore = classdict['_ignore_']\n        for key in ignore:\n            classdict.pop(key, None)\n        #\n        # grab member names\n        member_names = classdict._member_names\n        #\n        # check for illegal enum names (any others?)\n        invalid_names = set(member_names) & {'mro', ''}\n        if invalid_names:\n            raise ValueError('invalid enum member name(s) %s'  % (\n                    ','.join(repr(n) for n in invalid_names)\n                    ))\n        #\n        # adjust the sunders\n        _order_ = classdict.pop('_order_', None)\n        # convert to normal dict\n        classdict = dict(classdict.items())\n        #\n        # data type of member and the controlling Enum class\n        member_type, first_enum = metacls._get_mixins_(cls, bases)\n        __new__, save_new, use_args = metacls._find_new_(\n                classdict, member_type, first_enum,\n                )\n        classdict['_new_member_'] = __new__\n        classdict['_use_args_'] = use_args\n        #\n        # convert future enum members into temporary _proto_members\n        for name in member_names:\n            value = classdict[name]\n            classdict[name] = _proto_member(value)\n        #\n        # house-keeping structures\n        classdict['_member_names_'] = []\n        classdict['_member_map_'] = {}\n        classdict['_value2member_map_'] = {}\n        classdict['_unhashable_values_'] = []\n        classdict['_member_type_'] = member_type\n        # now set the __repr__ for the value\n        classdict['_value_repr_'] = metacls._find_data_repr_(cls, bases)\n        #\n        # Flag structures (will be removed if final class is not a Flag\n        classdict['_boundary_'] = (\n                boundary\n                or getattr(first_enum, '_boundary_', None)\n                )\n        classdict['_flag_mask_'] = 0\n        classdict['_singles_mask_'] = 0\n        classdict['_all_bits_'] = 0\n        classdict['_inverted_'] = None\n        try:\n            exc = None\n            enum_class = super().__new__(metacls, cls, bases, classdict, **kwds)\n        except RuntimeError as e:\n            # any exceptions raised by member.__new__ will get converted to a\n            # RuntimeError, so get that original exception back and raise it instead\n            exc = e.__cause__ or e\n        if exc is not None:\n            raise exc\n        #\n        # update classdict with any changes made by __init_subclass__\n        classdict.update(enum_class.__dict__)\n        #\n        # double check that repr and friends are not the mixin's or various\n        # things break (such as pickle)\n        # however, if the method is defined in the Enum itself, don't replace\n        # it\n        #\n        # Also, special handling for ReprEnum\n        if ReprEnum is not None and ReprEnum in bases:\n            if member_type is object:\n                raise TypeError(\n                        'ReprEnum subclasses must be mixed with a data type (i.e.'\n                        ' int, str, float, etc.)'\n                        )\n            if '__format__' not in classdict:\n                enum_class.__format__ = member_type.__format__\n                classdict['__format__'] = enum_class.__format__\n            if '__str__' not in classdict:\n                method = member_type.__str__\n                if method is object.__str__:\n                    # if member_type does not define __str__, object.__str__ will use\n                    # its __repr__ instead, so we'll also use its __repr__\n                    method = member_type.__repr__\n                enum_class.__str__ = method\n                classdict['__str__'] = enum_class.__str__\n        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):\n            if name not in classdict:\n                # check for mixin overrides before replacing\n                enum_method = getattr(first_enum, name)\n                found_method = getattr(enum_class, name)\n                object_method = getattr(object, name)\n                data_type_method = getattr(member_type, name)\n                if found_method in (data_type_method, object_method):\n                    setattr(enum_class, name, enum_method)\n        #\n        # for Flag, add __or__, __and__, __xor__, and __invert__\n        if Flag is not None and issubclass(enum_class, Flag):\n            for name in (\n                    '__or__', '__and__', '__xor__',\n                    '__ror__', '__rand__', '__rxor__',\n                    '__invert__'\n                ):\n                if name not in classdict:\n                    enum_method = getattr(Flag, name)\n                    setattr(enum_class, name, enum_method)\n                    classdict[name] = enum_method\n        #\n        # replace any other __new__ with our own (as long as Enum is not None,\n        # anyway) -- again, this is to support pickle\n        if Enum is not None:\n            # if the user defined their own __new__, save it before it gets\n            # clobbered in case they subclass later\n            if save_new:\n                enum_class.__new_member__ = __new__\n            enum_class.__new__ = Enum.__new__\n        #\n        # py3 support for definition order (helps keep py2/py3 code in sync)\n        #\n        # _order_ checking is spread out into three/four steps\n        # - if enum_class is a Flag:\n        #   - remove any non-single-bit flags from _order_\n        # - remove any aliases from _order_\n        # - check that _order_ and _member_names_ match\n        #\n        # step 1: ensure we have a list\n        if _order_ is not None:\n            if isinstance(_order_, str):\n                _order_ = _order_.replace(',', ' ').split()\n        #\n        # remove Flag structures if final class is not a Flag\n        if (\n                Flag is None and cls != 'Flag'\n                or Flag is not None and not issubclass(enum_class, Flag)\n            ):\n            delattr(enum_class, '_boundary_')\n            delattr(enum_class, '_flag_mask_')\n            delattr(enum_class, '_singles_mask_')\n            delattr(enum_class, '_all_bits_')\n            delattr(enum_class, '_inverted_')\n        elif Flag is not None and issubclass(enum_class, Flag):\n            # set correct __iter__\n            member_list = [m._value_ for m in enum_class]\n            if member_list != sorted(member_list):\n                enum_class._iter_member_ = enum_class._iter_member_by_def_\n            if _order_:\n                # _order_ step 2: remove any items from _order_ that are not single-bit\n                _order_ = [\n                        o\n                        for o in _order_\n                        if o not in enum_class._member_map_ or _is_single_bit(enum_class[o]._value_)\n                        ]\n        #\n        if _order_:\n            # _order_ step 3: remove aliases from _order_\n            _order_ = [\n                    o\n                    for o in _order_\n                    if (\n                        o not in enum_class._member_map_\n                        or\n                        (o in enum_class._member_map_ and o in enum_class._member_names_)\n                        )]\n            # _order_ step 4: verify that _order_ and _member_names_ match\n            if _order_ != enum_class._member_names_:\n                raise TypeError(\n                        'member order does not match _order_:\\n  %r\\n  %r'\n                        % (enum_class._member_names_, _order_)\n                        )\n\n        return enum_class\n\n    def __bool__(cls):\n        \"\"\"\n        classes/types should always be True.\n        \"\"\"\n        return True\n\n    def __call__(cls, value, names=None, *, module=None, qualname=None, type=None, start=1, boundary=None):\n        \"\"\"\n        Either returns an existing member, or creates a new enum class.\n\n        This method is used both when an enum class is given a value to match\n        to an enumeration member (i.e. Color(3)) and for the functional API\n        (i.e. Color = Enum('Color', names='RED GREEN BLUE')).\n\n        When used for the functional API:\n\n        `value` will be the name of the new class.\n\n        `names` should be either a string of white-space/comma delimited names\n        (values will start at `start`), or an iterator/mapping of name, value pairs.\n\n        `module` should be set to the module this class is being created in;\n        if it is not set, an attempt to find that module will be made, but if\n        it fails the class will not be picklable.\n\n        `qualname` should be set to the actual location this class can be found\n        at in its module; by default it is set to the global scope.  If this is\n        not correct, unpickling will fail in some circumstances.\n\n        `type`, if set, will be mixed in as the first base class.\n        \"\"\"\n        if names is None:  # simple value lookup\n            return cls.__new__(cls, value)\n        # otherwise, functional API: we're creating a new Enum type\n        return cls._create_(\n                value,\n                names,\n                module=module,\n                qualname=qualname,\n                type=type,\n                start=start,\n                boundary=boundary,\n                )\n\n    def __contains__(cls, member):\n        \"\"\"\n        Return True if member is a member of this enum\n        raises TypeError if member is not an enum member\n\n        note: in 3.12 TypeError will no longer be raised, and True will also be\n        returned if member is the value of a member in this enum\n        \"\"\"\n        if not isinstance(member, Enum):\n            import warnings\n            warnings.warn(\n                    \"in 3.12 __contains__ will no longer raise TypeError, but will return True or\\n\"\n                    \"False depending on whether the value is a member or the value of a member\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                    )\n            raise TypeError(\n                \"unsupported operand type(s) for 'in': '%s' and '%s'\" % (\n                    type(member).__qualname__, cls.__class__.__qualname__))\n        return isinstance(member, cls) and member._name_ in cls._member_map_\n\n    def __delattr__(cls, attr):\n        # nicer error message when someone tries to delete an attribute\n        # (see issue19025).\n        if attr in cls._member_map_:\n            raise AttributeError(\"%r cannot delete member %r.\" % (cls.__name__, attr))\n        super().__delattr__(attr)\n\n    def __dir__(cls):\n        interesting = set([\n                '__class__', '__contains__', '__doc__', '__getitem__',\n                '__iter__', '__len__', '__members__', '__module__',\n                '__name__', '__qualname__',\n                ]\n                + cls._member_names_\n                )\n        if cls._new_member_ is not object.__new__:\n            interesting.add('__new__')\n        if cls.__init_subclass__ is not object.__init_subclass__:\n            interesting.add('__init_subclass__')\n        if cls._member_type_ is object:\n            return sorted(interesting)\n        else:\n            # return whatever mixed-in data type has\n            return sorted(set(dir(cls._member_type_)) | interesting)\n\n    def __getattr__(cls, name):\n        \"\"\"\n        Return the enum member matching `name`\n\n        We use __getattr__ instead of descriptors or inserting into the enum\n        class' __dict__ in order to support `name` and `value` being both\n        properties for enum members (which live in the class' __dict__) and\n        enum members themselves.\n        \"\"\"\n        if _is_dunder(name):\n            raise AttributeError(name)\n        try:\n            return cls._member_map_[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __getitem__(cls, name):\n        \"\"\"\n        Return the member matching `name`.\n        \"\"\"\n        return cls._member_map_[name]\n\n    def __iter__(cls):\n        \"\"\"\n        Return members in definition order.\n        \"\"\"\n        return (cls._member_map_[name] for name in cls._member_names_)\n\n    def __len__(cls):\n        \"\"\"\n        Return the number of members (no aliases)\n        \"\"\"\n        return len(cls._member_names_)\n\n    @bltns.property\n    def __members__(cls):\n        \"\"\"\n        Returns a mapping of member name->value.\n\n        This mapping lists all enum members, including aliases. Note that this\n        is a read-only view of the internal mapping.\n        \"\"\"\n        return MappingProxyType(cls._member_map_)\n\n    def __repr__(cls):\n        if Flag is not None and issubclass(cls, Flag):\n            return \"<flag %r>\" % cls.__name__\n        else:\n            return \"<enum %r>\" % cls.__name__\n\n    def __reversed__(cls):\n        \"\"\"\n        Return members in reverse definition order.\n        \"\"\"\n        return (cls._member_map_[name] for name in reversed(cls._member_names_))\n\n    def __setattr__(cls, name, value):\n        \"\"\"\n        Block attempts to reassign Enum members.\n\n        A simple assignment to the class namespace only changes one of the\n        several possible ways to get an Enum member from the Enum class,\n        resulting in an inconsistent Enumeration.\n        \"\"\"\n        member_map = cls.__dict__.get('_member_map_', {})\n        if name in member_map:\n            raise AttributeError('cannot reassign member %r' % (name, ))\n        super().__setattr__(name, value)\n\n    def _create_(cls, class_name, names, *, module=None, qualname=None, type=None, start=1, boundary=None):\n        \"\"\"\n        Convenience method to create a new Enum class.\n\n        `names` can be:\n\n        * A string containing member names, separated either with spaces or\n          commas.  Values are incremented by 1 from `start`.\n        * An iterable of member names.  Values are incremented by 1 from `start`.\n        * An iterable of (member name, value) pairs.\n        * A mapping of member name -> value pairs.\n        \"\"\"\n        metacls = cls.__class__\n        bases = (cls, ) if type is None else (type, cls)\n        _, first_enum = cls._get_mixins_(class_name, bases)\n        classdict = metacls.__prepare__(class_name, bases)\n\n        # special processing needed for names?\n        if isinstance(names, str):\n            names = names.replace(',', ' ').split()\n        if isinstance(names, (tuple, list)) and names and isinstance(names[0], str):\n            original_names, names = names, []\n            last_values = []\n            for count, name in enumerate(original_names):\n                value = first_enum._generate_next_value_(name, start, count, last_values[:])\n                last_values.append(value)\n                names.append((name, value))\n        if names is None:\n            names = ()\n\n        # Here, names is either an iterable of (name, value) or a mapping.\n        for item in names:\n            if isinstance(item, str):\n                member_name, member_value = item, names[item]\n            else:\n                member_name, member_value = item\n            classdict[member_name] = member_value\n\n        # TODO: replace the frame hack if a blessed way to know the calling\n        # module is ever developed\n        if module is None:\n            try:\n                module = sys._getframe(2).f_globals['__name__']\n            except (AttributeError, ValueError, KeyError):\n                pass\n        if module is None:\n            _make_class_unpicklable(classdict)\n        else:\n            classdict['__module__'] = module\n        if qualname is not None:\n            classdict['__qualname__'] = qualname\n\n        return metacls.__new__(metacls, class_name, bases, classdict, boundary=boundary)\n\n    def _convert_(cls, name, module, filter, source=None, *, boundary=None, as_global=False):\n        \"\"\"\n        Create a new Enum subclass that replaces a collection of global constants\n        \"\"\"\n        # convert all constants from source (or module) that pass filter() to\n        # a new Enum called name, and export the enum and its members back to\n        # module;\n        # also, replace the __reduce_ex__ method so unpickling works in\n        # previous Python versions\n        module_globals = sys.modules[module].__dict__\n        if source:\n            source = source.__dict__\n        else:\n            source = module_globals\n        # _value2member_map_ is populated in the same order every time\n        # for a consistent reverse mapping of number to name when there\n        # are multiple names for the same number.\n        members = [\n                (name, value)\n                for name, value in source.items()\n                if filter(name)]\n        try:\n            # sort by value\n            members.sort(key=lambda t: (t[1], t[0]))\n        except TypeError:\n            # unless some values aren't comparable, in which case sort by name\n            members.sort(key=lambda t: t[0])\n        body = {t[0]: t[1] for t in members}\n        body['__module__'] = module\n        tmp_cls = type(name, (object, ), body)\n        cls = _simple_enum(etype=cls, boundary=boundary or KEEP)(tmp_cls)\n        if as_global:\n            global_enum(cls)\n        else:\n            sys.modules[cls.__module__].__dict__.update(cls.__members__)\n        module_globals[name] = cls\n        return cls\n\n    @classmethod\n    def _check_for_existing_members_(mcls, class_name, bases):\n        for chain in bases:\n            for base in chain.__mro__:\n                if isinstance(base, EnumType) and base._member_names_:\n                    raise TypeError(\n                            \"<enum %r> cannot extend %r\"\n                            % (class_name, base)\n                            )\n\n    @classmethod\n    def _get_mixins_(mcls, class_name, bases):\n        \"\"\"\n        Returns the type for creating enum members, and the first inherited\n        enum class.\n\n        bases: the tuple of bases that was given to __new__\n        \"\"\"\n        if not bases:\n            return object, Enum\n\n        mcls._check_for_existing_members_(class_name, bases)\n\n        # ensure final parent class is an Enum derivative, find any concrete\n        # data type, and check that Enum has no members\n        first_enum = bases[-1]\n        if not isinstance(first_enum, EnumType):\n            raise TypeError(\"new enumerations should be created as \"\n                    \"`EnumName([mixin_type, ...] [data_type,] enum_type)`\")\n        member_type = mcls._find_data_type_(class_name, bases) or object\n        return member_type, first_enum\n\n    @classmethod\n    def _find_data_repr_(mcls, class_name, bases):\n        for chain in bases:\n            for base in chain.__mro__:\n                if base is object:\n                    continue\n                elif isinstance(base, EnumType):\n                    # if we hit an Enum, use it's _value_repr_\n                    return base._value_repr_\n                elif '__repr__' in base.__dict__:\n                    # this is our data repr\n                    return base.__dict__['__repr__']\n        return None\n\n    @classmethod\n    def _find_data_type_(mcls, class_name, bases):\n        # a datatype has a __new__ method\n        data_types = set()\n        base_chain = set()\n        for chain in bases:\n            candidate = None\n            for base in chain.__mro__:\n                base_chain.add(base)\n                if base is object:\n                    continue\n                elif isinstance(base, EnumType):\n                    if base._member_type_ is not object:\n                        data_types.add(base._member_type_)\n                        break\n                elif '__new__' in base.__dict__ or '__dataclass_fields__' in base.__dict__:\n                    if isinstance(base, EnumType):\n                        continue\n                    data_types.add(candidate or base)\n                    break\n                else:\n                    candidate = candidate or base\n        if len(data_types) > 1:\n            raise TypeError('too many data types for %r: %r' % (class_name, data_types))\n        elif data_types:\n            return data_types.pop()\n        else:\n            return None\n\n    @classmethod\n    def _find_new_(mcls, classdict, member_type, first_enum):\n        \"\"\"\n        Returns the __new__ to be used for creating the enum members.\n\n        classdict: the class dictionary given to __new__\n        member_type: the data type whose __new__ will be used by default\n        first_enum: enumeration to check for an overriding __new__\n        \"\"\"\n        # now find the correct __new__, checking to see of one was defined\n        # by the user; also check earlier enum classes in case a __new__ was\n        # saved as __new_member__\n        __new__ = classdict.get('__new__', None)\n\n        # should __new__ be saved as __new_member__ later?\n        save_new = first_enum is not None and __new__ is not None\n\n        if __new__ is None:\n            # check all possibles for __new_member__ before falling back to\n            # __new__\n            for method in ('__new_member__', '__new__'):\n                for possible in (member_type, first_enum):\n                    target = getattr(possible, method, None)\n                    if target not in {\n                            None,\n                            None.__new__,\n                            object.__new__,\n                            Enum.__new__,\n                            }:\n                        __new__ = target\n                        break\n                if __new__ is not None:\n                    break\n            else:\n                __new__ = object.__new__\n\n        # if a non-object.__new__ is used then whatever value/tuple was\n        # assigned to the enum member name will be passed to __new__ and to the\n        # new enum member's __init__\n        if first_enum is None or __new__ in (Enum.__new__, object.__new__):\n            use_args = False\n        else:\n            use_args = True\n        return __new__, save_new, use_args\nEnumMeta = EnumType\n\n\nclass Enum(metaclass=EnumType):\n    \"\"\"\n    Create a collection of name/value pairs.\n\n    Example enumeration:\n\n    >>> class Color(Enum):\n    ...     RED = 1\n    ...     BLUE = 2\n    ...     GREEN = 3\n\n    Access them by:\n\n    - attribute access::\n\n    >>> Color.RED\n    <Color.RED: 1>\n\n    - value lookup:\n\n    >>> Color(1)\n    <Color.RED: 1>\n\n    - name lookup:\n\n    >>> Color['RED']\n    <Color.RED: 1>\n\n    Enumerations can be iterated over, and know how many members they have:\n\n    >>> len(Color)\n    3\n\n    >>> list(Color)\n    [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\n    Methods can be added to enumerations, and members can have their own\n    attributes -- see the documentation for details.\n    \"\"\"\n\n    def __new__(cls, value):\n        # all enum instances are actually created during class construction\n        # without calling this method; this method is called by the metaclass'\n        # __call__ (i.e. Color(3) ), and by pickle\n        if type(value) is cls:\n            # For lookups like Color(Color.RED)\n            return value\n        # by-value search for a matching enum member\n        # see if it's in the reverse mapping (for hashable values)\n        try:\n            return cls._value2member_map_[value]\n        except KeyError:\n            # Not found, no need to do long O(n) search\n            pass\n        except TypeError:\n            # not there, now do long search -- O(n) behavior\n            for member in cls._member_map_.values():\n                if member._value_ == value:\n                    return member\n        # still not found -- verify that members exist, in-case somebody got here mistakenly\n        # (such as via super when trying to override __new__)\n        if not cls._member_map_:\n            raise TypeError(\"%r has no members defined\" % cls)\n        #\n        # still not found -- try _missing_ hook\n        try:\n            exc = None\n            result = cls._missing_(value)\n        except Exception as e:\n            exc = e\n            result = None\n        try:\n            if isinstance(result, cls):\n                return result\n            elif (\n                    Flag is not None and issubclass(cls, Flag)\n                    and cls._boundary_ is EJECT and isinstance(result, int)\n                ):\n                return result\n            else:\n                ve_exc = ValueError(\"%r is not a valid %s\" % (value, cls.__qualname__))\n                if result is None and exc is None:\n                    raise ve_exc\n                elif exc is None:\n                    exc = TypeError(\n                            'error in %s._missing_: returned %r instead of None or a valid member'\n                            % (cls.__name__, result)\n                            )\n                if not isinstance(exc, ValueError):\n                    exc.__context__ = ve_exc\n                raise exc\n        finally:\n            # ensure all variables that could hold an exception are destroyed\n            exc = None\n            ve_exc = None\n\n    def __init__(self, *args, **kwds):\n        pass\n\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Generate the next value when not given.\n\n        name: the name of the member\n        start: the initial start value or None\n        count: the number of existing members\n        last_values: the list of values assigned\n        \"\"\"\n        if not last_values:\n            return start\n        try:\n            last = last_values[-1]\n            last_values.sort()\n            if last == last_values[-1]:\n                # no difference between old and new methods\n                return last + 1\n            else:\n                # trigger old method (with warning)\n                raise TypeError\n        except TypeError:\n            import warnings\n            warnings.warn(\n                    \"In 3.13 the default `auto()`/`_generate_next_value_` will require all values to be sortable and support adding +1\\n\"\n                    \"and the value returned will be the largest value in the enum incremented by 1\",\n                    DeprecationWarning,\n                    stacklevel=3,\n                    )\n            for v in reversed(last_values):\n                try:\n                    return v + 1\n                except TypeError:\n                    pass\n            return start\n\n    @classmethod\n    def _missing_(cls, value):\n        return None\n\n    def __repr__(self):\n        v_repr = self.__class__._value_repr_ or repr\n        return \"<%s.%s: %s>\" % (self.__class__.__name__, self._name_, v_repr(self._value_))\n\n    def __str__(self):\n        return \"%s.%s\" % (self.__class__.__name__, self._name_, )\n\n    def __dir__(self):\n        \"\"\"\n        Returns public methods and other interesting attributes.\n        \"\"\"\n        interesting = set()\n        if self.__class__._member_type_ is not object:\n            interesting = set(object.__dir__(self))\n        for name in getattr(self, '__dict__', []):\n            if name[0] != '_' and name not in self._member_map_:\n                interesting.add(name)\n        for cls in self.__class__.mro():\n            for name, obj in cls.__dict__.items():\n                if name[0] == '_':\n                    continue\n                if isinstance(obj, property):\n                    # that's an enum.property\n                    if obj.fget is not None or name not in self._member_map_:\n                        interesting.add(name)\n                    else:\n                        # in case it was added by `dir(self)`\n                        interesting.discard(name)\n                elif name not in self._member_map_:\n                    interesting.add(name)\n        names = sorted(\n                set(['__class__', '__doc__', '__eq__', '__hash__', '__module__'])\n                | interesting\n                )\n        return names\n\n    def __format__(self, format_spec):\n        return str.__format__(str(self), format_spec)\n\n    def __hash__(self):\n        return hash(self._name_)\n\n    def __reduce_ex__(self, proto):\n        return self.__class__, (self._value_, )\n\n    def __deepcopy__(self,memo):\n        return self\n\n    def __copy__(self):\n        return self\n\n    # enum.property is used to provide access to the `name` and\n    # `value` attributes of enum members while keeping some measure of\n    # protection from modification, while still allowing for an enumeration\n    # to have members named `name` and `value`.  This works because enumeration\n    # members are not set directly on the enum class; they are kept in a\n    # separate structure, _member_map_, which is where enum.property looks for\n    # them\n\n    @property\n    def name(self):\n        \"\"\"The name of the Enum member.\"\"\"\n        return self._name_\n\n    @property\n    def value(self):\n        \"\"\"The value of the Enum member.\"\"\"\n        return self._value_\n\n\nclass ReprEnum(Enum):\n    \"\"\"\n    Only changes the repr(), leaving str() and format() to the mixed-in type.\n    \"\"\"\n\n\nclass IntEnum(int, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) ints\n    \"\"\"\n\n\nclass StrEnum(str, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) strings\n    \"\"\"\n\n    def __new__(cls, *values):\n        \"values must already be of type `str`\"\n        if len(values) > 3:\n            raise TypeError('too many arguments for str(): %r' % (values, ))\n        if len(values) == 1:\n            # it must be a string\n            if not isinstance(values[0], str):\n                raise TypeError('%r is not a string' % (values[0], ))\n        if len(values) >= 2:\n            # check that encoding argument is a string\n            if not isinstance(values[1], str):\n                raise TypeError('encoding must be a string, not %r' % (values[1], ))\n        if len(values) == 3:\n            # check that errors argument is a string\n            if not isinstance(values[2], str):\n                raise TypeError('errors must be a string, not %r' % (values[2]))\n        value = str(*values)\n        member = str.__new__(cls, value)\n        member._value_ = value\n        return member\n\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Return the lower-cased version of the member name.\n        \"\"\"\n        return name.lower()\n\n\ndef pickle_by_global_name(self, proto):\n    # should not be used with Flag-type enums\n    return self.name\n_reduce_ex_by_global_name = pickle_by_global_name\n\ndef pickle_by_enum_name(self, proto):\n    # should not be used with Flag-type enums\n    return getattr, (self.__class__, self._name_)\n\nclass FlagBoundary(StrEnum):\n    \"\"\"\n    control how out of range values are handled\n    \"strict\" -> error is raised             [default for Flag]\n    \"conform\" -> extra bits are discarded\n    \"eject\" -> lose flag status\n    \"keep\" -> keep flag status and all bits [default for IntFlag]\n    \"\"\"\n    STRICT = auto()\n    CONFORM = auto()\n    EJECT = auto()\n    KEEP = auto()\nSTRICT, CONFORM, EJECT, KEEP = FlagBoundary\n\n\nclass Flag(Enum, boundary=STRICT):\n    \"\"\"\n    Support for flags\n    \"\"\"\n\n    _numeric_repr_ = repr\n\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Generate the next value when not given.\n\n        name: the name of the member\n        start: the initial start value or None\n        count: the number of existing members\n        last_values: the last value assigned or None\n        \"\"\"\n        if not count:\n            return start if start is not None else 1\n        last_value = max(last_values)\n        try:\n            high_bit = _high_bit(last_value)\n        except Exception:\n            raise TypeError('invalid flag value %r' % last_value) from None\n        return 2 ** (high_bit+1)\n\n    @classmethod\n    def _iter_member_by_value_(cls, value):\n        \"\"\"\n        Extract all members from the value in definition (i.e. increasing value) order.\n        \"\"\"\n        for val in _iter_bits_lsb(value & cls._flag_mask_):\n            yield cls._value2member_map_.get(val)\n\n    _iter_member_ = _iter_member_by_value_\n\n    @classmethod\n    def _iter_member_by_def_(cls, value):\n        \"\"\"\n        Extract all members from the value in definition order.\n        \"\"\"\n        yield from sorted(\n                cls._iter_member_by_value_(value),\n                key=lambda m: m._sort_order_,\n                )\n\n    @classmethod\n    def _missing_(cls, value):\n        \"\"\"\n        Create a composite member containing all canonical members present in `value`.\n\n        If non-member values are present, result depends on `_boundary_` setting.\n        \"\"\"\n        if not isinstance(value, int):\n            raise ValueError(\n                    \"%r is not a valid %s\" % (value, cls.__qualname__)\n                    )\n        # check boundaries\n        # - value must be in range (e.g. -16 <-> +15, i.e. ~15 <-> 15)\n        # - value must not include any skipped flags (e.g. if bit 2 is not\n        #   defined, then 0d10 is invalid)\n        flag_mask = cls._flag_mask_\n        singles_mask = cls._singles_mask_\n        all_bits = cls._all_bits_\n        neg_value = None\n        if (\n                not ~all_bits <= value <= all_bits\n                or value & (all_bits ^ flag_mask)\n            ):\n            if cls._boundary_ is STRICT:\n                max_bits = max(value.bit_length(), flag_mask.bit_length())\n                raise ValueError(\n                        \"%r invalid value %r\\n    given %s\\n  allowed %s\" % (\n                            cls, value, bin(value, max_bits), bin(flag_mask, max_bits),\n                            ))\n            elif cls._boundary_ is CONFORM:\n                value = value & flag_mask\n            elif cls._boundary_ is EJECT:\n                return value\n            elif cls._boundary_ is KEEP:\n                if value < 0:\n                    value = (\n                            max(all_bits+1, 2**(value.bit_length()))\n                            + value\n                            )\n            else:\n                raise ValueError(\n                        '%r unknown flag boundary %r' % (cls, cls._boundary_, )\n                        )\n        if value < 0:\n            neg_value = value\n            value = all_bits + 1 + value\n        # get members and unknown\n        unknown = value & ~flag_mask\n        aliases = value & ~singles_mask\n        member_value = value & singles_mask\n        if unknown and cls._boundary_ is not KEEP:\n            raise ValueError(\n                    '%s(%r) -->  unknown values %r [%s]'\n                    % (cls.__name__, value, unknown, bin(unknown))\n                    )\n        # normal Flag?\n        if cls._member_type_ is object:\n            # construct a singleton enum pseudo-member\n            pseudo_member = object.__new__(cls)\n        else:\n            pseudo_member = cls._member_type_.__new__(cls, value)\n        if not hasattr(pseudo_member, '_value_'):\n            pseudo_member._value_ = value\n        if member_value or aliases:\n            members = []\n            combined_value = 0\n            for m in cls._iter_member_(member_value):\n                members.append(m)\n                combined_value |= m._value_\n            if aliases:\n                value = member_value | aliases\n                for n, pm in cls._member_map_.items():\n                    if pm not in members and pm._value_ and pm._value_ & value == pm._value_:\n                        members.append(pm)\n                        combined_value |= pm._value_\n            unknown = value ^ combined_value\n            pseudo_member._name_ = '|'.join([m._name_ for m in members])\n            if not combined_value:\n                pseudo_member._name_ = None\n            elif unknown and cls._boundary_ is STRICT:\n                raise ValueError('%r: no members with value %r' % (cls, unknown))\n            elif unknown:\n                pseudo_member._name_ += '|%s' % cls._numeric_repr_(unknown)\n        else:\n            pseudo_member._name_ = None\n        # use setdefault in case another thread already created a composite\n        # with this value\n        # note: zero is a special case -- always add it\n        pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)\n        if neg_value is not None:\n            cls._value2member_map_[neg_value] = pseudo_member\n        return pseudo_member\n\n    def __contains__(self, other):\n        \"\"\"\n        Returns True if self has at least the same flags set as other.\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise TypeError(\n                \"unsupported operand type(s) for 'in': %r and %r\" % (\n                    type(other).__qualname__, self.__class__.__qualname__))\n        return other._value_ & self._value_ == other._value_\n\n    def __iter__(self):\n        \"\"\"\n        Returns flags in definition order.\n        \"\"\"\n        yield from self._iter_member_(self._value_)\n\n    def __len__(self):\n        return self._value_.bit_count()\n\n    def __repr__(self):\n        cls_name = self.__class__.__name__\n        v_repr = self.__class__._value_repr_ or repr\n        if self._name_ is None:\n            return \"<%s: %s>\" % (cls_name, v_repr(self._value_))\n        else:\n            return \"<%s.%s: %s>\" % (cls_name, self._name_, v_repr(self._value_))\n\n    def __str__(self):\n        cls_name = self.__class__.__name__\n        if self._name_ is None:\n            return '%s(%r)' % (cls_name, self._value_)\n        else:\n            return \"%s.%s\" % (cls_name, self._name_)\n\n    def __bool__(self):\n        return bool(self._value_)\n\n    def _get_value(self, flag):\n        if isinstance(flag, self.__class__):\n            return flag._value_\n        elif self._member_type_ is not object and isinstance(flag, self._member_type_):\n            return flag\n        return NotImplemented\n\n    def __or__(self, other):\n        other_value = self._get_value(other)\n        if other_value is NotImplemented:\n            return NotImplemented\n\n        for flag in self, other:\n            if self._get_value(flag) is None:\n                raise TypeError(f\"'{flag}' cannot be combined with other flags with |\")\n        value = self._value_\n        return self.__class__(value | other_value)\n\n    def __and__(self, other):\n        other_value = self._get_value(other)\n        if other_value is NotImplemented:\n            return NotImplemented\n\n        for flag in self, other:\n            if self._get_value(flag) is None:\n                raise TypeError(f\"'{flag}' cannot be combined with other flags with &\")\n        value = self._value_\n        return self.__class__(value & other_value)\n\n    def __xor__(self, other):\n        other_value = self._get_value(other)\n        if other_value is NotImplemented:\n            return NotImplemented\n\n        for flag in self, other:\n            if self._get_value(flag) is None:\n                raise TypeError(f\"'{flag}' cannot be combined with other flags with ^\")\n        value = self._value_\n        return self.__class__(value ^ other_value)\n\n    def __invert__(self):\n        if self._get_value(self) is None:\n            raise TypeError(f\"'{self}' cannot be inverted\")\n\n        if self._inverted_ is None:\n            if self._boundary_ in (EJECT, KEEP):\n                self._inverted_ = self.__class__(~self._value_)\n            else:\n                self._inverted_ = self.__class__(self._singles_mask_ & ~self._value_)\n        return self._inverted_\n\n    __rand__ = __and__\n    __ror__ = __or__\n    __rxor__ = __xor__\n\n\nclass IntFlag(int, ReprEnum, Flag, boundary=KEEP):\n    \"\"\"\n    Support for integer-based Flags\n    \"\"\"\n\n\ndef _high_bit(value):\n    \"\"\"\n    returns index of highest bit, or -1 if value is zero or negative\n    \"\"\"\n    return value.bit_length() - 1\n\ndef unique(enumeration):\n    \"\"\"\n    Class decorator for enumerations ensuring unique member values.\n    \"\"\"\n    duplicates = []\n    for name, member in enumeration.__members__.items():\n        if name != member.name:\n            duplicates.append((name, member.name))\n    if duplicates:\n        alias_details = ', '.join(\n                [\"%s -> %s\" % (alias, name) for (alias, name) in duplicates])\n        raise ValueError('duplicate values found in %r: %s' %\n                (enumeration, alias_details))\n    return enumeration\n\ndef _power_of_two(value):\n    if value < 1:\n        return False\n    return value == 2 ** _high_bit(value)\n\ndef global_enum_repr(self):\n    \"\"\"\n    use module.enum_name instead of class.enum_name\n\n    the module is the last module in case of a multi-module name\n    \"\"\"\n    module = self.__class__.__module__.split('.')[-1]\n    return '%s.%s' % (module, self._name_)\n\ndef global_flag_repr(self):\n    \"\"\"\n    use module.flag_name instead of class.flag_name\n\n    the module is the last module in case of a multi-module name\n    \"\"\"\n    module = self.__class__.__module__.split('.')[-1]\n    cls_name = self.__class__.__name__\n    if self._name_ is None:\n        return \"%s.%s(%r)\" % (module, cls_name, self._value_)\n    if _is_single_bit(self._value_):\n        return '%s.%s' % (module, self._name_)\n    if self._boundary_ is not FlagBoundary.KEEP:\n        return '|'.join(['%s.%s' % (module, name) for name in self.name.split('|')])\n    else:\n        name = []\n        for n in self._name_.split('|'):\n            if n[0].isdigit():\n                name.append(n)\n            else:\n                name.append('%s.%s' % (module, n))\n        return '|'.join(name)\n\ndef global_str(self):\n    \"\"\"\n    use enum_name instead of class.enum_name\n    \"\"\"\n    if self._name_ is None:\n        cls_name = self.__class__.__name__\n        return \"%s(%r)\" % (cls_name, self._value_)\n    else:\n        return self._name_\n\ndef global_enum(cls, update_str=False):\n    \"\"\"\n    decorator that makes the repr() of an enum member reference its module\n    instead of its class; also exports all members to the enum's module's\n    global namespace\n    \"\"\"\n    if issubclass(cls, Flag):\n        cls.__repr__ = global_flag_repr\n    else:\n        cls.__repr__ = global_enum_repr\n    if not issubclass(cls, ReprEnum) or update_str:\n        cls.__str__ = global_str\n    sys.modules[cls.__module__].__dict__.update(cls.__members__)\n    return cls\n\ndef _simple_enum(etype=Enum, *, boundary=None, use_args=None):\n    \"\"\"\n    Class decorator that converts a normal class into an :class:`Enum`.  No\n    safety checks are done, and some advanced behavior (such as\n    :func:`__init_subclass__`) is not available.  Enum creation can be faster\n    using :func:`simple_enum`.\n\n        >>> from enum import Enum, _simple_enum\n        >>> @_simple_enum(Enum)\n        ... class Color:\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> Color\n        <enum 'Color'>\n    \"\"\"\n    def convert_class(cls):\n        nonlocal use_args\n        cls_name = cls.__name__\n        if use_args is None:\n            use_args = etype._use_args_\n        __new__ = cls.__dict__.get('__new__')\n        if __new__ is not None:\n            new_member = __new__.__func__\n        else:\n            new_member = etype._member_type_.__new__\n        attrs = {}\n        body = {}\n        if __new__ is not None:\n            body['__new_member__'] = new_member\n        body['_new_member_'] = new_member\n        body['_use_args_'] = use_args\n        body['_generate_next_value_'] = gnv = etype._generate_next_value_\n        body['_member_names_'] = member_names = []\n        body['_member_map_'] = member_map = {}\n        body['_value2member_map_'] = value2member_map = {}\n        body['_unhashable_values_'] = []\n        body['_member_type_'] = member_type = etype._member_type_\n        body['_value_repr_'] = etype._value_repr_\n        if issubclass(etype, Flag):\n            body['_boundary_'] = boundary or etype._boundary_\n            body['_flag_mask_'] = None\n            body['_all_bits_'] = None\n            body['_singles_mask_'] = None\n            body['_inverted_'] = None\n            body['__or__'] = Flag.__or__\n            body['__xor__'] = Flag.__xor__\n            body['__and__'] = Flag.__and__\n            body['__ror__'] = Flag.__ror__\n            body['__rxor__'] = Flag.__rxor__\n            body['__rand__'] = Flag.__rand__\n            body['__invert__'] = Flag.__invert__\n        for name, obj in cls.__dict__.items():\n            if name in ('__dict__', '__weakref__'):\n                continue\n            if _is_dunder(name) or _is_private(cls_name, name) or _is_sunder(name) or _is_descriptor(obj):\n                body[name] = obj\n            else:\n                attrs[name] = obj\n        if cls.__dict__.get('__doc__') is None:\n            body['__doc__'] = 'An enumeration.'\n        #\n        # double check that repr and friends are not the mixin's or various\n        # things break (such as pickle)\n        # however, if the method is defined in the Enum itself, don't replace\n        # it\n        enum_class = type(cls_name, (etype, ), body, boundary=boundary, _simple=True)\n        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):\n            if name not in body:\n                # check for mixin overrides before replacing\n                enum_method = getattr(etype, name)\n                found_method = getattr(enum_class, name)\n                object_method = getattr(object, name)\n                data_type_method = getattr(member_type, name)\n                if found_method in (data_type_method, object_method):\n                    setattr(enum_class, name, enum_method)\n        gnv_last_values = []\n        if issubclass(enum_class, Flag):\n            # Flag / IntFlag\n            single_bits = multi_bits = 0\n            for name, value in attrs.items():\n                if isinstance(value, auto) and auto.value is _auto_null:\n                    value = gnv(name, 1, len(member_names), gnv_last_values)\n                if value in value2member_map:\n                    # an alias to an existing member\n                    redirect = property()\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = value2member_map[value]\n                else:\n                    # create the member\n                    if use_args:\n                        if not isinstance(value, tuple):\n                            value = (value, )\n                        member = new_member(enum_class, *value)\n                        value = value[0]\n                    else:\n                        member = new_member(enum_class)\n                    if __new__ is None:\n                        member._value_ = value\n                    member._name_ = name\n                    member.__objclass__ = enum_class\n                    member.__init__(value)\n                    redirect = property()\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = member\n                    member._sort_order_ = len(member_names)\n                    value2member_map[value] = member\n                    if _is_single_bit(value):\n                        # not a multi-bit alias, record in _member_names_ and _flag_mask_\n                        member_names.append(name)\n                        single_bits |= value\n                    else:\n                        multi_bits |= value\n                    gnv_last_values.append(value)\n            enum_class._flag_mask_ = single_bits | multi_bits\n            enum_class._singles_mask_ = single_bits\n            enum_class._all_bits_ = 2 ** ((single_bits|multi_bits).bit_length()) - 1\n            # set correct __iter__\n            member_list = [m._value_ for m in enum_class]\n            if member_list != sorted(member_list):\n                enum_class._iter_member_ = enum_class._iter_member_by_def_\n        else:\n            # Enum / IntEnum / StrEnum\n            for name, value in attrs.items():\n                if isinstance(value, auto):\n                    if value.value is _auto_null:\n                        value.value = gnv(name, 1, len(member_names), gnv_last_values)\n                    value = value.value\n                if value in value2member_map:\n                    # an alias to an existing member\n                    redirect = property()\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = value2member_map[value]\n                else:\n                    # create the member\n                    if use_args:\n                        if not isinstance(value, tuple):\n                            value = (value, )\n                        member = new_member(enum_class, *value)\n                        value = value[0]\n                    else:\n                        member = new_member(enum_class)\n                    if __new__ is None:\n                        member._value_ = value\n                    member._name_ = name\n                    member.__objclass__ = enum_class\n                    member.__init__(value)\n                    member._sort_order_ = len(member_names)\n                    redirect = property()\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = member\n                    value2member_map[value] = member\n                    member_names.append(name)\n                    gnv_last_values.append(value)\n        if '__new__' in body:\n            enum_class.__new_member__ = enum_class.__new__\n        enum_class.__new__ = Enum.__new__\n        return enum_class\n    return convert_class\n\n@_simple_enum(StrEnum)\nclass EnumCheck:\n    \"\"\"\n    various conditions to check an enumeration for\n    \"\"\"\n    CONTINUOUS = \"no skipped integer values\"\n    NAMED_FLAGS = \"multi-flag aliases may not contain unnamed flags\"\n    UNIQUE = \"one name per value\"\nCONTINUOUS, NAMED_FLAGS, UNIQUE = EnumCheck\n\n\nclass verify:\n    \"\"\"\n    Check an enumeration for various constraints. (see EnumCheck)\n    \"\"\"\n    def __init__(self, *checks):\n        self.checks = checks\n    def __call__(self, enumeration):\n        checks = self.checks\n        cls_name = enumeration.__name__\n        if Flag is not None and issubclass(enumeration, Flag):\n            enum_type = 'flag'\n        elif issubclass(enumeration, Enum):\n            enum_type = 'enum'\n        else:\n            raise TypeError(\"the 'verify' decorator only works with Enum and Flag\")\n        for check in checks:\n            if check is UNIQUE:\n                # check for duplicate names\n                duplicates = []\n                for name, member in enumeration.__members__.items():\n                    if name != member.name:\n                        duplicates.append((name, member.name))\n                if duplicates:\n                    alias_details = ', '.join(\n                            [\"%s -> %s\" % (alias, name) for (alias, name) in duplicates])\n                    raise ValueError('aliases found in %r: %s' %\n                            (enumeration, alias_details))\n            elif check is CONTINUOUS:\n                values = set(e.value for e in enumeration)\n                if len(values) < 2:\n                    continue\n                low, high = min(values), max(values)\n                missing = []\n                if enum_type == 'flag':\n                    # check for powers of two\n                    for i in range(_high_bit(low)+1, _high_bit(high)):\n                        if 2**i not in values:\n                            missing.append(2**i)\n                elif enum_type == 'enum':\n                    # check for powers of one\n                    for i in range(low+1, high):\n                        if i not in values:\n                            missing.append(i)\n                else:\n                    raise Exception('verify: unknown type %r' % enum_type)\n                if missing:\n                    raise ValueError(('invalid %s %r: missing values %s' % (\n                            enum_type, cls_name, ', '.join((str(m) for m in missing)))\n                            )[:256])\n                            # limit max length to protect against DOS attacks\n            elif check is NAMED_FLAGS:\n                # examine each alias and check for unnamed flags\n                member_names = enumeration._member_names_\n                member_values = [m.value for m in enumeration]\n                missing_names = []\n                missing_value = 0\n                for name, alias in enumeration._member_map_.items():\n                    if name in member_names:\n                        # not an alias\n                        continue\n                    if alias.value < 0:\n                        # negative numbers are not checked\n                        continue\n                    values = list(_iter_bits_lsb(alias.value))\n                    missed = [v for v in values if v not in member_values]\n                    if missed:\n                        missing_names.append(name)\n                        missing_value |= reduce(_or_, missed)\n                if missing_names:\n                    if len(missing_names) == 1:\n                        alias = 'alias %s is missing' % missing_names[0]\n                    else:\n                        alias = 'aliases %s and %s are missing' % (\n                                ', '.join(missing_names[:-1]), missing_names[-1]\n                                )\n                    if _is_single_bit(missing_value):\n                        value = 'value 0x%x' % missing_value\n                    else:\n                        value = 'combined values of 0x%x' % missing_value\n                    raise ValueError(\n                            'invalid Flag %r: %s %s [use enum.show_flag_values(value) for details]'\n                            % (cls_name, alias, value)\n                            )\n        return enumeration\n\ndef _test_simple_enum(checked_enum, simple_enum):\n    \"\"\"\n    A function that can be used to test an enum created with :func:`_simple_enum`\n    against the version created by subclassing :class:`Enum`::\n\n        >>> from enum import Enum, _simple_enum, _test_simple_enum\n        >>> @_simple_enum(Enum)\n        ... class Color:\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> class CheckedColor(Enum):\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> _test_simple_enum(CheckedColor, Color)\n\n    If differences are found, a :exc:`TypeError` is raised.\n    \"\"\"\n    failed = []\n    if checked_enum.__dict__ != simple_enum.__dict__:\n        checked_dict = checked_enum.__dict__\n        checked_keys = list(checked_dict.keys())\n        simple_dict = simple_enum.__dict__\n        simple_keys = list(simple_dict.keys())\n        member_names = set(\n                list(checked_enum._member_map_.keys())\n                + list(simple_enum._member_map_.keys())\n                )\n        for key in set(checked_keys + simple_keys):\n            if key in ('__module__', '_member_map_', '_value2member_map_', '__doc__'):\n                # keys known to be different, or very long\n                continue\n            elif key in member_names:\n                # members are checked below\n                continue\n            elif key not in simple_keys:\n                failed.append(\"missing key: %r\" % (key, ))\n            elif key not in checked_keys:\n                failed.append(\"extra key:   %r\" % (key, ))\n            else:\n                checked_value = checked_dict[key]\n                simple_value = simple_dict[key]\n                if callable(checked_value) or isinstance(checked_value, bltns.property):\n                    continue\n                if key == '__doc__':\n                    # remove all spaces/tabs\n                    compressed_checked_value = checked_value.replace(' ','').replace('\\t','')\n                    compressed_simple_value = simple_value.replace(' ','').replace('\\t','')\n                    if compressed_checked_value != compressed_simple_value:\n                        failed.append(\"%r:\\n         %s\\n         %s\" % (\n                                key,\n                                \"checked -> %r\" % (checked_value, ),\n                                \"simple  -> %r\" % (simple_value, ),\n                                ))\n                elif checked_value != simple_value:\n                    failed.append(\"%r:\\n         %s\\n         %s\" % (\n                            key,\n                            \"checked -> %r\" % (checked_value, ),\n                            \"simple  -> %r\" % (simple_value, ),\n                            ))\n        failed.sort()\n        for name in member_names:\n            failed_member = []\n            if name not in simple_keys:\n                failed.append('missing member from simple enum: %r' % name)\n            elif name not in checked_keys:\n                failed.append('extra member in simple enum: %r' % name)\n            else:\n                checked_member_dict = checked_enum[name].__dict__\n                checked_member_keys = list(checked_member_dict.keys())\n                simple_member_dict = simple_enum[name].__dict__\n                simple_member_keys = list(simple_member_dict.keys())\n                for key in set(checked_member_keys + simple_member_keys):\n                    if key in ('__module__', '__objclass__', '_inverted_'):\n                        # keys known to be different or absent\n                        continue\n                    elif key not in simple_member_keys:\n                        failed_member.append(\"missing key %r not in the simple enum member %r\" % (key, name))\n                    elif key not in checked_member_keys:\n                        failed_member.append(\"extra key %r in simple enum member %r\" % (key, name))\n                    else:\n                        checked_value = checked_member_dict[key]\n                        simple_value = simple_member_dict[key]\n                        if checked_value != simple_value:\n                            failed_member.append(\"%r:\\n         %s\\n         %s\" % (\n                                    key,\n                                    \"checked member -> %r\" % (checked_value, ),\n                                    \"simple member  -> %r\" % (simple_value, ),\n                                    ))\n            if failed_member:\n                failed.append('%r member mismatch:\\n      %s' % (\n                        name, '\\n      '.join(failed_member),\n                        ))\n        for method in (\n                '__str__', '__repr__', '__reduce_ex__', '__format__',\n                '__getnewargs_ex__', '__getnewargs__', '__reduce_ex__', '__reduce__'\n            ):\n            if method in simple_keys and method in checked_keys:\n                # cannot compare functions, and it exists in both, so we're good\n                continue\n            elif method not in simple_keys and method not in checked_keys:\n                # method is inherited -- check it out\n                checked_method = getattr(checked_enum, method, None)\n                simple_method = getattr(simple_enum, method, None)\n                if hasattr(checked_method, '__func__'):\n                    checked_method = checked_method.__func__\n                    simple_method = simple_method.__func__\n                if checked_method != simple_method:\n                    failed.append(\"%r:  %-30s %s\" % (\n                            method,\n                            \"checked -> %r\" % (checked_method, ),\n                            \"simple -> %r\" % (simple_method, ),\n                            ))\n            else:\n                # if the method existed in only one of the enums, it will have been caught\n                # in the first checks above\n                pass\n    if failed:\n        raise TypeError('enum mismatch:\\n   %s' % '\\n   '.join(failed))\n\ndef _old_convert_(etype, name, module, filter, source=None, *, boundary=None):\n    \"\"\"\n    Create a new Enum subclass that replaces a collection of global constants\n    \"\"\"\n    # convert all constants from source (or module) that pass filter() to\n    # a new Enum called name, and export the enum and its members back to\n    # module;\n    # also, replace the __reduce_ex__ method so unpickling works in\n    # previous Python versions\n    module_globals = sys.modules[module].__dict__\n    if source:\n        source = source.__dict__\n    else:\n        source = module_globals\n    # _value2member_map_ is populated in the same order every time\n    # for a consistent reverse mapping of number to name when there\n    # are multiple names for the same number.\n    members = [\n            (name, value)\n            for name, value in source.items()\n            if filter(name)]\n    try:\n        # sort by value\n        members.sort(key=lambda t: (t[1], t[0]))\n    except TypeError:\n        # unless some values aren't comparable, in which case sort by name\n        members.sort(key=lambda t: t[0])\n    cls = etype(name, members, module=module, boundary=boundary or KEEP)\n    return cls\n\n_stdlib_enums = IntEnum, StrEnum, IntFlag\n", 2063], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py": ["from __future__ import annotations\n\nfrom ..common import _aliases\n\nfrom .._internal import get_xp\n\nfrom ._info import __array_namespace_info__\n\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from typing import Optional, Union\n    from ._typing import ndarray, Device, Dtype, NestedSequence, SupportsBufferProtocol\n\nimport numpy as np\nbool = np.bool_\n\n# Basic renames\nacos = np.arccos\nacosh = np.arccosh\nasin = np.arcsin\nasinh = np.arcsinh\natan = np.arctan\natan2 = np.arctan2\natanh = np.arctanh\nbitwise_left_shift = np.left_shift\nbitwise_invert = np.invert\nbitwise_right_shift = np.right_shift\nconcat = np.concatenate\npow = np.power\n\narange = get_xp(np)(_aliases.arange)\nempty = get_xp(np)(_aliases.empty)\nempty_like = get_xp(np)(_aliases.empty_like)\neye = get_xp(np)(_aliases.eye)\nfull = get_xp(np)(_aliases.full)\nfull_like = get_xp(np)(_aliases.full_like)\nlinspace = get_xp(np)(_aliases.linspace)\nones = get_xp(np)(_aliases.ones)\nones_like = get_xp(np)(_aliases.ones_like)\nzeros = get_xp(np)(_aliases.zeros)\nzeros_like = get_xp(np)(_aliases.zeros_like)\nUniqueAllResult = get_xp(np)(_aliases.UniqueAllResult)\nUniqueCountsResult = get_xp(np)(_aliases.UniqueCountsResult)\nUniqueInverseResult = get_xp(np)(_aliases.UniqueInverseResult)\nunique_all = get_xp(np)(_aliases.unique_all)\nunique_counts = get_xp(np)(_aliases.unique_counts)\nunique_inverse = get_xp(np)(_aliases.unique_inverse)\nunique_values = get_xp(np)(_aliases.unique_values)\nastype = _aliases.astype\nstd = get_xp(np)(_aliases.std)\nvar = get_xp(np)(_aliases.var)\ncumulative_sum = get_xp(np)(_aliases.cumulative_sum)\nclip = get_xp(np)(_aliases.clip)\npermute_dims = get_xp(np)(_aliases.permute_dims)\nreshape = get_xp(np)(_aliases.reshape)\nargsort = get_xp(np)(_aliases.argsort)\nsort = get_xp(np)(_aliases.sort)\nnonzero = get_xp(np)(_aliases.nonzero)\nceil = get_xp(np)(_aliases.ceil)\nfloor = get_xp(np)(_aliases.floor)\ntrunc = get_xp(np)(_aliases.trunc)\nmatmul = get_xp(np)(_aliases.matmul)\nmatrix_transpose = get_xp(np)(_aliases.matrix_transpose)\ntensordot = get_xp(np)(_aliases.tensordot)\nsign = get_xp(np)(_aliases.sign)\n\ndef _supports_buffer_protocol(obj):\n    try:\n        memoryview(obj)\n    except TypeError:\n        return False\n    return True\n\n# asarray also adds the copy keyword, which is not present in numpy 1.0.\n# asarray() is different enough between numpy, cupy, and dask, the logic\n# complicated enough that it's easier to define it separately for each module\n# rather than trying to combine everything into one function in common/\ndef asarray(\n    obj: Union[\n        ndarray,\n        bool,\n        int,\n        float,\n        NestedSequence[bool | int | float],\n        SupportsBufferProtocol,\n    ],\n    /,\n    *,\n    dtype: Optional[Dtype] = None,\n    device: Optional[Device] = None,\n    copy: \"Optional[Union[bool, np._CopyMode]]\" = None,\n    **kwargs,\n) -> ndarray:\n    \"\"\"\n    Array API compatibility wrapper for asarray().\n\n    See the corresponding documentation in the array library and/or the array API\n    specification for more details.\n    \"\"\"\n    if device not in [\"cpu\", None]:\n        raise ValueError(f\"Unsupported device for NumPy: {device!r}\")\n\n    if hasattr(np, '_CopyMode'):\n        if copy is None:\n            copy = np._CopyMode.IF_NEEDED\n        elif copy is False:\n            copy = np._CopyMode.NEVER\n        elif copy is True:\n            copy = np._CopyMode.ALWAYS\n    else:\n        # Not present in older NumPys. In this case, we cannot really support\n        # copy=False.\n        if copy is False:\n            raise NotImplementedError(\"asarray(copy=False) requires a newer version of NumPy.\")\n\n    return np.array(obj, copy=copy, dtype=dtype, **kwargs)\n\n# These functions are completely new here. If the library already has them\n# (i.e., numpy 2.0), use the library version instead of our wrapper.\nif hasattr(np, 'vecdot'):\n    vecdot = np.vecdot\nelse:\n    vecdot = get_xp(np)(_aliases.vecdot)\n\nif hasattr(np, 'isdtype'):\n    isdtype = np.isdtype\nelse:\n    isdtype = get_xp(np)(_aliases.isdtype)\n\nif hasattr(np, 'unstack'):\n    unstack = np.unstack\nelse:\n    unstack = get_xp(np)(_aliases.unstack)\n\n__all__ = _aliases.__all__ + ['__array_namespace_info__', 'asarray', 'bool',\n                              'acos', 'acosh', 'asin', 'asinh', 'atan',\n                              'atan2', 'atanh', 'bitwise_left_shift',\n                              'bitwise_invert', 'bitwise_right_shift',\n                              'concat', 'pow']\n\n_all_ignore = ['np', 'get_xp']\n", 141], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py": ["from __future__ import annotations\n\nimport warnings\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from ._typing import Array, ModuleType\n\n__all__ = [\"atleast_nd\", \"cov\", \"create_diagonal\", \"expand_dims\", \"kron\", \"sinc\"]\n\n\ndef atleast_nd(x: Array, /, *, ndim: int, xp: ModuleType) -> Array:\n    \"\"\"\n    Recursively expand the dimension of an array to at least `ndim`.\n\n    Parameters\n    ----------\n    x : array\n    ndim : int\n        The minimum number of dimensions for the result.\n    xp : array_namespace\n        The standard-compatible namespace for `x`.\n\n    Returns\n    -------\n    res : array\n        An array with ``res.ndim`` >= `ndim`.\n        If ``x.ndim`` >= `ndim`, `x` is returned.\n        If ``x.ndim`` < `ndim`, `x` is expanded by prepending new axes\n        until ``res.ndim`` equals `ndim`.\n\n    Examples\n    --------\n    >>> import array_api_strict as xp\n    >>> import array_api_extra as xpx\n    >>> x = xp.asarray([1])\n    >>> xpx.atleast_nd(x, ndim=3, xp=xp)\n    Array([[[1]]], dtype=array_api_strict.int64)\n\n    >>> x = xp.asarray([[[1, 2],\n    ...                  [3, 4]]])\n    >>> xpx.atleast_nd(x, ndim=1, xp=xp) is x\n    True\n\n    \"\"\"\n    if x.ndim < ndim:\n        x = xp.expand_dims(x, axis=0)\n        x = atleast_nd(x, ndim=ndim, xp=xp)\n    return x\n\n\ndef cov(m: Array, /, *, xp: ModuleType) -> Array:\n    \"\"\"\n    Estimate a covariance matrix.\n\n    Covariance indicates the level to which two variables vary together.\n    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,\n    then the covariance matrix element :math:`C_{ij}` is the covariance of\n    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance\n    of :math:`x_i`.\n\n    This provides a subset of the functionality of ``numpy.cov``.\n\n    Parameters\n    ----------\n    m : array\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `m` represents a variable, and each column a single\n        observation of all those variables.\n    xp : array_namespace\n        The standard-compatible namespace for `m`.\n\n    Returns\n    -------\n    res : array\n        The covariance matrix of the variables.\n\n    Examples\n    --------\n    >>> import array_api_strict as xp\n    >>> import array_api_extra as xpx\n\n    Consider two variables, :math:`x_0` and :math:`x_1`, which\n    correlate perfectly, but in opposite directions:\n\n    >>> x = xp.asarray([[0, 2], [1, 1], [2, 0]]).T\n    >>> x\n    Array([[0, 1, 2],\n           [2, 1, 0]], dtype=array_api_strict.int64)\n\n    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance\n    matrix shows this clearly:\n\n    >>> xpx.cov(x, xp=xp)\n    Array([[ 1., -1.],\n           [-1.,  1.]], dtype=array_api_strict.float64)\n\n\n    Note that element :math:`C_{0,1}`, which shows the correlation between\n    :math:`x_0` and :math:`x_1`, is negative.\n\n    Further, note how `x` and `y` are combined:\n\n    >>> x = xp.asarray([-2.1, -1,  4.3])\n    >>> y = xp.asarray([3,  1.1,  0.12])\n    >>> X = xp.stack((x, y), axis=0)\n    >>> xpx.cov(X, xp=xp)\n    Array([[11.71      , -4.286     ],\n           [-4.286     ,  2.14413333]], dtype=array_api_strict.float64)\n\n    >>> xpx.cov(x, xp=xp)\n    Array(11.71, dtype=array_api_strict.float64)\n\n    >>> xpx.cov(y, xp=xp)\n    Array(2.14413333, dtype=array_api_strict.float64)\n\n    \"\"\"\n    m = xp.asarray(m, copy=True)\n    dtype = (\n        xp.float64 if xp.isdtype(m.dtype, \"integral\") else xp.result_type(m, xp.float64)\n    )\n\n    m = atleast_nd(m, ndim=2, xp=xp)\n    m = xp.astype(m, dtype)\n\n    avg = _mean(m, axis=1, xp=xp)\n    fact = m.shape[1] - 1\n\n    if fact <= 0:\n        warnings.warn(\"Degrees of freedom <= 0 for slice\", RuntimeWarning, stacklevel=2)\n        fact = 0.0\n\n    m -= avg[:, None]\n    m_transpose = m.T\n    if xp.isdtype(m_transpose.dtype, \"complex floating\"):\n        m_transpose = xp.conj(m_transpose)\n    c = m @ m_transpose\n    c /= fact\n    axes = tuple(axis for axis, length in enumerate(c.shape) if length == 1)\n    return xp.squeeze(c, axis=axes)\n\n\ndef create_diagonal(x: Array, /, *, offset: int = 0, xp: ModuleType) -> Array:\n    \"\"\"\n    Construct a diagonal array.\n\n    Parameters\n    ----------\n    x : array\n        A 1-D array\n    offset : int, optional\n        Offset from the leading diagonal (default is ``0``).\n        Use positive ints for diagonals above the leading diagonal,\n        and negative ints for diagonals below the leading diagonal.\n    xp : array_namespace\n        The standard-compatible namespace for `x`.\n\n    Returns\n    -------\n    res : array\n        A 2-D array with `x` on the diagonal (offset by `offset`).\n\n    Examples\n    --------\n    >>> import array_api_strict as xp\n    >>> import array_api_extra as xpx\n    >>> x = xp.asarray([2, 4, 8])\n\n    >>> xpx.create_diagonal(x, xp=xp)\n    Array([[2, 0, 0],\n           [0, 4, 0],\n           [0, 0, 8]], dtype=array_api_strict.int64)\n\n    >>> xpx.create_diagonal(x, offset=-2, xp=xp)\n    Array([[0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0],\n           [2, 0, 0, 0, 0],\n           [0, 4, 0, 0, 0],\n           [0, 0, 8, 0, 0]], dtype=array_api_strict.int64)\n\n    \"\"\"\n    if x.ndim != 1:\n        err_msg = \"`x` must be 1-dimensional.\"\n        raise ValueError(err_msg)\n    n = x.shape[0] + abs(offset)\n    diag = xp.zeros(n**2, dtype=x.dtype)\n    i = offset if offset >= 0 else abs(offset) * n\n    diag[i : min(n * (n - offset), diag.shape[0]) : n + 1] = x\n    return xp.reshape(diag, (n, n))\n\n\ndef _mean(\n    x: Array,\n    /,\n    *,\n    axis: int | tuple[int, ...] | None = None,\n    keepdims: bool = False,\n    xp: ModuleType,\n) -> Array:\n    \"\"\"\n    Complex mean, https://github.com/data-apis/array-api/issues/846.\n    \"\"\"\n    if xp.isdtype(x.dtype, \"complex floating\"):\n        x_real = xp.real(x)\n        x_imag = xp.imag(x)\n        mean_real = xp.mean(x_real, axis=axis, keepdims=keepdims)\n        mean_imag = xp.mean(x_imag, axis=axis, keepdims=keepdims)\n        return mean_real + (mean_imag * xp.asarray(1j))\n    return xp.mean(x, axis=axis, keepdims=keepdims)\n\n\ndef expand_dims(\n    a: Array, /, *, axis: int | tuple[int, ...] = (0,), xp: ModuleType\n) -> Array:\n    \"\"\"\n    Expand the shape of an array.\n\n    Insert (a) new axis/axes that will appear at the position(s) specified by\n    `axis` in the expanded array shape.\n\n    This is ``xp.expand_dims`` for `axis` an int *or a tuple of ints*.\n    Roughly equivalent to ``numpy.expand_dims`` for NumPy arrays.\n\n    Parameters\n    ----------\n    a : array\n    axis : int or tuple of ints, optional\n        Position(s) in the expanded axes where the new axis (or axes) is/are placed.\n        If multiple positions are provided, they should be unique (note that a position\n        given by a positive index could also be referred to by a negative index -\n        that will also result in an error).\n        Default: ``(0,)``.\n    xp : array_namespace\n        The standard-compatible namespace for `a`.\n\n    Returns\n    -------\n    res : array\n        `a` with an expanded shape.\n\n    Examples\n    --------\n    >>> import array_api_strict as xp\n    >>> import array_api_extra as xpx\n    >>> x = xp.asarray([1, 2])\n    >>> x.shape\n    (2,)\n\n    The following is equivalent to ``x[xp.newaxis, :]`` or ``x[xp.newaxis]``:\n\n    >>> y = xpx.expand_dims(x, axis=0, xp=xp)\n    >>> y\n    Array([[1, 2]], dtype=array_api_strict.int64)\n    >>> y.shape\n    (1, 2)\n\n    The following is equivalent to ``x[:, xp.newaxis]``:\n\n    >>> y = xpx.expand_dims(x, axis=1, xp=xp)\n    >>> y\n    Array([[1],\n           [2]], dtype=array_api_strict.int64)\n    >>> y.shape\n    (2, 1)\n\n    ``axis`` may also be a tuple:\n\n    >>> y = xpx.expand_dims(x, axis=(0, 1), xp=xp)\n    >>> y\n    Array([[[1, 2]]], dtype=array_api_strict.int64)\n\n    >>> y = xpx.expand_dims(x, axis=(2, 0), xp=xp)\n    >>> y\n    Array([[[1],\n            [2]]], dtype=array_api_strict.int64)\n\n    \"\"\"\n    if not isinstance(axis, tuple):\n        axis = (axis,)\n    ndim = a.ndim + len(axis)\n    if axis != () and (min(axis) < -ndim or max(axis) >= ndim):\n        err_msg = (\n            f\"a provided axis position is out of bounds for array of dimension {a.ndim}\"\n        )\n        raise IndexError(err_msg)\n    axis = tuple(dim % ndim for dim in axis)\n    if len(set(axis)) != len(axis):\n        err_msg = \"Duplicate dimensions specified in `axis`.\"\n        raise ValueError(err_msg)\n    for i in sorted(axis):\n        a = xp.expand_dims(a, axis=i)\n    return a\n\n\ndef kron(a: Array, b: Array, /, *, xp: ModuleType) -> Array:\n    \"\"\"\n    Kronecker product of two arrays.\n\n    Computes the Kronecker product, a composite array made of blocks of the\n    second array scaled by the first.\n\n    Equivalent to ``numpy.kron`` for NumPy arrays.\n\n    Parameters\n    ----------\n    a, b : array\n    xp : array_namespace\n        The standard-compatible namespace for `a` and `b`.\n\n    Returns\n    -------\n    res : array\n        The Kronecker product of `a` and `b`.\n\n    Notes\n    -----\n    The function assumes that the number of dimensions of `a` and `b`\n    are the same, if necessary prepending the smallest with ones.\n    If ``a.shape = (r0,r1,..,rN)`` and ``b.shape = (s0,s1,...,sN)``,\n    the Kronecker product has shape ``(r0*s0, r1*s1, ..., rN*SN)``.\n    The elements are products of elements from `a` and `b`, organized\n    explicitly by::\n\n        kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]\n\n    where::\n\n        kt = it * st + jt,  t = 0,...,N\n\n    In the common 2-D case (N=1), the block structure can be visualized::\n\n        [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],\n         [  ...                              ...   ],\n         [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]\n\n\n    Examples\n    --------\n    >>> import array_api_strict as xp\n    >>> import array_api_extra as xpx\n    >>> xpx.kron(xp.asarray([1, 10, 100]), xp.asarray([5, 6, 7]), xp=xp)\n    Array([  5,   6,   7,  50,  60,  70, 500,\n           600, 700], dtype=array_api_strict.int64)\n\n    >>> xpx.kron(xp.asarray([5, 6, 7]), xp.asarray([1, 10, 100]), xp=xp)\n    Array([  5,  50, 500,   6,  60, 600,   7,\n            70, 700], dtype=array_api_strict.int64)\n\n    >>> xpx.kron(xp.eye(2), xp.ones((2, 2)), xp=xp)\n    Array([[1., 1., 0., 0.],\n           [1., 1., 0., 0.],\n           [0., 0., 1., 1.],\n           [0., 0., 1., 1.]], dtype=array_api_strict.float64)\n\n\n    >>> a = xp.reshape(xp.arange(100), (2, 5, 2, 5))\n    >>> b = xp.reshape(xp.arange(24), (2, 3, 4))\n    >>> c = xpx.kron(a, b, xp=xp)\n    >>> c.shape\n    (2, 10, 6, 20)\n    >>> I = (1, 3, 0, 2)\n    >>> J = (0, 2, 1)\n    >>> J1 = (0,) + J             # extend to ndim=4\n    >>> S1 = (1,) + b.shape\n    >>> K = tuple(xp.asarray(I) * xp.asarray(S1) + xp.asarray(J1))\n    >>> c[K] == a[I]*b[J]\n    Array(True, dtype=array_api_strict.bool)\n\n    \"\"\"\n\n    b = xp.asarray(b)\n    singletons = (1,) * (b.ndim - a.ndim)\n    a = xp.broadcast_to(xp.asarray(a), singletons + a.shape)\n\n    nd_b, nd_a = b.ndim, a.ndim\n    nd_max = max(nd_b, nd_a)\n    if nd_a == 0 or nd_b == 0:\n        return xp.multiply(a, b)\n\n    a_shape = a.shape\n    b_shape = b.shape\n\n    # Equalise the shapes by prepending smaller one with 1s\n    a_shape = (1,) * max(0, nd_b - nd_a) + a_shape\n    b_shape = (1,) * max(0, nd_a - nd_b) + b_shape\n\n    # Insert empty dimensions\n    a_arr = expand_dims(a, axis=tuple(range(nd_b - nd_a)), xp=xp)\n    b_arr = expand_dims(b, axis=tuple(range(nd_a - nd_b)), xp=xp)\n\n    # Compute the product\n    a_arr = expand_dims(a_arr, axis=tuple(range(1, nd_max * 2, 2)), xp=xp)\n    b_arr = expand_dims(b_arr, axis=tuple(range(0, nd_max * 2, 2)), xp=xp)\n    result = xp.multiply(a_arr, b_arr)\n\n    # Reshape back and return\n    a_shape = xp.asarray(a_shape)\n    b_shape = xp.asarray(b_shape)\n    return xp.reshape(result, tuple(xp.multiply(a_shape, b_shape)))\n\n\ndef sinc(x: Array, /, *, xp: ModuleType) -> Array:\n    r\"\"\"\n    Return the normalized sinc function.\n\n    The sinc function is equal to :math:`\\sin(\\pi x)/(\\pi x)` for any argument\n    :math:`x\\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not\n    only everywhere continuous but also infinitely differentiable.\n\n    .. note::\n\n        Note the normalization factor of ``pi`` used in the definition.\n        This is the most commonly used definition in signal processing.\n        Use ``sinc(x / xp.pi)`` to obtain the unnormalized sinc function\n        :math:`\\sin(x)/x` that is more common in mathematics.\n\n    Parameters\n    ----------\n    x : array\n        Array (possibly multi-dimensional) of values for which to calculate\n        ``sinc(x)``. Must have a real floating point dtype.\n    xp : array_namespace\n        The standard-compatible namespace for `x`.\n\n    Returns\n    -------\n    res : array\n        ``sinc(x)`` calculated elementwise, which has the same shape as the input.\n\n    Notes\n    -----\n    The name sinc is short for \"sine cardinal\" or \"sinus cardinalis\".\n\n    The sinc function is used in various signal processing applications,\n    including in anti-aliasing, in the construction of a Lanczos resampling\n    filter, and in interpolation.\n\n    For bandlimited interpolation of discrete-time signals, the ideal\n    interpolation kernel is proportional to the sinc function.\n\n    References\n    ----------\n    .. [1] Weisstein, Eric W. \"Sinc Function.\" From MathWorld--A Wolfram Web\n           Resource. https://mathworld.wolfram.com/SincFunction.html\n    .. [2] Wikipedia, \"Sinc function\",\n           https://en.wikipedia.org/wiki/Sinc_function\n\n    Examples\n    --------\n    >>> import array_api_strict as xp\n    >>> import array_api_extra as xpx\n    >>> x = xp.linspace(-4, 4, 41)\n    >>> xpx.sinc(x, xp=xp)\n    Array([-3.89817183e-17, -4.92362781e-02,\n           -8.40918587e-02, -8.90384387e-02,\n           -5.84680802e-02,  3.89817183e-17,\n            6.68206631e-02,  1.16434881e-01,\n            1.26137788e-01,  8.50444803e-02,\n           -3.89817183e-17, -1.03943254e-01,\n           -1.89206682e-01, -2.16236208e-01,\n           -1.55914881e-01,  3.89817183e-17,\n            2.33872321e-01,  5.04551152e-01,\n            7.56826729e-01,  9.35489284e-01,\n            1.00000000e+00,  9.35489284e-01,\n            7.56826729e-01,  5.04551152e-01,\n            2.33872321e-01,  3.89817183e-17,\n           -1.55914881e-01, -2.16236208e-01,\n           -1.89206682e-01, -1.03943254e-01,\n           -3.89817183e-17,  8.50444803e-02,\n            1.26137788e-01,  1.16434881e-01,\n            6.68206631e-02,  3.89817183e-17,\n           -5.84680802e-02, -8.90384387e-02,\n           -8.40918587e-02, -4.92362781e-02,\n           -3.89817183e-17], dtype=array_api_strict.float64)\n\n    \"\"\"\n    if not xp.isdtype(x.dtype, \"real floating\"):\n        err_msg = \"`x` must have a real floating data type.\"\n        raise ValueError(err_msg)\n    # no scalars in `where` - array-api#807\n    y = xp.pi * xp.where(\n        x, x, xp.asarray(xp.finfo(x.dtype).smallest_normal, dtype=x.dtype)\n    )\n    return xp.sin(y) / y\n", 484], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py": ["\"\"\"\nnumerictypes: Define the numeric type objects\n\nThis module is designed so \"from numerictypes import \\\\*\" is safe.\nExported symbols include:\n\n  Dictionary with all registered number types (including aliases):\n    sctypeDict\n\n  Type objects (not all will be available, depends on platform):\n      see variable sctypes for which ones you have\n\n    Bit-width names\n\n    int8 int16 int32 int64 int128\n    uint8 uint16 uint32 uint64 uint128\n    float16 float32 float64 float96 float128 float256\n    complex32 complex64 complex128 complex192 complex256 complex512\n    datetime64 timedelta64\n\n    c-based names\n\n    bool\n\n    object_\n\n    void, str_\n\n    byte, ubyte,\n    short, ushort\n    intc, uintc,\n    intp, uintp,\n    int_, uint,\n    longlong, ulonglong,\n\n    single, csingle,\n    double, cdouble,\n    longdouble, clongdouble,\n\n   As part of the type-hierarchy:    xx -- is bit-width\n\n   generic\n     +-> bool                                   (kind=b)\n     +-> number\n     |   +-> integer\n     |   |   +-> signedinteger     (intxx)      (kind=i)\n     |   |   |     byte\n     |   |   |     short\n     |   |   |     intc\n     |   |   |     intp\n     |   |   |     int_\n     |   |   |     longlong\n     |   |   \\\\-> unsignedinteger  (uintxx)     (kind=u)\n     |   |         ubyte\n     |   |         ushort\n     |   |         uintc\n     |   |         uintp\n     |   |         uint\n     |   |         ulonglong\n     |   +-> inexact\n     |       +-> floating          (floatxx)    (kind=f)\n     |       |     half\n     |       |     single\n     |       |     double\n     |       |     longdouble\n     |       \\\\-> complexfloating  (complexxx)  (kind=c)\n     |             csingle\n     |             cdouble\n     |             clongdouble\n     +-> flexible\n     |   +-> character\n     |   |     bytes_                           (kind=S)\n     |   |     str_                             (kind=U)\n     |   |\n     |   \\\\-> void                              (kind=V)\n     \\\\-> object_ (not used much)               (kind=O)\n\n\"\"\"\nimport numbers\nimport warnings\n\nfrom . import multiarray as ma\nfrom .multiarray import (\n        ndarray, dtype, datetime_data, datetime_as_string,\n        busday_offset, busday_count, is_busday, busdaycalendar\n        )\nfrom .._utils import set_module\n\n# we add more at the bottom\n__all__ = [\n    'ScalarType', 'typecodes', 'issubdtype', 'datetime_data',\n    'datetime_as_string', 'busday_offset', 'busday_count',\n    'is_busday', 'busdaycalendar', 'isdtype'\n]\n\n# we don't need all these imports, but we need to keep them for compatibility\n# for users using np._core.numerictypes.UPPER_TABLE\nfrom ._string_helpers import (  # noqa: F401\n    english_lower, english_upper, english_capitalize, LOWER_TABLE, UPPER_TABLE\n)\n\nfrom ._type_aliases import (\n    sctypeDict, allTypes, sctypes\n)\nfrom ._dtype import _kind_name\n\n# we don't export these for import *, but we do want them accessible\n# as numerictypes.bool, etc.\nfrom builtins import bool, int, float, complex, object, str, bytes  # noqa: F401, UP029\n\n\n# We use this later\ngeneric = allTypes['generic']\n\ngenericTypeRank = ['bool', 'int8', 'uint8', 'int16', 'uint16',\n                   'int32', 'uint32', 'int64', 'uint64', 'int128',\n                   'uint128', 'float16',\n                   'float32', 'float64', 'float80', 'float96', 'float128',\n                   'float256',\n                   'complex32', 'complex64', 'complex128', 'complex160',\n                   'complex192', 'complex256', 'complex512', 'object']\n\n@set_module('numpy')\ndef maximum_sctype(t):\n    \"\"\"\n    Return the scalar type of highest precision of the same kind as the input.\n\n    .. deprecated:: 2.0\n        Use an explicit dtype like int64 or float64 instead.\n\n    Parameters\n    ----------\n    t : dtype or dtype specifier\n        The input data type. This can be a `dtype` object or an object that\n        is convertible to a `dtype`.\n\n    Returns\n    -------\n    out : dtype\n        The highest precision data type of the same kind (`dtype.kind`) as `t`.\n\n    See Also\n    --------\n    obj2sctype, mintypecode, sctype2char\n    dtype\n\n    Examples\n    --------\n    >>> from numpy._core.numerictypes import maximum_sctype\n    >>> maximum_sctype(int)\n    <class 'numpy.int64'>\n    >>> maximum_sctype(np.uint8)\n    <class 'numpy.uint64'>\n    >>> maximum_sctype(complex)\n    <class 'numpy.complex256'> # may vary\n\n    >>> maximum_sctype(str)\n    <class 'numpy.str_'>\n\n    >>> maximum_sctype('i2')\n    <class 'numpy.int64'>\n    >>> maximum_sctype('f4')\n    <class 'numpy.float128'> # may vary\n\n    \"\"\"\n\n    # Deprecated in NumPy 2.0, 2023-07-11\n    warnings.warn(\n        \"`maximum_sctype` is deprecated. Use an explicit dtype like int64 \"\n        \"or float64 instead. (deprecated in NumPy 2.0)\",\n        DeprecationWarning,\n        stacklevel=2\n    )\n\n    g = obj2sctype(t)\n    if g is None:\n        return t\n    t = g\n    base = _kind_name(dtype(t))\n    if base in sctypes:\n        return sctypes[base][-1]\n    else:\n        return t\n\n\n@set_module('numpy')\ndef issctype(rep):\n    \"\"\"\n    Determines whether the given object represents a scalar data-type.\n\n    Parameters\n    ----------\n    rep : any\n        If `rep` is an instance of a scalar dtype, True is returned. If not,\n        False is returned.\n\n    Returns\n    -------\n    out : bool\n        Boolean result of check whether `rep` is a scalar dtype.\n\n    See Also\n    --------\n    issubsctype, issubdtype, obj2sctype, sctype2char\n\n    Examples\n    --------\n    >>> from numpy._core.numerictypes import issctype\n    >>> issctype(np.int32)\n    True\n    >>> issctype(list)\n    False\n    >>> issctype(1.1)\n    False\n\n    Strings are also a scalar type:\n\n    >>> issctype(np.dtype('str'))\n    True\n\n    \"\"\"\n    if not isinstance(rep, (type, dtype)):\n        return False\n    try:\n        res = obj2sctype(rep)\n        if res and res != object_:\n            return True\n        else:\n            return False\n    except Exception:\n        return False\n\n\n@set_module('numpy')\ndef obj2sctype(rep, default=None):\n    \"\"\"\n    Return the scalar dtype or NumPy equivalent of Python type of an object.\n\n    Parameters\n    ----------\n    rep : any\n        The object of which the type is returned.\n    default : any, optional\n        If given, this is returned for objects whose types can not be\n        determined. If not given, None is returned for those objects.\n\n    Returns\n    -------\n    dtype : dtype or Python type\n        The data type of `rep`.\n\n    See Also\n    --------\n    sctype2char, issctype, issubsctype, issubdtype\n\n    Examples\n    --------\n    >>> from numpy._core.numerictypes import obj2sctype\n    >>> obj2sctype(np.int32)\n    <class 'numpy.int32'>\n    >>> obj2sctype(np.array([1., 2.]))\n    <class 'numpy.float64'>\n    >>> obj2sctype(np.array([1.j]))\n    <class 'numpy.complex128'>\n\n    >>> obj2sctype(dict)\n    <class 'numpy.object_'>\n    >>> obj2sctype('string')\n\n    >>> obj2sctype(1, default=list)\n    <class 'list'>\n\n    \"\"\"\n    # prevent abstract classes being upcast\n    if isinstance(rep, type) and issubclass(rep, generic):\n        return rep\n    # extract dtype from arrays\n    if isinstance(rep, ndarray):\n        return rep.dtype.type\n    # fall back on dtype to convert\n    try:\n        res = dtype(rep)\n    except Exception:\n        return default\n    else:\n        return res.type\n\n\n@set_module('numpy')\ndef issubclass_(arg1, arg2):\n    \"\"\"\n    Determine if a class is a subclass of a second class.\n\n    `issubclass_` is equivalent to the Python built-in ``issubclass``,\n    except that it returns False instead of raising a TypeError if one\n    of the arguments is not a class.\n\n    Parameters\n    ----------\n    arg1 : class\n        Input class. True is returned if `arg1` is a subclass of `arg2`.\n    arg2 : class or tuple of classes.\n        Input class. If a tuple of classes, True is returned if `arg1` is a\n        subclass of any of the tuple elements.\n\n    Returns\n    -------\n    out : bool\n        Whether `arg1` is a subclass of `arg2` or not.\n\n    See Also\n    --------\n    issubsctype, issubdtype, issctype\n\n    Examples\n    --------\n    >>> np.issubclass_(np.int32, int)\n    False\n    >>> np.issubclass_(np.int32, float)\n    False\n    >>> np.issubclass_(np.float64, float)\n    True\n\n    \"\"\"\n    try:\n        return issubclass(arg1, arg2)\n    except TypeError:\n        return False\n\n\n@set_module('numpy')\ndef issubsctype(arg1, arg2):\n    \"\"\"\n    Determine if the first argument is a subclass of the second argument.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype or dtype specifier\n        Data-types.\n\n    Returns\n    -------\n    out : bool\n        The result.\n\n    See Also\n    --------\n    issctype, issubdtype, obj2sctype\n\n    Examples\n    --------\n    >>> from numpy._core import issubsctype\n    >>> issubsctype('S8', str)\n    False\n    >>> issubsctype(np.array([1]), int)\n    True\n    >>> issubsctype(np.array([1]), float)\n    False\n\n    \"\"\"\n    return issubclass(obj2sctype(arg1), obj2sctype(arg2))\n\n\nclass _PreprocessDTypeError(Exception):\n    pass\n\n\ndef _preprocess_dtype(dtype):\n    \"\"\"\n    Preprocess dtype argument by:\n      1. fetching type from a data type\n      2. verifying that types are built-in NumPy dtypes\n    \"\"\"\n    if isinstance(dtype, ma.dtype):\n        dtype = dtype.type\n    if isinstance(dtype, ndarray) or dtype not in allTypes.values():\n        raise _PreprocessDTypeError\n    return dtype\n\n\n@set_module('numpy')\ndef isdtype(dtype, kind):\n    \"\"\"\n    Determine if a provided dtype is of a specified data type ``kind``.\n\n    This function only supports built-in NumPy's data types.\n    Third-party dtypes are not yet supported.\n\n    Parameters\n    ----------\n    dtype : dtype\n        The input dtype.\n    kind : dtype or str or tuple of dtypes/strs.\n        dtype or dtype kind. Allowed dtype kinds are:\n        * ``'bool'`` : boolean kind\n        * ``'signed integer'`` : signed integer data types\n        * ``'unsigned integer'`` : unsigned integer data types\n        * ``'integral'`` : integer data types\n        * ``'real floating'`` : real-valued floating-point data types\n        * ``'complex floating'`` : complex floating-point data types\n        * ``'numeric'`` : numeric data types\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    issubdtype\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.isdtype(np.float32, np.float64)\n    False\n    >>> np.isdtype(np.float32, \"real floating\")\n    True\n    >>> np.isdtype(np.complex128, (\"real floating\", \"complex floating\"))\n    True\n\n    \"\"\"\n    try:\n        dtype = _preprocess_dtype(dtype)\n    except _PreprocessDTypeError:\n        raise TypeError(\n            \"dtype argument must be a NumPy dtype, \"\n            f\"but it is a {type(dtype)}.\"\n        ) from None\n\n    input_kinds = kind if isinstance(kind, tuple) else (kind,)\n\n    processed_kinds = set()\n\n    for kind in input_kinds:\n        if kind == \"bool\":\n            processed_kinds.add(allTypes[\"bool\"])\n        elif kind == \"signed integer\":\n            processed_kinds.update(sctypes[\"int\"])\n        elif kind == \"unsigned integer\":\n            processed_kinds.update(sctypes[\"uint\"])\n        elif kind == \"integral\":\n            processed_kinds.update(sctypes[\"int\"] + sctypes[\"uint\"])\n        elif kind == \"real floating\":\n            processed_kinds.update(sctypes[\"float\"])\n        elif kind == \"complex floating\":\n            processed_kinds.update(sctypes[\"complex\"])\n        elif kind == \"numeric\":\n            processed_kinds.update(\n                sctypes[\"int\"] + sctypes[\"uint\"] +\n                sctypes[\"float\"] + sctypes[\"complex\"]\n            )\n        elif isinstance(kind, str):\n            raise ValueError(\n                \"kind argument is a string, but\"\n                f\" {kind!r} is not a known kind name.\"\n            )\n        else:\n            try:\n                kind = _preprocess_dtype(kind)\n            except _PreprocessDTypeError:\n                raise TypeError(\n                    \"kind argument must be comprised of \"\n                    \"NumPy dtypes or strings only, \"\n                    f\"but is a {type(kind)}.\"\n                ) from None\n            processed_kinds.add(kind)\n\n    return dtype in processed_kinds\n\n\n@set_module('numpy')\ndef issubdtype(arg1, arg2):\n    r\"\"\"\n    Returns True if first argument is a typecode lower/equal in type hierarchy.\n\n    This is like the builtin :func:`issubclass`, but for `dtype`\\ s.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype_like\n        `dtype` or object coercible to one\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    :ref:`arrays.scalars` : Overview of the numpy type hierarchy.\n\n    Examples\n    --------\n    `issubdtype` can be used to check the type of arrays:\n\n    >>> ints = np.array([1, 2, 3], dtype=np.int32)\n    >>> np.issubdtype(ints.dtype, np.integer)\n    True\n    >>> np.issubdtype(ints.dtype, np.floating)\n    False\n\n    >>> floats = np.array([1, 2, 3], dtype=np.float32)\n    >>> np.issubdtype(floats.dtype, np.integer)\n    False\n    >>> np.issubdtype(floats.dtype, np.floating)\n    True\n\n    Similar types of different sizes are not subdtypes of each other:\n\n    >>> np.issubdtype(np.float64, np.float32)\n    False\n    >>> np.issubdtype(np.float32, np.float64)\n    False\n\n    but both are subtypes of `floating`:\n\n    >>> np.issubdtype(np.float64, np.floating)\n    True\n    >>> np.issubdtype(np.float32, np.floating)\n    True\n\n    For convenience, dtype-like objects are allowed too:\n\n    >>> np.issubdtype('S1', np.bytes_)\n    True\n    >>> np.issubdtype('i4', np.signedinteger)\n    True\n\n    \"\"\"\n    if not issubclass_(arg1, generic):\n        arg1 = dtype(arg1).type\n    if not issubclass_(arg2, generic):\n        arg2 = dtype(arg2).type\n\n    return issubclass(arg1, arg2)\n\n\n@set_module('numpy')\ndef sctype2char(sctype):\n    \"\"\"\n    Return the string representation of a scalar dtype.\n\n    Parameters\n    ----------\n    sctype : scalar dtype or object\n        If a scalar dtype, the corresponding string character is\n        returned. If an object, `sctype2char` tries to infer its scalar type\n        and then return the corresponding string character.\n\n    Returns\n    -------\n    typechar : str\n        The string character corresponding to the scalar type.\n\n    Raises\n    ------\n    ValueError\n        If `sctype` is an object for which the type can not be inferred.\n\n    See Also\n    --------\n    obj2sctype, issctype, issubsctype, mintypecode\n\n    Examples\n    --------\n    >>> from numpy._core.numerictypes import sctype2char\n    >>> for sctype in [np.int32, np.double, np.cdouble, np.bytes_, np.ndarray]:\n    ...     print(sctype2char(sctype))\n    l # may vary\n    d\n    D\n    S\n    O\n\n    >>> x = np.array([1., 2-1.j])\n    >>> sctype2char(x)\n    'D'\n    >>> sctype2char(list)\n    'O'\n\n    \"\"\"\n    sctype = obj2sctype(sctype)\n    if sctype is None:\n        raise ValueError(\"unrecognized type\")\n    if sctype not in sctypeDict.values():\n        # for compatibility\n        raise KeyError(sctype)\n    return dtype(sctype).char\n\n\ndef _scalar_type_key(typ):\n    \"\"\"A ``key`` function for `sorted`.\"\"\"\n    dt = dtype(typ)\n    return (dt.kind.lower(), dt.itemsize)\n\n\nScalarType = [int, float, complex, bool, bytes, str, memoryview]\nScalarType += sorted(set(sctypeDict.values()), key=_scalar_type_key)\nScalarType = tuple(ScalarType)\n\n\n# Now add the types we've determined to this module\nfor key in allTypes:\n    globals()[key] = allTypes[key]\n    __all__.append(key)\n\ndel key\n\ntypecodes = {'Character': 'c',\n             'Integer': 'bhilqnp',\n             'UnsignedInteger': 'BHILQNP',\n             'Float': 'efdg',\n             'Complex': 'FDG',\n             'AllInteger': 'bBhHiIlLqQnNpP',\n             'AllFloat': 'efdgFDG',\n             'Datetime': 'Mm',\n             'All': '?bhilqnpBHILQNPefdgFDGSUVOMm'}\n\n# backwards compatibility --- deprecated name\n# Formal deprecation: Numpy 1.20.0, 2020-10-19 (see numpy/__init__.py)\ntypeDict = sctypeDict\n\ndef _register_types():\n    numbers.Integral.register(integer)\n    numbers.Complex.register(inexact)\n    numbers.Real.register(floating)\n    numbers.Number.register(number)\n\n\n_register_types()\n", 629], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py": ["\"\"\"\nThese are functions that are just aliases of existing functions in NumPy.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from typing import Optional, Sequence, Tuple, Union\n    from ._typing import ndarray, Device, Dtype\n\nfrom typing import NamedTuple\nimport inspect\n\nfrom ._helpers import array_namespace, _check_device, device, is_torch_array, is_cupy_namespace\n\n# These functions are modified from the NumPy versions.\n\n# Creation functions add the device keyword (which does nothing for NumPy)\n\ndef arange(\n    start: Union[int, float],\n    /,\n    stop: Optional[Union[int, float]] = None,\n    step: Union[int, float] = 1,\n    *,\n    xp,\n    dtype: Optional[Dtype] = None,\n    device: Optional[Device] = None,\n    **kwargs\n) -> ndarray:\n    _check_device(xp, device)\n    return xp.arange(start, stop=stop, step=step, dtype=dtype, **kwargs)\n\ndef empty(\n    shape: Union[int, Tuple[int, ...]],\n    xp,\n    *,\n    dtype: Optional[Dtype] = None,\n    device: Optional[Device] = None,\n    **kwargs\n) -> ndarray:\n    _check_device(xp, device)\n    return xp.empty(shape, dtype=dtype, **kwargs)\n\ndef empty_like(\n    x: ndarray, /, xp, *, dtype: Optional[Dtype] = None, device: Optional[Device] = None,\n    **kwargs\n) -> ndarray:\n    _check_device(xp, device)\n    return xp.empty_like(x, dtype=dtype, **kwargs)\n\ndef eye(\n    n_rows: int,\n    n_cols: Optional[int] = None,\n    /,\n    *,\n    xp,\n    k: int = 0,\n    dtype: Optional[Dtype] = None,\n    device: Optional[Device] = None,\n    **kwargs,\n) -> ndarray:\n    _check_device(xp, device)\n    return xp.eye(n_rows, M=n_cols, k=k, dtype=dtype, **kwargs)\n\ndef full(\n    shape: Union[int, Tuple[int, ...]],\n    fill_value: Union[int, float],\n    xp,\n    *,\n    dtype: Optional[Dtype] = None,\n    device: Optional[Device] = None,\n    **kwargs,\n) -> ndarray:\n    _check_device(xp, device)\n    return xp.full(shape, fill_value, dtype=dtype, **kwargs)\n\ndef full_like(\n    x: ndarray,\n    /,\n    fill_value: Union[int, float],\n    *,\n    xp,\n    dtype: Optional[Dtype] = None,\n    device: Optional[Device] = None,\n    **kwargs,\n) -> ndarray:\n    _check_device(xp, device)\n    return xp.full_like(x, fill_value, dtype=dtype, **kwargs)\n\ndef linspace(\n    start: Union[int, float],\n    stop: Union[int, float],\n    /,\n    num: int,\n    *,\n    xp,\n    dtype: Optional[Dtype] = None,\n    device: Optional[Device] = None,\n    endpoint: bool = True,\n    **kwargs,\n) -> ndarray:\n    _check_device(xp, device)\n    return xp.linspace(start, stop, num, dtype=dtype, endpoint=endpoint, **kwargs)\n\ndef ones(\n    shape: Union[int, Tuple[int, ...]],\n    xp,\n    *,\n    dtype: Optional[Dtype] = None,\n    device: Optional[Device] = None,\n    **kwargs,\n) -> ndarray:\n    _check_device(xp, device)\n    return xp.ones(shape, dtype=dtype, **kwargs)\n\ndef ones_like(\n    x: ndarray, /, xp, *, dtype: Optional[Dtype] = None, device: Optional[Device] = None,\n    **kwargs,\n) -> ndarray:\n    _check_device(xp, device)\n    return xp.ones_like(x, dtype=dtype, **kwargs)\n\ndef zeros(\n    shape: Union[int, Tuple[int, ...]],\n    xp,\n    *,\n    dtype: Optional[Dtype] = None,\n    device: Optional[Device] = None,\n    **kwargs,\n) -> ndarray:\n    _check_device(xp, device)\n    return xp.zeros(shape, dtype=dtype, **kwargs)\n\ndef zeros_like(\n    x: ndarray, /, xp, *, dtype: Optional[Dtype] = None, device: Optional[Device] = None,\n    **kwargs,\n) -> ndarray:\n    _check_device(xp, device)\n    return xp.zeros_like(x, dtype=dtype, **kwargs)\n\n# np.unique() is split into four functions in the array API:\n# unique_all, unique_counts, unique_inverse, and unique_values (this is done\n# to remove polymorphic return types).\n\n# The functions here return namedtuples (np.unique() returns a normal\n# tuple).\n\n# Note that these named tuples aren't actually part of the standard namespace,\n# but I don't see any issue with exporting the names here regardless.\nclass UniqueAllResult(NamedTuple):\n    values: ndarray\n    indices: ndarray\n    inverse_indices: ndarray\n    counts: ndarray\n\n\nclass UniqueCountsResult(NamedTuple):\n    values: ndarray\n    counts: ndarray\n\n\nclass UniqueInverseResult(NamedTuple):\n    values: ndarray\n    inverse_indices: ndarray\n\n\ndef _unique_kwargs(xp):\n    # Older versions of NumPy and CuPy do not have equal_nan. Rather than\n    # trying to parse version numbers, just check if equal_nan is in the\n    # signature.\n    s = inspect.signature(xp.unique)\n    if 'equal_nan' in s.parameters:\n        return {'equal_nan': False}\n    return {}\n\ndef unique_all(x: ndarray, /, xp) -> UniqueAllResult:\n    kwargs = _unique_kwargs(xp)\n    values, indices, inverse_indices, counts = xp.unique(\n        x,\n        return_counts=True,\n        return_index=True,\n        return_inverse=True,\n        **kwargs,\n    )\n    # np.unique() flattens inverse indices, but they need to share x's shape\n    # See https://github.com/numpy/numpy/issues/20638\n    inverse_indices = inverse_indices.reshape(x.shape)\n    return UniqueAllResult(\n        values,\n        indices,\n        inverse_indices,\n        counts,\n    )\n\n\ndef unique_counts(x: ndarray, /, xp) -> UniqueCountsResult:\n    kwargs = _unique_kwargs(xp)\n    res = xp.unique(\n        x,\n        return_counts=True,\n        return_index=False,\n        return_inverse=False,\n        **kwargs\n    )\n\n    return UniqueCountsResult(*res)\n\n\ndef unique_inverse(x: ndarray, /, xp) -> UniqueInverseResult:\n    kwargs = _unique_kwargs(xp)\n    values, inverse_indices = xp.unique(\n        x,\n        return_counts=False,\n        return_index=False,\n        return_inverse=True,\n        **kwargs,\n    )\n    # xp.unique() flattens inverse indices, but they need to share x's shape\n    # See https://github.com/numpy/numpy/issues/20638\n    inverse_indices = inverse_indices.reshape(x.shape)\n    return UniqueInverseResult(values, inverse_indices)\n\n\ndef unique_values(x: ndarray, /, xp) -> ndarray:\n    kwargs = _unique_kwargs(xp)\n    return xp.unique(\n        x,\n        return_counts=False,\n        return_index=False,\n        return_inverse=False,\n        **kwargs,\n    )\n\ndef astype(x: ndarray, dtype: Dtype, /, *, copy: bool = True) -> ndarray:\n    if not copy and dtype == x.dtype:\n        return x\n    return x.astype(dtype=dtype, copy=copy)\n\n# These functions have different keyword argument names\n\ndef std(\n    x: ndarray,\n    /,\n    xp,\n    *,\n    axis: Optional[Union[int, Tuple[int, ...]]] = None,\n    correction: Union[int, float] = 0.0, # correction instead of ddof\n    keepdims: bool = False,\n    **kwargs,\n) -> ndarray:\n    return xp.std(x, axis=axis, ddof=correction, keepdims=keepdims, **kwargs)\n\ndef var(\n    x: ndarray,\n    /,\n    xp,\n    *,\n    axis: Optional[Union[int, Tuple[int, ...]]] = None,\n    correction: Union[int, float] = 0.0, # correction instead of ddof\n    keepdims: bool = False,\n    **kwargs,\n) -> ndarray:\n    return xp.var(x, axis=axis, ddof=correction, keepdims=keepdims, **kwargs)\n\n# cumulative_sum is renamed from cumsum, and adds the include_initial keyword\n# argument\n\ndef cumulative_sum(\n    x: ndarray,\n    /,\n    xp,\n    *,\n    axis: Optional[int] = None,\n    dtype: Optional[Dtype] = None,\n    include_initial: bool = False,\n    **kwargs\n) -> ndarray:\n    wrapped_xp = array_namespace(x)\n\n    # TODO: The standard is not clear about what should happen when x.ndim == 0.\n    if axis is None:\n        if x.ndim > 1:\n            raise ValueError(\"axis must be specified in cumulative_sum for more than one dimension\")\n        axis = 0\n\n    res = xp.cumsum(x, axis=axis, dtype=dtype, **kwargs)\n\n    # np.cumsum does not support include_initial\n    if include_initial:\n        initial_shape = list(x.shape)\n        initial_shape[axis] = 1\n        res = xp.concatenate(\n            [wrapped_xp.zeros(shape=initial_shape, dtype=res.dtype, device=device(res)), res],\n            axis=axis,\n        )\n    return res\n\n# The min and max argument names in clip are different and not optional in numpy, and type\n# promotion behavior is different.\ndef clip(\n    x: ndarray,\n    /,\n    min: Optional[Union[int, float, ndarray]] = None,\n    max: Optional[Union[int, float, ndarray]] = None,\n    *,\n    xp,\n    # TODO: np.clip has other ufunc kwargs\n    out: Optional[ndarray] = None,\n) -> ndarray:\n    def _isscalar(a):\n        return isinstance(a, (int, float, type(None)))\n    min_shape = () if _isscalar(min) else min.shape\n    max_shape = () if _isscalar(max) else max.shape\n\n    wrapped_xp = array_namespace(x)\n\n    result_shape = xp.broadcast_shapes(x.shape, min_shape, max_shape)\n\n    # np.clip does type promotion but the array API clip requires that the\n    # output have the same dtype as x. We do this instead of just downcasting\n    # the result of xp.clip() to handle some corner cases better (e.g.,\n    # avoiding uint64 -> float64 promotion).\n\n    # Note: cases where min or max overflow (integer) or round (float) in the\n    # wrong direction when downcasting to x.dtype are unspecified. This code\n    # just does whatever NumPy does when it downcasts in the assignment, but\n    # other behavior could be preferred, especially for integers. For example,\n    # this code produces:\n\n    # >>> clip(asarray(0, dtype=int8), asarray(128, dtype=int16), None)\n    # -128\n\n    # but an answer of 0 might be preferred. See\n    # https://github.com/numpy/numpy/issues/24976 for more discussion on this issue.\n\n\n    # At least handle the case of Python integers correctly (see\n    # https://github.com/numpy/numpy/pull/26892).\n    if type(min) is int and min <= wrapped_xp.iinfo(x.dtype).min:\n        min = None\n    if type(max) is int and max >= wrapped_xp.iinfo(x.dtype).max:\n        max = None\n\n    if out is None:\n        out = wrapped_xp.asarray(xp.broadcast_to(x, result_shape),\n                                 copy=True, device=device(x))\n    if min is not None:\n        if is_torch_array(x) and x.dtype == xp.float64 and _isscalar(min):\n            # Avoid loss of precision due to torch defaulting to float32\n            min = wrapped_xp.asarray(min, dtype=xp.float64)\n        a = xp.broadcast_to(wrapped_xp.asarray(min, device=device(x)), result_shape)\n        ia = (out < a) | xp.isnan(a)\n        # torch requires an explicit cast here\n        out[ia] = wrapped_xp.astype(a[ia], out.dtype)\n    if max is not None:\n        if is_torch_array(x) and x.dtype == xp.float64 and _isscalar(max):\n            max = wrapped_xp.asarray(max, dtype=xp.float64)\n        b = xp.broadcast_to(wrapped_xp.asarray(max, device=device(x)), result_shape)\n        ib = (out > b) | xp.isnan(b)\n        out[ib] = wrapped_xp.astype(b[ib], out.dtype)\n    # Return a scalar for 0-D\n    return out[()]\n\n# Unlike transpose(), the axes argument to permute_dims() is required.\ndef permute_dims(x: ndarray, /, axes: Tuple[int, ...], xp) -> ndarray:\n    return xp.transpose(x, axes)\n\n# np.reshape calls the keyword argument 'newshape' instead of 'shape'\ndef reshape(x: ndarray,\n            /,\n            shape: Tuple[int, ...],\n            xp, copy: Optional[bool] = None,\n            **kwargs) -> ndarray:\n    if copy is True:\n        x = x.copy()\n    elif copy is False:\n        y = x.view()\n        y.shape = shape\n        return y\n    return xp.reshape(x, shape, **kwargs)\n\n# The descending keyword is new in sort and argsort, and 'kind' replaced with\n# 'stable'\ndef argsort(\n    x: ndarray, /, xp, *, axis: int = -1, descending: bool = False, stable: bool = True,\n    **kwargs,\n) -> ndarray:\n    # Note: this keyword argument is different, and the default is different.\n    # We set it in kwargs like this because numpy.sort uses kind='quicksort'\n    # as the default whereas cupy.sort uses kind=None.\n    if stable:\n        kwargs['kind'] = \"stable\"\n    if not descending:\n        res = xp.argsort(x, axis=axis, **kwargs)\n    else:\n        # As NumPy has no native descending sort, we imitate it here. Note that\n        # simply flipping the results of xp.argsort(x, ...) would not\n        # respect the relative order like it would in native descending sorts.\n        res = xp.flip(\n            xp.argsort(xp.flip(x, axis=axis), axis=axis, **kwargs),\n            axis=axis,\n        )\n        # Rely on flip()/argsort() to validate axis\n        normalised_axis = axis if axis >= 0 else x.ndim + axis\n        max_i = x.shape[normalised_axis] - 1\n        res = max_i - res\n    return res\n\ndef sort(\n    x: ndarray, /, xp, *, axis: int = -1, descending: bool = False, stable: bool = True,\n    **kwargs,\n) -> ndarray:\n    # Note: this keyword argument is different, and the default is different.\n    # We set it in kwargs like this because numpy.sort uses kind='quicksort'\n    # as the default whereas cupy.sort uses kind=None.\n    if stable:\n        kwargs['kind'] = \"stable\"\n    res = xp.sort(x, axis=axis, **kwargs)\n    if descending:\n        res = xp.flip(res, axis=axis)\n    return res\n\n# nonzero should error for zero-dimensional arrays\ndef nonzero(x: ndarray, /, xp, **kwargs) -> Tuple[ndarray, ...]:\n    if x.ndim == 0:\n        raise ValueError(\"nonzero() does not support zero-dimensional arrays\")\n    return xp.nonzero(x, **kwargs)\n\n# ceil, floor, and trunc return integers for integer inputs\n\ndef ceil(x: ndarray, /, xp, **kwargs) -> ndarray:\n    if xp.issubdtype(x.dtype, xp.integer):\n        return x\n    return xp.ceil(x, **kwargs)\n\ndef floor(x: ndarray, /, xp, **kwargs) -> ndarray:\n    if xp.issubdtype(x.dtype, xp.integer):\n        return x\n    return xp.floor(x, **kwargs)\n\ndef trunc(x: ndarray, /, xp, **kwargs) -> ndarray:\n    if xp.issubdtype(x.dtype, xp.integer):\n        return x\n    return xp.trunc(x, **kwargs)\n\n# linear algebra functions\n\ndef matmul(x1: ndarray, x2: ndarray, /, xp, **kwargs) -> ndarray:\n    return xp.matmul(x1, x2, **kwargs)\n\n# Unlike transpose, matrix_transpose only transposes the last two axes.\ndef matrix_transpose(x: ndarray, /, xp) -> ndarray:\n    if x.ndim < 2:\n        raise ValueError(\"x must be at least 2-dimensional for matrix_transpose\")\n    return xp.swapaxes(x, -1, -2)\n\ndef tensordot(x1: ndarray,\n              x2: ndarray,\n              /,\n              xp,\n              *,\n              axes: Union[int, Tuple[Sequence[int], Sequence[int]]] = 2,\n              **kwargs,\n) -> ndarray:\n    return xp.tensordot(x1, x2, axes=axes, **kwargs)\n\ndef vecdot(x1: ndarray, x2: ndarray, /, xp, *, axis: int = -1) -> ndarray:\n    if x1.shape[axis] != x2.shape[axis]:\n        raise ValueError(\"x1 and x2 must have the same size along the given axis\")\n\n    if hasattr(xp, 'broadcast_tensors'):\n        _broadcast = xp.broadcast_tensors\n    else:\n        _broadcast = xp.broadcast_arrays\n\n    x1_ = xp.moveaxis(x1, axis, -1)\n    x2_ = xp.moveaxis(x2, axis, -1)\n    x1_, x2_ = _broadcast(x1_, x2_)\n\n    res = x1_[..., None, :] @ x2_[..., None]\n    return res[..., 0, 0]\n\n# isdtype is a new function in the 2022.12 array API specification.\n\ndef isdtype(\n    dtype: Dtype, kind: Union[Dtype, str, Tuple[Union[Dtype, str], ...]], xp,\n    *, _tuple=True, # Disallow nested tuples\n) -> bool:\n    \"\"\"\n    Returns a boolean indicating whether a provided dtype is of a specified data type ``kind``.\n\n    Note that outside of this function, this compat library does not yet fully\n    support complex numbers.\n\n    See\n    https://data-apis.org/array-api/latest/API_specification/generated/array_api.isdtype.html\n    for more details\n    \"\"\"\n    if isinstance(kind, tuple) and _tuple:\n        return any(isdtype(dtype, k, xp, _tuple=False) for k in kind)\n    elif isinstance(kind, str):\n        if kind == 'bool':\n            return dtype == xp.bool_\n        elif kind == 'signed integer':\n            return xp.issubdtype(dtype, xp.signedinteger)\n        elif kind == 'unsigned integer':\n            return xp.issubdtype(dtype, xp.unsignedinteger)\n        elif kind == 'integral':\n            return xp.issubdtype(dtype, xp.integer)\n        elif kind == 'real floating':\n            return xp.issubdtype(dtype, xp.floating)\n        elif kind == 'complex floating':\n            return xp.issubdtype(dtype, xp.complexfloating)\n        elif kind == 'numeric':\n            return xp.issubdtype(dtype, xp.number)\n        else:\n            raise ValueError(f\"Unrecognized data type kind: {kind!r}\")\n    else:\n        # This will allow things that aren't required by the spec, like\n        # isdtype(np.float64, float) or isdtype(np.int64, 'l'). Should we be\n        # more strict here to match the type annotation? Note that the\n        # array_api_strict implementation will be very strict.\n        return dtype == kind\n\n# unstack is a new function in the 2023.12 array API standard\ndef unstack(x: ndarray, /, xp, *, axis: int = 0) -> Tuple[ndarray, ...]:\n    if x.ndim == 0:\n        raise ValueError(\"Input array must be at least 1-d.\")\n    return tuple(xp.moveaxis(x, axis, 0))\n\n# numpy 1.26 does not use the standard definition for sign on complex numbers\n\ndef sign(x: ndarray, /, xp, **kwargs) -> ndarray:\n    if isdtype(x.dtype, 'complex floating', xp=xp):\n        out = (x/xp.abs(x, **kwargs))[...]\n        # sign(0) = 0 but the above formula would give nan\n        out[x == 0+0j] = 0+0j\n    else:\n        out = xp.sign(x, **kwargs)\n    # CuPy sign() does not propagate nans. See\n    # https://github.com/data-apis/array-api-compat/issues/136\n    if is_cupy_namespace(xp) and isdtype(x.dtype, 'real floating', xp=xp):\n        out[xp.isnan(x)] = xp.nan\n    return out[()]\n\n__all__ = ['arange', 'empty', 'empty_like', 'eye', 'full', 'full_like',\n           'linspace', 'ones', 'ones_like', 'zeros', 'zeros_like',\n           'UniqueAllResult', 'UniqueCountsResult', 'UniqueInverseResult',\n           'unique_all', 'unique_counts', 'unique_inverse', 'unique_values',\n           'astype', 'std', 'var', 'cumulative_sum', 'clip', 'permute_dims',\n           'reshape', 'argsort', 'sort', 'nonzero', 'ceil', 'floor', 'trunc',\n           'matmul', 'matrix_transpose', 'tensordot', 'vecdot', 'isdtype',\n           'unstack', 'sign']\n", 555], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/_internal.py": ["\"\"\"\nInternal helpers\n\"\"\"\n\nfrom functools import wraps\nfrom inspect import signature\n\ndef get_xp(xp):\n    \"\"\"\n    Decorator to automatically replace xp with the corresponding array module.\n\n    Use like\n\n    import numpy as np\n\n    @get_xp(np)\n    def func(x, /, xp, kwarg=None):\n        return xp.func(x, kwarg=kwarg)\n\n    Note that xp must be a keyword argument and come after all non-keyword\n    arguments.\n\n    \"\"\"\n\n    def inner(f):\n        @wraps(f)\n        def wrapped_f(*args, **kwargs):\n            return f(*args, xp=xp, **kwargs)\n\n        sig = signature(f)\n        new_sig = sig.replace(\n            parameters=[sig.parameters[i] for i in sig.parameters if i != \"xp\"]\n        )\n\n        if wrapped_f.__doc__ is None:\n            wrapped_f.__doc__ = f\"\"\"\\\nArray API compatibility wrapper for {f.__name__}.\n\nSee the corresponding documentation in NumPy/CuPy and/or the array API\nspecification for more details.\n\n\"\"\"\n        wrapped_f.__signature__ = new_sig\n        return wrapped_f\n\n    return inner\n", 46], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py": ["\"\"\"\nThis module implements the Sequential Least Squares Programming optimization\nalgorithm (SLSQP), originally developed by Dieter Kraft.\nSee http://www.netlib.org/toms/733\n\nFunctions\n---------\n.. autosummary::\n   :toctree: generated/\n\n    approx_jacobian\n    fmin_slsqp\n\n\"\"\"\n\n__all__ = ['approx_jacobian', 'fmin_slsqp']\n\nimport numpy as np\nfrom scipy.optimize._slsqp import slsqp\nfrom numpy import (zeros, array, linalg, append, concatenate, finfo,\n                   sqrt, vstack, isfinite, atleast_1d)\nfrom ._optimize import (OptimizeResult, _check_unknown_options,\n                        _prepare_scalar_function, _clip_x_for_func,\n                        _check_clip_x)\nfrom ._numdiff import approx_derivative\nfrom ._constraints import old_bound_to_new, _arr_to_scalar\nfrom scipy._lib._array_api import array_namespace\nfrom scipy._lib import array_api_extra as xpx\n\n\n__docformat__ = \"restructuredtext en\"\n\n_epsilon = sqrt(finfo(float).eps)\n\n\ndef approx_jacobian(x, func, epsilon, *args):\n    \"\"\"\n    Approximate the Jacobian matrix of a callable function.\n\n    Parameters\n    ----------\n    x : array_like\n        The state vector at which to compute the Jacobian matrix.\n    func : callable f(x,*args)\n        The vector-valued function.\n    epsilon : float\n        The perturbation used to determine the partial derivatives.\n    args : sequence\n        Additional arguments passed to func.\n\n    Returns\n    -------\n    An array of dimensions ``(lenf, lenx)`` where ``lenf`` is the length\n    of the outputs of `func`, and ``lenx`` is the number of elements in\n    `x`.\n\n    Notes\n    -----\n    The approximation is done using forward differences.\n\n    \"\"\"\n    # approx_derivative returns (m, n) == (lenf, lenx)\n    jac = approx_derivative(func, x, method='2-point', abs_step=epsilon,\n                            args=args)\n    # if func returns a scalar jac.shape will be (lenx,). Make sure\n    # it's at least a 2D array.\n    return np.atleast_2d(jac)\n\n\ndef fmin_slsqp(func, x0, eqcons=(), f_eqcons=None, ieqcons=(), f_ieqcons=None,\n               bounds=(), fprime=None, fprime_eqcons=None,\n               fprime_ieqcons=None, args=(), iter=100, acc=1.0E-6,\n               iprint=1, disp=None, full_output=0, epsilon=_epsilon,\n               callback=None):\n    \"\"\"\n    Minimize a function using Sequential Least Squares Programming\n\n    Python interface function for the SLSQP Optimization subroutine\n    originally implemented by Dieter Kraft.\n\n    Parameters\n    ----------\n    func : callable f(x,*args)\n        Objective function.  Must return a scalar.\n    x0 : 1-D ndarray of float\n        Initial guess for the independent variable(s).\n    eqcons : list, optional\n        A list of functions of length n such that\n        eqcons[j](x,*args) == 0.0 in a successfully optimized\n        problem.\n    f_eqcons : callable f(x,*args), optional\n        Returns a 1-D array in which each element must equal 0.0 in a\n        successfully optimized problem. If f_eqcons is specified,\n        eqcons is ignored.\n    ieqcons : list, optional\n        A list of functions of length n such that\n        ieqcons[j](x,*args) >= 0.0 in a successfully optimized\n        problem.\n    f_ieqcons : callable f(x,*args), optional\n        Returns a 1-D ndarray in which each element must be greater or\n        equal to 0.0 in a successfully optimized problem. If\n        f_ieqcons is specified, ieqcons is ignored.\n    bounds : list, optional\n        A list of tuples specifying the lower and upper bound\n        for each independent variable [(xl0, xu0),(xl1, xu1),...]\n        Infinite values will be interpreted as large floating values.\n    fprime : callable ``f(x,*args)``, optional\n        A function that evaluates the partial derivatives of func.\n    fprime_eqcons : callable ``f(x,*args)``, optional\n        A function of the form ``f(x, *args)`` that returns the m by n\n        array of equality constraint normals. If not provided,\n        the normals will be approximated. The array returned by\n        fprime_eqcons should be sized as ( len(eqcons), len(x0) ).\n    fprime_ieqcons : callable ``f(x,*args)``, optional\n        A function of the form ``f(x, *args)`` that returns the m by n\n        array of inequality constraint normals. If not provided,\n        the normals will be approximated. The array returned by\n        fprime_ieqcons should be sized as ( len(ieqcons), len(x0) ).\n    args : sequence, optional\n        Additional arguments passed to func and fprime.\n    iter : int, optional\n        The maximum number of iterations.\n    acc : float, optional\n        Requested accuracy.\n    iprint : int, optional\n        The verbosity of fmin_slsqp :\n\n        * iprint <= 0 : Silent operation\n        * iprint == 1 : Print summary upon completion (default)\n        * iprint >= 2 : Print status of each iterate and summary\n    disp : int, optional\n        Overrides the iprint interface (preferred).\n    full_output : bool, optional\n        If False, return only the minimizer of func (default).\n        Otherwise, output final objective function and summary\n        information.\n    epsilon : float, optional\n        The step size for finite-difference derivative estimates.\n    callback : callable, optional\n        Called after each iteration, as ``callback(x)``, where ``x`` is the\n        current parameter vector.\n\n    Returns\n    -------\n    out : ndarray of float\n        The final minimizer of func.\n    fx : ndarray of float, if full_output is true\n        The final value of the objective function.\n    its : int, if full_output is true\n        The number of iterations.\n    imode : int, if full_output is true\n        The exit mode from the optimizer (see below).\n    smode : string, if full_output is true\n        Message describing the exit mode from the optimizer.\n\n    See also\n    --------\n    minimize: Interface to minimization algorithms for multivariate\n        functions. See the 'SLSQP' `method` in particular.\n\n    Notes\n    -----\n    Exit modes are defined as follows:\n\n    - ``-1`` : Gradient evaluation required (g & a)\n    - ``0`` : Optimization terminated successfully\n    - ``1`` : Function evaluation required (f & c)\n    - ``2`` : More equality constraints than independent variables\n    - ``3`` : More than 3*n iterations in LSQ subproblem\n    - ``4`` : Inequality constraints incompatible\n    - ``5`` : Singular matrix E in LSQ subproblem\n    - ``6`` : Singular matrix C in LSQ subproblem\n    - ``7`` : Rank-deficient equality constraint subproblem HFTI\n    - ``8`` : Positive directional derivative for linesearch\n    - ``9`` : Iteration limit reached\n\n    Examples\n    --------\n    Examples are given :ref:`in the tutorial <tutorial-sqlsp>`.\n\n    \"\"\"\n    if disp is not None:\n        iprint = disp\n\n    opts = {'maxiter': iter,\n            'ftol': acc,\n            'iprint': iprint,\n            'disp': iprint != 0,\n            'eps': epsilon,\n            'callback': callback}\n\n    # Build the constraints as a tuple of dictionaries\n    cons = ()\n    # 1. constraints of the 1st kind (eqcons, ieqcons); no Jacobian; take\n    #    the same extra arguments as the objective function.\n    cons += tuple({'type': 'eq', 'fun': c, 'args': args} for c in eqcons)\n    cons += tuple({'type': 'ineq', 'fun': c, 'args': args} for c in ieqcons)\n    # 2. constraints of the 2nd kind (f_eqcons, f_ieqcons) and their Jacobian\n    #    (fprime_eqcons, fprime_ieqcons); also take the same extra arguments\n    #    as the objective function.\n    if f_eqcons:\n        cons += ({'type': 'eq', 'fun': f_eqcons, 'jac': fprime_eqcons,\n                  'args': args}, )\n    if f_ieqcons:\n        cons += ({'type': 'ineq', 'fun': f_ieqcons, 'jac': fprime_ieqcons,\n                  'args': args}, )\n\n    res = _minimize_slsqp(func, x0, args, jac=fprime, bounds=bounds,\n                          constraints=cons, **opts)\n    if full_output:\n        return res['x'], res['fun'], res['nit'], res['status'], res['message']\n    else:\n        return res['x']\n\n\ndef _minimize_slsqp(func, x0, args=(), jac=None, bounds=None,\n                    constraints=(),\n                    maxiter=100, ftol=1.0E-6, iprint=1, disp=False,\n                    eps=_epsilon, callback=None, finite_diff_rel_step=None,\n                    **unknown_options):\n    \"\"\"\n    Minimize a scalar function of one or more variables using Sequential\n    Least Squares Programming (SLSQP).\n\n    Options\n    -------\n    ftol : float\n        Precision goal for the value of f in the stopping criterion.\n    eps : float\n        Step size used for numerical approximation of the Jacobian.\n    disp : bool\n        Set to True to print convergence messages. If False,\n        `verbosity` is ignored and set to 0.\n    maxiter : int\n        Maximum number of iterations.\n    finite_diff_rel_step : None or array_like, optional\n        If ``jac in ['2-point', '3-point', 'cs']`` the relative step size to\n        use for numerical approximation of `jac`. The absolute step\n        size is computed as ``h = rel_step * sign(x) * max(1, abs(x))``,\n        possibly adjusted to fit into the bounds. For ``method='3-point'``\n        the sign of `h` is ignored. If None (default) then step is selected\n        automatically.\n    \"\"\"\n    _check_unknown_options(unknown_options)\n    iter = maxiter - 1\n    acc = ftol\n    epsilon = eps\n\n    if not disp:\n        iprint = 0\n\n    # Transform x0 into an array.\n    xp = array_namespace(x0)\n    x0 = xpx.atleast_nd(xp.asarray(x0), ndim=1, xp=xp)\n    dtype = xp.float64\n    if xp.isdtype(x0.dtype, \"real floating\"):\n        dtype = x0.dtype\n    x = xp.reshape(xp.astype(x0, dtype), -1)\n\n    # SLSQP is sent 'old-style' bounds, 'new-style' bounds are required by\n    # ScalarFunction\n    if bounds is None or len(bounds) == 0:\n        new_bounds = (-np.inf, np.inf)\n    else:\n        new_bounds = old_bound_to_new(bounds)\n\n    # clip the initial guess to bounds, otherwise ScalarFunction doesn't work\n    x = np.clip(x, new_bounds[0], new_bounds[1])\n\n    # Constraints are triaged per type into a dictionary of tuples\n    if isinstance(constraints, dict):\n        constraints = (constraints, )\n\n    cons = {'eq': (), 'ineq': ()}\n    for ic, con in enumerate(constraints):\n        # check type\n        try:\n            ctype = con['type'].lower()\n        except KeyError as e:\n            raise KeyError('Constraint %d has no type defined.' % ic) from e\n        except TypeError as e:\n            raise TypeError('Constraints must be defined using a '\n                            'dictionary.') from e\n        except AttributeError as e:\n            raise TypeError(\"Constraint's type must be a string.\") from e\n        else:\n            if ctype not in ['eq', 'ineq']:\n                raise ValueError(f\"Unknown constraint type '{con['type']}'.\")\n\n        # check function\n        if 'fun' not in con:\n            raise ValueError('Constraint %d has no function defined.' % ic)\n\n        # check Jacobian\n        cjac = con.get('jac')\n        if cjac is None:\n            # approximate Jacobian function. The factory function is needed\n            # to keep a reference to `fun`, see gh-4240.\n            def cjac_factory(fun):\n                def cjac(x, *args):\n                    x = _check_clip_x(x, new_bounds)\n\n                    if jac in ['2-point', '3-point', 'cs']:\n                        return approx_derivative(fun, x, method=jac, args=args,\n                                                 rel_step=finite_diff_rel_step,\n                                                 bounds=new_bounds)\n                    else:\n                        return approx_derivative(fun, x, method='2-point',\n                                                 abs_step=epsilon, args=args,\n                                                 bounds=new_bounds)\n\n                return cjac\n            cjac = cjac_factory(con['fun'])\n\n        # update constraints' dictionary\n        cons[ctype] += ({'fun': con['fun'],\n                         'jac': cjac,\n                         'args': con.get('args', ())}, )\n\n    exit_modes = {-1: \"Gradient evaluation required (g & a)\",\n                   0: \"Optimization terminated successfully\",\n                   1: \"Function evaluation required (f & c)\",\n                   2: \"More equality constraints than independent variables\",\n                   3: \"More than 3*n iterations in LSQ subproblem\",\n                   4: \"Inequality constraints incompatible\",\n                   5: \"Singular matrix E in LSQ subproblem\",\n                   6: \"Singular matrix C in LSQ subproblem\",\n                   7: \"Rank-deficient equality constraint subproblem HFTI\",\n                   8: \"Positive directional derivative for linesearch\",\n                   9: \"Iteration limit reached\"}\n\n    # Set the parameters that SLSQP will need\n    # meq, mieq: number of equality and inequality constraints\n    meq = sum(map(len, [atleast_1d(c['fun'](x, *c['args']))\n              for c in cons['eq']]))\n    mieq = sum(map(len, [atleast_1d(c['fun'](x, *c['args']))\n               for c in cons['ineq']]))\n    # m = The total number of constraints\n    m = meq + mieq\n    # la = The number of constraints, or 1 if there are no constraints\n    la = array([1, m]).max()\n    # n = The number of independent variables\n    n = len(x)\n\n    # Define the workspaces for SLSQP\n    n1 = n + 1\n    mineq = m - meq + n1 + n1\n    len_w = (3*n1+m)*(n1+1)+(n1-meq+1)*(mineq+2) + 2*mineq+(n1+mineq)*(n1-meq) \\\n            + 2*meq + n1 + ((n+1)*n)//2 + 2*m + 3*n + 3*n1 + 1\n    len_jw = mineq\n    w = zeros(len_w)\n    jw = zeros(len_jw)\n\n    # Decompose bounds into xl and xu\n    if bounds is None or len(bounds) == 0:\n        xl = np.empty(n, dtype=float)\n        xu = np.empty(n, dtype=float)\n        xl.fill(np.nan)\n        xu.fill(np.nan)\n    else:\n        bnds = array([(_arr_to_scalar(l), _arr_to_scalar(u))\n                      for (l, u) in bounds], float)\n        if bnds.shape[0] != n:\n            raise IndexError('SLSQP Error: the length of bounds is not '\n                             'compatible with that of x0.')\n\n        with np.errstate(invalid='ignore'):\n            bnderr = bnds[:, 0] > bnds[:, 1]\n\n        if bnderr.any():\n            raise ValueError(\"SLSQP Error: lb > ub in bounds \"\n                             f\"{', '.join(str(b) for b in bnderr)}.\")\n        xl, xu = bnds[:, 0], bnds[:, 1]\n\n        # Mark infinite bounds with nans; the Fortran code understands this\n        infbnd = ~isfinite(bnds)\n        xl[infbnd[:, 0]] = np.nan\n        xu[infbnd[:, 1]] = np.nan\n\n    # ScalarFunction provides function and gradient evaluation\n    sf = _prepare_scalar_function(func, x, jac=jac, args=args, epsilon=eps,\n                                  finite_diff_rel_step=finite_diff_rel_step,\n                                  bounds=new_bounds)\n    # gh11403 SLSQP sometimes exceeds bounds by 1 or 2 ULP, make sure this\n    # doesn't get sent to the func/grad evaluator.\n    wrapped_fun = _clip_x_for_func(sf.fun, new_bounds)\n    wrapped_grad = _clip_x_for_func(sf.grad, new_bounds)\n\n    # Initialize the iteration counter and the mode value\n    mode = array(0, int)\n    acc = array(acc, float)\n    majiter = array(iter, int)\n    majiter_prev = 0\n\n    # Initialize internal SLSQP state variables\n    alpha = array(0, float)\n    f0 = array(0, float)\n    gs = array(0, float)\n    h1 = array(0, float)\n    h2 = array(0, float)\n    h3 = array(0, float)\n    h4 = array(0, float)\n    t = array(0, float)\n    t0 = array(0, float)\n    tol = array(0, float)\n    iexact = array(0, int)\n    incons = array(0, int)\n    ireset = array(0, int)\n    itermx = array(0, int)\n    line = array(0, int)\n    n1 = array(0, int)\n    n2 = array(0, int)\n    n3 = array(0, int)\n\n    # Print the header if iprint >= 2\n    if iprint >= 2:\n        print(\"%5s %5s %16s %16s\" % (\"NIT\", \"FC\", \"OBJFUN\", \"GNORM\"))\n\n    # mode is zero on entry, so call objective, constraints and gradients\n    # there should be no func evaluations here because it's cached from\n    # ScalarFunction\n    fx = wrapped_fun(x)\n    g = append(wrapped_grad(x), 0.0)\n    c = _eval_constraint(x, cons)\n    a = _eval_con_normals(x, cons, la, n, m, meq, mieq)\n\n    while 1:\n        # Call SLSQP\n        slsqp(m, meq, x, xl, xu, fx, c, g, a, acc, majiter, mode, w, jw,\n              alpha, f0, gs, h1, h2, h3, h4, t, t0, tol,\n              iexact, incons, ireset, itermx, line,\n              n1, n2, n3)\n\n        if mode == 1:  # objective and constraint evaluation required\n            fx = wrapped_fun(x)\n            c = _eval_constraint(x, cons)\n\n        if mode == -1:  # gradient evaluation required\n            g = append(wrapped_grad(x), 0.0)\n            a = _eval_con_normals(x, cons, la, n, m, meq, mieq)\n\n        if majiter > majiter_prev:\n            # call callback if major iteration has incremented\n            if callback is not None:\n                callback(np.copy(x))\n\n            # Print the status of the current iterate if iprint > 2\n            if iprint >= 2:\n                print(\"%5i %5i % 16.6E % 16.6E\" % (majiter, sf.nfev,\n                                                   fx, linalg.norm(g)))\n\n        # If exit mode is not -1 or 1, slsqp has completed\n        if abs(mode) != 1:\n            break\n\n        majiter_prev = int(majiter)\n\n    # Optimization loop complete. Print status if requested\n    if iprint >= 1:\n        print(exit_modes[int(mode)] + \"    (Exit mode \" + str(mode) + ')')\n        print(\"            Current function value:\", fx)\n        print(\"            Iterations:\", majiter)\n        print(\"            Function evaluations:\", sf.nfev)\n        print(\"            Gradient evaluations:\", sf.ngev)\n\n    return OptimizeResult(x=x, fun=fx, jac=g[:-1], nit=int(majiter),\n                          nfev=sf.nfev, njev=sf.ngev, status=int(mode),\n                          message=exit_modes[int(mode)], success=(mode == 0))\n\n\ndef _eval_constraint(x, cons):\n    # Compute constraints\n    if cons['eq']:\n        c_eq = concatenate([atleast_1d(con['fun'](x, *con['args']))\n                            for con in cons['eq']])\n    else:\n        c_eq = zeros(0)\n\n    if cons['ineq']:\n        c_ieq = concatenate([atleast_1d(con['fun'](x, *con['args']))\n                             for con in cons['ineq']])\n    else:\n        c_ieq = zeros(0)\n\n    # Now combine c_eq and c_ieq into a single matrix\n    c = concatenate((c_eq, c_ieq))\n    return c\n\n\ndef _eval_con_normals(x, cons, la, n, m, meq, mieq):\n    # Compute the normals of the constraints\n    if cons['eq']:\n        a_eq = vstack([con['jac'](x, *con['args'])\n                       for con in cons['eq']])\n    else:  # no equality constraint\n        a_eq = zeros((meq, n))\n\n    if cons['ineq']:\n        a_ieq = vstack([con['jac'](x, *con['args'])\n                        for con in cons['ineq']])\n    else:  # no inequality constraint\n        a_ieq = zeros((mieq, n))\n\n    # Now combine a_eq and a_ieq into a single a matrix\n    if m == 0:  # no constraints\n        a = zeros((la, n))\n    else:\n        a = vstack((a_eq, a_ieq))\n    a = concatenate((a, zeros([la, 1])), 1)\n\n    return a\n", 511], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py": ["from scipy.optimize import minimize\nfrom viztracer import VizTracer\n\n\n\ndef main():\n    # c.f. https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html\n    func = lambda x: (x[0] - 1) ** 2 + (x[1] - 2.5) ** 2\n    x0 = (2, 0)\n\n    constraints = (\n        {\"type\": \"ineq\", \"fun\": lambda x: x[0] - 2 * x[1] + 2},\n        {\"type\": \"ineq\", \"fun\": lambda x: -x[0] - 2 * x[1] + 6},\n        {\"type\": \"ineq\", \"fun\": lambda x: -x[0] + 2 * x[1] + 2},\n    )\n\n    bounds = ((0, None), (0, None))\n\n    result = minimize(func, x0, method=\"SLSQP\", bounds=bounds, constraints=constraints)\n    print(f\"result:\\n{result}\")\n    print(f\"best fit parameters: {result.x}\")\n\n\nif __name__ == \"__main__\":\n    with VizTracer(output_file=\"optional.json\") as tracer:\n        main()\n    ", 26], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py": ["\"\"\"\nFunctions for changing global ufunc configuration\n\nThis provides helpers which wrap `_get_extobj_dict` and `_make_extobj`, and\n`_extobj_contextvar` from umath.\n\"\"\"\nimport contextlib\nimport contextvars\nimport functools\n\nfrom .._utils import set_module\nfrom .umath import _make_extobj, _get_extobj_dict, _extobj_contextvar\n\n__all__ = [\n    \"seterr\", \"geterr\", \"setbufsize\", \"getbufsize\", \"seterrcall\", \"geterrcall\",\n    \"errstate\"\n]\n\n\n@set_module('numpy')\ndef seterr(all=None, divide=None, over=None, under=None, invalid=None):\n    \"\"\"\n    Set how floating-point errors are handled.\n\n    Note that operations on integer scalar types (such as `int16`) are\n    handled like floating point, and are affected by these settings.\n\n    Parameters\n    ----------\n    all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Set treatment for all types of floating-point errors at once:\n\n        - ignore: Take no action when the exception occurs.\n        - warn: Print a :exc:`RuntimeWarning` (via the Python `warnings`\n          module).\n        - raise: Raise a :exc:`FloatingPointError`.\n        - call: Call a function specified using the `seterrcall` function.\n        - print: Print a warning directly to ``stdout``.\n        - log: Record error in a Log object specified by `seterrcall`.\n\n        The default is not to change the current behavior.\n    divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for division by zero.\n    over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point overflow.\n    under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point underflow.\n    invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for invalid floating-point operation.\n\n    Returns\n    -------\n    old_settings : dict\n        Dictionary containing the old settings.\n\n    See also\n    --------\n    seterrcall : Set a callback function for the 'call' mode.\n    geterr, geterrcall, errstate\n\n    Notes\n    -----\n    The floating-point exceptions are defined in the IEEE 754 standard [1]_:\n\n    - Division by zero: infinite result obtained from finite numbers.\n    - Overflow: result too large to be expressed.\n    - Underflow: result so close to zero that some precision\n      was lost.\n    - Invalid operation: result is not an expressible number, typically\n      indicates that a NaN was produced.\n\n    .. [1] https://en.wikipedia.org/wiki/IEEE_754\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> orig_settings = np.seterr(all='ignore')  # seterr to known value\n    >>> np.int16(32000) * np.int16(3)\n    np.int16(30464)\n    >>> np.seterr(over='raise')\n    {'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}\n    >>> old_settings = np.seterr(all='warn', over='raise')\n    >>> np.int16(32000) * np.int16(3)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    FloatingPointError: overflow encountered in scalar multiply\n\n    >>> old_settings = np.seterr(all='print')\n    >>> np.geterr()\n    {'divide': 'print', 'over': 'print', 'under': 'print', 'invalid': 'print'}\n    >>> np.int16(32000) * np.int16(3)\n    np.int16(30464)\n    >>> np.seterr(**orig_settings)  # restore original\n    {'divide': 'print', 'over': 'print', 'under': 'print', 'invalid': 'print'}\n\n    \"\"\"\n\n    old = _get_extobj_dict()\n    # The errstate doesn't include call and bufsize, so pop them:\n    old.pop(\"call\", None)\n    old.pop(\"bufsize\", None)\n\n    extobj = _make_extobj(\n            all=all, divide=divide, over=over, under=under, invalid=invalid)\n    _extobj_contextvar.set(extobj)\n    return old\n\n\n@set_module('numpy')\ndef geterr():\n    \"\"\"\n    Get the current way of handling floating-point errors.\n\n    Returns\n    -------\n    res : dict\n        A dictionary with keys \"divide\", \"over\", \"under\", and \"invalid\",\n        whose values are from the strings \"ignore\", \"print\", \"log\", \"warn\",\n        \"raise\", and \"call\". The keys represent possible floating-point\n        exceptions, and the values define how these exceptions are handled.\n\n    See Also\n    --------\n    geterrcall, seterr, seterrcall\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.geterr()\n    {'divide': 'warn', 'over': 'warn', 'under': 'ignore', 'invalid': 'warn'}\n    >>> np.arange(3.) / np.arange(3.)  # doctest: +SKIP\n    array([nan,  1.,  1.])\n    RuntimeWarning: invalid value encountered in divide\n\n    >>> oldsettings = np.seterr(all='warn', invalid='raise')\n    >>> np.geterr()\n    {'divide': 'warn', 'over': 'warn', 'under': 'warn', 'invalid': 'raise'}\n    >>> np.arange(3.) / np.arange(3.)\n    Traceback (most recent call last):\n      ...\n    FloatingPointError: invalid value encountered in divide\n    >>> oldsettings = np.seterr(**oldsettings)  # restore original\n\n    \"\"\"\n    res = _get_extobj_dict()\n    # The \"geterr\" doesn't include call and bufsize,:\n    res.pop(\"call\", None)\n    res.pop(\"bufsize\", None)\n    return res\n\n\n@set_module('numpy')\ndef setbufsize(size):\n    \"\"\"\n    Set the size of the buffer used in ufuncs.\n\n    .. versionchanged:: 2.0\n        The scope of setting the buffer is tied to the `numpy.errstate`\n        context.  Exiting a ``with errstate():`` will also restore the bufsize.\n\n    Parameters\n    ----------\n    size : int\n        Size of buffer.\n\n    Returns\n    -------\n    bufsize : int\n        Previous size of ufunc buffer in bytes.\n\n    Examples\n    --------\n    When exiting a `numpy.errstate` context manager the bufsize is restored:\n\n    >>> import numpy as np\n    >>> with np.errstate():\n    ...     np.setbufsize(4096)\n    ...     print(np.getbufsize())\n    ...\n    8192\n    4096\n    >>> np.getbufsize()\n    8192\n\n    \"\"\"\n    old = _get_extobj_dict()[\"bufsize\"]\n    extobj = _make_extobj(bufsize=size)\n    _extobj_contextvar.set(extobj)\n    return old\n\n\n@set_module('numpy')\ndef getbufsize():\n    \"\"\"\n    Return the size of the buffer used in ufuncs.\n\n    Returns\n    -------\n    getbufsize : int\n        Size of ufunc buffer in bytes.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.getbufsize()\n    8192\n\n    \"\"\"\n    return _get_extobj_dict()[\"bufsize\"]\n\n\n@set_module('numpy')\ndef seterrcall(func):\n    \"\"\"\n    Set the floating-point error callback function or log object.\n\n    There are two ways to capture floating-point error messages.  The first\n    is to set the error-handler to 'call', using `seterr`.  Then, set\n    the function to call using this function.\n\n    The second is to set the error-handler to 'log', using `seterr`.\n    Floating-point errors then trigger a call to the 'write' method of\n    the provided object.\n\n    Parameters\n    ----------\n    func : callable f(err, flag) or object with write method\n        Function to call upon floating-point errors ('call'-mode) or\n        object whose 'write' method is used to log such message ('log'-mode).\n\n        The call function takes two arguments. The first is a string describing\n        the type of error (such as \"divide by zero\", \"overflow\", \"underflow\",\n        or \"invalid value\"), and the second is the status flag.  The flag is a\n        byte, whose four least-significant bits indicate the type of error, one\n        of \"divide\", \"over\", \"under\", \"invalid\"::\n\n          [0 0 0 0 divide over under invalid]\n\n        In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.\n\n        If an object is provided, its write method should take one argument,\n        a string.\n\n    Returns\n    -------\n    h : callable, log instance or None\n        The old error handler.\n\n    See Also\n    --------\n    seterr, geterr, geterrcall\n\n    Examples\n    --------\n    Callback upon error:\n\n    >>> def err_handler(type, flag):\n    ...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n    ...\n\n    >>> import numpy as np\n\n    >>> orig_handler = np.seterrcall(err_handler)\n    >>> orig_err = np.seterr(all='call')\n\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([inf, inf, inf])\n\n    >>> np.seterrcall(orig_handler)\n    <function err_handler at 0x...>\n    >>> np.seterr(**orig_err)\n    {'divide': 'call', 'over': 'call', 'under': 'call', 'invalid': 'call'}\n\n    Log error message:\n\n    >>> class Log:\n    ...     def write(self, msg):\n    ...         print(\"LOG: %s\" % msg)\n    ...\n\n    >>> log = Log()\n    >>> saved_handler = np.seterrcall(log)\n    >>> save_err = np.seterr(all='log')\n\n    >>> np.array([1, 2, 3]) / 0.0\n    LOG: Warning: divide by zero encountered in divide\n    array([inf, inf, inf])\n\n    >>> np.seterrcall(orig_handler)\n    <numpy.Log object at 0x...>\n    >>> np.seterr(**orig_err)\n    {'divide': 'log', 'over': 'log', 'under': 'log', 'invalid': 'log'}\n\n    \"\"\"\n    old = _get_extobj_dict()[\"call\"]\n    extobj = _make_extobj(call=func)\n    _extobj_contextvar.set(extobj)\n    return old\n\n\n@set_module('numpy')\ndef geterrcall():\n    \"\"\"\n    Return the current callback function used on floating-point errors.\n\n    When the error handling for a floating-point error (one of \"divide\",\n    \"over\", \"under\", or \"invalid\") is set to 'call' or 'log', the function\n    that is called or the log instance that is written to is returned by\n    `geterrcall`. This function or log instance has been set with\n    `seterrcall`.\n\n    Returns\n    -------\n    errobj : callable, log instance or None\n        The current error handler. If no handler was set through `seterrcall`,\n        ``None`` is returned.\n\n    See Also\n    --------\n    seterrcall, seterr, geterr\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.geterrcall()  # we did not yet set a handler, returns None\n\n    >>> orig_settings = np.seterr(all='call')\n    >>> def err_handler(type, flag):\n    ...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n    >>> old_handler = np.seterrcall(err_handler)\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([inf, inf, inf])\n\n    >>> cur_handler = np.geterrcall()\n    >>> cur_handler is err_handler\n    True\n    >>> old_settings = np.seterr(**orig_settings)  # restore original\n    >>> old_handler = np.seterrcall(None)  # restore original\n\n    \"\"\"\n    return _get_extobj_dict()[\"call\"]\n\n\nclass _unspecified:\n    pass\n\n\n_Unspecified = _unspecified()\n\n\n@set_module('numpy')\nclass errstate:\n    \"\"\"\n    errstate(**kwargs)\n\n    Context manager for floating-point error handling.\n\n    Using an instance of `errstate` as a context manager allows statements in\n    that context to execute with a known error handling behavior. Upon entering\n    the context the error handling is set with `seterr` and `seterrcall`, and\n    upon exiting it is reset to what it was before.\n\n    ..  versionchanged:: 1.17.0\n        `errstate` is also usable as a function decorator, saving\n        a level of indentation if an entire function is wrapped.\n\n    .. versionchanged:: 2.0\n        `errstate` is now fully thread and asyncio safe, but may not be\n        entered more than once.\n        It is not safe to decorate async functions using ``errstate``.\n\n    Parameters\n    ----------\n    kwargs : {divide, over, under, invalid}\n        Keyword arguments. The valid keywords are the possible floating-point\n        exceptions. Each keyword should have a string value that defines the\n        treatment for the particular error. Possible values are\n        {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.\n\n    See Also\n    --------\n    seterr, geterr, seterrcall, geterrcall\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> olderr = np.seterr(all='ignore')  # Set error handling to known state.\n\n    >>> np.arange(3) / 0.\n    array([nan, inf, inf])\n    >>> with np.errstate(divide='ignore'):\n    ...     np.arange(3) / 0.\n    array([nan, inf, inf])\n\n    >>> np.sqrt(-1)\n    np.float64(nan)\n    >>> with np.errstate(invalid='raise'):\n    ...     np.sqrt(-1)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 2, in <module>\n    FloatingPointError: invalid value encountered in sqrt\n\n    Outside the context the error handling behavior has not changed:\n\n    >>> np.geterr()\n    {'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}\n    >>> olderr = np.seterr(**olderr)  # restore original state\n\n    \"\"\"\n    __slots__ = (\n        \"_call\", \"_all\", \"_divide\", \"_over\", \"_under\", \"_invalid\", \"_token\")\n\n    def __init__(self, *, call=_Unspecified,\n                 all=None, divide=None, over=None, under=None, invalid=None):\n        self._token = None\n        self._call = call\n        self._all = all\n        self._divide = divide\n        self._over = over\n        self._under = under\n        self._invalid = invalid\n\n    def __enter__(self):\n        # Note that __call__ duplicates much of this logic\n        if self._token is not None:\n            raise TypeError(\"Cannot enter `np.errstate` twice.\")\n        if self._call is _Unspecified:\n            extobj = _make_extobj(\n                    all=self._all, divide=self._divide, over=self._over,\n                    under=self._under, invalid=self._invalid)\n        else:\n            extobj = _make_extobj(\n                    call=self._call,\n                    all=self._all, divide=self._divide, over=self._over,\n                    under=self._under, invalid=self._invalid)\n\n        self._token = _extobj_contextvar.set(extobj)\n\n    def __exit__(self, *exc_info):\n        _extobj_contextvar.reset(self._token)\n\n    def __call__(self, func):\n        # We need to customize `__call__` compared to `ContextDecorator`\n        # because we must store the token per-thread so cannot store it on\n        # the instance (we could create a new instance for this).\n        # This duplicates the code from `__enter__`.\n        @functools.wraps(func)\n        def inner(*args, **kwargs):\n            if self._call is _Unspecified:\n                extobj = _make_extobj(\n                        all=self._all, divide=self._divide, over=self._over,\n                        under=self._under, invalid=self._invalid)\n            else:\n                extobj = _make_extobj(\n                        call=self._call,\n                        all=self._all, divide=self._divide, over=self._over,\n                        under=self._under, invalid=self._invalid)\n\n            _token = _extobj_contextvar.set(extobj)\n            try:\n                # Call the original, decorated, function:\n                return func(*args, **kwargs)\n            finally:\n                _extobj_contextvar.reset(_token)\n\n        return inner\n", 483], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py": ["import numpy as np\nimport scipy.sparse as sps\nfrom ._numdiff import approx_derivative, group_columns\nfrom ._hessian_update_strategy import HessianUpdateStrategy\nfrom scipy.sparse.linalg import LinearOperator\nfrom scipy._lib._array_api import array_namespace\nfrom scipy._lib import array_api_extra as xpx\n\n\nFD_METHODS = ('2-point', '3-point', 'cs')\n\n\ndef _wrapper_fun(fun, args=()):\n    ncalls = [0]\n\n    def wrapped(x):\n        ncalls[0] += 1\n        # Send a copy because the user may overwrite it.\n        # Overwriting results in undefined behaviour because\n        # fun(self.x) will change self.x, with the two no longer linked.\n        fx = fun(np.copy(x), *args)\n        # Make sure the function returns a true scalar\n        if not np.isscalar(fx):\n            try:\n                fx = np.asarray(fx).item()\n            except (TypeError, ValueError) as e:\n                raise ValueError(\n                    \"The user-provided objective function \"\n                    \"must return a scalar value.\"\n                ) from e\n        return fx\n    return wrapped, ncalls\n\n\ndef _wrapper_grad(grad, fun=None, args=(), finite_diff_options=None):\n    ncalls = [0]\n\n    if callable(grad):\n        def wrapped(x, **kwds):\n            # kwds present to give function same signature as numdiff variant\n            ncalls[0] += 1\n            return np.atleast_1d(grad(np.copy(x), *args))\n        return wrapped, ncalls\n\n    elif grad in FD_METHODS:\n        def wrapped1(x, f0=None):\n            ncalls[0] += 1\n            return approx_derivative(\n                fun, x, f0=f0, **finite_diff_options\n            )\n\n        return wrapped1, ncalls\n\n\ndef _wrapper_hess(hess, grad=None, x0=None, args=(), finite_diff_options=None):\n    if callable(hess):\n        H = hess(np.copy(x0), *args)\n        ncalls = [1]\n\n        if sps.issparse(H):\n            def wrapped(x, **kwds):\n                ncalls[0] += 1\n                return sps.csr_matrix(hess(np.copy(x), *args))\n\n            H = sps.csr_matrix(H)\n\n        elif isinstance(H, LinearOperator):\n            def wrapped(x, **kwds):\n                ncalls[0] += 1\n                return hess(np.copy(x), *args)\n\n        else:  # dense\n            def wrapped(x, **kwds):\n                ncalls[0] += 1\n                return np.atleast_2d(np.asarray(hess(np.copy(x), *args)))\n\n            H = np.atleast_2d(np.asarray(H))\n\n        return wrapped, ncalls, H\n    elif hess in FD_METHODS:\n        ncalls = [0]\n\n        def wrapped1(x, f0=None):\n            return approx_derivative(\n                grad, x, f0=f0, **finite_diff_options\n            )\n\n        return wrapped1, ncalls, None\n\n\nclass ScalarFunction:\n    \"\"\"Scalar function and its derivatives.\n\n    This class defines a scalar function F: R^n->R and methods for\n    computing or approximating its first and second derivatives.\n\n    Parameters\n    ----------\n    fun : callable\n        evaluates the scalar function. Must be of the form ``fun(x, *args)``,\n        where ``x`` is the argument in the form of a 1-D array and ``args`` is\n        a tuple of any additional fixed parameters needed to completely specify\n        the function. Should return a scalar.\n    x0 : array-like\n        Provides an initial set of variables for evaluating fun. Array of real\n        elements of size (n,), where 'n' is the number of independent\n        variables.\n    args : tuple, optional\n        Any additional fixed parameters needed to completely specify the scalar\n        function.\n    grad : {callable, '2-point', '3-point', 'cs'}\n        Method for computing the gradient vector.\n        If it is a callable, it should be a function that returns the gradient\n        vector:\n\n            ``grad(x, *args) -> array_like, shape (n,)``\n\n        where ``x`` is an array with shape (n,) and ``args`` is a tuple with\n        the fixed parameters.\n        Alternatively, the keywords  {'2-point', '3-point', 'cs'} can be used\n        to select a finite difference scheme for numerical estimation of the\n        gradient with a relative step size. These finite difference schemes\n        obey any specified `bounds`.\n    hess : {callable, '2-point', '3-point', 'cs', HessianUpdateStrategy}\n        Method for computing the Hessian matrix. If it is callable, it should\n        return the  Hessian matrix:\n\n            ``hess(x, *args) -> {LinearOperator, spmatrix, array}, (n, n)``\n\n        where x is a (n,) ndarray and `args` is a tuple with the fixed\n        parameters. Alternatively, the keywords {'2-point', '3-point', 'cs'}\n        select a finite difference scheme for numerical estimation. Or, objects\n        implementing `HessianUpdateStrategy` interface can be used to\n        approximate the Hessian.\n        Whenever the gradient is estimated via finite-differences, the Hessian\n        cannot be estimated with options {'2-point', '3-point', 'cs'} and needs\n        to be estimated using one of the quasi-Newton strategies.\n    finite_diff_rel_step : None or array_like\n        Relative step size to use. The absolute step size is computed as\n        ``h = finite_diff_rel_step * sign(x0) * max(1, abs(x0))``, possibly\n        adjusted to fit into the bounds. For ``method='3-point'`` the sign\n        of `h` is ignored. If None then finite_diff_rel_step is selected\n        automatically,\n    finite_diff_bounds : tuple of array_like\n        Lower and upper bounds on independent variables. Defaults to no bounds,\n        (-np.inf, np.inf). Each bound must match the size of `x0` or be a\n        scalar, in the latter case the bound will be the same for all\n        variables. Use it to limit the range of function evaluation.\n    epsilon : None or array_like, optional\n        Absolute step size to use, possibly adjusted to fit into the bounds.\n        For ``method='3-point'`` the sign of `epsilon` is ignored. By default\n        relative steps are used, only if ``epsilon is not None`` are absolute\n        steps used.\n\n    Notes\n    -----\n    This class implements a memoization logic. There are methods `fun`,\n    `grad`, hess` and corresponding attributes `f`, `g` and `H`. The following\n    things should be considered:\n\n        1. Use only public methods `fun`, `grad` and `hess`.\n        2. After one of the methods is called, the corresponding attribute\n           will be set. However, a subsequent call with a different argument\n           of *any* of the methods may overwrite the attribute.\n    \"\"\"\n    def __init__(self, fun, x0, args, grad, hess, finite_diff_rel_step,\n                 finite_diff_bounds, epsilon=None):\n        if not callable(grad) and grad not in FD_METHODS:\n            raise ValueError(\n                f\"`grad` must be either callable or one of {FD_METHODS}.\"\n            )\n\n        if not (callable(hess) or hess in FD_METHODS\n                or isinstance(hess, HessianUpdateStrategy)):\n            raise ValueError(\n                f\"`hess` must be either callable, HessianUpdateStrategy\"\n                f\" or one of {FD_METHODS}.\"\n            )\n\n        if grad in FD_METHODS and hess in FD_METHODS:\n            raise ValueError(\"Whenever the gradient is estimated via \"\n                             \"finite-differences, we require the Hessian \"\n                             \"to be estimated using one of the \"\n                             \"quasi-Newton strategies.\")\n\n        self.xp = xp = array_namespace(x0)\n        _x = xpx.atleast_nd(xp.asarray(x0), ndim=1, xp=xp)\n        _dtype = xp.float64\n        if xp.isdtype(_x.dtype, \"real floating\"):\n            _dtype = _x.dtype\n\n        # original arguments\n        self._wrapped_fun, self._nfev = _wrapper_fun(fun, args=args)\n        self._orig_fun = fun\n        self._orig_grad = grad\n        self._orig_hess = hess\n        self._args = args\n\n        # promotes to floating\n        self.x = xp.astype(_x, _dtype)\n        self.x_dtype = _dtype\n        self.n = self.x.size\n        self.f_updated = False\n        self.g_updated = False\n        self.H_updated = False\n\n        self._lowest_x = None\n        self._lowest_f = np.inf\n\n        finite_diff_options = {}\n        if grad in FD_METHODS:\n            finite_diff_options[\"method\"] = grad\n            finite_diff_options[\"rel_step\"] = finite_diff_rel_step\n            finite_diff_options[\"abs_step\"] = epsilon\n            finite_diff_options[\"bounds\"] = finite_diff_bounds\n        if hess in FD_METHODS:\n            finite_diff_options[\"method\"] = hess\n            finite_diff_options[\"rel_step\"] = finite_diff_rel_step\n            finite_diff_options[\"abs_step\"] = epsilon\n            finite_diff_options[\"as_linear_operator\"] = True\n\n        # Initial function evaluation\n        self._update_fun()\n\n        # Initial gradient evaluation\n        self._wrapped_grad, self._ngev = _wrapper_grad(\n            grad,\n            fun=self._wrapped_fun,\n            args=args,\n            finite_diff_options=finite_diff_options\n        )\n        self._update_grad()\n\n        # Hessian evaluation\n        if callable(hess):\n            self._wrapped_hess, self._nhev, self.H = _wrapper_hess(\n                hess, x0=x0, args=args\n            )\n            self.H_updated = True\n        elif hess in FD_METHODS:\n            self._wrapped_hess, self._nhev, self.H = _wrapper_hess(\n                hess,\n                grad=self._wrapped_grad,\n                x0=x0,\n                finite_diff_options=finite_diff_options\n            )\n            self._update_grad()\n            self.H = self._wrapped_hess(self.x, f0=self.g)\n            self.H_updated = True\n        elif isinstance(hess, HessianUpdateStrategy):\n            self.H = hess\n            self.H.initialize(self.n, 'hess')\n            self.H_updated = True\n            self.x_prev = None\n            self.g_prev = None\n            self._nhev = [0]\n\n    @property\n    def nfev(self):\n        return self._nfev[0]\n\n    @property\n    def ngev(self):\n        return self._ngev[0]\n\n    @property\n    def nhev(self):\n        return self._nhev[0]\n\n    def _update_x(self, x):\n        if isinstance(self._orig_hess, HessianUpdateStrategy):\n            self._update_grad()\n            self.x_prev = self.x\n            self.g_prev = self.g\n            # ensure that self.x is a copy of x. Don't store a reference\n            # otherwise the memoization doesn't work properly.\n\n            _x = xpx.atleast_nd(self.xp.asarray(x), ndim=1, xp=self.xp)\n            self.x = self.xp.astype(_x, self.x_dtype)\n            self.f_updated = False\n            self.g_updated = False\n            self.H_updated = False\n            self._update_hess()\n        else:\n            # ensure that self.x is a copy of x. Don't store a reference\n            # otherwise the memoization doesn't work properly.\n            _x = xpx.atleast_nd(self.xp.asarray(x), ndim=1, xp=self.xp)\n            self.x = self.xp.astype(_x, self.x_dtype)\n            self.f_updated = False\n            self.g_updated = False\n            self.H_updated = False\n\n    def _update_fun(self):\n        if not self.f_updated:\n            fx = self._wrapped_fun(self.x)\n            if fx < self._lowest_f:\n                self._lowest_x = self.x\n                self._lowest_f = fx\n\n            self.f = fx\n            self.f_updated = True\n\n    def _update_grad(self):\n        if not self.g_updated:\n            if self._orig_grad in FD_METHODS:\n                self._update_fun()\n            self.g = self._wrapped_grad(self.x, f0=self.f)\n            self.g_updated = True\n\n    def _update_hess(self):\n        if not self.H_updated:\n            if self._orig_hess in FD_METHODS:\n                self._update_grad()\n                self.H = self._wrapped_hess(self.x, f0=self.g)\n            elif isinstance(self._orig_hess, HessianUpdateStrategy):\n                self._update_grad()\n                self.H.update(self.x - self.x_prev, self.g - self.g_prev)\n            else:       # should be callable(hess)\n                self.H = self._wrapped_hess(self.x)\n\n            self.H_updated = True\n\n    def fun(self, x):\n        if not np.array_equal(x, self.x):\n            self._update_x(x)\n        self._update_fun()\n        return self.f\n\n    def grad(self, x):\n        if not np.array_equal(x, self.x):\n            self._update_x(x)\n        self._update_grad()\n        return self.g\n\n    def hess(self, x):\n        if not np.array_equal(x, self.x):\n            self._update_x(x)\n        self._update_hess()\n        return self.H\n\n    def fun_and_grad(self, x):\n        if not np.array_equal(x, self.x):\n            self._update_x(x)\n        self._update_fun()\n        self._update_grad()\n        return self.f, self.g\n\n\nclass VectorFunction:\n    \"\"\"Vector function and its derivatives.\n\n    This class defines a vector function F: R^n->R^m and methods for\n    computing or approximating its first and second derivatives.\n\n    Notes\n    -----\n    This class implements a memoization logic. There are methods `fun`,\n    `jac`, hess` and corresponding attributes `f`, `J` and `H`. The following\n    things should be considered:\n\n        1. Use only public methods `fun`, `jac` and `hess`.\n        2. After one of the methods is called, the corresponding attribute\n           will be set. However, a subsequent call with a different argument\n           of *any* of the methods may overwrite the attribute.\n    \"\"\"\n    def __init__(self, fun, x0, jac, hess,\n                 finite_diff_rel_step, finite_diff_jac_sparsity,\n                 finite_diff_bounds, sparse_jacobian):\n        if not callable(jac) and jac not in FD_METHODS:\n            raise ValueError(f\"`jac` must be either callable or one of {FD_METHODS}.\")\n\n        if not (callable(hess) or hess in FD_METHODS\n                or isinstance(hess, HessianUpdateStrategy)):\n            raise ValueError(\"`hess` must be either callable,\"\n                             f\"HessianUpdateStrategy or one of {FD_METHODS}.\")\n\n        if jac in FD_METHODS and hess in FD_METHODS:\n            raise ValueError(\"Whenever the Jacobian is estimated via \"\n                             \"finite-differences, we require the Hessian to \"\n                             \"be estimated using one of the quasi-Newton \"\n                             \"strategies.\")\n\n        self.xp = xp = array_namespace(x0)\n        _x = xpx.atleast_nd(xp.asarray(x0), ndim=1, xp=xp)\n        _dtype = xp.float64\n        if xp.isdtype(_x.dtype, \"real floating\"):\n            _dtype = _x.dtype\n\n        # promotes to floating\n        self.x = xp.astype(_x, _dtype)\n        self.x_dtype = _dtype\n\n        self.n = self.x.size\n        self.nfev = 0\n        self.njev = 0\n        self.nhev = 0\n        self.f_updated = False\n        self.J_updated = False\n        self.H_updated = False\n\n        finite_diff_options = {}\n        if jac in FD_METHODS:\n            finite_diff_options[\"method\"] = jac\n            finite_diff_options[\"rel_step\"] = finite_diff_rel_step\n            if finite_diff_jac_sparsity is not None:\n                sparsity_groups = group_columns(finite_diff_jac_sparsity)\n                finite_diff_options[\"sparsity\"] = (finite_diff_jac_sparsity,\n                                                   sparsity_groups)\n            finite_diff_options[\"bounds\"] = finite_diff_bounds\n            self.x_diff = np.copy(self.x)\n        if hess in FD_METHODS:\n            finite_diff_options[\"method\"] = hess\n            finite_diff_options[\"rel_step\"] = finite_diff_rel_step\n            finite_diff_options[\"as_linear_operator\"] = True\n            self.x_diff = np.copy(self.x)\n        if jac in FD_METHODS and hess in FD_METHODS:\n            raise ValueError(\"Whenever the Jacobian is estimated via \"\n                             \"finite-differences, we require the Hessian to \"\n                             \"be estimated using one of the quasi-Newton \"\n                             \"strategies.\")\n\n        # Function evaluation\n        def fun_wrapped(x):\n            self.nfev += 1\n            return np.atleast_1d(fun(x))\n\n        def update_fun():\n            self.f = fun_wrapped(self.x)\n\n        self._update_fun_impl = update_fun\n        update_fun()\n\n        self.v = np.zeros_like(self.f)\n        self.m = self.v.size\n\n        # Jacobian Evaluation\n        if callable(jac):\n            self.J = jac(self.x)\n            self.J_updated = True\n            self.njev += 1\n\n            if (sparse_jacobian or\n                    sparse_jacobian is None and sps.issparse(self.J)):\n                def jac_wrapped(x):\n                    self.njev += 1\n                    return sps.csr_matrix(jac(x))\n                self.J = sps.csr_matrix(self.J)\n                self.sparse_jacobian = True\n\n            elif sps.issparse(self.J):\n                def jac_wrapped(x):\n                    self.njev += 1\n                    return jac(x).toarray()\n                self.J = self.J.toarray()\n                self.sparse_jacobian = False\n\n            else:\n                def jac_wrapped(x):\n                    self.njev += 1\n                    return np.atleast_2d(jac(x))\n                self.J = np.atleast_2d(self.J)\n                self.sparse_jacobian = False\n\n            def update_jac():\n                self.J = jac_wrapped(self.x)\n\n        elif jac in FD_METHODS:\n            self.J = approx_derivative(fun_wrapped, self.x, f0=self.f,\n                                       **finite_diff_options)\n            self.J_updated = True\n\n            if (sparse_jacobian or\n                    sparse_jacobian is None and sps.issparse(self.J)):\n                def update_jac():\n                    self._update_fun()\n                    self.J = sps.csr_matrix(\n                        approx_derivative(fun_wrapped, self.x, f0=self.f,\n                                          **finite_diff_options))\n                self.J = sps.csr_matrix(self.J)\n                self.sparse_jacobian = True\n\n            elif sps.issparse(self.J):\n                def update_jac():\n                    self._update_fun()\n                    self.J = approx_derivative(fun_wrapped, self.x, f0=self.f,\n                                               **finite_diff_options).toarray()\n                self.J = self.J.toarray()\n                self.sparse_jacobian = False\n\n            else:\n                def update_jac():\n                    self._update_fun()\n                    self.J = np.atleast_2d(\n                        approx_derivative(fun_wrapped, self.x, f0=self.f,\n                                          **finite_diff_options))\n                self.J = np.atleast_2d(self.J)\n                self.sparse_jacobian = False\n\n        self._update_jac_impl = update_jac\n\n        # Define Hessian\n        if callable(hess):\n            self.H = hess(self.x, self.v)\n            self.H_updated = True\n            self.nhev += 1\n\n            if sps.issparse(self.H):\n                def hess_wrapped(x, v):\n                    self.nhev += 1\n                    return sps.csr_matrix(hess(x, v))\n                self.H = sps.csr_matrix(self.H)\n\n            elif isinstance(self.H, LinearOperator):\n                def hess_wrapped(x, v):\n                    self.nhev += 1\n                    return hess(x, v)\n\n            else:\n                def hess_wrapped(x, v):\n                    self.nhev += 1\n                    return np.atleast_2d(np.asarray(hess(x, v)))\n                self.H = np.atleast_2d(np.asarray(self.H))\n\n            def update_hess():\n                self.H = hess_wrapped(self.x, self.v)\n        elif hess in FD_METHODS:\n            def jac_dot_v(x, v):\n                return jac_wrapped(x).T.dot(v)\n\n            def update_hess():\n                self._update_jac()\n                self.H = approx_derivative(jac_dot_v, self.x,\n                                           f0=self.J.T.dot(self.v),\n                                           args=(self.v,),\n                                           **finite_diff_options)\n            update_hess()\n            self.H_updated = True\n        elif isinstance(hess, HessianUpdateStrategy):\n            self.H = hess\n            self.H.initialize(self.n, 'hess')\n            self.H_updated = True\n            self.x_prev = None\n            self.J_prev = None\n\n            def update_hess():\n                self._update_jac()\n                # When v is updated before x was updated, then x_prev and\n                # J_prev are None and we need this check.\n                if self.x_prev is not None and self.J_prev is not None:\n                    delta_x = self.x - self.x_prev\n                    delta_g = self.J.T.dot(self.v) - self.J_prev.T.dot(self.v)\n                    self.H.update(delta_x, delta_g)\n\n        self._update_hess_impl = update_hess\n\n        if isinstance(hess, HessianUpdateStrategy):\n            def update_x(x):\n                self._update_jac()\n                self.x_prev = self.x\n                self.J_prev = self.J\n                _x = xpx.atleast_nd(self.xp.asarray(x), ndim=1, xp=self.xp)\n                self.x = self.xp.astype(_x, self.x_dtype)\n                self.f_updated = False\n                self.J_updated = False\n                self.H_updated = False\n                self._update_hess()\n        else:\n            def update_x(x):\n                _x = xpx.atleast_nd(self.xp.asarray(x), ndim=1, xp=self.xp)\n                self.x = self.xp.astype(_x, self.x_dtype)\n                self.f_updated = False\n                self.J_updated = False\n                self.H_updated = False\n\n        self._update_x_impl = update_x\n\n    def _update_v(self, v):\n        if not np.array_equal(v, self.v):\n            self.v = v\n            self.H_updated = False\n\n    def _update_x(self, x):\n        if not np.array_equal(x, self.x):\n            self._update_x_impl(x)\n\n    def _update_fun(self):\n        if not self.f_updated:\n            self._update_fun_impl()\n            self.f_updated = True\n\n    def _update_jac(self):\n        if not self.J_updated:\n            self._update_jac_impl()\n            self.J_updated = True\n\n    def _update_hess(self):\n        if not self.H_updated:\n            self._update_hess_impl()\n            self.H_updated = True\n\n    def fun(self, x):\n        self._update_x(x)\n        self._update_fun()\n        return self.f\n\n    def jac(self, x):\n        self._update_x(x)\n        self._update_jac()\n        return self.J\n\n    def hess(self, x, v):\n        # v should be updated before x.\n        self._update_v(v)\n        self._update_x(x)\n        self._update_hess()\n        return self.H\n\n\nclass LinearVectorFunction:\n    \"\"\"Linear vector function and its derivatives.\n\n    Defines a linear function F = A x, where x is N-D vector and\n    A is m-by-n matrix. The Jacobian is constant and equals to A. The Hessian\n    is identically zero and it is returned as a csr matrix.\n    \"\"\"\n    def __init__(self, A, x0, sparse_jacobian):\n        if sparse_jacobian or sparse_jacobian is None and sps.issparse(A):\n            self.J = sps.csr_matrix(A)\n            self.sparse_jacobian = True\n        elif sps.issparse(A):\n            self.J = A.toarray()\n            self.sparse_jacobian = False\n        else:\n            # np.asarray makes sure A is ndarray and not matrix\n            self.J = np.atleast_2d(np.asarray(A))\n            self.sparse_jacobian = False\n\n        self.m, self.n = self.J.shape\n\n        self.xp = xp = array_namespace(x0)\n        _x = xpx.atleast_nd(xp.asarray(x0), ndim=1, xp=xp)\n        _dtype = xp.float64\n        if xp.isdtype(_x.dtype, \"real floating\"):\n            _dtype = _x.dtype\n\n        # promotes to floating\n        self.x = xp.astype(_x, _dtype)\n        self.x_dtype = _dtype\n\n        self.f = self.J.dot(self.x)\n        self.f_updated = True\n\n        self.v = np.zeros(self.m, dtype=float)\n        self.H = sps.csr_matrix((self.n, self.n))\n\n    def _update_x(self, x):\n        if not np.array_equal(x, self.x):\n            _x = xpx.atleast_nd(self.xp.asarray(x), ndim=1, xp=self.xp)\n            self.x = self.xp.astype(_x, self.x_dtype)\n            self.f_updated = False\n\n    def fun(self, x):\n        self._update_x(x)\n        if not self.f_updated:\n            self.f = self.J.dot(x)\n            self.f_updated = True\n        return self.f\n\n    def jac(self, x):\n        self._update_x(x)\n        return self.J\n\n    def hess(self, x, v):\n        self._update_x(x)\n        self.v = v\n        return self.H\n\n\nclass IdentityVectorFunction(LinearVectorFunction):\n    \"\"\"Identity vector function and its derivatives.\n\n    The Jacobian is the identity matrix, returned as a dense array when\n    `sparse_jacobian=False` and as a csr matrix otherwise. The Hessian is\n    identically zero and it is returned as a csr matrix.\n    \"\"\"\n    def __init__(self, x0, sparse_jacobian):\n        n = len(x0)\n        if sparse_jacobian or sparse_jacobian is None:\n            A = sps.eye(n, format='csr')\n            sparse_jacobian = True\n        else:\n            A = np.eye(n)\n            sparse_jacobian = False\n        super().__init__(A, x0, sparse_jacobian)\n", 694], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py": ["import functools\nimport itertools\nimport operator\nimport sys\nimport warnings\nimport numbers\nimport builtins\nimport math\n\nimport numpy as np\nfrom . import multiarray\nfrom . import numerictypes as nt\nfrom .multiarray import (\n    ALLOW_THREADS, BUFSIZE, CLIP, MAXDIMS, MAY_SHARE_BOUNDS, MAY_SHARE_EXACT,\n    RAISE, WRAP, arange, array, asarray, asanyarray, ascontiguousarray,\n    asfortranarray, broadcast, can_cast, concatenate, copyto, dot, dtype,\n    empty, empty_like, flatiter, frombuffer, from_dlpack, fromfile, fromiter,\n    fromstring, inner, lexsort, matmul, may_share_memory, min_scalar_type,\n    ndarray, nditer, nested_iters, promote_types, putmask, result_type,\n    shares_memory, vdot, where, zeros, normalize_axis_index, vecdot\n)\n\nfrom . import overrides\nfrom . import umath\nfrom . import shape_base\nfrom .overrides import finalize_array_function_like, set_module\nfrom .umath import (multiply, invert, sin, PINF, NAN)\nfrom . import numerictypes\nfrom ..exceptions import AxisError\nfrom ._ufunc_config import errstate\n\nbitwise_not = invert\nufunc = type(sin)\nnewaxis = None\n\narray_function_dispatch = functools.partial(\n    overrides.array_function_dispatch, module='numpy')\n\n\n__all__ = [\n    'newaxis', 'ndarray', 'flatiter', 'nditer', 'nested_iters', 'ufunc',\n    'arange', 'array', 'asarray', 'asanyarray', 'ascontiguousarray',\n    'asfortranarray', 'zeros', 'count_nonzero', 'empty', 'broadcast', 'dtype',\n    'fromstring', 'fromfile', 'frombuffer', 'from_dlpack', 'where',\n    'argwhere', 'copyto', 'concatenate', 'lexsort', 'astype',\n    'can_cast', 'promote_types', 'min_scalar_type',\n    'result_type', 'isfortran', 'empty_like', 'zeros_like', 'ones_like',\n    'correlate', 'convolve', 'inner', 'dot', 'outer', 'vdot', 'roll',\n    'rollaxis', 'moveaxis', 'cross', 'tensordot', 'little_endian',\n    'fromiter', 'array_equal', 'array_equiv', 'indices', 'fromfunction',\n    'isclose', 'isscalar', 'binary_repr', 'base_repr', 'ones',\n    'identity', 'allclose', 'putmask',\n    'flatnonzero', 'inf', 'nan', 'False_', 'True_', 'bitwise_not',\n    'full', 'full_like', 'matmul', 'vecdot', 'shares_memory',\n    'may_share_memory']\n\n\ndef _zeros_like_dispatcher(\n    a, dtype=None, order=None, subok=None, shape=None, *, device=None\n):\n    return (a,)\n\n\n@array_function_dispatch(_zeros_like_dispatcher)\ndef zeros_like(\n    a, dtype=None, order='K', subok=True, shape=None, *, device=None\n):\n    \"\"\"\n    Return an array of zeros with the same shape and type as a given array.\n\n    Parameters\n    ----------\n    a : array_like\n        The shape and data-type of `a` define these same attributes of\n        the returned array.\n    dtype : data-type, optional\n        Overrides the data type of the result.\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Overrides the memory layout of the result. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible.\n    subok : bool, optional.\n        If True, then the newly created array will use the sub-class\n        type of `a`, otherwise it will be a base-class array. Defaults\n        to True.\n    shape : int or sequence of ints, optional.\n        Overrides the shape of the result. If order='K' and the number of\n        dimensions is unchanged, will try to keep order, otherwise,\n        order='C' is implied.\n    device : str, optional\n        The device on which to place the created array. Default: None.\n        For Array-API interoperability only, so must be ``\"cpu\"`` if passed.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of zeros with the same shape and type as `a`.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    ones_like : Return an array of ones with shape and type of input.\n    full_like : Return a new array with shape of input filled with value.\n    zeros : Return a new array setting values to zero.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.arange(6)\n    >>> x = x.reshape((2, 3))\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.zeros_like(x)\n    array([[0, 0, 0],\n           [0, 0, 0]])\n\n    >>> y = np.arange(3, dtype=float)\n    >>> y\n    array([0., 1., 2.])\n    >>> np.zeros_like(y)\n    array([0.,  0.,  0.])\n\n    \"\"\"\n    res = empty_like(\n        a, dtype=dtype, order=order, subok=subok, shape=shape, device=device\n    )\n    # needed instead of a 0 to get same result as zeros for string dtypes\n    z = zeros(1, dtype=res.dtype)\n    multiarray.copyto(res, z, casting='unsafe')\n    return res\n\n\n@finalize_array_function_like\n@set_module('numpy')\ndef ones(shape, dtype=None, order='C', *, device=None, like=None):\n    \"\"\"\n    Return a new array of given shape and type, filled with ones.\n\n    Parameters\n    ----------\n    shape : int or sequence of ints\n        Shape of the new array, e.g., ``(2, 3)`` or ``2``.\n    dtype : data-type, optional\n        The desired data-type for the array, e.g., `numpy.int8`.  Default is\n        `numpy.float64`.\n    order : {'C', 'F'}, optional, default: C\n        Whether to store multi-dimensional data in row-major\n        (C-style) or column-major (Fortran-style) order in\n        memory.\n    device : str, optional\n        The device on which to place the created array. Default: None.\n        For Array-API interoperability only, so must be ``\"cpu\"`` if passed.\n\n        .. versionadded:: 2.0.0\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of ones with the given shape, dtype, and order.\n\n    See Also\n    --------\n    ones_like : Return an array of ones with shape and type of input.\n    empty : Return a new uninitialized array.\n    zeros : Return a new array setting values to zero.\n    full : Return a new array of given shape filled with value.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.ones(5)\n    array([1., 1., 1., 1., 1.])\n\n    >>> np.ones((5,), dtype=int)\n    array([1, 1, 1, 1, 1])\n\n    >>> np.ones((2, 1))\n    array([[1.],\n           [1.]])\n\n    >>> s = (2,2)\n    >>> np.ones(s)\n    array([[1.,  1.],\n           [1.,  1.]])\n\n    \"\"\"\n    if like is not None:\n        return _ones_with_like(\n            like, shape, dtype=dtype, order=order, device=device\n        )\n\n    a = empty(shape, dtype, order, device=device)\n    multiarray.copyto(a, 1, casting='unsafe')\n    return a\n\n\n_ones_with_like = array_function_dispatch()(ones)\n\n\ndef _ones_like_dispatcher(\n    a, dtype=None, order=None, subok=None, shape=None, *, device=None\n):\n    return (a,)\n\n\n@array_function_dispatch(_ones_like_dispatcher)\ndef ones_like(\n    a, dtype=None, order='K', subok=True, shape=None, *, device=None\n):\n    \"\"\"\n    Return an array of ones with the same shape and type as a given array.\n\n    Parameters\n    ----------\n    a : array_like\n        The shape and data-type of `a` define these same attributes of\n        the returned array.\n    dtype : data-type, optional\n        Overrides the data type of the result.\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Overrides the memory layout of the result. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible.\n    subok : bool, optional.\n        If True, then the newly created array will use the sub-class\n        type of `a`, otherwise it will be a base-class array. Defaults\n        to True.\n    shape : int or sequence of ints, optional.\n        Overrides the shape of the result. If order='K' and the number of\n        dimensions is unchanged, will try to keep order, otherwise,\n        order='C' is implied.\n    device : str, optional\n        The device on which to place the created array. Default: None.\n        For Array-API interoperability only, so must be ``\"cpu\"`` if passed.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of ones with the same shape and type as `a`.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    zeros_like : Return an array of zeros with shape and type of input.\n    full_like : Return a new array with shape of input filled with value.\n    ones : Return a new array setting values to one.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.arange(6)\n    >>> x = x.reshape((2, 3))\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.ones_like(x)\n    array([[1, 1, 1],\n           [1, 1, 1]])\n\n    >>> y = np.arange(3, dtype=float)\n    >>> y\n    array([0., 1., 2.])\n    >>> np.ones_like(y)\n    array([1.,  1.,  1.])\n\n    \"\"\"\n    res = empty_like(\n        a, dtype=dtype, order=order, subok=subok, shape=shape, device=device\n    )\n    multiarray.copyto(res, 1, casting='unsafe')\n    return res\n\n\ndef _full_dispatcher(\n    shape, fill_value, dtype=None, order=None, *, device=None, like=None\n):\n    return(like,)\n\n\n@finalize_array_function_like\n@set_module('numpy')\ndef full(shape, fill_value, dtype=None, order='C', *, device=None, like=None):\n    \"\"\"\n    Return a new array of given shape and type, filled with `fill_value`.\n\n    Parameters\n    ----------\n    shape : int or sequence of ints\n        Shape of the new array, e.g., ``(2, 3)`` or ``2``.\n    fill_value : scalar or array_like\n        Fill value.\n    dtype : data-type, optional\n        The desired data-type for the array  The default, None, means\n         ``np.array(fill_value).dtype``.\n    order : {'C', 'F'}, optional\n        Whether to store multidimensional data in C- or Fortran-contiguous\n        (row- or column-wise) order in memory.\n    device : str, optional\n        The device on which to place the created array. Default: None.\n        For Array-API interoperability only, so must be ``\"cpu\"`` if passed.\n\n        .. versionadded:: 2.0.0\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of `fill_value` with the given shape, dtype, and order.\n\n    See Also\n    --------\n    full_like : Return a new array with shape of input filled with value.\n    empty : Return a new uninitialized array.\n    ones : Return a new array setting values to one.\n    zeros : Return a new array setting values to zero.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.full((2, 2), np.inf)\n    array([[inf, inf],\n           [inf, inf]])\n    >>> np.full((2, 2), 10)\n    array([[10, 10],\n           [10, 10]])\n\n    >>> np.full((2, 2), [1, 2])\n    array([[1, 2],\n           [1, 2]])\n\n    \"\"\"\n    if like is not None:\n        return _full_with_like(\n            like, shape, fill_value, dtype=dtype, order=order, device=device\n        )\n\n    if dtype is None:\n        fill_value = asarray(fill_value)\n        dtype = fill_value.dtype\n    a = empty(shape, dtype, order, device=device)\n    multiarray.copyto(a, fill_value, casting='unsafe')\n    return a\n\n\n_full_with_like = array_function_dispatch()(full)\n\n\ndef _full_like_dispatcher(\n    a, fill_value, dtype=None, order=None, subok=None, shape=None,\n    *, device=None\n):\n    return (a,)\n\n\n@array_function_dispatch(_full_like_dispatcher)\ndef full_like(\n    a, fill_value, dtype=None, order='K', subok=True, shape=None,\n    *, device=None\n):\n    \"\"\"\n    Return a full array with the same shape and type as a given array.\n\n    Parameters\n    ----------\n    a : array_like\n        The shape and data-type of `a` define these same attributes of\n        the returned array.\n    fill_value : array_like\n        Fill value.\n    dtype : data-type, optional\n        Overrides the data type of the result.\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Overrides the memory layout of the result. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible.\n    subok : bool, optional.\n        If True, then the newly created array will use the sub-class\n        type of `a`, otherwise it will be a base-class array. Defaults\n        to True.\n    shape : int or sequence of ints, optional.\n        Overrides the shape of the result. If order='K' and the number of\n        dimensions is unchanged, will try to keep order, otherwise,\n        order='C' is implied.\n    device : str, optional\n        The device on which to place the created array. Default: None.\n        For Array-API interoperability only, so must be ``\"cpu\"`` if passed.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of `fill_value` with the same shape and type as `a`.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    ones_like : Return an array of ones with shape and type of input.\n    zeros_like : Return an array of zeros with shape and type of input.\n    full : Return a new array of given shape filled with value.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.arange(6, dtype=int)\n    >>> np.full_like(x, 1)\n    array([1, 1, 1, 1, 1, 1])\n    >>> np.full_like(x, 0.1)\n    array([0, 0, 0, 0, 0, 0])\n    >>> np.full_like(x, 0.1, dtype=np.double)\n    array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n    >>> np.full_like(x, np.nan, dtype=np.double)\n    array([nan, nan, nan, nan, nan, nan])\n\n    >>> y = np.arange(6, dtype=np.double)\n    >>> np.full_like(y, 0.1)\n    array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n\n    >>> y = np.zeros([2, 2, 3], dtype=int)\n    >>> np.full_like(y, [0, 0, 255])\n    array([[[  0,   0, 255],\n            [  0,   0, 255]],\n           [[  0,   0, 255],\n            [  0,   0, 255]]])\n    \"\"\"\n    res = empty_like(\n        a, dtype=dtype, order=order, subok=subok, shape=shape, device=device\n    )\n    multiarray.copyto(res, fill_value, casting='unsafe')\n    return res\n\n\ndef _count_nonzero_dispatcher(a, axis=None, *, keepdims=None):\n    return (a,)\n\n\n@array_function_dispatch(_count_nonzero_dispatcher)\ndef count_nonzero(a, axis=None, *, keepdims=False):\n    \"\"\"\n    Counts the number of non-zero values in the array ``a``.\n\n    The word \"non-zero\" is in reference to the Python 2.x\n    built-in method ``__nonzero__()`` (renamed ``__bool__()``\n    in Python 3.x) of Python objects that tests an object's\n    \"truthfulness\". For example, any number is considered\n    truthful if it is nonzero, whereas any string is considered\n    truthful if it is not the empty string. Thus, this function\n    (recursively) counts how many elements in ``a`` (and in\n    sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``\n    method evaluated to ``True``.\n\n    Parameters\n    ----------\n    a : array_like\n        The array for which to count non-zeros.\n    axis : int or tuple, optional\n        Axis or tuple of axes along which to count non-zeros.\n        Default is None, meaning that non-zeros will be counted\n        along a flattened version of ``a``.\n    keepdims : bool, optional\n        If this is set to True, the axes that are counted are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n    Returns\n    -------\n    count : int or array of int\n        Number of non-zero values in the array along a given axis.\n        Otherwise, the total number of non-zero values in the array\n        is returned.\n\n    See Also\n    --------\n    nonzero : Return the coordinates of all the non-zero values.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.count_nonzero(np.eye(4))\n    4\n    >>> a = np.array([[0, 1, 7, 0],\n    ...               [3, 0, 2, 19]])\n    >>> np.count_nonzero(a)\n    5\n    >>> np.count_nonzero(a, axis=0)\n    array([1, 1, 2, 1])\n    >>> np.count_nonzero(a, axis=1)\n    array([2, 3])\n    >>> np.count_nonzero(a, axis=1, keepdims=True)\n    array([[2],\n           [3]])\n    \"\"\"\n    if axis is None and not keepdims:\n        return multiarray.count_nonzero(a)\n\n    a = asanyarray(a)\n\n    # TODO: this works around .astype(bool) not working properly (gh-9847)\n    if np.issubdtype(a.dtype, np.character):\n        a_bool = a != a.dtype.type()\n    else:\n        a_bool = a.astype(np.bool, copy=False)\n\n    return a_bool.sum(axis=axis, dtype=np.intp, keepdims=keepdims)\n\n\n@set_module('numpy')\ndef isfortran(a):\n    \"\"\"\n    Check if the array is Fortran contiguous but *not* C contiguous.\n\n    This function is obsolete. If you only want to check if an array is Fortran\n    contiguous use ``a.flags.f_contiguous`` instead.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n\n    Returns\n    -------\n    isfortran : bool\n        Returns True if the array is Fortran contiguous but *not* C contiguous.\n\n\n    Examples\n    --------\n\n    np.array allows to specify whether the array is written in C-contiguous\n    order (last index varies the fastest), or FORTRAN-contiguous order in\n    memory (first index varies the fastest).\n\n    >>> import numpy as np\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n\n    >>> b = np.array([[1, 2, 3], [4, 5, 6]], order='F')\n    >>> b\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(b)\n    True\n\n\n    The transpose of a C-ordered array is a FORTRAN-ordered array.\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n    >>> b = a.T\n    >>> b\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n    >>> np.isfortran(b)\n    True\n\n    C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.\n\n    >>> np.isfortran(np.array([1, 2], order='F'))\n    False\n\n    \"\"\"\n    return a.flags.fnc\n\n\ndef _argwhere_dispatcher(a):\n    return (a,)\n\n\n@array_function_dispatch(_argwhere_dispatcher)\ndef argwhere(a):\n    \"\"\"\n    Find the indices of array elements that are non-zero, grouped by element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    index_array : (N, a.ndim) ndarray\n        Indices of elements that are non-zero. Indices are grouped by element.\n        This array will have shape ``(N, a.ndim)`` where ``N`` is the number of\n        non-zero items.\n\n    See Also\n    --------\n    where, nonzero\n\n    Notes\n    -----\n    ``np.argwhere(a)`` is almost the same as ``np.transpose(np.nonzero(a))``,\n    but produces a result of the correct shape for a 0D array.\n\n    The output of ``argwhere`` is not suitable for indexing arrays.\n    For this purpose use ``nonzero(a)`` instead.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argwhere(x>1)\n    array([[0, 2],\n           [1, 0],\n           [1, 1],\n           [1, 2]])\n\n    \"\"\"\n    # nonzero does not behave well on 0d, so promote to 1d\n    if np.ndim(a) == 0:\n        a = shape_base.atleast_1d(a)\n        # then remove the added dimension\n        return argwhere(a)[:, :0]\n    return transpose(nonzero(a))\n\n\ndef _flatnonzero_dispatcher(a):\n    return (a,)\n\n\n@array_function_dispatch(_flatnonzero_dispatcher)\ndef flatnonzero(a):\n    \"\"\"\n    Return indices that are non-zero in the flattened version of a.\n\n    This is equivalent to ``np.nonzero(np.ravel(a))[0]``.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, containing the indices of the elements of ``a.ravel()``\n        that are non-zero.\n\n    See Also\n    --------\n    nonzero : Return the indices of the non-zero elements of the input array.\n    ravel : Return a 1-D array containing the elements of the input array.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.arange(-2, 3)\n    >>> x\n    array([-2, -1,  0,  1,  2])\n    >>> np.flatnonzero(x)\n    array([0, 1, 3, 4])\n\n    Use the indices of the non-zero elements as an index array to extract\n    these elements:\n\n    >>> x.ravel()[np.flatnonzero(x)]\n    array([-2, -1,  1,  2])\n\n    \"\"\"\n    return np.nonzero(np.ravel(a))[0]\n\n\ndef _correlate_dispatcher(a, v, mode=None):\n    return (a, v)\n\n\n@array_function_dispatch(_correlate_dispatcher)\ndef correlate(a, v, mode='valid'):\n    r\"\"\"\n    Cross-correlation of two 1-dimensional sequences.\n\n    This function computes the correlation as generally defined in signal\n    processing texts [1]_:\n\n    .. math:: c_k = \\sum_n a_{n+k} \\cdot \\overline{v}_n\n\n    with a and v sequences being zero-padded where necessary and\n    :math:`\\overline v` denoting complex conjugation.\n\n    Parameters\n    ----------\n    a, v : array_like\n        Input sequences.\n    mode : {'valid', 'same', 'full'}, optional\n        Refer to the `convolve` docstring.  Note that the default\n        is 'valid', unlike `convolve`, which uses 'full'.\n\n    Returns\n    -------\n    out : ndarray\n        Discrete cross-correlation of `a` and `v`.\n\n    See Also\n    --------\n    convolve : Discrete, linear convolution of two one-dimensional sequences.\n    scipy.signal.correlate : uses FFT which has superior performance\n        on large arrays.\n\n    Notes\n    -----\n    The definition of correlation above is not unique and sometimes\n    correlation may be defined differently. Another common definition is [1]_:\n\n    .. math:: c'_k = \\sum_n a_{n} \\cdot \\overline{v_{n+k}}\n\n    which is related to :math:`c_k` by :math:`c'_k = c_{-k}`.\n\n    `numpy.correlate` may perform slowly in large arrays (i.e. n = 1e5)\n    because it does not use the FFT to compute the convolution; in that case,\n    `scipy.signal.correlate` might be preferable.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Cross-correlation\",\n           https://en.wikipedia.org/wiki/Cross-correlation\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5])\n    array([3.5])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"same\")\n    array([2. ,  3.5,  3. ])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"full\")\n    array([0.5,  2. ,  3.5,  3. ,  0. ])\n\n    Using complex sequences:\n\n    >>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')\n    array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])\n\n    Note that you get the time reversed, complex conjugated result\n    (:math:`\\overline{c_{-k}}`) when the two input sequences a and v change\n    places:\n\n    >>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')\n    array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])\n\n    \"\"\"\n    return multiarray.correlate2(a, v, mode)\n\n\ndef _convolve_dispatcher(a, v, mode=None):\n    return (a, v)\n\n\n@array_function_dispatch(_convolve_dispatcher)\ndef convolve(a, v, mode='full'):\n    \"\"\"\n    Returns the discrete, linear convolution of two one-dimensional sequences.\n\n    The convolution operator is often seen in signal processing, where it\n    models the effect of a linear time-invariant system on a signal [1]_.  In\n    probability theory, the sum of two independent random variables is\n    distributed according to the convolution of their individual\n    distributions.\n\n    If `v` is longer than `a`, the arrays are swapped before computation.\n\n    Parameters\n    ----------\n    a : (N,) array_like\n        First one-dimensional input array.\n    v : (M,) array_like\n        Second one-dimensional input array.\n    mode : {'full', 'valid', 'same'}, optional\n        'full':\n          By default, mode is 'full'.  This returns the convolution\n          at each point of overlap, with an output shape of (N+M-1,). At\n          the end-points of the convolution, the signals do not overlap\n          completely, and boundary effects may be seen.\n\n        'same':\n          Mode 'same' returns output of length ``max(M, N)``.  Boundary\n          effects are still visible.\n\n        'valid':\n          Mode 'valid' returns output of length\n          ``max(M, N) - min(M, N) + 1``.  The convolution product is only given\n          for points where the signals overlap completely.  Values outside\n          the signal boundary have no effect.\n\n    Returns\n    -------\n    out : ndarray\n        Discrete, linear convolution of `a` and `v`.\n\n    See Also\n    --------\n    scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier\n                               Transform.\n    scipy.linalg.toeplitz : Used to construct the convolution operator.\n    polymul : Polynomial multiplication. Same output as convolve, but also\n              accepts poly1d objects as input.\n\n    Notes\n    -----\n    The discrete convolution operation is defined as\n\n    .. math:: (a * v)_n = \\\\sum_{m = -\\\\infty}^{\\\\infty} a_m v_{n - m}\n\n    It can be shown that a convolution :math:`x(t) * y(t)` in time/space\n    is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier\n    domain, after appropriate padding (padding is necessary to prevent\n    circular convolution).  Since multiplication is more efficient (faster)\n    than convolution, the function `scipy.signal.fftconvolve` exploits the\n    FFT to calculate the convolution of large data-sets.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Convolution\",\n        https://en.wikipedia.org/wiki/Convolution\n\n    Examples\n    --------\n    Note how the convolution operator flips the second array\n    before \"sliding\" the two across one another:\n\n    >>> import numpy as np\n    >>> np.convolve([1, 2, 3], [0, 1, 0.5])\n    array([0. , 1. , 2.5, 4. , 1.5])\n\n    Only return the middle values of the convolution.\n    Contains boundary effects, where zeros are taken\n    into account:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'same')\n    array([1. ,  2.5,  4. ])\n\n    The two arrays are of the same length, so there\n    is only one position where they completely overlap:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'valid')\n    array([2.5])\n\n    \"\"\"\n    a, v = array(a, copy=None, ndmin=1), array(v, copy=None, ndmin=1)\n    if (len(v) > len(a)):\n        a, v = v, a\n    if len(a) == 0:\n        raise ValueError('a cannot be empty')\n    if len(v) == 0:\n        raise ValueError('v cannot be empty')\n    return multiarray.correlate(a, v[::-1], mode)\n\n\ndef _outer_dispatcher(a, b, out=None):\n    return (a, b, out)\n\n\n@array_function_dispatch(_outer_dispatcher)\ndef outer(a, b, out=None):\n    \"\"\"\n    Compute the outer product of two vectors.\n\n    Given two vectors `a` and `b` of length ``M`` and ``N``, respectively,\n    the outer product [1]_ is::\n\n      [[a_0*b_0  a_0*b_1 ... a_0*b_{N-1} ]\n       [a_1*b_0    .\n       [ ...          .\n       [a_{M-1}*b_0            a_{M-1}*b_{N-1} ]]\n\n    Parameters\n    ----------\n    a : (M,) array_like\n        First input vector.  Input is flattened if\n        not already 1-dimensional.\n    b : (N,) array_like\n        Second input vector.  Input is flattened if\n        not already 1-dimensional.\n    out : (M, N) ndarray, optional\n        A location where the result is stored\n\n    Returns\n    -------\n    out : (M, N) ndarray\n        ``out[i, j] = a[i] * b[j]``\n\n    See also\n    --------\n    inner\n    einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.\n    ufunc.outer : A generalization to dimensions other than 1D and other\n                  operations. ``np.multiply.outer(a.ravel(), b.ravel())``\n                  is the equivalent.\n    linalg.outer : An Array API compatible variation of ``np.outer``,\n                   which accepts 1-dimensional inputs only.\n    tensordot : ``np.tensordot(a.ravel(), b.ravel(), axes=((), ()))``\n                is the equivalent.\n\n    References\n    ----------\n    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd\n           ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n           pg. 8.\n\n    Examples\n    --------\n    Make a (*very* coarse) grid for computing a Mandelbrot set:\n\n    >>> import numpy as np\n    >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n    >>> rl\n    array([[-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.]])\n    >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n    >>> im\n    array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n           [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n           [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n           [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n           [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n    >>> grid = rl + im\n    >>> grid\n    array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n           [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n           [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n           [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n           [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n    An example using a \"vector\" of letters:\n\n    >>> x = np.array(['a', 'b', 'c'], dtype=object)\n    >>> np.outer(x, [1, 2, 3])\n    array([['a', 'aa', 'aaa'],\n           ['b', 'bb', 'bbb'],\n           ['c', 'cc', 'ccc']], dtype=object)\n\n    \"\"\"\n    a = asarray(a)\n    b = asarray(b)\n    return multiply(a.ravel()[:, newaxis], b.ravel()[newaxis, :], out)\n\n\ndef _tensordot_dispatcher(a, b, axes=None):\n    return (a, b)\n\n\n@array_function_dispatch(_tensordot_dispatcher)\ndef tensordot(a, b, axes=2):\n    \"\"\"\n    Compute tensor dot product along specified axes.\n\n    Given two tensors, `a` and `b`, and an array_like object containing\n    two array_like objects, ``(a_axes, b_axes)``, sum the products of\n    `a`'s and `b`'s elements (components) over the axes specified by\n    ``a_axes`` and ``b_axes``. The third argument can be a single non-negative\n    integer_like scalar, ``N``; if it is such, then the last ``N`` dimensions\n    of `a` and the first ``N`` dimensions of `b` are summed over.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Tensors to \"dot\".\n\n    axes : int or (2,) array_like\n        * integer_like\n          If an int N, sum over the last N axes of `a` and the first N axes\n          of `b` in order. The sizes of the corresponding axes must match.\n        * (2,) array_like\n          Or, a list of axes to be summed over, first sequence applying to `a`,\n          second to `b`. Both elements array_like must be of the same length.\n\n    Returns\n    -------\n    output : ndarray\n        The tensor dot product of the input.\n\n    See Also\n    --------\n    dot, einsum\n\n    Notes\n    -----\n    Three common use cases are:\n        * ``axes = 0`` : tensor product :math:`a\\\\otimes b`\n        * ``axes = 1`` : tensor dot product :math:`a\\\\cdot b`\n        * ``axes = 2`` : (default) tensor double contraction :math:`a:b`\n\n    When `axes` is integer_like, the sequence of axes for evaluation\n    will be: from the -Nth axis to the -1th axis in `a`,\n    and from the 0th axis to (N-1)th axis in `b`.\n    For example, ``axes = 2`` is the equal to\n    ``axes = [[-2, -1], [0, 1]]``.\n    When N-1 is smaller than 0, or when -N is larger than -1,\n    the element of `a` and `b` are defined as the `axes`.\n\n    When there is more than one axis to sum over - and they are not the last\n    (first) axes of `a` (`b`) - the argument `axes` should consist of\n    two sequences of the same length, with the first axis to sum over given\n    first in both sequences, the second axis second, and so forth.\n    The calculation can be referred to ``numpy.einsum``.\n\n    The shape of the result consists of the non-contracted axes of the\n    first tensor, followed by the non-contracted axes of the second.\n\n    Examples\n    -------- \n    An example on integer_like:\n\n    >>> a_0 = np.array([[1, 2], [3, 4]])\n    >>> b_0 = np.array([[5, 6], [7, 8]])\n    >>> c_0 = np.tensordot(a_0, b_0, axes=0)\n    >>> c_0.shape\n    (2, 2, 2, 2)\n    >>> c_0\n    array([[[[ 5,  6],\n             [ 7,  8]],\n            [[10, 12],\n             [14, 16]]],\n           [[[15, 18],\n             [21, 24]],\n            [[20, 24],\n             [28, 32]]]])\n\n    An example on array_like:\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> c = np.tensordot(a,b, axes=([1,0],[0,1]))\n    >>> c.shape\n    (5, 2)\n    >>> c\n    array([[4400., 4730.],\n           [4532., 4874.],\n           [4664., 5018.],\n           [4796., 5162.],\n           [4928., 5306.]])\n           \n    A slower but equivalent way of computing the same...\n    \n    >>> d = np.zeros((5,2))\n    >>> for i in range(5):\n    ...   for j in range(2):\n    ...     for k in range(3):\n    ...       for n in range(4):\n    ...         d[i,j] += a[k,n,i] * b[n,k,j]\n    >>> c == d\n    array([[ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True]])\n\n    An extended example taking advantage of the overloading of + and \\\\*:\n\n    >>> a = np.array(range(1, 9))\n    >>> a.shape = (2, 2, 2)\n    >>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)\n    >>> A.shape = (2, 2)\n    >>> a; A\n    array([[[1, 2],\n            [3, 4]],\n           [[5, 6],\n            [7, 8]]])\n    array([['a', 'b'],\n           ['c', 'd']], dtype=object)\n\n    >>> np.tensordot(a, A) # third argument default is 2 for double-contraction\n    array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)\n\n    >>> np.tensordot(a, A, 1)\n    array([[['acc', 'bdd'],\n            ['aaacccc', 'bbbdddd']],\n           [['aaaaacccccc', 'bbbbbdddddd'],\n            ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)\n\n    >>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)\n    array([[[[['a', 'b'],\n              ['c', 'd']],\n              ...\n\n    >>> np.tensordot(a, A, (0, 1))\n    array([[['abbbbb', 'cddddd'],\n            ['aabbbbbb', 'ccdddddd']],\n           [['aaabbbbbbb', 'cccddddddd'],\n            ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)\n\n    >>> np.tensordot(a, A, (2, 1))\n    array([[['abb', 'cdd'],\n            ['aaabbbb', 'cccdddd']],\n           [['aaaaabbbbbb', 'cccccdddddd'],\n            ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)\n\n    >>> np.tensordot(a, A, ((0, 1), (0, 1)))\n    array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)\n\n    >>> np.tensordot(a, A, ((2, 1), (1, 0)))\n    array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)\n\n    \"\"\"\n    try:\n        iter(axes)\n    except Exception:\n        axes_a = list(range(-axes, 0))\n        axes_b = list(range(0, axes))\n    else:\n        axes_a, axes_b = axes\n    try:\n        na = len(axes_a)\n        axes_a = list(axes_a)\n    except TypeError:\n        axes_a = [axes_a]\n        na = 1\n    try:\n        nb = len(axes_b)\n        axes_b = list(axes_b)\n    except TypeError:\n        axes_b = [axes_b]\n        nb = 1\n\n    a, b = asarray(a), asarray(b)\n    as_ = a.shape\n    nda = a.ndim\n    bs = b.shape\n    ndb = b.ndim\n    equal = True\n    if na != nb:\n        equal = False\n    else:\n        for k in range(na):\n            if as_[axes_a[k]] != bs[axes_b[k]]:\n                equal = False\n                break\n            if axes_a[k] < 0:\n                axes_a[k] += nda\n            if axes_b[k] < 0:\n                axes_b[k] += ndb\n    if not equal:\n        raise ValueError(\"shape-mismatch for sum\")\n\n    # Move the axes to sum over to the end of \"a\"\n    # and to the front of \"b\"\n    notin = [k for k in range(nda) if k not in axes_a]\n    newaxes_a = notin + axes_a\n    N2 = math.prod(as_[axis] for axis in axes_a)\n    newshape_a = (math.prod([as_[ax] for ax in notin]), N2)\n    olda = [as_[axis] for axis in notin]\n\n    notin = [k for k in range(ndb) if k not in axes_b]\n    newaxes_b = axes_b + notin\n    N2 = math.prod(bs[axis] for axis in axes_b)\n    newshape_b = (N2, math.prod([bs[ax] for ax in notin]))\n    oldb = [bs[axis] for axis in notin]\n\n    at = a.transpose(newaxes_a).reshape(newshape_a)\n    bt = b.transpose(newaxes_b).reshape(newshape_b)\n    res = dot(at, bt)\n    return res.reshape(olda + oldb)\n\n\ndef _roll_dispatcher(a, shift, axis=None):\n    return (a,)\n\n\n@array_function_dispatch(_roll_dispatcher)\ndef roll(a, shift, axis=None):\n    \"\"\"\n    Roll array elements along a given axis.\n\n    Elements that roll beyond the last position are re-introduced at\n    the first.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    shift : int or tuple of ints\n        The number of places by which elements are shifted.  If a tuple,\n        then `axis` must be a tuple of the same size, and each of the\n        given axes is shifted by the corresponding number.  If an int\n        while `axis` is a tuple of ints, then the same value is used for\n        all given axes.\n    axis : int or tuple of ints, optional\n        Axis or axes along which elements are shifted.  By default, the\n        array is flattened before shifting, after which the original\n        shape is restored.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, with the same shape as `a`.\n\n    See Also\n    --------\n    rollaxis : Roll the specified axis backwards, until it lies in a\n               given position.\n\n    Notes\n    -----\n    Supports rolling over multiple dimensions simultaneously.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.arange(10)\n    >>> np.roll(x, 2)\n    array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\n    >>> np.roll(x, -2)\n    array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])\n\n    >>> x2 = np.reshape(x, (2, 5))\n    >>> x2\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> np.roll(x2, 1)\n    array([[9, 0, 1, 2, 3],\n           [4, 5, 6, 7, 8]])\n    >>> np.roll(x2, -1)\n    array([[1, 2, 3, 4, 5],\n           [6, 7, 8, 9, 0]])\n    >>> np.roll(x2, 1, axis=0)\n    array([[5, 6, 7, 8, 9],\n           [0, 1, 2, 3, 4]])\n    >>> np.roll(x2, -1, axis=0)\n    array([[5, 6, 7, 8, 9],\n           [0, 1, 2, 3, 4]])\n    >>> np.roll(x2, 1, axis=1)\n    array([[4, 0, 1, 2, 3],\n           [9, 5, 6, 7, 8]])\n    >>> np.roll(x2, -1, axis=1)\n    array([[1, 2, 3, 4, 0],\n           [6, 7, 8, 9, 5]])\n    >>> np.roll(x2, (1, 1), axis=(1, 0))\n    array([[9, 5, 6, 7, 8],\n           [4, 0, 1, 2, 3]])\n    >>> np.roll(x2, (2, 1), axis=(1, 0))\n    array([[8, 9, 5, 6, 7],\n           [3, 4, 0, 1, 2]])\n\n    \"\"\"\n    a = asanyarray(a)\n    if axis is None:\n        return roll(a.ravel(), shift, 0).reshape(a.shape)\n\n    else:\n        axis = normalize_axis_tuple(axis, a.ndim, allow_duplicate=True)\n        broadcasted = broadcast(shift, axis)\n        if broadcasted.ndim > 1:\n            raise ValueError(\n                \"'shift' and 'axis' should be scalars or 1D sequences\")\n        shifts = {ax: 0 for ax in range(a.ndim)}\n        for sh, ax in broadcasted:\n            shifts[ax] += int(sh)\n\n        rolls = [((slice(None), slice(None)),)] * a.ndim\n        for ax, offset in shifts.items():\n            offset %= a.shape[ax] or 1  # If `a` is empty, nothing matters.\n            if offset:\n                # (original, result), (original, result)\n                rolls[ax] = ((slice(None, -offset), slice(offset, None)),\n                             (slice(-offset, None), slice(None, offset)))\n\n        result = empty_like(a)\n        for indices in itertools.product(*rolls):\n            arr_index, res_index = zip(*indices)\n            result[res_index] = a[arr_index]\n\n        return result\n\n\ndef _rollaxis_dispatcher(a, axis, start=None):\n    return (a,)\n\n\n@array_function_dispatch(_rollaxis_dispatcher)\ndef rollaxis(a, axis, start=0):\n    \"\"\"\n    Roll the specified axis backwards, until it lies in a given position.\n\n    This function continues to be supported for backward compatibility, but you\n    should prefer `moveaxis`. The `moveaxis` function was added in NumPy\n    1.11.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    axis : int\n        The axis to be rolled. The positions of the other axes do not\n        change relative to one another.\n    start : int, optional\n        When ``start <= axis``, the axis is rolled back until it lies in\n        this position. When ``start > axis``, the axis is rolled until it\n        lies before this position. The default, 0, results in a \"complete\"\n        roll. The following table describes how negative values of ``start``\n        are interpreted:\n\n        .. table::\n           :align: left\n\n           +-------------------+----------------------+\n           |     ``start``     | Normalized ``start`` |\n           +===================+======================+\n           | ``-(arr.ndim+1)`` | raise ``AxisError``  |\n           +-------------------+----------------------+\n           | ``-arr.ndim``     | 0                    |\n           +-------------------+----------------------+\n           | |vdots|           | |vdots|              |\n           +-------------------+----------------------+\n           | ``-1``            | ``arr.ndim-1``       |\n           +-------------------+----------------------+\n           | ``0``             | ``0``                |\n           +-------------------+----------------------+\n           | |vdots|           | |vdots|              |\n           +-------------------+----------------------+\n           | ``arr.ndim``      | ``arr.ndim``         |\n           +-------------------+----------------------+\n           | ``arr.ndim + 1``  | raise ``AxisError``  |\n           +-------------------+----------------------+\n\n        .. |vdots|   unicode:: U+22EE .. Vertical Ellipsis\n\n    Returns\n    -------\n    res : ndarray\n        For NumPy >= 1.10.0 a view of `a` is always returned. For earlier\n        NumPy versions a view of `a` is returned only if the order of the\n        axes is changed, otherwise the input array is returned.\n\n    See Also\n    --------\n    moveaxis : Move array axes to new positions.\n    roll : Roll the elements of an array by a number of positions along a\n        given axis.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.ones((3,4,5,6))\n    >>> np.rollaxis(a, 3, 1).shape\n    (3, 6, 4, 5)\n    >>> np.rollaxis(a, 2).shape\n    (5, 3, 4, 6)\n    >>> np.rollaxis(a, 1, 4).shape\n    (3, 5, 6, 4)\n\n    \"\"\"\n    n = a.ndim\n    axis = normalize_axis_index(axis, n)\n    if start < 0:\n        start += n\n    msg = \"'%s' arg requires %d <= %s < %d, but %d was passed in\"\n    if not (0 <= start < n + 1):\n        raise AxisError(msg % ('start', -n, 'start', n + 1, start))\n    if axis < start:\n        # it's been removed\n        start -= 1\n    if axis == start:\n        return a[...]\n    axes = list(range(0, n))\n    axes.remove(axis)\n    axes.insert(start, axis)\n    return a.transpose(axes)\n\n\n@set_module(\"numpy.lib.array_utils\")\ndef normalize_axis_tuple(axis, ndim, argname=None, allow_duplicate=False):\n    \"\"\"\n    Normalizes an axis argument into a tuple of non-negative integer axes.\n\n    This handles shorthands such as ``1`` and converts them to ``(1,)``,\n    as well as performing the handling of negative indices covered by\n    `normalize_axis_index`.\n\n    By default, this forbids axes from being specified multiple times.\n\n    Used internally by multi-axis-checking logic.\n\n    Parameters\n    ----------\n    axis : int, iterable of int\n        The un-normalized index or indices of the axis.\n    ndim : int\n        The number of dimensions of the array that `axis` should be normalized\n        against.\n    argname : str, optional\n        A prefix to put before the error message, typically the name of the\n        argument.\n    allow_duplicate : bool, optional\n        If False, the default, disallow an axis from being specified twice.\n\n    Returns\n    -------\n    normalized_axes : tuple of int\n        The normalized axis index, such that `0 <= normalized_axis < ndim`\n\n    Raises\n    ------\n    AxisError\n        If any axis provided is out of range\n    ValueError\n        If an axis is repeated\n\n    See also\n    --------\n    normalize_axis_index : normalizing a single scalar axis\n    \"\"\"\n    # Optimization to speed-up the most common cases.\n    if type(axis) not in (tuple, list):\n        try:\n            axis = [operator.index(axis)]\n        except TypeError:\n            pass\n    # Going via an iterator directly is slower than via list comprehension.\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\n    if not allow_duplicate and len(set(axis)) != len(axis):\n        if argname:\n            raise ValueError('repeated axis in `{}` argument'.format(argname))\n        else:\n            raise ValueError('repeated axis')\n    return axis\n\n\ndef _moveaxis_dispatcher(a, source, destination):\n    return (a,)\n\n\n@array_function_dispatch(_moveaxis_dispatcher)\ndef moveaxis(a, source, destination):\n    \"\"\"\n    Move axes of an array to new positions.\n\n    Other axes remain in their original order.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        The array whose axes should be reordered.\n    source : int or sequence of int\n        Original positions of the axes to move. These must be unique.\n    destination : int or sequence of int\n        Destination positions for each of the original axes. These must also be\n        unique.\n\n    Returns\n    -------\n    result : np.ndarray\n        Array with moved axes. This array is a view of the input array.\n\n    See Also\n    --------\n    transpose : Permute the dimensions of an array.\n    swapaxes : Interchange two axes of an array.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.zeros((3, 4, 5))\n    >>> np.moveaxis(x, 0, -1).shape\n    (4, 5, 3)\n    >>> np.moveaxis(x, -1, 0).shape\n    (5, 3, 4)\n\n    These all achieve the same result:\n\n    >>> np.transpose(x).shape\n    (5, 4, 3)\n    >>> np.swapaxes(x, 0, -1).shape\n    (5, 4, 3)\n    >>> np.moveaxis(x, [0, 1], [-1, -2]).shape\n    (5, 4, 3)\n    >>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape\n    (5, 4, 3)\n\n    \"\"\"\n    try:\n        # allow duck-array types if they define transpose\n        transpose = a.transpose\n    except AttributeError:\n        a = asarray(a)\n        transpose = a.transpose\n\n    source = normalize_axis_tuple(source, a.ndim, 'source')\n    destination = normalize_axis_tuple(destination, a.ndim, 'destination')\n    if len(source) != len(destination):\n        raise ValueError('`source` and `destination` arguments must have '\n                         'the same number of elements')\n\n    order = [n for n in range(a.ndim) if n not in source]\n\n    for dest, src in sorted(zip(destination, source)):\n        order.insert(dest, src)\n\n    result = transpose(order)\n    return result\n\n\ndef _cross_dispatcher(a, b, axisa=None, axisb=None, axisc=None, axis=None):\n    return (a, b)\n\n\n@array_function_dispatch(_cross_dispatcher)\ndef cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):\n    \"\"\"\n    Return the cross product of two (arrays of) vectors.\n\n    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular\n    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors\n    are defined by the last axis of `a` and `b` by default, and these axes\n    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is\n    2, the third component of the input vector is assumed to be zero and the\n    cross product calculated accordingly.  In cases where both input vectors\n    have dimension 2, the z-component of the cross product is returned.\n\n    Parameters\n    ----------\n    a : array_like\n        Components of the first vector(s).\n    b : array_like\n        Components of the second vector(s).\n    axisa : int, optional\n        Axis of `a` that defines the vector(s).  By default, the last axis.\n    axisb : int, optional\n        Axis of `b` that defines the vector(s).  By default, the last axis.\n    axisc : int, optional\n        Axis of `c` containing the cross product vector(s).  Ignored if\n        both input vectors have dimension 2, as the return is scalar.\n        By default, the last axis.\n    axis : int, optional\n        If defined, the axis of `a`, `b` and `c` that defines the vector(s)\n        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.\n\n    Returns\n    -------\n    c : ndarray\n        Vector cross product(s).\n\n    Raises\n    ------\n    ValueError\n        When the dimension of the vector(s) in `a` and/or `b` does not\n        equal 2 or 3.\n\n    See Also\n    --------\n    inner : Inner product\n    outer : Outer product.\n    linalg.cross : An Array API compatible variation of ``np.cross``,\n                   which accepts (arrays of) 3-element vectors only.\n    ix_ : Construct index arrays.\n\n    Notes\n    -----\n    Supports full broadcasting of the inputs.\n\n    Dimension-2 input arrays were deprecated in 2.0.0. If you do need this\n    functionality, you can use::\n\n        def cross2d(x, y):\n            return x[..., 0] * y[..., 1] - x[..., 1] * y[..., 0]\n\n    Examples\n    --------\n    Vector cross-product.\n\n    >>> import numpy as np\n    >>> x = [1, 2, 3]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([-3,  6, -3])\n\n    One vector with dimension 2.\n\n    >>> x = [1, 2]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Equivalently:\n\n    >>> x = [1, 2, 0]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Both vectors with dimension 2.\n\n    >>> x = [1,2]\n    >>> y = [4,5]\n    >>> np.cross(x, y)\n    array(-3)\n\n    Multiple vector cross-products. Note that the direction of the cross\n    product vector is defined by the *right-hand rule*.\n\n    >>> x = np.array([[1,2,3], [4,5,6]])\n    >>> y = np.array([[4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[-3,  6, -3],\n           [ 3, -6,  3]])\n\n    The orientation of `c` can be changed using the `axisc` keyword.\n\n    >>> np.cross(x, y, axisc=0)\n    array([[-3,  3],\n           [ 6, -6],\n           [-3,  3]])\n\n    Change the vector definition of `x` and `y` using `axisa` and `axisb`.\n\n    >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n    >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[ -6,  12,  -6],\n           [  0,   0,   0],\n           [  6, -12,   6]])\n    >>> np.cross(x, y, axisa=0, axisb=0)\n    array([[-24,  48, -24],\n           [-30,  60, -30],\n           [-36,  72, -36]])\n\n    \"\"\"\n    if axis is not None:\n        axisa, axisb, axisc = (axis,) * 3\n    a = asarray(a)\n    b = asarray(b)\n\n    if (a.ndim < 1) or (b.ndim < 1):\n        raise ValueError(\"At least one array has zero dimension\")\n\n    # Check axisa and axisb are within bounds\n    axisa = normalize_axis_index(axisa, a.ndim, msg_prefix='axisa')\n    axisb = normalize_axis_index(axisb, b.ndim, msg_prefix='axisb')\n\n    # Move working axis to the end of the shape\n    a = moveaxis(a, axisa, -1)\n    b = moveaxis(b, axisb, -1)\n    msg = (\"incompatible dimensions for cross product\\n\"\n           \"(dimension must be 2 or 3)\")\n    if a.shape[-1] not in (2, 3) or b.shape[-1] not in (2, 3):\n        raise ValueError(msg)\n    if a.shape[-1] == 2 or b.shape[-1] == 2:\n        # Deprecated in NumPy 2.0, 2023-09-26\n        warnings.warn(\n            \"Arrays of 2-dimensional vectors are deprecated. Use arrays of \"\n            \"3-dimensional vectors instead. (deprecated in NumPy 2.0)\",\n            DeprecationWarning, stacklevel=2\n        )\n\n    # Create the output array\n    shape = broadcast(a[..., 0], b[..., 0]).shape\n    if a.shape[-1] == 3 or b.shape[-1] == 3:\n        shape += (3,)\n        # Check axisc is within bounds\n        axisc = normalize_axis_index(axisc, len(shape), msg_prefix='axisc')\n    dtype = promote_types(a.dtype, b.dtype)\n    cp = empty(shape, dtype)\n\n    # recast arrays as dtype\n    a = a.astype(dtype)\n    b = b.astype(dtype)\n\n    # create local aliases for readability\n    a0 = a[..., 0]\n    a1 = a[..., 1]\n    if a.shape[-1] == 3:\n        a2 = a[..., 2]\n    b0 = b[..., 0]\n    b1 = b[..., 1]\n    if b.shape[-1] == 3:\n        b2 = b[..., 2]\n    if cp.ndim != 0 and cp.shape[-1] == 3:\n        cp0 = cp[..., 0]\n        cp1 = cp[..., 1]\n        cp2 = cp[..., 2]\n\n    if a.shape[-1] == 2:\n        if b.shape[-1] == 2:\n            # a0 * b1 - a1 * b0\n            multiply(a0, b1, out=cp)\n            cp -= a1 * b0\n            return cp\n        else:\n            assert b.shape[-1] == 3\n            # cp0 = a1 * b2 - 0  (a2 = 0)\n            # cp1 = 0 - a0 * b2  (a2 = 0)\n            # cp2 = a0 * b1 - a1 * b0\n            multiply(a1, b2, out=cp0)\n            multiply(a0, b2, out=cp1)\n            negative(cp1, out=cp1)\n            multiply(a0, b1, out=cp2)\n            cp2 -= a1 * b0\n    else:\n        assert a.shape[-1] == 3\n        if b.shape[-1] == 3:\n            # cp0 = a1 * b2 - a2 * b1\n            # cp1 = a2 * b0 - a0 * b2\n            # cp2 = a0 * b1 - a1 * b0\n            multiply(a1, b2, out=cp0)\n            tmp = array(a2 * b1)\n            cp0 -= tmp\n            multiply(a2, b0, out=cp1)\n            multiply(a0, b2, out=tmp)\n            cp1 -= tmp\n            multiply(a0, b1, out=cp2)\n            multiply(a1, b0, out=tmp)\n            cp2 -= tmp\n        else:\n            assert b.shape[-1] == 2\n            # cp0 = 0 - a2 * b1  (b2 = 0)\n            # cp1 = a2 * b0 - 0  (b2 = 0)\n            # cp2 = a0 * b1 - a1 * b0\n            multiply(a2, b1, out=cp0)\n            negative(cp0, out=cp0)\n            multiply(a2, b0, out=cp1)\n            multiply(a0, b1, out=cp2)\n            cp2 -= a1 * b0\n\n    return moveaxis(cp, -1, axisc)\n\n\nlittle_endian = (sys.byteorder == 'little')\n\n\n@set_module('numpy')\ndef indices(dimensions, dtype=int, sparse=False):\n    \"\"\"\n    Return an array representing the indices of a grid.\n\n    Compute an array where the subarrays contain index values 0, 1, ...\n    varying only along the corresponding axis.\n\n    Parameters\n    ----------\n    dimensions : sequence of ints\n        The shape of the grid.\n    dtype : dtype, optional\n        Data type of the result.\n    sparse : boolean, optional\n        Return a sparse representation of the grid instead of a dense\n        representation. Default is False.\n\n    Returns\n    -------\n    grid : one ndarray or tuple of ndarrays\n        If sparse is False:\n            Returns one array of grid indices,\n            ``grid.shape = (len(dimensions),) + tuple(dimensions)``.\n        If sparse is True:\n            Returns a tuple of arrays, with\n            ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with\n            dimensions[i] in the ith place\n\n    See Also\n    --------\n    mgrid, ogrid, meshgrid\n\n    Notes\n    -----\n    The output shape in the dense case is obtained by prepending the number\n    of dimensions in front of the tuple of dimensions, i.e. if `dimensions`\n    is a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is\n    ``(N, r0, ..., rN-1)``.\n\n    The subarrays ``grid[k]`` contains the N-D array of indices along the\n    ``k-th`` axis. Explicitly::\n\n        grid[k, i0, i1, ..., iN-1] = ik\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> grid = np.indices((2, 3))\n    >>> grid.shape\n    (2, 2, 3)\n    >>> grid[0]        # row indices\n    array([[0, 0, 0],\n           [1, 1, 1]])\n    >>> grid[1]        # column indices\n    array([[0, 1, 2],\n           [0, 1, 2]])\n\n    The indices can be used as an index into an array.\n\n    >>> x = np.arange(20).reshape(5, 4)\n    >>> row, col = np.indices((2, 3))\n    >>> x[row, col]\n    array([[0, 1, 2],\n           [4, 5, 6]])\n\n    Note that it would be more straightforward in the above example to\n    extract the required elements directly with ``x[:2, :3]``.\n\n    If sparse is set to true, the grid will be returned in a sparse\n    representation.\n\n    >>> i, j = np.indices((2, 3), sparse=True)\n    >>> i.shape\n    (2, 1)\n    >>> j.shape\n    (1, 3)\n    >>> i        # row indices\n    array([[0],\n           [1]])\n    >>> j        # column indices\n    array([[0, 1, 2]])\n\n    \"\"\"\n    dimensions = tuple(dimensions)\n    N = len(dimensions)\n    shape = (1,)*N\n    if sparse:\n        res = tuple()\n    else:\n        res = empty((N,)+dimensions, dtype=dtype)\n    for i, dim in enumerate(dimensions):\n        idx = arange(dim, dtype=dtype).reshape(\n            shape[:i] + (dim,) + shape[i+1:]\n        )\n        if sparse:\n            res = res + (idx,)\n        else:\n            res[i] = idx\n    return res\n\n\n@finalize_array_function_like\n@set_module('numpy')\ndef fromfunction(function, shape, *, dtype=float, like=None, **kwargs):\n    \"\"\"\n    Construct an array by executing a function over each coordinate.\n\n    The resulting array therefore has a value ``fn(x, y, z)`` at\n    coordinate ``(x, y, z)``.\n\n    Parameters\n    ----------\n    function : callable\n        The function is called with N parameters, where N is the rank of\n        `shape`.  Each parameter represents the coordinates of the array\n        varying along a specific axis.  For example, if `shape`\n        were ``(2, 2)``, then the parameters would be\n        ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``\n    shape : (N,) tuple of ints\n        Shape of the output array, which also determines the shape of\n        the coordinate arrays passed to `function`.\n    dtype : data-type, optional\n        Data-type of the coordinate arrays passed to `function`.\n        By default, `dtype` is float.\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    fromfunction : any\n        The result of the call to `function` is passed back directly.\n        Therefore the shape of `fromfunction` is completely determined by\n        `function`.  If `function` returns a scalar value, the shape of\n        `fromfunction` would not match the `shape` parameter.\n\n    See Also\n    --------\n    indices, meshgrid\n\n    Notes\n    -----\n    Keywords other than `dtype` and `like` are passed to `function`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.fromfunction(lambda i, j: i, (2, 2), dtype=float)\n    array([[0., 0.],\n           [1., 1.]])\n\n    >>> np.fromfunction(lambda i, j: j, (2, 2), dtype=float)\n    array([[0., 1.],\n           [0., 1.]])\n\n    >>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\n    array([[ True, False, False],\n           [False,  True, False],\n           [False, False,  True]])\n\n    >>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\n    array([[0, 1, 2],\n           [1, 2, 3],\n           [2, 3, 4]])\n\n    \"\"\"\n    if like is not None:\n        return _fromfunction_with_like(\n                like, function, shape, dtype=dtype, **kwargs)\n\n    args = indices(shape, dtype=dtype)\n    return function(*args, **kwargs)\n\n\n_fromfunction_with_like = array_function_dispatch()(fromfunction)\n\n\ndef _frombuffer(buf, dtype, shape, order):\n    return frombuffer(buf, dtype=dtype).reshape(shape, order=order)\n\n\n@set_module('numpy')\ndef isscalar(element):\n    \"\"\"\n    Returns True if the type of `element` is a scalar type.\n\n    Parameters\n    ----------\n    element : any\n        Input argument, can be of any type and shape.\n\n    Returns\n    -------\n    val : bool\n        True if `element` is a scalar type, False if it is not.\n\n    See Also\n    --------\n    ndim : Get the number of dimensions of an array\n\n    Notes\n    -----\n    If you need a stricter way to identify a *numerical* scalar, use\n    ``isinstance(x, numbers.Number)``, as that returns ``False`` for most\n    non-numerical elements such as strings.\n\n    In most cases ``np.ndim(x) == 0`` should be used instead of this function,\n    as that will also return true for 0d arrays. This is how numpy overloads\n    functions in the style of the ``dx`` arguments to `gradient` and\n    the ``bins`` argument to `histogram`. Some key differences:\n\n    +------------------------------------+---------------+-------------------+\n    | x                                  |``isscalar(x)``|``np.ndim(x) == 0``|\n    +====================================+===============+===================+\n    | PEP 3141 numeric objects           | ``True``      | ``True``          |\n    | (including builtins)               |               |                   |\n    +------------------------------------+---------------+-------------------+\n    | builtin string and buffer objects  | ``True``      | ``True``          |\n    +------------------------------------+---------------+-------------------+\n    | other builtin objects, like        | ``False``     | ``True``          |\n    | `pathlib.Path`, `Exception`,       |               |                   |\n    | the result of `re.compile`         |               |                   |\n    +------------------------------------+---------------+-------------------+\n    | third-party objects like           | ``False``     | ``True``          |\n    | `matplotlib.figure.Figure`         |               |                   |\n    +------------------------------------+---------------+-------------------+\n    | zero-dimensional numpy arrays      | ``False``     | ``True``          |\n    +------------------------------------+---------------+-------------------+\n    | other numpy arrays                 | ``False``     | ``False``         |\n    +------------------------------------+---------------+-------------------+\n    | `list`, `tuple`, and other         | ``False``     | ``False``         |\n    | sequence objects                   |               |                   |\n    +------------------------------------+---------------+-------------------+\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    >>> np.isscalar(3.1)\n    True\n\n    >>> np.isscalar(np.array(3.1))\n    False\n\n    >>> np.isscalar([3.1])\n    False\n\n    >>> np.isscalar(False)\n    True\n\n    >>> np.isscalar('numpy')\n    True\n\n    NumPy supports PEP 3141 numbers:\n\n    >>> from fractions import Fraction\n    >>> np.isscalar(Fraction(5, 17))\n    True\n    >>> from numbers import Number\n    >>> np.isscalar(Number())\n    True\n\n    \"\"\"\n    return (isinstance(element, generic)\n            or type(element) in ScalarType\n            or isinstance(element, numbers.Number))\n\n\n@set_module('numpy')\ndef binary_repr(num, width=None):\n    \"\"\"\n    Return the binary representation of the input number as a string.\n\n    For negative numbers, if width is not given, a minus sign is added to the\n    front. If width is given, the two's complement of the number is\n    returned, with respect to that width.\n\n    In a two's-complement system negative numbers are represented by the two's\n    complement of the absolute value. This is the most common method of\n    representing signed integers on computers [1]_. A N-bit two's-complement\n    system can represent every integer in the range\n    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\n    Parameters\n    ----------\n    num : int\n        Only an integer decimal number can be used.\n    width : int, optional\n        The length of the returned string if `num` is positive, or the length\n        of the two's complement if `num` is negative, provided that `width` is\n        at least a sufficient number of bits for `num` to be represented in\n        the designated form. If the `width` value is insufficient, an error is\n        raised.\n\n    Returns\n    -------\n    bin : str\n        Binary representation of `num` or two's complement of `num`.\n\n    See Also\n    --------\n    base_repr: Return a string representation of a number in the given base\n               system.\n    bin: Python's built-in binary representation generator of an integer.\n\n    Notes\n    -----\n    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x\n    faster.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Two's complement\",\n        https://en.wikipedia.org/wiki/Two's_complement\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.binary_repr(3)\n    '11'\n    >>> np.binary_repr(-3)\n    '-11'\n    >>> np.binary_repr(3, width=4)\n    '0011'\n\n    The two's complement is returned when the input number is negative and\n    width is specified:\n\n    >>> np.binary_repr(-3, width=3)\n    '101'\n    >>> np.binary_repr(-3, width=5)\n    '11101'\n\n    \"\"\"\n    def err_if_insufficient(width, binwidth):\n        if width is not None and width < binwidth:\n            raise ValueError(\n                f\"Insufficient bit {width=} provided for {binwidth=}\"\n            )\n\n    # Ensure that num is a Python integer to avoid overflow or unwanted\n    # casts to floating point.\n    num = operator.index(num)\n\n    if num == 0:\n        return '0' * (width or 1)\n\n    elif num > 0:\n        binary = bin(num)[2:]\n        binwidth = len(binary)\n        outwidth = (binwidth if width is None\n                    else builtins.max(binwidth, width))\n        err_if_insufficient(width, binwidth)\n        return binary.zfill(outwidth)\n\n    else:\n        if width is None:\n            return '-' + bin(-num)[2:]\n\n        else:\n            poswidth = len(bin(-num)[2:])\n\n            # See gh-8679: remove extra digit\n            # for numbers at boundaries.\n            if 2**(poswidth - 1) == -num:\n                poswidth -= 1\n\n            twocomp = 2**(poswidth + 1) + num\n            binary = bin(twocomp)[2:]\n            binwidth = len(binary)\n\n            outwidth = builtins.max(binwidth, width)\n            err_if_insufficient(width, binwidth)\n            return '1' * (outwidth - binwidth) + binary\n\n\n@set_module('numpy')\ndef base_repr(number, base=2, padding=0):\n    \"\"\"\n    Return a string representation of a number in the given base system.\n\n    Parameters\n    ----------\n    number : int\n        The value to convert. Positive and negative values are handled.\n    base : int, optional\n        Convert `number` to the `base` number system. The valid range is 2-36,\n        the default value is 2.\n    padding : int, optional\n        Number of zeros padded on the left. Default is 0 (no padding).\n\n    Returns\n    -------\n    out : str\n        String representation of `number` in `base` system.\n\n    See Also\n    --------\n    binary_repr : Faster version of `base_repr` for base 2.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.base_repr(5)\n    '101'\n    >>> np.base_repr(6, 5)\n    '11'\n    >>> np.base_repr(7, base=5, padding=3)\n    '00012'\n\n    >>> np.base_repr(10, base=16)\n    'A'\n    >>> np.base_repr(32, base=16)\n    '20'\n\n    \"\"\"\n    digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    if base > len(digits):\n        raise ValueError(\"Bases greater than 36 not handled in base_repr.\")\n    elif base < 2:\n        raise ValueError(\"Bases less than 2 not handled in base_repr.\")\n\n    num = abs(int(number))\n    res = []\n    while num:\n        res.append(digits[num % base])\n        num //= base\n    if padding:\n        res.append('0' * padding)\n    if number < 0:\n        res.append('-')\n    return ''.join(reversed(res or '0'))\n\n\n# These are all essentially abbreviations\n# These might wind up in a special abbreviations module\n\n\ndef _maketup(descr, val):\n    dt = dtype(descr)\n    # Place val in all scalar tuples:\n    fields = dt.fields\n    if fields is None:\n        return val\n    else:\n        res = [_maketup(fields[name][0], val) for name in dt.names]\n        return tuple(res)\n\n\n@finalize_array_function_like\n@set_module('numpy')\ndef identity(n, dtype=None, *, like=None):\n    \"\"\"\n    Return the identity array.\n\n    The identity array is a square array with ones on\n    the main diagonal.\n\n    Parameters\n    ----------\n    n : int\n        Number of rows (and columns) in `n` x `n` output.\n    dtype : data-type, optional\n        Data-type of the output.  Defaults to ``float``.\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    out : ndarray\n        `n` x `n` array with its main diagonal set to one,\n        and all other elements 0.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.identity(3)\n    array([[1.,  0.,  0.],\n           [0.,  1.,  0.],\n           [0.,  0.,  1.]])\n\n    \"\"\"\n    if like is not None:\n        return _identity_with_like(like, n, dtype=dtype)\n\n    from numpy import eye\n    return eye(n, dtype=dtype, like=like)\n\n\n_identity_with_like = array_function_dispatch()(identity)\n\n\ndef _allclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):\n    return (a, b, rtol, atol)\n\n\n@array_function_dispatch(_allclose_dispatcher)\ndef allclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):\n    \"\"\"\n    Returns True if two arrays are element-wise equal within a tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    .. warning:: The default `atol` is not appropriate for comparing numbers\n                 with magnitudes much smaller than one (see Notes).\n\n    NaNs are treated as equal if they are in the same place and if\n    ``equal_nan=True``.  Infs are treated as equal if they are in the same\n    place and of the same sign in both arrays.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : array_like\n        The relative tolerance parameter (see Notes).\n    atol : array_like\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN's as equal.  If True, NaN's in `a` will be\n        considered equal to NaN's in `b` in the output array.\n\n    Returns\n    -------\n    allclose : bool\n        Returns True if the two arrays are equal within the given\n        tolerance; False otherwise.\n\n    See Also\n    --------\n    isclose, all, any, equal\n\n    Notes\n    -----\n    If the following equation is element-wise True, then allclose returns\n    True.::\n\n     absolute(a - b) <= (atol + rtol * absolute(b))\n\n    The above equation is not symmetric in `a` and `b`, so that\n    ``allclose(a, b)`` might be different from ``allclose(b, a)`` in\n    some rare cases.\n\n    The default value of `atol` is not appropriate when the reference value\n    `b` has magnitude smaller than one. For example, it is unlikely that\n    ``a = 1e-9`` and ``b = 2e-9`` should be considered \"close\", yet\n    ``allclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure\n    to select `atol` for the use case at hand, especially for defining the\n    threshold below which a non-zero value in `a` will be considered \"close\"\n    to a very small or zero value in `b`.\n\n    The comparison of `a` and `b` uses standard broadcasting, which\n    means that `a` and `b` need not have the same shape in order for\n    ``allclose(a, b)`` to evaluate to True.  The same is true for\n    `equal` but not `array_equal`.\n\n    `allclose` is not defined for non-numeric data types.\n    `bool` is considered a numeric data-type for this purpose.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\n    False\n\n    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\n    True\n\n    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\n    False\n\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan])\n    False\n\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\n    True\n\n\n    \"\"\"\n    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))\n    return builtins.bool(res)\n\n\ndef _isclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):\n    return (a, b, rtol, atol)\n\n\n@array_function_dispatch(_isclose_dispatcher)\ndef isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):\n    \"\"\"\n    Returns a boolean array where two arrays are element-wise equal within a\n    tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    .. warning:: The default `atol` is not appropriate for comparing numbers\n                 with magnitudes much smaller than one (see Notes).\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : array_like\n        The relative tolerance parameter (see Notes).\n    atol : array_like\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN's as equal.  If True, NaN's in `a` will be\n        considered equal to NaN's in `b` in the output array.\n\n    Returns\n    -------\n    y : array_like\n        Returns a boolean array of where `a` and `b` are equal within the\n        given tolerance. If both `a` and `b` are scalars, returns a single\n        boolean value.\n\n    See Also\n    --------\n    allclose\n    math.isclose\n\n    Notes\n    -----\n    For finite values, isclose uses the following equation to test whether\n    two floating point values are equivalent.::\n\n     absolute(a - b) <= (atol + rtol * absolute(b))\n\n    Unlike the built-in `math.isclose`, the above equation is not symmetric\n    in `a` and `b` -- it assumes `b` is the reference value -- so that\n    `isclose(a, b)` might be different from `isclose(b, a)`.\n\n    The default value of `atol` is not appropriate when the reference value\n    `b` has magnitude smaller than one. For example, it is unlikely that\n    ``a = 1e-9`` and ``b = 2e-9`` should be considered \"close\", yet\n    ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure\n    to select `atol` for the use case at hand, especially for defining the\n    threshold below which a non-zero value in `a` will be considered \"close\"\n    to a very small or zero value in `b`.\n\n    `isclose` is not defined for non-numeric data types.\n    :class:`bool` is considered a numeric data-type for this purpose.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])\n    array([ True, False])\n\n    >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])\n    array([ True, True])\n\n    >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])\n    array([False,  True])\n\n    >>> np.isclose([1.0, np.nan], [1.0, np.nan])\n    array([ True, False])\n\n    >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\n    array([ True, True])\n\n    >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])\n    array([ True, False])\n\n    >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)\n    array([False, False])\n\n    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])\n    array([ True,  True])\n\n    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)\n    array([False,  True])\n\n    \"\"\"\n    # Turn all but python scalars into arrays.\n    x, y, atol, rtol = (\n        a if isinstance(a, (int, float, complex)) else asanyarray(a)\n        for a in (a, b, atol, rtol))\n\n    # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).\n    # This will cause casting of x later. Also, make sure to allow subclasses\n    # (e.g., for numpy.ma).\n    # NOTE: We explicitly allow timedelta, which used to work. This could\n    #       possibly be deprecated. See also gh-18286.\n    #       timedelta works if `atol` is an integer or also a timedelta.\n    #       Although, the default tolerances are unlikely to be useful\n    if (dtype := getattr(y, \"dtype\", None)) is not None and dtype.kind != \"m\":\n        dt = multiarray.result_type(y, 1.)\n        y = asanyarray(y, dtype=dt)\n    elif isinstance(y, int):\n        y = float(y)\n\n    with errstate(invalid='ignore'):\n        result = (less_equal(abs(x-y), atol + rtol * abs(y))\n                  & isfinite(y)\n                  | (x == y))\n        if equal_nan:\n            result |= isnan(x) & isnan(y)\n\n    return result[()]  # Flatten 0d arrays to scalars\n\n\ndef _array_equal_dispatcher(a1, a2, equal_nan=None):\n    return (a1, a2)\n\n\n_no_nan_types = {\n    # should use np.dtype.BoolDType, but as of writing\n    # that fails the reloading test.\n    type(dtype(nt.bool)),\n    type(dtype(nt.int8)),\n    type(dtype(nt.int16)),\n    type(dtype(nt.int32)),\n    type(dtype(nt.int64)),\n}\n\n\ndef _dtype_cannot_hold_nan(dtype):\n    return type(dtype) in _no_nan_types\n\n\n@array_function_dispatch(_array_equal_dispatcher)\ndef array_equal(a1, a2, equal_nan=False):\n    \"\"\"\n    True if two arrays have the same shape and elements, False otherwise.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n    equal_nan : bool\n        Whether to compare NaN's as equal. If the dtype of a1 and a2 is\n        complex, values will be considered equal if either the real or the\n        imaginary component of a given value is ``nan``.\n\n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equal.\n\n    See Also\n    --------\n    allclose: Returns True if two arrays are element-wise equal within a\n              tolerance.\n    array_equiv: Returns True if input arrays are shape consistent and all\n                 elements equal.\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    >>> np.array_equal([1, 2], [1, 2])\n    True\n\n    >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\n    True\n\n    >>> np.array_equal([1, 2], [1, 2, 3])\n    False\n\n    >>> np.array_equal([1, 2], [1, 4])\n    False\n\n    >>> a = np.array([1, np.nan])\n    >>> np.array_equal(a, a)\n    False\n\n    >>> np.array_equal(a, a, equal_nan=True)\n    True\n\n    When ``equal_nan`` is True, complex values with nan components are\n    considered equal if either the real *or* the imaginary components are nan.\n\n    >>> a = np.array([1 + 1j])\n    >>> b = a.copy()\n    >>> a.real = np.nan\n    >>> b.imag = np.nan\n    >>> np.array_equal(a, b, equal_nan=True)\n    True\n    \"\"\"\n    try:\n        a1, a2 = asarray(a1), asarray(a2)\n    except Exception:\n        return False\n    if a1.shape != a2.shape:\n        return False\n    if not equal_nan:\n        return builtins.bool((asanyarray(a1 == a2)).all())\n\n    if a1 is a2:\n        # nan will compare equal so an array will compare equal to itself.\n        return True\n\n    cannot_have_nan = (_dtype_cannot_hold_nan(a1.dtype)\n                       and _dtype_cannot_hold_nan(a2.dtype))\n    if cannot_have_nan:\n        return builtins.bool(asarray(a1 == a2).all())\n\n    # Handling NaN values if equal_nan is True\n    a1nan, a2nan = isnan(a1), isnan(a2)\n    # NaN's occur at different locations\n    if not (a1nan == a2nan).all():\n        return False\n    # Shapes of a1, a2 and masks are guaranteed to be consistent by this point\n    return builtins.bool((a1[~a1nan] == a2[~a1nan]).all())\n\n\ndef _array_equiv_dispatcher(a1, a2):\n    return (a1, a2)\n\n\n@array_function_dispatch(_array_equiv_dispatcher)\ndef array_equiv(a1, a2):\n    \"\"\"\n    Returns True if input arrays are shape consistent and all elements equal.\n\n    Shape consistent means they are either the same shape, or one input array\n    can be broadcasted to create the same shape as the other one.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    out : bool\n        True if equivalent, False otherwise.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.array_equiv([1, 2], [1, 2])\n    True\n    >>> np.array_equiv([1, 2], [1, 3])\n    False\n\n    Showing the shape equivalence:\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])\n    True\n    >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\n    False\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])\n    False\n\n    \"\"\"\n    try:\n        a1, a2 = asarray(a1), asarray(a2)\n    except Exception:\n        return False\n    try:\n        multiarray.broadcast(a1, a2)\n    except Exception:\n        return False\n\n    return builtins.bool(asanyarray(a1 == a2).all())\n\n\ndef _astype_dispatcher(x, dtype, /, *, copy=None, device=None):\n    return (x, dtype)\n\n\n@array_function_dispatch(_astype_dispatcher)\ndef astype(x, dtype, /, *, copy=True, device=None):\n    \"\"\"\n    Copies an array to a specified data type.\n\n    This function is an Array API compatible alternative to\n    `numpy.ndarray.astype`.\n\n    Parameters\n    ----------\n    x : ndarray\n        Input NumPy array to cast. ``array_likes`` are explicitly not\n        supported here.\n    dtype : dtype\n        Data type of the result.\n    copy : bool, optional\n        Specifies whether to copy an array when the specified dtype matches\n        the data type of the input array ``x``. If ``True``, a newly allocated\n        array must always be returned. If ``False`` and the specified dtype\n        matches the data type of the input array, the input array must be\n        returned; otherwise, a newly allocated array must be returned.\n        Defaults to ``True``.\n    device : str, optional\n        The device on which to place the returned array. Default: None.\n        For Array-API interoperability only, so must be ``\"cpu\"`` if passed.\n\n        .. versionadded:: 2.1.0\n\n    Returns\n    -------\n    out : ndarray\n        An array having the specified data type.\n\n    See Also\n    --------\n    ndarray.astype\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> arr = np.array([1, 2, 3]); arr\n    array([1, 2, 3])\n    >>> np.astype(arr, np.float64)\n    array([1., 2., 3.])\n\n    Non-copy case:\n\n    >>> arr = np.array([1, 2, 3])\n    >>> arr_noncpy = np.astype(arr, arr.dtype, copy=False)\n    >>> np.shares_memory(arr, arr_noncpy)\n    True\n\n    \"\"\"\n    if not (isinstance(x, np.ndarray) or isscalar(x)):\n        raise TypeError(\n            \"Input should be a NumPy array or scalar. \"\n            f\"It is a {type(x)} instead.\"\n        )\n    if device is not None and device != \"cpu\":\n        raise ValueError(\n            'Device not understood. Only \"cpu\" is allowed, but received:'\n            f' {device}'\n        )\n    return x.astype(dtype, copy=copy)\n\n\ninf = PINF\nnan = NAN\nFalse_ = nt.bool(False)\nTrue_ = nt.bool(True)\n\n\ndef extend_all(module):\n    existing = set(__all__)\n    mall = module.__all__\n    for a in mall:\n        if a not in existing:\n            __all__.append(a)\n\n\nfrom .umath import *\nfrom .numerictypes import *\nfrom . import fromnumeric\nfrom .fromnumeric import *\nfrom . import arrayprint\nfrom .arrayprint import *\nfrom . import _asarray\nfrom ._asarray import *\nfrom . import _ufunc_config\nfrom ._ufunc_config import *\nextend_all(fromnumeric)\nextend_all(umath)\nextend_all(numerictypes)\nextend_all(arrayprint)\nextend_all(_asarray)\nextend_all(_ufunc_config)\n", 2713], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py": ["\"\"\"Routines for numerical differentiation.\"\"\"\nimport functools\nimport numpy as np\nfrom numpy.linalg import norm\n\nfrom scipy.sparse.linalg import LinearOperator\nfrom ..sparse import issparse, csc_matrix, csr_matrix, coo_matrix, find\nfrom ._group_columns import group_dense, group_sparse\nfrom scipy._lib._array_api import array_namespace\nfrom scipy._lib import array_api_extra as xpx\n\n\ndef _adjust_scheme_to_bounds(x0, h, num_steps, scheme, lb, ub):\n    \"\"\"Adjust final difference scheme to the presence of bounds.\n\n    Parameters\n    ----------\n    x0 : ndarray, shape (n,)\n        Point at which we wish to estimate derivative.\n    h : ndarray, shape (n,)\n        Desired absolute finite difference steps.\n    num_steps : int\n        Number of `h` steps in one direction required to implement finite\n        difference scheme. For example, 2 means that we need to evaluate\n        f(x0 + 2 * h) or f(x0 - 2 * h)\n    scheme : {'1-sided', '2-sided'}\n        Whether steps in one or both directions are required. In other\n        words '1-sided' applies to forward and backward schemes, '2-sided'\n        applies to center schemes.\n    lb : ndarray, shape (n,)\n        Lower bounds on independent variables.\n    ub : ndarray, shape (n,)\n        Upper bounds on independent variables.\n\n    Returns\n    -------\n    h_adjusted : ndarray, shape (n,)\n        Adjusted absolute step sizes. Step size decreases only if a sign flip\n        or switching to one-sided scheme doesn't allow to take a full step.\n    use_one_sided : ndarray of bool, shape (n,)\n        Whether to switch to one-sided scheme. Informative only for\n        ``scheme='2-sided'``.\n    \"\"\"\n    if scheme == '1-sided':\n        use_one_sided = np.ones_like(h, dtype=bool)\n    elif scheme == '2-sided':\n        h = np.abs(h)\n        use_one_sided = np.zeros_like(h, dtype=bool)\n    else:\n        raise ValueError(\"`scheme` must be '1-sided' or '2-sided'.\")\n\n    if np.all((lb == -np.inf) & (ub == np.inf)):\n        return h, use_one_sided\n\n    h_total = h * num_steps\n    h_adjusted = h.copy()\n\n    lower_dist = x0 - lb\n    upper_dist = ub - x0\n\n    if scheme == '1-sided':\n        x = x0 + h_total\n        violated = (x < lb) | (x > ub)\n        fitting = np.abs(h_total) <= np.maximum(lower_dist, upper_dist)\n        h_adjusted[violated & fitting] *= -1\n\n        forward = (upper_dist >= lower_dist) & ~fitting\n        h_adjusted[forward] = upper_dist[forward] / num_steps\n        backward = (upper_dist < lower_dist) & ~fitting\n        h_adjusted[backward] = -lower_dist[backward] / num_steps\n    elif scheme == '2-sided':\n        central = (lower_dist >= h_total) & (upper_dist >= h_total)\n\n        forward = (upper_dist >= lower_dist) & ~central\n        h_adjusted[forward] = np.minimum(\n            h[forward], 0.5 * upper_dist[forward] / num_steps)\n        use_one_sided[forward] = True\n\n        backward = (upper_dist < lower_dist) & ~central\n        h_adjusted[backward] = -np.minimum(\n            h[backward], 0.5 * lower_dist[backward] / num_steps)\n        use_one_sided[backward] = True\n\n        min_dist = np.minimum(upper_dist, lower_dist) / num_steps\n        adjusted_central = (~central & (np.abs(h_adjusted) <= min_dist))\n        h_adjusted[adjusted_central] = min_dist[adjusted_central]\n        use_one_sided[adjusted_central] = False\n\n    return h_adjusted, use_one_sided\n\n\n@functools.lru_cache\ndef _eps_for_method(x0_dtype, f0_dtype, method):\n    \"\"\"\n    Calculates relative EPS step to use for a given data type\n    and numdiff step method.\n\n    Progressively smaller steps are used for larger floating point types.\n\n    Parameters\n    ----------\n    f0_dtype: np.dtype\n        dtype of function evaluation\n\n    x0_dtype: np.dtype\n        dtype of parameter vector\n\n    method: {'2-point', '3-point', 'cs'}\n\n    Returns\n    -------\n    EPS: float\n        relative step size. May be np.float16, np.float32, np.float64\n\n    Notes\n    -----\n    The default relative step will be np.float64. However, if x0 or f0 are\n    smaller floating point types (np.float16, np.float32), then the smallest\n    floating point type is chosen.\n    \"\"\"\n    # the default EPS value\n    EPS = np.finfo(np.float64).eps\n\n    x0_is_fp = False\n    if np.issubdtype(x0_dtype, np.inexact):\n        # if you're a floating point type then over-ride the default EPS\n        EPS = np.finfo(x0_dtype).eps\n        x0_itemsize = np.dtype(x0_dtype).itemsize\n        x0_is_fp = True\n\n    if np.issubdtype(f0_dtype, np.inexact):\n        f0_itemsize = np.dtype(f0_dtype).itemsize\n        # choose the smallest itemsize between x0 and f0\n        if x0_is_fp and f0_itemsize < x0_itemsize:\n            EPS = np.finfo(f0_dtype).eps\n\n    if method in [\"2-point\", \"cs\"]:\n        return EPS**0.5\n    elif method in [\"3-point\"]:\n        return EPS**(1/3)\n    else:\n        raise RuntimeError(\"Unknown step method, should be one of \"\n                           \"{'2-point', '3-point', 'cs'}\")\n\n\ndef _compute_absolute_step(rel_step, x0, f0, method):\n    \"\"\"\n    Computes an absolute step from a relative step for finite difference\n    calculation.\n\n    Parameters\n    ----------\n    rel_step: None or array-like\n        Relative step for the finite difference calculation\n    x0 : np.ndarray\n        Parameter vector\n    f0 : np.ndarray or scalar\n    method : {'2-point', '3-point', 'cs'}\n\n    Returns\n    -------\n    h : float\n        The absolute step size\n\n    Notes\n    -----\n    `h` will always be np.float64. However, if `x0` or `f0` are\n    smaller floating point dtypes (e.g. np.float32), then the absolute\n    step size will be calculated from the smallest floating point size.\n    \"\"\"\n    # this is used instead of np.sign(x0) because we need\n    # sign_x0 to be 1 when x0 == 0.\n    sign_x0 = (x0 >= 0).astype(float) * 2 - 1\n\n    rstep = _eps_for_method(x0.dtype, f0.dtype, method)\n\n    if rel_step is None:\n        abs_step = rstep * sign_x0 * np.maximum(1.0, np.abs(x0))\n    else:\n        # User has requested specific relative steps.\n        # Don't multiply by max(1, abs(x0) because if x0 < 1 then their\n        # requested step is not used.\n        abs_step = rel_step * sign_x0 * np.abs(x0)\n\n        # however we don't want an abs_step of 0, which can happen if\n        # rel_step is 0, or x0 is 0. Instead, substitute a realistic step\n        dx = ((x0 + abs_step) - x0)\n        abs_step = np.where(dx == 0,\n                            rstep * sign_x0 * np.maximum(1.0, np.abs(x0)),\n                            abs_step)\n\n    return abs_step\n\n\ndef _prepare_bounds(bounds, x0):\n    \"\"\"\n    Prepares new-style bounds from a two-tuple specifying the lower and upper\n    limits for values in x0. If a value is not bound then the lower/upper bound\n    will be expected to be -np.inf/np.inf.\n\n    Examples\n    --------\n    >>> _prepare_bounds([(0, 1, 2), (1, 2, np.inf)], [0.5, 1.5, 2.5])\n    (array([0., 1., 2.]), array([ 1.,  2., inf]))\n    \"\"\"\n    lb, ub = (np.asarray(b, dtype=float) for b in bounds)\n    if lb.ndim == 0:\n        lb = np.resize(lb, x0.shape)\n\n    if ub.ndim == 0:\n        ub = np.resize(ub, x0.shape)\n\n    return lb, ub\n\n\ndef group_columns(A, order=0):\n    \"\"\"Group columns of a 2-D matrix for sparse finite differencing [1]_.\n\n    Two columns are in the same group if in each row at least one of them\n    has zero. A greedy sequential algorithm is used to construct groups.\n\n    Parameters\n    ----------\n    A : array_like or sparse matrix, shape (m, n)\n        Matrix of which to group columns.\n    order : int, iterable of int with shape (n,) or None\n        Permutation array which defines the order of columns enumeration.\n        If int or None, a random permutation is used with `order` used as\n        a random seed. Default is 0, that is use a random permutation but\n        guarantee repeatability.\n\n    Returns\n    -------\n    groups : ndarray of int, shape (n,)\n        Contains values from 0 to n_groups-1, where n_groups is the number\n        of found groups. Each value ``groups[i]`` is an index of a group to\n        which ith column assigned. The procedure was helpful only if\n        n_groups is significantly less than n.\n\n    References\n    ----------\n    .. [1] A. Curtis, M. J. D. Powell, and J. Reid, \"On the estimation of\n           sparse Jacobian matrices\", Journal of the Institute of Mathematics\n           and its Applications, 13 (1974), pp. 117-120.\n    \"\"\"\n    if issparse(A):\n        A = csc_matrix(A)\n    else:\n        A = np.atleast_2d(A)\n        A = (A != 0).astype(np.int32)\n\n    if A.ndim != 2:\n        raise ValueError(\"`A` must be 2-dimensional.\")\n\n    m, n = A.shape\n\n    if order is None or np.isscalar(order):\n        rng = np.random.RandomState(order)\n        order = rng.permutation(n)\n    else:\n        order = np.asarray(order)\n        if order.shape != (n,):\n            raise ValueError(\"`order` has incorrect shape.\")\n\n    A = A[:, order]\n\n    if issparse(A):\n        groups = group_sparse(m, n, A.indices, A.indptr)\n    else:\n        groups = group_dense(m, n, A)\n\n    groups[order] = groups.copy()\n\n    return groups\n\n\ndef approx_derivative(fun, x0, method='3-point', rel_step=None, abs_step=None,\n                      f0=None, bounds=(-np.inf, np.inf), sparsity=None,\n                      as_linear_operator=False, args=(), kwargs=None):\n    \"\"\"Compute finite difference approximation of the derivatives of a\n    vector-valued function.\n\n    If a function maps from R^n to R^m, its derivatives form m-by-n matrix\n    called the Jacobian, where an element (i, j) is a partial derivative of\n    f[i] with respect to x[j].\n\n    Parameters\n    ----------\n    fun : callable\n        Function of which to estimate the derivatives. The argument x\n        passed to this function is ndarray of shape (n,) (never a scalar\n        even if n=1). It must return 1-D array_like of shape (m,) or a scalar.\n    x0 : array_like of shape (n,) or float\n        Point at which to estimate the derivatives. Float will be converted\n        to a 1-D array.\n    method : {'3-point', '2-point', 'cs'}, optional\n        Finite difference method to use:\n            - '2-point' - use the first order accuracy forward or backward\n                          difference.\n            - '3-point' - use central difference in interior points and the\n                          second order accuracy forward or backward difference\n                          near the boundary.\n            - 'cs' - use a complex-step finite difference scheme. This assumes\n                     that the user function is real-valued and can be\n                     analytically continued to the complex plane. Otherwise,\n                     produces bogus results.\n    rel_step : None or array_like, optional\n        Relative step size to use. If None (default) the absolute step size is\n        computed as ``h = rel_step * sign(x0) * max(1, abs(x0))``, with\n        `rel_step` being selected automatically, see Notes. Otherwise\n        ``h = rel_step * sign(x0) * abs(x0)``. For ``method='3-point'`` the\n        sign of `h` is ignored. The calculated step size is possibly adjusted\n        to fit into the bounds.\n    abs_step : array_like, optional\n        Absolute step size to use, possibly adjusted to fit into the bounds.\n        For ``method='3-point'`` the sign of `abs_step` is ignored. By default\n        relative steps are used, only if ``abs_step is not None`` are absolute\n        steps used.\n    f0 : None or array_like, optional\n        If not None it is assumed to be equal to ``fun(x0)``, in this case\n        the ``fun(x0)`` is not called. Default is None.\n    bounds : tuple of array_like, optional\n        Lower and upper bounds on independent variables. Defaults to no bounds.\n        Each bound must match the size of `x0` or be a scalar, in the latter\n        case the bound will be the same for all variables. Use it to limit the\n        range of function evaluation. Bounds checking is not implemented\n        when `as_linear_operator` is True.\n    sparsity : {None, array_like, sparse matrix, 2-tuple}, optional\n        Defines a sparsity structure of the Jacobian matrix. If the Jacobian\n        matrix is known to have only few non-zero elements in each row, then\n        it's possible to estimate its several columns by a single function\n        evaluation [3]_. To perform such economic computations two ingredients\n        are required:\n\n        * structure : array_like or sparse matrix of shape (m, n). A zero\n          element means that a corresponding element of the Jacobian\n          identically equals to zero.\n        * groups : array_like of shape (n,). A column grouping for a given\n          sparsity structure, use `group_columns` to obtain it.\n\n        A single array or a sparse matrix is interpreted as a sparsity\n        structure, and groups are computed inside the function. A tuple is\n        interpreted as (structure, groups). If None (default), a standard\n        dense differencing will be used.\n\n        Note, that sparse differencing makes sense only for large Jacobian\n        matrices where each row contains few non-zero elements.\n    as_linear_operator : bool, optional\n        When True the function returns an `scipy.sparse.linalg.LinearOperator`.\n        Otherwise it returns a dense array or a sparse matrix depending on\n        `sparsity`. The linear operator provides an efficient way of computing\n        ``J.dot(p)`` for any vector ``p`` of shape (n,), but does not allow\n        direct access to individual elements of the matrix. By default\n        `as_linear_operator` is False.\n    args, kwargs : tuple and dict, optional\n        Additional arguments passed to `fun`. Both empty by default.\n        The calling signature is ``fun(x, *args, **kwargs)``.\n\n    Returns\n    -------\n    J : {ndarray, sparse matrix, LinearOperator}\n        Finite difference approximation of the Jacobian matrix.\n        If `as_linear_operator` is True returns a LinearOperator\n        with shape (m, n). Otherwise it returns a dense array or sparse\n        matrix depending on how `sparsity` is defined. If `sparsity`\n        is None then a ndarray with shape (m, n) is returned. If\n        `sparsity` is not None returns a csr_matrix with shape (m, n).\n        For sparse matrices and linear operators it is always returned as\n        a 2-D structure, for ndarrays, if m=1 it is returned\n        as a 1-D gradient array with shape (n,).\n\n    See Also\n    --------\n    check_derivative : Check correctness of a function computing derivatives.\n\n    Notes\n    -----\n    If `rel_step` is not provided, it assigned as ``EPS**(1/s)``, where EPS is\n    determined from the smallest floating point dtype of `x0` or `fun(x0)`,\n    ``np.finfo(x0.dtype).eps``, s=2 for '2-point' method and\n    s=3 for '3-point' method. Such relative step approximately minimizes a sum\n    of truncation and round-off errors, see [1]_. Relative steps are used by\n    default. However, absolute steps are used when ``abs_step is not None``.\n    If any of the absolute or relative steps produces an indistinguishable\n    difference from the original `x0`, ``(x0 + dx) - x0 == 0``, then a\n    automatic step size is substituted for that particular entry.\n\n    A finite difference scheme for '3-point' method is selected automatically.\n    The well-known central difference scheme is used for points sufficiently\n    far from the boundary, and 3-point forward or backward scheme is used for\n    points near the boundary. Both schemes have the second-order accuracy in\n    terms of Taylor expansion. Refer to [2]_ for the formulas of 3-point\n    forward and backward difference schemes.\n\n    For dense differencing when m=1 Jacobian is returned with a shape (n,),\n    on the other hand when n=1 Jacobian is returned with a shape (m, 1).\n    Our motivation is the following: a) It handles a case of gradient\n    computation (m=1) in a conventional way. b) It clearly separates these two\n    different cases. b) In all cases np.atleast_2d can be called to get 2-D\n    Jacobian with correct dimensions.\n\n    References\n    ----------\n    .. [1] W. H. Press et. al. \"Numerical Recipes. The Art of Scientific\n           Computing. 3rd edition\", sec. 5.7.\n\n    .. [2] A. Curtis, M. J. D. Powell, and J. Reid, \"On the estimation of\n           sparse Jacobian matrices\", Journal of the Institute of Mathematics\n           and its Applications, 13 (1974), pp. 117-120.\n\n    .. [3] B. Fornberg, \"Generation of Finite Difference Formulas on\n           Arbitrarily Spaced Grids\", Mathematics of Computation 51, 1988.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.optimize._numdiff import approx_derivative\n    >>>\n    >>> def f(x, c1, c2):\n    ...     return np.array([x[0] * np.sin(c1 * x[1]),\n    ...                      x[0] * np.cos(c2 * x[1])])\n    ...\n    >>> x0 = np.array([1.0, 0.5 * np.pi])\n    >>> approx_derivative(f, x0, args=(1, 2))\n    array([[ 1.,  0.],\n           [-1.,  0.]])\n\n    Bounds can be used to limit the region of function evaluation.\n    In the example below we compute left and right derivative at point 1.0.\n\n    >>> def g(x):\n    ...     return x**2 if x >= 1 else x\n    ...\n    >>> x0 = 1.0\n    >>> approx_derivative(g, x0, bounds=(-np.inf, 1.0))\n    array([ 1.])\n    >>> approx_derivative(g, x0, bounds=(1.0, np.inf))\n    array([ 2.])\n    \"\"\"\n    if method not in ['2-point', '3-point', 'cs']:\n        raise ValueError(f\"Unknown method '{method}'. \")\n\n    xp = array_namespace(x0)\n    _x = xpx.atleast_nd(xp.asarray(x0), ndim=1, xp=xp)\n    _dtype = xp.float64\n    if xp.isdtype(_x.dtype, \"real floating\"):\n        _dtype = _x.dtype\n\n    # promotes to floating\n    x0 = xp.astype(_x, _dtype)\n\n    if x0.ndim > 1:\n        raise ValueError(\"`x0` must have at most 1 dimension.\")\n\n    lb, ub = _prepare_bounds(bounds, x0)\n\n    if lb.shape != x0.shape or ub.shape != x0.shape:\n        raise ValueError(\"Inconsistent shapes between bounds and `x0`.\")\n\n    if as_linear_operator and not (np.all(np.isinf(lb))\n                                   and np.all(np.isinf(ub))):\n        raise ValueError(\"Bounds not supported when \"\n                         \"`as_linear_operator` is True.\")\n\n    if kwargs is None:\n        kwargs = {}\n\n    def fun_wrapped(x):\n        # send user function same fp type as x0. (but only if cs is not being\n        # used\n        if xp.isdtype(x.dtype, \"real floating\"):\n            x = xp.astype(x, x0.dtype)\n\n        f = np.atleast_1d(fun(x, *args, **kwargs))\n        if f.ndim > 1:\n            raise RuntimeError(\"`fun` return value has \"\n                               \"more than 1 dimension.\")\n        return f\n\n    if f0 is None:\n        f0 = fun_wrapped(x0)\n    else:\n        f0 = np.atleast_1d(f0)\n        if f0.ndim > 1:\n            raise ValueError(\"`f0` passed has more than 1 dimension.\")\n\n    if np.any((x0 < lb) | (x0 > ub)):\n        raise ValueError(\"`x0` violates bound constraints.\")\n\n    if as_linear_operator:\n        if rel_step is None:\n            rel_step = _eps_for_method(x0.dtype, f0.dtype, method)\n\n        return _linear_operator_difference(fun_wrapped, x0,\n                                           f0, rel_step, method)\n    else:\n        # by default we use rel_step\n        if abs_step is None:\n            h = _compute_absolute_step(rel_step, x0, f0, method)\n        else:\n            # user specifies an absolute step\n            sign_x0 = (x0 >= 0).astype(float) * 2 - 1\n            h = abs_step\n\n            # cannot have a zero step. This might happen if x0 is very large\n            # or small. In which case fall back to relative step.\n            dx = ((x0 + h) - x0)\n            h = np.where(dx == 0,\n                         _eps_for_method(x0.dtype, f0.dtype, method) *\n                         sign_x0 * np.maximum(1.0, np.abs(x0)),\n                         h)\n\n        if method == '2-point':\n            h, use_one_sided = _adjust_scheme_to_bounds(\n                x0, h, 1, '1-sided', lb, ub)\n        elif method == '3-point':\n            h, use_one_sided = _adjust_scheme_to_bounds(\n                x0, h, 1, '2-sided', lb, ub)\n        elif method == 'cs':\n            use_one_sided = False\n\n        if sparsity is None:\n            return _dense_difference(fun_wrapped, x0, f0, h,\n                                     use_one_sided, method)\n        else:\n            if not issparse(sparsity) and len(sparsity) == 2:\n                structure, groups = sparsity\n            else:\n                structure = sparsity\n                groups = group_columns(sparsity)\n\n            if issparse(structure):\n                structure = csc_matrix(structure)\n            else:\n                structure = np.atleast_2d(structure)\n\n            groups = np.atleast_1d(groups)\n            return _sparse_difference(fun_wrapped, x0, f0, h,\n                                      use_one_sided, structure,\n                                      groups, method)\n\n\ndef _linear_operator_difference(fun, x0, f0, h, method):\n    m = f0.size\n    n = x0.size\n\n    if method == '2-point':\n        def matvec(p):\n            if np.array_equal(p, np.zeros_like(p)):\n                return np.zeros(m)\n            dx = h / norm(p)\n            x = x0 + dx*p\n            df = fun(x) - f0\n            return df / dx\n\n    elif method == '3-point':\n        def matvec(p):\n            if np.array_equal(p, np.zeros_like(p)):\n                return np.zeros(m)\n            dx = 2*h / norm(p)\n            x1 = x0 - (dx/2)*p\n            x2 = x0 + (dx/2)*p\n            f1 = fun(x1)\n            f2 = fun(x2)\n            df = f2 - f1\n            return df / dx\n\n    elif method == 'cs':\n        def matvec(p):\n            if np.array_equal(p, np.zeros_like(p)):\n                return np.zeros(m)\n            dx = h / norm(p)\n            x = x0 + dx*p*1.j\n            f1 = fun(x)\n            df = f1.imag\n            return df / dx\n\n    else:\n        raise RuntimeError(\"Never be here.\")\n\n    return LinearOperator((m, n), matvec)\n\n\ndef _dense_difference(fun, x0, f0, h, use_one_sided, method):\n    m = f0.size\n    n = x0.size\n    J_transposed = np.empty((n, m))\n    x1 = x0.copy()\n    x2 = x0.copy()\n    xc = x0.astype(complex, copy=True)\n\n    for i in range(h.size):\n        if method == '2-point':\n            x1[i] += h[i]\n            dx = x1[i] - x0[i]  # Recompute dx as exactly representable number.\n            df = fun(x1) - f0\n        elif method == '3-point' and use_one_sided[i]:\n            x1[i] += h[i]\n            x2[i] += 2 * h[i]\n            dx = x2[i] - x0[i]\n            f1 = fun(x1)\n            f2 = fun(x2)\n            df = -3.0 * f0 + 4 * f1 - f2\n        elif method == '3-point' and not use_one_sided[i]:\n            x1[i] -= h[i]\n            x2[i] += h[i]\n            dx = x2[i] - x1[i]\n            f1 = fun(x1)\n            f2 = fun(x2)\n            df = f2 - f1\n        elif method == 'cs':\n            xc[i] += h[i] * 1.j\n            f1 = fun(xc)\n            df = f1.imag\n            dx = h[i]\n        else:\n            raise RuntimeError(\"Never be here.\")\n\n        J_transposed[i] = df / dx\n        x1[i] = x2[i] = xc[i] = x0[i]\n\n    if m == 1:\n        J_transposed = np.ravel(J_transposed)\n\n    return J_transposed.T\n\n\ndef _sparse_difference(fun, x0, f0, h, use_one_sided,\n                       structure, groups, method):\n    m = f0.size\n    n = x0.size\n    row_indices = []\n    col_indices = []\n    fractions = []\n\n    n_groups = np.max(groups) + 1\n    for group in range(n_groups):\n        # Perturb variables which are in the same group simultaneously.\n        e = np.equal(group, groups)\n        h_vec = h * e\n        if method == '2-point':\n            x = x0 + h_vec\n            dx = x - x0\n            df = fun(x) - f0\n            # The result is  written to columns which correspond to perturbed\n            # variables.\n            cols, = np.nonzero(e)\n            # Find all non-zero elements in selected columns of Jacobian.\n            i, j, _ = find(structure[:, cols])\n            # Restore column indices in the full array.\n            j = cols[j]\n        elif method == '3-point':\n            # Here we do conceptually the same but separate one-sided\n            # and two-sided schemes.\n            x1 = x0.copy()\n            x2 = x0.copy()\n\n            mask_1 = use_one_sided & e\n            x1[mask_1] += h_vec[mask_1]\n            x2[mask_1] += 2 * h_vec[mask_1]\n\n            mask_2 = ~use_one_sided & e\n            x1[mask_2] -= h_vec[mask_2]\n            x2[mask_2] += h_vec[mask_2]\n\n            dx = np.zeros(n)\n            dx[mask_1] = x2[mask_1] - x0[mask_1]\n            dx[mask_2] = x2[mask_2] - x1[mask_2]\n\n            f1 = fun(x1)\n            f2 = fun(x2)\n\n            cols, = np.nonzero(e)\n            i, j, _ = find(structure[:, cols])\n            j = cols[j]\n\n            mask = use_one_sided[j]\n            df = np.empty(m)\n\n            rows = i[mask]\n            df[rows] = -3 * f0[rows] + 4 * f1[rows] - f2[rows]\n\n            rows = i[~mask]\n            df[rows] = f2[rows] - f1[rows]\n        elif method == 'cs':\n            f1 = fun(x0 + h_vec*1.j)\n            df = f1.imag\n            dx = h_vec\n            cols, = np.nonzero(e)\n            i, j, _ = find(structure[:, cols])\n            j = cols[j]\n        else:\n            raise ValueError(\"Never be here.\")\n\n        # All that's left is to compute the fraction. We store i, j and\n        # fractions as separate arrays and later construct coo_matrix.\n        row_indices.append(i)\n        col_indices.append(j)\n        fractions.append(df[i] / dx[j])\n\n    row_indices = np.hstack(row_indices)\n    col_indices = np.hstack(col_indices)\n    fractions = np.hstack(fractions)\n    J = coo_matrix((fractions, (row_indices, col_indices)), shape=(m, n))\n    return csr_matrix(J)\n\n\ndef check_derivative(fun, jac, x0, bounds=(-np.inf, np.inf), args=(),\n                     kwargs=None):\n    \"\"\"Check correctness of a function computing derivatives (Jacobian or\n    gradient) by comparison with a finite difference approximation.\n\n    Parameters\n    ----------\n    fun : callable\n        Function of which to estimate the derivatives. The argument x\n        passed to this function is ndarray of shape (n,) (never a scalar\n        even if n=1). It must return 1-D array_like of shape (m,) or a scalar.\n    jac : callable\n        Function which computes Jacobian matrix of `fun`. It must work with\n        argument x the same way as `fun`. The return value must be array_like\n        or sparse matrix with an appropriate shape.\n    x0 : array_like of shape (n,) or float\n        Point at which to estimate the derivatives. Float will be converted\n        to 1-D array.\n    bounds : 2-tuple of array_like, optional\n        Lower and upper bounds on independent variables. Defaults to no bounds.\n        Each bound must match the size of `x0` or be a scalar, in the latter\n        case the bound will be the same for all variables. Use it to limit the\n        range of function evaluation.\n    args, kwargs : tuple and dict, optional\n        Additional arguments passed to `fun` and `jac`. Both empty by default.\n        The calling signature is ``fun(x, *args, **kwargs)`` and the same\n        for `jac`.\n\n    Returns\n    -------\n    accuracy : float\n        The maximum among all relative errors for elements with absolute values\n        higher than 1 and absolute errors for elements with absolute values\n        less or equal than 1. If `accuracy` is on the order of 1e-6 or lower,\n        then it is likely that your `jac` implementation is correct.\n\n    See Also\n    --------\n    approx_derivative : Compute finite difference approximation of derivative.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.optimize._numdiff import check_derivative\n    >>>\n    >>>\n    >>> def f(x, c1, c2):\n    ...     return np.array([x[0] * np.sin(c1 * x[1]),\n    ...                      x[0] * np.cos(c2 * x[1])])\n    ...\n    >>> def jac(x, c1, c2):\n    ...     return np.array([\n    ...         [np.sin(c1 * x[1]),  c1 * x[0] * np.cos(c1 * x[1])],\n    ...         [np.cos(c2 * x[1]), -c2 * x[0] * np.sin(c2 * x[1])]\n    ...     ])\n    ...\n    >>>\n    >>> x0 = np.array([1.0, 0.5 * np.pi])\n    >>> check_derivative(f, jac, x0, args=(1, 2))\n    2.4492935982947064e-16\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n    J_to_test = jac(x0, *args, **kwargs)\n    if issparse(J_to_test):\n        J_diff = approx_derivative(fun, x0, bounds=bounds, sparsity=J_to_test,\n                                   args=args, kwargs=kwargs)\n        J_to_test = csr_matrix(J_to_test)\n        abs_err = J_to_test - J_diff\n        i, j, abs_err_data = find(abs_err)\n        J_diff_data = np.asarray(J_diff[i, j]).ravel()\n        return np.max(np.abs(abs_err_data) /\n                      np.maximum(1, np.abs(J_diff_data)))\n    else:\n        J_diff = approx_derivative(fun, x0, bounds=bounds,\n                                   args=args, kwargs=kwargs)\n        abs_err = np.abs(J_to_test - J_diff)\n        return np.max(abs_err / np.maximum(1, np.abs(J_diff)))\n", 785], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/getlimits.py": ["\"\"\"Machine limits for Float32 and Float64 and (long double) if available...\n\n\"\"\"\n__all__ = ['finfo', 'iinfo']\n\nimport types\nimport warnings\n\nfrom .._utils import set_module\nfrom ._machar import MachAr\nfrom . import numeric\nfrom . import numerictypes as ntypes\nfrom .numeric import array, inf, nan\nfrom .umath import log10, exp2, nextafter, isnan\n\n\ndef _fr0(a):\n    \"\"\"fix rank-0 --> rank-1\"\"\"\n    if a.ndim == 0:\n        a = a.copy()\n        a.shape = (1,)\n    return a\n\n\ndef _fr1(a):\n    \"\"\"fix rank > 0 --> rank-0\"\"\"\n    if a.size == 1:\n        a = a.copy()\n        a.shape = ()\n    return a\n\n\nclass MachArLike:\n    \"\"\" Object to simulate MachAr instance \"\"\"\n    def __init__(self, ftype, *, eps, epsneg, huge, tiny,\n                 ibeta, smallest_subnormal=None, **kwargs):\n        self.params = _MACHAR_PARAMS[ftype]\n        self.ftype = ftype\n        self.title = self.params['title']\n        # Parameter types same as for discovered MachAr object.\n        if not smallest_subnormal:\n            self._smallest_subnormal = nextafter(\n                self.ftype(0), self.ftype(1), dtype=self.ftype)\n        else:\n            self._smallest_subnormal = smallest_subnormal\n        self.epsilon = self.eps = self._float_to_float(eps)\n        self.epsneg = self._float_to_float(epsneg)\n        self.xmax = self.huge = self._float_to_float(huge)\n        self.xmin = self._float_to_float(tiny)\n        self.smallest_normal = self.tiny = self._float_to_float(tiny)\n        self.ibeta = self.params['itype'](ibeta)\n        self.__dict__.update(kwargs)\n        self.precision = int(-log10(self.eps))\n        self.resolution = self._float_to_float(\n            self._float_conv(10) ** (-self.precision))\n        self._str_eps = self._float_to_str(self.eps)\n        self._str_epsneg = self._float_to_str(self.epsneg)\n        self._str_xmin = self._float_to_str(self.xmin)\n        self._str_xmax = self._float_to_str(self.xmax)\n        self._str_resolution = self._float_to_str(self.resolution)\n        self._str_smallest_normal = self._float_to_str(self.xmin)\n\n    @property\n    def smallest_subnormal(self):\n        \"\"\"Return the value for the smallest subnormal.\n\n        Returns\n        -------\n        smallest_subnormal : float\n            value for the smallest subnormal.\n\n        Warns\n        -----\n        UserWarning\n            If the calculated value for the smallest subnormal is zero.\n        \"\"\"\n        # Check that the calculated value is not zero, in case it raises a\n        # warning.\n        value = self._smallest_subnormal\n        if self.ftype(0) == value:\n            warnings.warn(\n                'The value of the smallest subnormal for {} type '\n                'is zero.'.format(self.ftype), UserWarning, stacklevel=2)\n\n        return self._float_to_float(value)\n\n    @property\n    def _str_smallest_subnormal(self):\n        \"\"\"Return the string representation of the smallest subnormal.\"\"\"\n        return self._float_to_str(self.smallest_subnormal)\n\n    def _float_to_float(self, value):\n        \"\"\"Converts float to float.\n\n        Parameters\n        ----------\n        value : float\n            value to be converted.\n        \"\"\"\n        return _fr1(self._float_conv(value))\n\n    def _float_conv(self, value):\n        \"\"\"Converts float to conv.\n\n        Parameters\n        ----------\n        value : float\n            value to be converted.\n        \"\"\"\n        return array([value], self.ftype)\n\n    def _float_to_str(self, value):\n        \"\"\"Converts float to str.\n\n        Parameters\n        ----------\n        value : float\n            value to be converted.\n        \"\"\"\n        return self.params['fmt'] % array(_fr0(value)[0], self.ftype)\n\n\n_convert_to_float = {\n    ntypes.csingle: ntypes.single,\n    ntypes.complex128: ntypes.float64,\n    ntypes.clongdouble: ntypes.longdouble\n    }\n\n# Parameters for creating MachAr / MachAr-like objects\n_title_fmt = 'numpy {} precision floating point number'\n_MACHAR_PARAMS = {\n    ntypes.double: dict(\n        itype = ntypes.int64,\n        fmt = '%24.16e',\n        title = _title_fmt.format('double')),\n    ntypes.single: dict(\n        itype = ntypes.int32,\n        fmt = '%15.7e',\n        title = _title_fmt.format('single')),\n    ntypes.longdouble: dict(\n        itype = ntypes.longlong,\n        fmt = '%s',\n        title = _title_fmt.format('long double')),\n    ntypes.half: dict(\n        itype = ntypes.int16,\n        fmt = '%12.5e',\n        title = _title_fmt.format('half'))}\n\n# Key to identify the floating point type.  Key is result of\n#\n#    ftype = np.longdouble        # or float64, float32, etc.\n#    v = (ftype(-1.0) / ftype(10.0))\n#    v.view(v.dtype.newbyteorder('<')).tobytes()\n#\n# Uses division to work around deficiencies in strtold on some platforms.\n# See:\n# https://perl5.git.perl.org/perl.git/blob/3118d7d684b56cbeb702af874f4326683c45f045:/Configure\n\n_KNOWN_TYPES = {}\ndef _register_type(machar, bytepat):\n    _KNOWN_TYPES[bytepat] = machar\n\n\n_float_ma = {}\n\n\ndef _register_known_types():\n    # Known parameters for float16\n    # See docstring of MachAr class for description of parameters.\n    f16 = ntypes.float16\n    float16_ma = MachArLike(f16,\n                            machep=-10,\n                            negep=-11,\n                            minexp=-14,\n                            maxexp=16,\n                            it=10,\n                            iexp=5,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=exp2(f16(-10)),\n                            epsneg=exp2(f16(-11)),\n                            huge=f16(65504),\n                            tiny=f16(2 ** -14))\n    _register_type(float16_ma, b'f\\xae')\n    _float_ma[16] = float16_ma\n\n    # Known parameters for float32\n    f32 = ntypes.float32\n    float32_ma = MachArLike(f32,\n                            machep=-23,\n                            negep=-24,\n                            minexp=-126,\n                            maxexp=128,\n                            it=23,\n                            iexp=8,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=exp2(f32(-23)),\n                            epsneg=exp2(f32(-24)),\n                            huge=f32((1 - 2 ** -24) * 2**128),\n                            tiny=exp2(f32(-126)))\n    _register_type(float32_ma, b'\\xcd\\xcc\\xcc\\xbd')\n    _float_ma[32] = float32_ma\n\n    # Known parameters for float64\n    f64 = ntypes.float64\n    epsneg_f64 = 2.0 ** -53.0\n    tiny_f64 = 2.0 ** -1022.0\n    float64_ma = MachArLike(f64,\n                            machep=-52,\n                            negep=-53,\n                            minexp=-1022,\n                            maxexp=1024,\n                            it=52,\n                            iexp=11,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=2.0 ** -52.0,\n                            epsneg=epsneg_f64,\n                            huge=(1.0 - epsneg_f64) / tiny_f64 * f64(4),\n                            tiny=tiny_f64)\n    _register_type(float64_ma, b'\\x9a\\x99\\x99\\x99\\x99\\x99\\xb9\\xbf')\n    _float_ma[64] = float64_ma\n\n    # Known parameters for IEEE 754 128-bit binary float\n    ld = ntypes.longdouble\n    epsneg_f128 = exp2(ld(-113))\n    tiny_f128 = exp2(ld(-16382))\n    # Ignore runtime error when this is not f128\n    with numeric.errstate(all='ignore'):\n        huge_f128 = (ld(1) - epsneg_f128) / tiny_f128 * ld(4)\n    float128_ma = MachArLike(ld,\n                             machep=-112,\n                             negep=-113,\n                             minexp=-16382,\n                             maxexp=16384,\n                             it=112,\n                             iexp=15,\n                             ibeta=2,\n                             irnd=5,\n                             ngrd=0,\n                             eps=exp2(ld(-112)),\n                             epsneg=epsneg_f128,\n                             huge=huge_f128,\n                             tiny=tiny_f128)\n    # IEEE 754 128-bit binary float\n    _register_type(float128_ma,\n        b'\\x9a\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\xfb\\xbf')\n    _float_ma[128] = float128_ma\n\n    # Known parameters for float80 (Intel 80-bit extended precision)\n    epsneg_f80 = exp2(ld(-64))\n    tiny_f80 = exp2(ld(-16382))\n    # Ignore runtime error when this is not f80\n    with numeric.errstate(all='ignore'):\n        huge_f80 = (ld(1) - epsneg_f80) / tiny_f80 * ld(4)\n    float80_ma = MachArLike(ld,\n                            machep=-63,\n                            negep=-64,\n                            minexp=-16382,\n                            maxexp=16384,\n                            it=63,\n                            iexp=15,\n                            ibeta=2,\n                            irnd=5,\n                            ngrd=0,\n                            eps=exp2(ld(-63)),\n                            epsneg=epsneg_f80,\n                            huge=huge_f80,\n                            tiny=tiny_f80)\n    # float80, first 10 bytes containing actual storage\n    _register_type(float80_ma, b'\\xcd\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xfb\\xbf')\n    _float_ma[80] = float80_ma\n\n    # Guessed / known parameters for double double; see:\n    # https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic\n    # These numbers have the same exponent range as float64, but extended\n    # number of digits in the significand.\n    huge_dd = nextafter(ld(inf), ld(0), dtype=ld)\n    # As the smallest_normal in double double is so hard to calculate we set\n    # it to NaN.\n    smallest_normal_dd = nan\n    # Leave the same value for the smallest subnormal as double\n    smallest_subnormal_dd = ld(nextafter(0., 1.))\n    float_dd_ma = MachArLike(ld,\n                             machep=-105,\n                             negep=-106,\n                             minexp=-1022,\n                             maxexp=1024,\n                             it=105,\n                             iexp=11,\n                             ibeta=2,\n                             irnd=5,\n                             ngrd=0,\n                             eps=exp2(ld(-105)),\n                             epsneg=exp2(ld(-106)),\n                             huge=huge_dd,\n                             tiny=smallest_normal_dd,\n                             smallest_subnormal=smallest_subnormal_dd)\n    # double double; low, high order (e.g. PPC 64)\n    _register_type(float_dd_ma,\n        b'\\x9a\\x99\\x99\\x99\\x99\\x99Y<\\x9a\\x99\\x99\\x99\\x99\\x99\\xb9\\xbf')\n    # double double; high, low order (e.g. PPC 64 le)\n    _register_type(float_dd_ma,\n        b'\\x9a\\x99\\x99\\x99\\x99\\x99\\xb9\\xbf\\x9a\\x99\\x99\\x99\\x99\\x99Y<')\n    _float_ma['dd'] = float_dd_ma\n\n\ndef _get_machar(ftype):\n    \"\"\" Get MachAr instance or MachAr-like instance\n\n    Get parameters for floating point type, by first trying signatures of\n    various known floating point types, then, if none match, attempting to\n    identify parameters by analysis.\n\n    Parameters\n    ----------\n    ftype : class\n        Numpy floating point type class (e.g. ``np.float64``)\n\n    Returns\n    -------\n    ma_like : instance of :class:`MachAr` or :class:`MachArLike`\n        Object giving floating point parameters for `ftype`.\n\n    Warns\n    -----\n    UserWarning\n        If the binary signature of the float type is not in the dictionary of\n        known float types.\n    \"\"\"\n    params = _MACHAR_PARAMS.get(ftype)\n    if params is None:\n        raise ValueError(repr(ftype))\n    # Detect known / suspected types\n    # ftype(-1.0) / ftype(10.0) is better than ftype('-0.1') because stold\n    # may be deficient\n    key = (ftype(-1.0) / ftype(10.))\n    key = key.view(key.dtype.newbyteorder(\"<\")).tobytes()\n    ma_like = None\n    if ftype == ntypes.longdouble:\n        # Could be 80 bit == 10 byte extended precision, where last bytes can\n        # be random garbage.\n        # Comparing first 10 bytes to pattern first to avoid branching on the\n        # random garbage.\n        ma_like = _KNOWN_TYPES.get(key[:10])\n    if ma_like is None:\n        # see if the full key is known.\n        ma_like = _KNOWN_TYPES.get(key)\n    if ma_like is None and len(key) == 16:\n        # machine limits could be f80 masquerading as np.float128,\n        # find all keys with length 16 and make new dict, but make the keys\n        # only 10 bytes long, the last bytes can be random garbage\n        _kt = {k[:10]: v for k, v in _KNOWN_TYPES.items() if len(k) == 16}\n        ma_like = _kt.get(key[:10])\n    if ma_like is not None:\n        return ma_like\n    # Fall back to parameter discovery\n    warnings.warn(\n        f'Signature {key} for {ftype} does not match any known type: '\n        'falling back to type probe function.\\n'\n        'This warnings indicates broken support for the dtype!',\n        UserWarning, stacklevel=2)\n    return _discovered_machar(ftype)\n\n\ndef _discovered_machar(ftype):\n    \"\"\" Create MachAr instance with found information on float types\n\n    TODO: MachAr should be retired completely ideally.  We currently only\n          ever use it system with broken longdouble (valgrind, WSL).\n    \"\"\"\n    params = _MACHAR_PARAMS[ftype]\n    return MachAr(lambda v: array([v], ftype),\n                  lambda v: _fr0(v.astype(params['itype']))[0],\n                  lambda v: array(_fr0(v)[0], ftype),\n                  lambda v: params['fmt'] % array(_fr0(v)[0], ftype),\n                  params['title'])\n\n\n@set_module('numpy')\nclass finfo:\n    \"\"\"\n    finfo(dtype)\n\n    Machine limits for floating point types.\n\n    Attributes\n    ----------\n    bits : int\n        The number of bits occupied by the type.\n    dtype : dtype\n        Returns the dtype for which `finfo` returns information. For complex\n        input, the returned dtype is the associated ``float*`` dtype for its\n        real and complex components.\n    eps : float\n        The difference between 1.0 and the next smallest representable float\n        larger than 1.0. For example, for 64-bit binary floats in the IEEE-754\n        standard, ``eps = 2**-52``, approximately 2.22e-16.\n    epsneg : float\n        The difference between 1.0 and the next smallest representable float\n        less than 1.0. For example, for 64-bit binary floats in the IEEE-754\n        standard, ``epsneg = 2**-53``, approximately 1.11e-16.\n    iexp : int\n        The number of bits in the exponent portion of the floating point\n        representation.\n    machep : int\n        The exponent that yields `eps`.\n    max : floating point number of the appropriate type\n        The largest representable number.\n    maxexp : int\n        The smallest positive power of the base (2) that causes overflow.\n    min : floating point number of the appropriate type\n        The smallest representable number, typically ``-max``.\n    minexp : int\n        The most negative power of the base (2) consistent with there\n        being no leading 0's in the mantissa.\n    negep : int\n        The exponent that yields `epsneg`.\n    nexp : int\n        The number of bits in the exponent including its sign and bias.\n    nmant : int\n        The number of bits in the mantissa.\n    precision : int\n        The approximate number of decimal digits to which this kind of\n        float is precise.\n    resolution : floating point number of the appropriate type\n        The approximate decimal resolution of this type, i.e.,\n        ``10**-precision``.\n    tiny : float\n        An alias for `smallest_normal`, kept for backwards compatibility.\n    smallest_normal : float\n        The smallest positive floating point number with 1 as leading bit in\n        the mantissa following IEEE-754 (see Notes).\n    smallest_subnormal : float\n        The smallest positive floating point number with 0 as leading bit in\n        the mantissa following IEEE-754.\n\n    Parameters\n    ----------\n    dtype : float, dtype, or instance\n        Kind of floating point or complex floating point\n        data-type about which to get information.\n\n    See Also\n    --------\n    iinfo : The equivalent for integer data types.\n    spacing : The distance between a value and the nearest adjacent number\n    nextafter : The next floating point value after x1 towards x2\n\n    Notes\n    -----\n    For developers of NumPy: do not instantiate this at the module level.\n    The initial calculation of these parameters is expensive and negatively\n    impacts import times.  These objects are cached, so calling ``finfo()``\n    repeatedly inside your functions is not a problem.\n\n    Note that ``smallest_normal`` is not actually the smallest positive\n    representable value in a NumPy floating point type. As in the IEEE-754\n    standard [1]_, NumPy floating point types make use of subnormal numbers to\n    fill the gap between 0 and ``smallest_normal``. However, subnormal numbers\n    may have significantly reduced precision [2]_.\n\n    This function can also be used for complex data types as well. If used,\n    the output will be the same as the corresponding real float type\n    (e.g. numpy.finfo(numpy.csingle) is the same as numpy.finfo(numpy.single)).\n    However, the output is true for the real and imaginary components.\n\n    References\n    ----------\n    .. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,\n           pp.1-70, 2008, https://doi.org/10.1109/IEEESTD.2008.4610935\n    .. [2] Wikipedia, \"Denormal Numbers\",\n           https://en.wikipedia.org/wiki/Denormal_number\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.finfo(np.float64).dtype\n    dtype('float64')\n    >>> np.finfo(np.complex64).dtype\n    dtype('float32')\n\n    \"\"\"\n\n    _finfo_cache = {}\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\n    def __new__(cls, dtype):\n        try:\n            obj = cls._finfo_cache.get(dtype)  # most common path\n            if obj is not None:\n                return obj\n        except TypeError:\n            pass\n\n        if dtype is None:\n            # Deprecated in NumPy 1.25, 2023-01-16\n            warnings.warn(\n                \"finfo() dtype cannot be None. This behavior will \"\n                \"raise an error in the future. (Deprecated in NumPy 1.25)\",\n                DeprecationWarning,\n                stacklevel=2\n            )\n\n        try:\n            dtype = numeric.dtype(dtype)\n        except TypeError:\n            # In case a float instance was given\n            dtype = numeric.dtype(type(dtype))\n\n        obj = cls._finfo_cache.get(dtype)\n        if obj is not None:\n            return obj\n        dtypes = [dtype]\n        newdtype = ntypes.obj2sctype(dtype)\n        if newdtype is not dtype:\n            dtypes.append(newdtype)\n            dtype = newdtype\n        if not issubclass(dtype, numeric.inexact):\n            raise ValueError(\"data type %r not inexact\" % (dtype))\n        obj = cls._finfo_cache.get(dtype)\n        if obj is not None:\n            return obj\n        if not issubclass(dtype, numeric.floating):\n            newdtype = _convert_to_float[dtype]\n            if newdtype is not dtype:\n                # dtype changed, for example from complex128 to float64\n                dtypes.append(newdtype)\n                dtype = newdtype\n\n                obj = cls._finfo_cache.get(dtype, None)\n                if obj is not None:\n                    # the original dtype was not in the cache, but the new\n                    # dtype is in the cache. we add the original dtypes to\n                    # the cache and return the result\n                    for dt in dtypes:\n                        cls._finfo_cache[dt] = obj\n                    return obj\n        obj = object.__new__(cls)._init(dtype)\n        for dt in dtypes:\n            cls._finfo_cache[dt] = obj\n        return obj\n\n    def _init(self, dtype):\n        self.dtype = numeric.dtype(dtype)\n        machar = _get_machar(dtype)\n\n        for word in ['precision', 'iexp',\n                     'maxexp', 'minexp', 'negep',\n                     'machep']:\n            setattr(self, word, getattr(machar, word))\n        for word in ['resolution', 'epsneg', 'smallest_subnormal']:\n            setattr(self, word, getattr(machar, word).flat[0])\n        self.bits = self.dtype.itemsize * 8\n        self.max = machar.huge.flat[0]\n        self.min = -self.max\n        self.eps = machar.eps.flat[0]\n        self.nexp = machar.iexp\n        self.nmant = machar.it\n        self._machar = machar\n        self._str_tiny = machar._str_xmin.strip()\n        self._str_max = machar._str_xmax.strip()\n        self._str_epsneg = machar._str_epsneg.strip()\n        self._str_eps = machar._str_eps.strip()\n        self._str_resolution = machar._str_resolution.strip()\n        self._str_smallest_normal = machar._str_smallest_normal.strip()\n        self._str_smallest_subnormal = machar._str_smallest_subnormal.strip()\n        return self\n\n    def __str__(self):\n        fmt = (\n            'Machine parameters for %(dtype)s\\n'\n            '---------------------------------------------------------------\\n'\n            'precision = %(precision)3s   resolution = %(_str_resolution)s\\n'\n            'machep = %(machep)6s   eps =        %(_str_eps)s\\n'\n            'negep =  %(negep)6s   epsneg =     %(_str_epsneg)s\\n'\n            'minexp = %(minexp)6s   tiny =       %(_str_tiny)s\\n'\n            'maxexp = %(maxexp)6s   max =        %(_str_max)s\\n'\n            'nexp =   %(nexp)6s   min =        -max\\n'\n            'smallest_normal = %(_str_smallest_normal)s   '\n            'smallest_subnormal = %(_str_smallest_subnormal)s\\n'\n            '---------------------------------------------------------------\\n'\n            )\n        return fmt % self.__dict__\n\n    def __repr__(self):\n        c = self.__class__.__name__\n        d = self.__dict__.copy()\n        d['klass'] = c\n        return ((\"%(klass)s(resolution=%(resolution)s, min=-%(_str_max)s,\"\n                 \" max=%(_str_max)s, dtype=%(dtype)s)\") % d)\n\n    @property\n    def smallest_normal(self):\n        \"\"\"Return the value for the smallest normal.\n\n        Returns\n        -------\n        smallest_normal : float\n            Value for the smallest normal.\n\n        Warns\n        -----\n        UserWarning\n            If the calculated value for the smallest normal is requested for\n            double-double.\n        \"\"\"\n        # This check is necessary because the value for smallest_normal is\n        # platform dependent for longdouble types.\n        if isnan(self._machar.smallest_normal.flat[0]):\n            warnings.warn(\n                'The value of smallest normal is undefined for double double',\n                UserWarning, stacklevel=2)\n        return self._machar.smallest_normal.flat[0]\n\n    @property\n    def tiny(self):\n        \"\"\"Return the value for tiny, alias of smallest_normal.\n\n        Returns\n        -------\n        tiny : float\n            Value for the smallest normal, alias of smallest_normal.\n\n        Warns\n        -----\n        UserWarning\n            If the calculated value for the smallest normal is requested for\n            double-double.\n        \"\"\"\n        return self.smallest_normal\n\n\n@set_module('numpy')\nclass iinfo:\n    \"\"\"\n    iinfo(type)\n\n    Machine limits for integer types.\n\n    Attributes\n    ----------\n    bits : int\n        The number of bits occupied by the type.\n    dtype : dtype\n        Returns the dtype for which `iinfo` returns information.\n    min : int\n        The smallest integer expressible by the type.\n    max : int\n        The largest integer expressible by the type.\n\n    Parameters\n    ----------\n    int_type : integer type, dtype, or instance\n        The kind of integer data type to get information about.\n\n    See Also\n    --------\n    finfo : The equivalent for floating point data types.\n\n    Examples\n    --------\n    With types:\n\n    >>> import numpy as np\n    >>> ii16 = np.iinfo(np.int16)\n    >>> ii16.min\n    -32768\n    >>> ii16.max\n    32767\n    >>> ii32 = np.iinfo(np.int32)\n    >>> ii32.min\n    -2147483648\n    >>> ii32.max\n    2147483647\n\n    With instances:\n\n    >>> ii32 = np.iinfo(np.int32(10))\n    >>> ii32.min\n    -2147483648\n    >>> ii32.max\n    2147483647\n\n    \"\"\"\n\n    _min_vals = {}\n    _max_vals = {}\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\n    def __init__(self, int_type):\n        try:\n            self.dtype = numeric.dtype(int_type)\n        except TypeError:\n            self.dtype = numeric.dtype(type(int_type))\n        self.kind = self.dtype.kind\n        self.bits = self.dtype.itemsize * 8\n        self.key = \"%s%d\" % (self.kind, self.bits)\n        if self.kind not in 'iu':\n            raise ValueError(\"Invalid integer data type %r.\" % (self.kind,))\n\n    @property\n    def min(self):\n        \"\"\"Minimum value of given dtype.\"\"\"\n        if self.kind == 'u':\n            return 0\n        else:\n            try:\n                val = iinfo._min_vals[self.key]\n            except KeyError:\n                val = int(-(1 << (self.bits-1)))\n                iinfo._min_vals[self.key] = val\n            return val\n\n    @property\n    def max(self):\n        \"\"\"Maximum value of given dtype.\"\"\"\n        try:\n            val = iinfo._max_vals[self.key]\n        except KeyError:\n            if self.kind == 'u':\n                val = int((1 << self.bits) - 1)\n            else:\n                val = int((1 << (self.bits-1)) - 1)\n            iinfo._max_vals[self.key] = val\n        return val\n\n    def __str__(self):\n        \"\"\"String representation.\"\"\"\n        fmt = (\n            'Machine parameters for %(dtype)s\\n'\n            '---------------------------------------------------------------\\n'\n            'min = %(min)s\\n'\n            'max = %(max)s\\n'\n            '---------------------------------------------------------------\\n'\n            )\n        return fmt % {'dtype': self.dtype, 'min': self.min, 'max': self.max}\n\n    def __repr__(self):\n        return \"%s(min=%s, max=%s, dtype=%s)\" % (self.__class__.__name__,\n                                    self.min, self.max, self.dtype)\n", 747], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py": ["\"\"\"\nCreate the numpy._core.multiarray namespace for backward compatibility.\nIn v1.16 the multiarray and umath c-extension modules were merged into\na single _multiarray_umath extension module. So we replicate the old\nnamespace by importing from the extension module.\n\n\"\"\"\n\nimport functools\nfrom . import overrides\nfrom . import _multiarray_umath\nfrom ._multiarray_umath import *  # noqa: F403\n# These imports are needed for backward compatibility,\n# do not change them. issue gh-15518\n# _get_ndarray_c_version is semi-public, on purpose not added to __all__\nfrom ._multiarray_umath import (\n    _flagdict, from_dlpack, _place, _reconstruct,\n    _vec_string, _ARRAY_API, _monotonicity, _get_ndarray_c_version,\n    _get_madvise_hugepage, _set_madvise_hugepage,\n    )\n\n__all__ = [\n    '_ARRAY_API', 'ALLOW_THREADS', 'BUFSIZE', 'CLIP', 'DATETIMEUNITS',\n    'ITEM_HASOBJECT', 'ITEM_IS_POINTER', 'LIST_PICKLE', 'MAXDIMS',\n    'MAY_SHARE_BOUNDS', 'MAY_SHARE_EXACT', 'NEEDS_INIT', 'NEEDS_PYAPI',\n    'RAISE', 'USE_GETITEM', 'USE_SETITEM', 'WRAP',\n    '_flagdict', 'from_dlpack', '_place', '_reconstruct', '_vec_string',\n    '_monotonicity', 'add_docstring', 'arange', 'array', 'asarray',\n    'asanyarray', 'ascontiguousarray', 'asfortranarray', 'bincount',\n    'broadcast', 'busday_count', 'busday_offset', 'busdaycalendar', 'can_cast',\n    'compare_chararrays', 'concatenate', 'copyto', 'correlate', 'correlate2',\n    'count_nonzero', 'c_einsum', 'datetime_as_string', 'datetime_data',\n    'dot', 'dragon4_positional', 'dragon4_scientific', 'dtype',\n    'empty', 'empty_like', 'error', 'flagsobj', 'flatiter', 'format_longfloat',\n    'frombuffer', 'fromfile', 'fromiter', 'fromstring',\n    'get_handler_name', 'get_handler_version', 'inner', 'interp',\n    'interp_complex', 'is_busday', 'lexsort', 'matmul', 'vecdot',\n    'may_share_memory', 'min_scalar_type', 'ndarray', 'nditer', 'nested_iters',\n    'normalize_axis_index', 'packbits', 'promote_types', 'putmask',\n    'ravel_multi_index', 'result_type', 'scalar', 'set_datetimeparse_function',\n    'set_typeDict', 'shares_memory', 'typeinfo',\n    'unpackbits', 'unravel_index', 'vdot', 'where', 'zeros']\n\n# For backward compatibility, make sure pickle imports\n# these functions from here\n_reconstruct.__module__ = 'numpy._core.multiarray'\nscalar.__module__ = 'numpy._core.multiarray'\n\n\nfrom_dlpack.__module__ = 'numpy'\narange.__module__ = 'numpy'\narray.__module__ = 'numpy'\nasarray.__module__ = 'numpy'\nasanyarray.__module__ = 'numpy'\nascontiguousarray.__module__ = 'numpy'\nasfortranarray.__module__ = 'numpy'\ndatetime_data.__module__ = 'numpy'\nempty.__module__ = 'numpy'\nfrombuffer.__module__ = 'numpy'\nfromfile.__module__ = 'numpy'\nfromiter.__module__ = 'numpy'\nfrompyfunc.__module__ = 'numpy'\nfromstring.__module__ = 'numpy'\nmay_share_memory.__module__ = 'numpy'\nnested_iters.__module__ = 'numpy'\npromote_types.__module__ = 'numpy'\nzeros.__module__ = 'numpy'\nnormalize_axis_index.__module__ = 'numpy.lib.array_utils'\nadd_docstring.__module__ = 'numpy.lib'\ncompare_chararrays.__module__ = 'numpy.char'\n\n\ndef _override___module__():\n    namespace_names = globals()\n    for ufunc_name in [\n        'absolute', 'arccos', 'arccosh', 'add', 'arcsin', 'arcsinh', 'arctan',\n        'arctan2', 'arctanh', 'bitwise_and', 'bitwise_count', 'invert',\n        'left_shift', 'bitwise_or', 'right_shift', 'bitwise_xor', 'cbrt',\n        'ceil', 'conjugate', 'copysign', 'cos', 'cosh', 'deg2rad', 'degrees',\n        'divide', 'divmod', 'equal', 'exp', 'exp2', 'expm1', 'fabs',\n        'float_power', 'floor', 'floor_divide', 'fmax', 'fmin', 'fmod',\n        'frexp', 'gcd', 'greater', 'greater_equal', 'heaviside', 'hypot',\n        'isfinite', 'isinf', 'isnan', 'isnat', 'lcm', 'ldexp', 'less',\n        'less_equal', 'log', 'log10', 'log1p', 'log2', 'logaddexp',\n        'logaddexp2', 'logical_and', 'logical_not', 'logical_or',\n        'logical_xor', 'matmul', 'matvec', 'maximum', 'minimum', 'remainder',\n        'modf', 'multiply', 'negative', 'nextafter', 'not_equal', 'positive',\n        'power', 'rad2deg', 'radians', 'reciprocal', 'rint', 'sign', 'signbit',\n        'sin', 'sinh', 'spacing', 'sqrt', 'square', 'subtract', 'tan', 'tanh',\n        'trunc', 'vecdot', 'vecmat',\n    ]:\n        ufunc = namespace_names[ufunc_name]\n        ufunc.__module__ = \"numpy\"\n        ufunc.__qualname__ = ufunc_name\n\n\n_override___module__()\n\n\n# We can't verify dispatcher signatures because NumPy's C functions don't\n# support introspection.\narray_function_from_c_func_and_dispatcher = functools.partial(\n    overrides.array_function_from_dispatcher,\n    module='numpy', docs_from_dispatcher=True, verify=False)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.empty_like)\ndef empty_like(\n    prototype, dtype=None, order=None, subok=None, shape=None, *, device=None\n):\n    \"\"\"\n    empty_like(prototype, dtype=None, order='K', subok=True, shape=None, *,\n               device=None)\n\n    Return a new array with the same shape and type as a given array.\n\n    Parameters\n    ----------\n    prototype : array_like\n        The shape and data-type of `prototype` define these same attributes\n        of the returned array.\n    dtype : data-type, optional\n        Overrides the data type of the result.\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Overrides the memory layout of the result. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `prototype` is Fortran\n        contiguous, 'C' otherwise. 'K' means match the layout of `prototype`\n        as closely as possible.\n    subok : bool, optional.\n        If True, then the newly created array will use the sub-class\n        type of `prototype`, otherwise it will be a base-class array. Defaults\n        to True.\n    shape : int or sequence of ints, optional.\n        Overrides the shape of the result. If order='K' and the number of\n        dimensions is unchanged, will try to keep order, otherwise,\n        order='C' is implied.\n    device : str, optional\n        The device on which to place the created array. Default: None.\n        For Array-API interoperability only, so must be ``\"cpu\"`` if passed.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of uninitialized (arbitrary) data with the same\n        shape and type as `prototype`.\n\n    See Also\n    --------\n    ones_like : Return an array of ones with shape and type of input.\n    zeros_like : Return an array of zeros with shape and type of input.\n    full_like : Return a new array with shape of input filled with value.\n    empty : Return a new uninitialized array.\n\n    Notes\n    -----\n    Unlike other array creation functions (e.g. `zeros_like`, `ones_like`,\n    `full_like`), `empty_like` does not initialize the values of the array,\n    and may therefore be marginally faster. However, the values stored in the\n    newly allocated array are arbitrary. For reproducible behavior, be sure\n    to set each element of the array before reading.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = ([1,2,3], [4,5,6])                         # a is array-like\n    >>> np.empty_like(a)\n    array([[-1073741821, -1073741821,           3],    # uninitialized\n           [          0,           0, -1073741821]])\n    >>> a = np.array([[1., 2., 3.],[4.,5.,6.]])\n    >>> np.empty_like(a)\n    array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized\n           [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])\n\n    \"\"\"   # NOQA\n    return (prototype,)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.concatenate)\ndef concatenate(arrays, axis=None, out=None, *, dtype=None, casting=None):\n    \"\"\"\n    concatenate(\n        (a1, a2, ...),\n        axis=0,\n        out=None,\n        dtype=None,\n        casting=\"same_kind\"\n    )\n\n    Join a sequence of arrays along an existing axis.\n\n    Parameters\n    ----------\n    a1, a2, ... : sequence of array_like\n        The arrays must have the same shape, except in the dimension\n        corresponding to `axis` (the first, by default).\n    axis : int, optional\n        The axis along which the arrays will be joined.  If axis is None,\n        arrays are flattened before use.  Default is 0.\n    out : ndarray, optional\n        If provided, the destination to place the result. The shape must be\n        correct, matching that of what concatenate would have returned if no\n        out argument were specified.\n    dtype : str or dtype\n        If provided, the destination array will have this dtype. Cannot be\n        provided together with `out`.\n\n        .. versionadded:: 1.20.0\n\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur. Defaults to 'same_kind'.\n        For a description of the options, please see :term:`casting`.\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    res : ndarray\n        The concatenated array.\n\n    See Also\n    --------\n    ma.concatenate : Concatenate function that preserves input masks.\n    array_split : Split an array into multiple sub-arrays of equal or\n                  near-equal size.\n    split : Split array into a list of multiple sub-arrays of equal size.\n    hsplit : Split array into multiple sub-arrays horizontally (column wise).\n    vsplit : Split array into multiple sub-arrays vertically (row wise).\n    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\n    stack : Stack a sequence of arrays along a new axis.\n    block : Assemble arrays from blocks.\n    hstack : Stack arrays in sequence horizontally (column wise).\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n    column_stack : Stack 1-D arrays as columns into a 2-D array.\n\n    Notes\n    -----\n    When one or more of the arrays to be concatenated is a MaskedArray,\n    this function will return a MaskedArray object instead of an ndarray,\n    but the input masks are *not* preserved. In cases where a MaskedArray\n    is expected as input, use the ma.concatenate function from the masked\n    array module instead.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([[5, 6]])\n    >>> np.concatenate((a, b), axis=0)\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.concatenate((a, b.T), axis=1)\n    array([[1, 2, 5],\n           [3, 4, 6]])\n    >>> np.concatenate((a, b), axis=None)\n    array([1, 2, 3, 4, 5, 6])\n\n    This function will not preserve masking of MaskedArray inputs.\n\n    >>> a = np.ma.arange(3)\n    >>> a[1] = np.ma.masked\n    >>> b = np.arange(2, 5)\n    >>> a\n    masked_array(data=[0, --, 2],\n                 mask=[False,  True, False],\n           fill_value=999999)\n    >>> b\n    array([2, 3, 4])\n    >>> np.concatenate([a, b])\n    masked_array(data=[0, 1, 2, 2, 3, 4],\n                 mask=False,\n           fill_value=999999)\n    >>> np.ma.concatenate([a, b])\n    masked_array(data=[0, --, 2, 2, 3, 4],\n                 mask=[False,  True, False, False, False, False],\n           fill_value=999999)\n\n    \"\"\"\n    if out is not None:\n        # optimize for the typical case where only arrays is provided\n        arrays = list(arrays)\n        arrays.append(out)\n    return arrays\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.inner)\ndef inner(a, b):\n    \"\"\"\n    inner(a, b, /)\n\n    Inner product of two arrays.\n\n    Ordinary inner product of vectors for 1-D arrays (without complex\n    conjugation), in higher dimensions a sum product over the last axes.\n\n    Parameters\n    ----------\n    a, b : array_like\n        If `a` and `b` are nonscalar, their last dimensions must match.\n\n    Returns\n    -------\n    out : ndarray\n        If `a` and `b` are both\n        scalars or both 1-D arrays then a scalar is returned; otherwise\n        an array is returned.\n        ``out.shape = (*a.shape[:-1], *b.shape[:-1])``\n\n    Raises\n    ------\n    ValueError\n        If both `a` and `b` are nonscalar and their last dimensions have\n        different sizes.\n\n    See Also\n    --------\n    tensordot : Sum products over arbitrary axes.\n    dot : Generalised matrix product, using second last dimension of `b`.\n    vecdot : Vector dot product of two arrays.\n    einsum : Einstein summation convention.\n\n    Notes\n    -----\n    For vectors (1-D arrays) it computes the ordinary inner-product::\n\n        np.inner(a, b) = sum(a[:]*b[:])\n\n    More generally, if ``ndim(a) = r > 0`` and ``ndim(b) = s > 0``::\n\n        np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\n\n    or explicitly::\n\n        np.inner(a, b)[i0,...,ir-2,j0,...,js-2]\n             = sum(a[i0,...,ir-2,:]*b[j0,...,js-2,:])\n\n    In addition `a` or `b` may be scalars, in which case::\n\n       np.inner(a,b) = a*b\n\n    Examples\n    --------\n    Ordinary inner product for vectors:\n\n    >>> import numpy as np\n    >>> a = np.array([1,2,3])\n    >>> b = np.array([0,1,0])\n    >>> np.inner(a, b)\n    2\n\n    Some multidimensional examples:\n\n    >>> a = np.arange(24).reshape((2,3,4))\n    >>> b = np.arange(4)\n    >>> c = np.inner(a, b)\n    >>> c.shape\n    (2, 3)\n    >>> c\n    array([[ 14,  38,  62],\n           [ 86, 110, 134]])\n\n    >>> a = np.arange(2).reshape((1,1,2))\n    >>> b = np.arange(6).reshape((3,2))\n    >>> c = np.inner(a, b)\n    >>> c.shape\n    (1, 1, 3)\n    >>> c\n    array([[[1, 3, 5]]])\n\n    An example where `b` is a scalar:\n\n    >>> np.inner(np.eye(2), 7)\n    array([[7., 0.],\n           [0., 7.]])\n\n    \"\"\"\n    return (a, b)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.where)\ndef where(condition, x=None, y=None):\n    \"\"\"\n    where(condition, [x, y], /)\n\n    Return elements chosen from `x` or `y` depending on `condition`.\n\n    .. note::\n        When only `condition` is provided, this function is a shorthand for\n        ``np.asarray(condition).nonzero()``. Using `nonzero` directly should be\n        preferred, as it behaves correctly for subclasses. The rest of this\n        documentation covers only the case where all three arguments are\n        provided.\n\n    Parameters\n    ----------\n    condition : array_like, bool\n        Where True, yield `x`, otherwise yield `y`.\n    x, y : array_like\n        Values from which to choose. `x`, `y` and `condition` need to be\n        broadcastable to some shape.\n\n    Returns\n    -------\n    out : ndarray\n        An array with elements from `x` where `condition` is True, and elements\n        from `y` elsewhere.\n\n    See Also\n    --------\n    choose\n    nonzero : The function that is called when x and y are omitted\n\n    Notes\n    -----\n    If all the arrays are 1-D, `where` is equivalent to::\n\n        [xv if c else yv\n         for c, xv, yv in zip(condition, x, y)]\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.arange(10)\n    >>> a\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    >>> np.where(a < 5, a, 10*a)\n    array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])\n\n    This can be used on multidimensional arrays too:\n\n    >>> np.where([[True, False], [True, True]],\n    ...          [[1, 2], [3, 4]],\n    ...          [[9, 8], [7, 6]])\n    array([[1, 8],\n           [3, 4]])\n\n    The shapes of x, y, and the condition are broadcast together:\n\n    >>> x, y = np.ogrid[:3, :4]\n    >>> np.where(x < y, x, 10 + y)  # both x and 10+y are broadcast\n    array([[10,  0,  0,  0],\n           [10, 11,  1,  1],\n           [10, 11, 12,  2]])\n\n    >>> a = np.array([[0, 1, 2],\n    ...               [0, 2, 4],\n    ...               [0, 3, 6]])\n    >>> np.where(a < 4, a, -1)  # -1 is broadcast\n    array([[ 0,  1,  2],\n           [ 0,  2, -1],\n           [ 0,  3, -1]])\n    \"\"\"\n    return (condition, x, y)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.lexsort)\ndef lexsort(keys, axis=None):\n    \"\"\"\n    lexsort(keys, axis=-1)\n\n    Perform an indirect stable sort using a sequence of keys.\n\n    Given multiple sorting keys, lexsort returns an array of integer indices\n    that describes the sort order by multiple keys. The last key in the\n    sequence is used for the primary sort order, ties are broken by the\n    second-to-last key, and so on.\n\n    Parameters\n    ----------\n    keys : (k, m, n, ...) array-like\n        The `k` keys to be sorted. The *last* key (e.g, the last\n        row if `keys` is a 2D array) is the primary sort key.\n        Each element of `keys` along the zeroth axis must be\n        an array-like object of the same shape.\n    axis : int, optional\n        Axis to be indirectly sorted. By default, sort over the last axis\n        of each sequence. Separate slices along `axis` sorted over\n        independently; see last example.\n\n    Returns\n    -------\n    indices : (m, n, ...) ndarray of ints\n        Array of indices that sort the keys along the specified axis.\n\n    See Also\n    --------\n    argsort : Indirect sort.\n    ndarray.sort : In-place sort.\n    sort : Return a sorted copy of an array.\n\n    Examples\n    --------\n    Sort names: first by surname, then by name.\n\n    >>> import numpy as np\n    >>> surnames =    ('Hertz',    'Galilei', 'Hertz')\n    >>> first_names = ('Heinrich', 'Galileo', 'Gustav')\n    >>> ind = np.lexsort((first_names, surnames))\n    >>> ind\n    array([1, 2, 0])\n\n    >>> [surnames[i] + \", \" + first_names[i] for i in ind]\n    ['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']\n\n    Sort according to two numerical keys, first by elements\n    of ``a``, then breaking ties according to elements of ``b``:\n\n    >>> a = [1, 5, 1, 4, 3, 4, 4]  # First sequence\n    >>> b = [9, 4, 0, 4, 0, 2, 1]  # Second sequence\n    >>> ind = np.lexsort((b, a))  # Sort by `a`, then by `b`\n    >>> ind\n    array([2, 0, 4, 6, 5, 3, 1])\n    >>> [(a[i], b[i]) for i in ind]\n    [(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]\n\n    Compare against `argsort`, which would sort each key independently.\n\n    >>> np.argsort((b, a), kind='stable')\n    array([[2, 4, 6, 5, 1, 3, 0],\n           [0, 2, 4, 3, 5, 6, 1]])\n\n    To sort lexicographically with `argsort`, we would need to provide a\n    structured array.\n\n    >>> x = np.array([(ai, bi) for ai, bi in zip(a, b)],\n    ...              dtype = np.dtype([('x', int), ('y', int)]))\n    >>> np.argsort(x)  # or np.argsort(x, order=('x', 'y'))\n    array([2, 0, 4, 6, 5, 3, 1])\n\n    The zeroth axis of `keys` always corresponds with the sequence of keys,\n    so 2D arrays are treated just like other sequences of keys.\n\n    >>> arr = np.asarray([b, a])\n    >>> ind2 = np.lexsort(arr)\n    >>> np.testing.assert_equal(ind2, ind)\n\n    Accordingly, the `axis` parameter refers to an axis of *each* key, not of\n    the `keys` argument itself. For instance, the array ``arr`` is treated as\n    a sequence of two 1-D keys, so specifying ``axis=0`` is equivalent to\n    using the default axis, ``axis=-1``.\n\n    >>> np.testing.assert_equal(np.lexsort(arr, axis=0),\n    ...                         np.lexsort(arr, axis=-1))\n\n    For higher-dimensional arrays, the axis parameter begins to matter. The\n    resulting array has the same shape as each key, and the values are what\n    we would expect if `lexsort` were performed on corresponding slices\n    of the keys independently. For instance,\n\n    >>> x = [[1, 2, 3, 4],\n    ...      [4, 3, 2, 1],\n    ...      [2, 1, 4, 3]]\n    >>> y = [[2, 2, 1, 1],\n    ...      [1, 2, 1, 2],\n    ...      [1, 1, 2, 1]]\n    >>> np.lexsort((x, y), axis=1)\n    array([[2, 3, 0, 1],\n           [2, 0, 3, 1],\n           [1, 0, 3, 2]])\n\n    Each row of the result is what we would expect if we were to perform\n    `lexsort` on the corresponding row of the keys:\n\n    >>> for i in range(3):\n    ...     print(np.lexsort((x[i], y[i])))\n    [2 3 0 1]\n    [2 0 3 1]\n    [1 0 3 2]\n\n    \"\"\"\n    if isinstance(keys, tuple):\n        return keys\n    else:\n        return (keys,)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.can_cast)\ndef can_cast(from_, to, casting=None):\n    \"\"\"\n    can_cast(from_, to, casting='safe')\n\n    Returns True if cast between data types can occur according to the\n    casting rule.\n\n    Parameters\n    ----------\n    from_ : dtype, dtype specifier, NumPy scalar, or array\n        Data type, NumPy scalar, or array to cast from.\n    to : dtype or dtype specifier\n        Data type to cast to.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.\n\n        * 'no' means the data types should not be cast at all.\n        * 'equiv' means only byte-order changes are allowed.\n        * 'safe' means only casts which can preserve values are allowed.\n        * 'same_kind' means only safe casts or casts within a kind,\n          like float64 to float32, are allowed.\n        * 'unsafe' means any data conversions may be done.\n\n    Returns\n    -------\n    out : bool\n        True if cast can occur according to the casting rule.\n\n    Notes\n    -----\n    .. versionchanged:: 2.0\n       This function does not support Python scalars anymore and does not\n       apply any value-based logic for 0-D arrays and NumPy scalars.\n\n    See also\n    --------\n    dtype, result_type\n\n    Examples\n    --------\n    Basic examples\n\n    >>> import numpy as np\n    >>> np.can_cast(np.int32, np.int64)\n    True\n    >>> np.can_cast(np.float64, complex)\n    True\n    >>> np.can_cast(complex, float)\n    False\n\n    >>> np.can_cast('i8', 'f8')\n    True\n    >>> np.can_cast('i8', 'f4')\n    False\n    >>> np.can_cast('i4', 'S4')\n    False\n\n    \"\"\"\n    return (from_,)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.min_scalar_type)\ndef min_scalar_type(a):\n    \"\"\"\n    min_scalar_type(a, /)\n\n    For scalar ``a``, returns the data type with the smallest size\n    and smallest scalar kind which can hold its value.  For non-scalar\n    array ``a``, returns the vector's dtype unmodified.\n\n    Floating point values are not demoted to integers,\n    and complex values are not demoted to floats.\n\n    Parameters\n    ----------\n    a : scalar or array_like\n        The value whose minimal data type is to be found.\n\n    Returns\n    -------\n    out : dtype\n        The minimal data type.\n\n    See Also\n    --------\n    result_type, promote_types, dtype, can_cast\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.min_scalar_type(10)\n    dtype('uint8')\n\n    >>> np.min_scalar_type(-260)\n    dtype('int16')\n\n    >>> np.min_scalar_type(3.1)\n    dtype('float16')\n\n    >>> np.min_scalar_type(1e50)\n    dtype('float64')\n\n    >>> np.min_scalar_type(np.arange(4,dtype='f8'))\n    dtype('float64')\n\n    \"\"\"\n    return (a,)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.result_type)\ndef result_type(*arrays_and_dtypes):\n    \"\"\"\n    result_type(*arrays_and_dtypes)\n\n    Returns the type that results from applying the NumPy\n    type promotion rules to the arguments.\n\n    Type promotion in NumPy works similarly to the rules in languages\n    like C++, with some slight differences.  When both scalars and\n    arrays are used, the array's type takes precedence and the actual value\n    of the scalar is taken into account.\n\n    For example, calculating 3*a, where a is an array of 32-bit floats,\n    intuitively should result in a 32-bit float output.  If the 3 is a\n    32-bit integer, the NumPy rules indicate it can't convert losslessly\n    into a 32-bit float, so a 64-bit float should be the result type.\n    By examining the value of the constant, '3', we see that it fits in\n    an 8-bit integer, which can be cast losslessly into the 32-bit float.\n\n    Parameters\n    ----------\n    arrays_and_dtypes : list of arrays and dtypes\n        The operands of some operation whose result type is needed.\n\n    Returns\n    -------\n    out : dtype\n        The result type.\n\n    See also\n    --------\n    dtype, promote_types, min_scalar_type, can_cast\n\n    Notes\n    -----\n    The specific algorithm used is as follows.\n\n    Categories are determined by first checking which of boolean,\n    integer (int/uint), or floating point (float/complex) the maximum\n    kind of all the arrays and the scalars are.\n\n    If there are only scalars or the maximum category of the scalars\n    is higher than the maximum category of the arrays,\n    the data types are combined with :func:`promote_types`\n    to produce the return value.\n\n    Otherwise, `min_scalar_type` is called on each scalar, and\n    the resulting data types are all combined with :func:`promote_types`\n    to produce the return value.\n\n    The set of int values is not a subset of the uint values for types\n    with the same number of bits, something not reflected in\n    :func:`min_scalar_type`, but handled as a special case in `result_type`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.result_type(3, np.arange(7, dtype='i1'))\n    dtype('int8')\n\n    >>> np.result_type('i4', 'c8')\n    dtype('complex128')\n\n    >>> np.result_type(3.0, -2)\n    dtype('float64')\n\n    \"\"\"\n    return arrays_and_dtypes\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.dot)\ndef dot(a, b, out=None):\n    \"\"\"\n    dot(a, b, out=None)\n\n    Dot product of two arrays. Specifically,\n\n    - If both `a` and `b` are 1-D arrays, it is inner product of vectors\n      (without complex conjugation).\n\n    - If both `a` and `b` are 2-D arrays, it is matrix multiplication,\n      but using :func:`matmul` or ``a @ b`` is preferred.\n\n    - If either `a` or `b` is 0-D (scalar), it is equivalent to\n      :func:`multiply` and using ``numpy.multiply(a, b)`` or ``a * b`` is\n      preferred.\n\n    - If `a` is an N-D array and `b` is a 1-D array, it is a sum product over\n      the last axis of `a` and `b`.\n\n    - If `a` is an N-D array and `b` is an M-D array (where ``M>=2``), it is a\n      sum product over the last axis of `a` and the second-to-last axis of\n      `b`::\n\n        dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])\n\n    It uses an optimized BLAS library when possible (see `numpy.linalg`).\n\n    Parameters\n    ----------\n    a : array_like\n        First argument.\n    b : array_like\n        Second argument.\n    out : ndarray, optional\n        Output argument. This must have the exact kind that would be returned\n        if it was not used. In particular, it must have the right type, must be\n        C-contiguous, and its dtype must be the dtype that would be returned\n        for `dot(a,b)`. This is a performance feature. Therefore, if these\n        conditions are not met, an exception is raised, instead of attempting\n        to be flexible.\n\n    Returns\n    -------\n    output : ndarray\n        Returns the dot product of `a` and `b`.  If `a` and `b` are both\n        scalars or both 1-D arrays then a scalar is returned; otherwise\n        an array is returned.\n        If `out` is given, then it is returned.\n\n    Raises\n    ------\n    ValueError\n        If the last dimension of `a` is not the same size as\n        the second-to-last dimension of `b`.\n\n    See Also\n    --------\n    vdot : Complex-conjugating dot product.\n    vecdot : Vector dot product of two arrays.\n    tensordot : Sum products over arbitrary axes.\n    einsum : Einstein summation convention.\n    matmul : '@' operator as method with out parameter.\n    linalg.multi_dot : Chained dot product.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.dot(3, 4)\n    12\n\n    Neither argument is complex-conjugated:\n\n    >>> np.dot([2j, 3j], [2j, 3j])\n    (-13+0j)\n\n    For 2-D arrays it is the matrix product:\n\n    >>> a = [[1, 0], [0, 1]]\n    >>> b = [[4, 1], [2, 2]]\n    >>> np.dot(a, b)\n    array([[4, 1],\n           [2, 2]])\n\n    >>> a = np.arange(3*4*5*6).reshape((3,4,5,6))\n    >>> b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))\n    >>> np.dot(a, b)[2,3,2,1,2,2]\n    499128\n    >>> sum(a[2,3,2,:] * b[1,2,:,2])\n    499128\n\n    \"\"\"\n    return (a, b, out)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.vdot)\ndef vdot(a, b):\n    r\"\"\"\n    vdot(a, b, /)\n\n    Return the dot product of two vectors.\n\n    The `vdot` function handles complex numbers differently than `dot`:\n    if the first argument is complex, it is replaced by its complex conjugate\n    in the dot product calculation. `vdot` also handles multidimensional\n    arrays differently than `dot`: it does not perform a matrix product, but\n    flattens the arguments to 1-D arrays before taking a vector dot product.\n\n    Consequently, when the arguments are 2-D arrays of the same shape, this\n    function effectively returns their\n    `Frobenius inner product <https://en.wikipedia.org/wiki/Frobenius_inner_product>`_\n    (also known as the *trace inner product* or the *standard inner product*\n    on a vector space of matrices).\n\n    Parameters\n    ----------\n    a : array_like\n        If `a` is complex the complex conjugate is taken before calculation\n        of the dot product.\n    b : array_like\n        Second argument to the dot product.\n\n    Returns\n    -------\n    output : ndarray\n        Dot product of `a` and `b`.  Can be an int, float, or\n        complex depending on the types of `a` and `b`.\n\n    See Also\n    --------\n    dot : Return the dot product without using the complex conjugate of the\n          first argument.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([1+2j,3+4j])\n    >>> b = np.array([5+6j,7+8j])\n    >>> np.vdot(a, b)\n    (70-8j)\n    >>> np.vdot(b, a)\n    (70+8j)\n\n    Note that higher-dimensional arrays are flattened!\n\n    >>> a = np.array([[1, 4], [5, 6]])\n    >>> b = np.array([[4, 1], [2, 2]])\n    >>> np.vdot(a, b)\n    30\n    >>> np.vdot(b, a)\n    30\n    >>> 1*4 + 4*1 + 5*2 + 6*2\n    30\n\n    \"\"\"  # noqa: E501\n    return (a, b)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.bincount)\ndef bincount(x, weights=None, minlength=None):\n    \"\"\"\n    bincount(x, /, weights=None, minlength=0)\n\n    Count number of occurrences of each value in array of non-negative ints.\n\n    The number of bins (of size 1) is one larger than the largest value in\n    `x`. If `minlength` is specified, there will be at least this number\n    of bins in the output array (though it will be longer if necessary,\n    depending on the contents of `x`).\n    Each bin gives the number of occurrences of its index value in `x`.\n    If `weights` is specified the input array is weighted by it, i.e. if a\n    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead\n    of ``out[n] += 1``.\n\n    Parameters\n    ----------\n    x : array_like, 1 dimension, nonnegative ints\n        Input array.\n    weights : array_like, optional\n        Weights, array of the same shape as `x`.\n    minlength : int, optional\n        A minimum number of bins for the output array.\n\n    Returns\n    -------\n    out : ndarray of ints\n        The result of binning the input array.\n        The length of `out` is equal to ``np.amax(x)+1``.\n\n    Raises\n    ------\n    ValueError\n        If the input is not 1-dimensional, or contains elements with negative\n        values, or if `minlength` is negative.\n    TypeError\n        If the type of the input is float or complex.\n\n    See Also\n    --------\n    histogram, digitize, unique\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.bincount(np.arange(5))\n    array([1, 1, 1, 1, 1])\n    >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\n    array([1, 3, 1, 1, 0, 0, 0, 1])\n\n    >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])\n    >>> np.bincount(x).size == np.amax(x)+1\n    True\n\n    The input array needs to be of integer dtype, otherwise a\n    TypeError is raised:\n\n    >>> np.bincount(np.arange(5, dtype=float))\n    Traceback (most recent call last):\n      ...\n    TypeError: Cannot cast array data from dtype('float64') to dtype('int64')\n    according to the rule 'safe'\n\n    A possible use of ``bincount`` is to perform sums over\n    variable-size chunks of an array, using the ``weights`` keyword.\n\n    >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights\n    >>> x = np.array([0, 1, 1, 2, 2, 2])\n    >>> np.bincount(x,  weights=w)\n    array([ 0.3,  0.7,  1.1])\n\n    \"\"\"\n    return (x, weights)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.ravel_multi_index)\ndef ravel_multi_index(multi_index, dims, mode=None, order=None):\n    \"\"\"\n    ravel_multi_index(multi_index, dims, mode='raise', order='C')\n\n    Converts a tuple of index arrays into an array of flat\n    indices, applying boundary modes to the multi-index.\n\n    Parameters\n    ----------\n    multi_index : tuple of array_like\n        A tuple of integer arrays, one array for each dimension.\n    dims : tuple of ints\n        The shape of array into which the indices from ``multi_index`` apply.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices are handled.  Can specify\n        either one mode or a tuple of modes, one mode per index.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        In 'clip' mode, a negative index which would normally\n        wrap will clip to 0 instead.\n    order : {'C', 'F'}, optional\n        Determines whether the multi-index should be viewed as\n        indexing in row-major (C-style) or column-major\n        (Fortran-style) order.\n\n    Returns\n    -------\n    raveled_indices : ndarray\n        An array of indices into the flattened version of an array\n        of dimensions ``dims``.\n\n    See Also\n    --------\n    unravel_index\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> arr = np.array([[3,6,6],[4,5,1]])\n    >>> np.ravel_multi_index(arr, (7,6))\n    array([22, 41, 37])\n    >>> np.ravel_multi_index(arr, (7,6), order='F')\n    array([31, 41, 13])\n    >>> np.ravel_multi_index(arr, (4,6), mode='clip')\n    array([22, 23, 19])\n    >>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))\n    array([12, 13, 13])\n\n    >>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))\n    1621\n    \"\"\"\n    return multi_index\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.unravel_index)\ndef unravel_index(indices, shape=None, order=None):\n    \"\"\"\n    unravel_index(indices, shape, order='C')\n\n    Converts a flat index or array of flat indices into a tuple\n    of coordinate arrays.\n\n    Parameters\n    ----------\n    indices : array_like\n        An integer array whose elements are indices into the flattened\n        version of an array of dimensions ``shape``. Before version 1.6.0,\n        this function accepted just one index value.\n    shape : tuple of ints\n        The shape of the array to use for unraveling ``indices``.\n    order : {'C', 'F'}, optional\n        Determines whether the indices should be viewed as indexing in\n        row-major (C-style) or column-major (Fortran-style) order.\n\n    Returns\n    -------\n    unraveled_coords : tuple of ndarray\n        Each array in the tuple has the same shape as the ``indices``\n        array.\n\n    See Also\n    --------\n    ravel_multi_index\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.unravel_index([22, 41, 37], (7,6))\n    (array([3, 6, 6]), array([4, 5, 1]))\n    >>> np.unravel_index([31, 41, 13], (7,6), order='F')\n    (array([3, 6, 6]), array([4, 5, 1]))\n\n    >>> np.unravel_index(1621, (6,7,8,9))\n    (3, 1, 4, 1)\n\n    \"\"\"\n    return (indices,)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.copyto)\ndef copyto(dst, src, casting=None, where=None):\n    \"\"\"\n    copyto(dst, src, casting='same_kind', where=True)\n\n    Copies values from one array to another, broadcasting as necessary.\n\n    Raises a TypeError if the `casting` rule is violated, and if\n    `where` is provided, it selects which elements to copy.\n\n    Parameters\n    ----------\n    dst : ndarray\n        The array into which values are copied.\n    src : array_like\n        The array from which values are copied.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur when copying.\n\n        * 'no' means the data types should not be cast at all.\n        * 'equiv' means only byte-order changes are allowed.\n        * 'safe' means only casts which can preserve values are allowed.\n        * 'same_kind' means only safe casts or casts within a kind,\n          like float64 to float32, are allowed.\n        * 'unsafe' means any data conversions may be done.\n    where : array_like of bool, optional\n        A boolean array which is broadcasted to match the dimensions\n        of `dst`, and selects elements to copy from `src` to `dst`\n        wherever it contains the value True.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> A = np.array([4, 5, 6])\n    >>> B = [1, 2, 3]\n    >>> np.copyto(A, B)\n    >>> A\n    array([1, 2, 3])\n\n    >>> A = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> B = [[4, 5, 6], [7, 8, 9]]\n    >>> np.copyto(A, B)\n    >>> A\n    array([[4, 5, 6],\n           [7, 8, 9]])\n\n    \"\"\"\n    return (dst, src, where)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.putmask)\ndef putmask(a, /, mask, values):\n    \"\"\"\n    putmask(a, mask, values)\n\n    Changes elements of an array based on conditional and input values.\n\n    Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.\n\n    If `values` is not the same size as `a` and `mask` then it will repeat.\n    This gives behavior different from ``a[mask] = values``.\n\n    Parameters\n    ----------\n    a : ndarray\n        Target array.\n    mask : array_like\n        Boolean mask array. It has to be the same shape as `a`.\n    values : array_like\n        Values to put into `a` where `mask` is True. If `values` is smaller\n        than `a` it will be repeated.\n\n    See Also\n    --------\n    place, put, take, copyto\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.arange(6).reshape(2, 3)\n    >>> np.putmask(x, x>2, x**2)\n    >>> x\n    array([[ 0,  1,  2],\n           [ 9, 16, 25]])\n\n    If `values` is smaller than `a` it is repeated:\n\n    >>> x = np.arange(5)\n    >>> np.putmask(x, x>1, [-33, -44])\n    >>> x\n    array([  0,   1, -33, -44, -33])\n\n    \"\"\"\n    return (a, mask, values)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.packbits)\ndef packbits(a, axis=None, bitorder='big'):\n    \"\"\"\n    packbits(a, /, axis=None, bitorder='big')\n\n    Packs the elements of a binary-valued array into bits in a uint8 array.\n\n    The result is padded to full bytes by inserting zero bits at the end.\n\n    Parameters\n    ----------\n    a : array_like\n        An array of integers or booleans whose elements should be packed to\n        bits.\n    axis : int, optional\n        The dimension over which bit-packing is done.\n        ``None`` implies packing the flattened array.\n    bitorder : {'big', 'little'}, optional\n        The order of the input bits. 'big' will mimic bin(val),\n        ``[0, 0, 0, 0, 0, 0, 1, 1] => 3 = 0b00000011``, 'little' will\n        reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] => 3``.\n        Defaults to 'big'.\n\n    Returns\n    -------\n    packed : ndarray\n        Array of type uint8 whose elements represent bits corresponding to the\n        logical (0 or nonzero) value of the input elements. The shape of\n        `packed` has the same number of dimensions as the input (unless `axis`\n        is None, in which case the output is 1-D).\n\n    See Also\n    --------\n    unpackbits: Unpacks elements of a uint8 array into a binary-valued output\n                array.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[[1,0,1],\n    ...                [0,1,0]],\n    ...               [[1,1,0],\n    ...                [0,0,1]]])\n    >>> b = np.packbits(a, axis=-1)\n    >>> b\n    array([[[160],\n            [ 64]],\n           [[192],\n            [ 32]]], dtype=uint8)\n\n    Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,\n    and 32 = 0010 0000.\n\n    \"\"\"\n    return (a,)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.unpackbits)\ndef unpackbits(a, axis=None, count=None, bitorder='big'):\n    \"\"\"\n    unpackbits(a, /, axis=None, count=None, bitorder='big')\n\n    Unpacks elements of a uint8 array into a binary-valued output array.\n\n    Each element of `a` represents a bit-field that should be unpacked\n    into a binary-valued output array. The shape of the output array is\n    either 1-D (if `axis` is ``None``) or the same shape as the input\n    array with unpacking done along the axis specified.\n\n    Parameters\n    ----------\n    a : ndarray, uint8 type\n       Input array.\n    axis : int, optional\n        The dimension over which bit-unpacking is done.\n        ``None`` implies unpacking the flattened array.\n    count : int or None, optional\n        The number of elements to unpack along `axis`, provided as a way\n        of undoing the effect of packing a size that is not a multiple\n        of eight. A non-negative number means to only unpack `count`\n        bits. A negative number means to trim off that many bits from\n        the end. ``None`` means to unpack the entire array (the\n        default). Counts larger than the available number of bits will\n        add zero padding to the output. Negative counts must not\n        exceed the available number of bits.\n    bitorder : {'big', 'little'}, optional\n        The order of the returned bits. 'big' will mimic bin(val),\n        ``3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1]``, 'little' will reverse\n        the order to ``[1, 1, 0, 0, 0, 0, 0, 0]``.\n        Defaults to 'big'.\n\n    Returns\n    -------\n    unpacked : ndarray, uint8 type\n       The elements are binary-valued (0 or 1).\n\n    See Also\n    --------\n    packbits : Packs the elements of a binary-valued array into bits in\n               a uint8 array.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a = np.array([[2], [7], [23]], dtype=np.uint8)\n    >>> a\n    array([[ 2],\n           [ 7],\n           [23]], dtype=uint8)\n    >>> b = np.unpackbits(a, axis=1)\n    >>> b\n    array([[0, 0, 0, 0, 0, 0, 1, 0],\n           [0, 0, 0, 0, 0, 1, 1, 1],\n           [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\n    >>> c = np.unpackbits(a, axis=1, count=-3)\n    >>> c\n    array([[0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0],\n           [0, 0, 0, 1, 0]], dtype=uint8)\n\n    >>> p = np.packbits(b, axis=0)\n    >>> np.unpackbits(p, axis=0)\n    array([[0, 0, 0, 0, 0, 0, 1, 0],\n           [0, 0, 0, 0, 0, 1, 1, 1],\n           [0, 0, 0, 1, 0, 1, 1, 1],\n           [0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)\n    >>> np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))\n    True\n\n    \"\"\"\n    return (a,)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.shares_memory)\ndef shares_memory(a, b, max_work=None):\n    \"\"\"\n    shares_memory(a, b, /, max_work=None)\n\n    Determine if two arrays share memory.\n\n    .. warning::\n\n       This function can be exponentially slow for some inputs, unless\n       `max_work` is set to zero or a positive integer.\n       If in doubt, use `numpy.may_share_memory` instead.\n\n    Parameters\n    ----------\n    a, b : ndarray\n        Input arrays\n    max_work : int, optional\n        Effort to spend on solving the overlap problem (maximum number\n        of candidate solutions to consider). The following special\n        values are recognized:\n\n        max_work=-1 (default)\n            The problem is solved exactly. In this case, the function returns\n            True only if there is an element shared between the arrays. Finding\n            the exact solution may take extremely long in some cases.\n        max_work=0\n            Only the memory bounds of a and b are checked.\n            This is equivalent to using ``may_share_memory()``.\n\n    Raises\n    ------\n    numpy.exceptions.TooHardError\n        Exceeded max_work.\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    may_share_memory\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.array([1, 2, 3, 4])\n    >>> np.shares_memory(x, np.array([5, 6, 7]))\n    False\n    >>> np.shares_memory(x[::2], x)\n    True\n    >>> np.shares_memory(x[::2], x[1::2])\n    False\n\n    Checking whether two arrays share memory is NP-complete, and\n    runtime may increase exponentially in the number of\n    dimensions. Hence, `max_work` should generally be set to a finite\n    number, as it is possible to construct examples that take\n    extremely long to run:\n\n    >>> from numpy.lib.stride_tricks import as_strided\n    >>> x = np.zeros([192163377], dtype=np.int8)\n    >>> x1 = as_strided(\n    ...     x, strides=(36674, 61119, 85569), shape=(1049, 1049, 1049))\n    >>> x2 = as_strided(\n    ...     x[64023025:], strides=(12223, 12224, 1), shape=(1049, 1049, 1))\n    >>> np.shares_memory(x1, x2, max_work=1000)\n    Traceback (most recent call last):\n    ...\n    numpy.exceptions.TooHardError: Exceeded max_work\n\n    Running ``np.shares_memory(x1, x2)`` without `max_work` set takes\n    around 1 minute for this case. It is possible to find problems\n    that take still significantly longer.\n\n    \"\"\"\n    return (a, b)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.may_share_memory)\ndef may_share_memory(a, b, max_work=None):\n    \"\"\"\n    may_share_memory(a, b, /, max_work=None)\n\n    Determine if two arrays might share memory\n\n    A return of True does not necessarily mean that the two arrays\n    share any element.  It just means that they *might*.\n\n    Only the memory bounds of a and b are checked by default.\n\n    Parameters\n    ----------\n    a, b : ndarray\n        Input arrays\n    max_work : int, optional\n        Effort to spend on solving the overlap problem.  See\n        `shares_memory` for details.  Default for ``may_share_memory``\n        is to do a bounds check.\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    shares_memory\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\n    False\n    >>> x = np.zeros([3, 4])\n    >>> np.may_share_memory(x[:,0], x[:,1])\n    True\n\n    \"\"\"\n    return (a, b)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.is_busday)\ndef is_busday(dates, weekmask=None, holidays=None, busdaycal=None, out=None):\n    \"\"\"\n    is_busday(\n        dates,\n        weekmask='1111100',\n        holidays=None,\n        busdaycal=None,\n        out=None\n    )\n\n    Calculates which of the given dates are valid days, and which are not.\n\n    Parameters\n    ----------\n    dates : array_like of datetime64[D]\n        The array of dates to process.\n    weekmask : str or array_like of bool, optional\n        A seven-element array indicating which of Monday through Sunday are\n        valid days. May be specified as a length-seven list or array, like\n        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string\n        like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for\n        weekdays, optionally separated by white space. Valid abbreviations\n        are: Mon Tue Wed Thu Fri Sat Sun\n    holidays : array_like of datetime64[D], optional\n        An array of dates to consider as invalid dates.  They may be\n        specified in any order, and NaT (not-a-time) dates are ignored.\n        This list is saved in a normalized form that is suited for\n        fast calculations of valid days.\n    busdaycal : busdaycalendar, optional\n        A `busdaycalendar` object which specifies the valid days. If this\n        parameter is provided, neither weekmask nor holidays may be\n        provided.\n    out : array of bool, optional\n        If provided, this array is filled with the result.\n\n    Returns\n    -------\n    out : array of bool\n        An array with the same shape as ``dates``, containing True for\n        each valid day, and False for each invalid day.\n\n    See Also\n    --------\n    busdaycalendar : An object that specifies a custom set of valid days.\n    busday_offset : Applies an offset counted in valid days.\n    busday_count : Counts how many valid days are in a half-open date range.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> # The weekdays are Friday, Saturday, and Monday\n    ... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],\n    ...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\n    array([False, False,  True])\n    \"\"\"\n    return (dates, weekmask, holidays, out)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.busday_offset)\ndef busday_offset(dates, offsets, roll=None, weekmask=None, holidays=None,\n                  busdaycal=None, out=None):\n    \"\"\"\n    busday_offset(\n        dates,\n        offsets,\n        roll='raise',\n        weekmask='1111100',\n        holidays=None,\n        busdaycal=None,\n        out=None\n    )\n\n    First adjusts the date to fall on a valid day according to\n    the ``roll`` rule, then applies offsets to the given dates\n    counted in valid days.\n\n    Parameters\n    ----------\n    dates : array_like of datetime64[D]\n        The array of dates to process.\n    offsets : array_like of int\n        The array of offsets, which is broadcast with ``dates``.\n    roll : {'raise', 'nat', 'forward', 'following', 'backward', 'preceding', \\\n        'modifiedfollowing', 'modifiedpreceding'}, optional\n        How to treat dates that do not fall on a valid day. The default\n        is 'raise'.\n\n        * 'raise' means to raise an exception for an invalid day.\n        * 'nat' means to return a NaT (not-a-time) for an invalid day.\n        * 'forward' and 'following' mean to take the first valid day\n          later in time.\n        * 'backward' and 'preceding' mean to take the first valid day\n          earlier in time.\n        * 'modifiedfollowing' means to take the first valid day\n          later in time unless it is across a Month boundary, in which\n          case to take the first valid day earlier in time.\n        * 'modifiedpreceding' means to take the first valid day\n          earlier in time unless it is across a Month boundary, in which\n          case to take the first valid day later in time.\n    weekmask : str or array_like of bool, optional\n        A seven-element array indicating which of Monday through Sunday are\n        valid days. May be specified as a length-seven list or array, like\n        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string\n        like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for\n        weekdays, optionally separated by white space. Valid abbreviations\n        are: Mon Tue Wed Thu Fri Sat Sun\n    holidays : array_like of datetime64[D], optional\n        An array of dates to consider as invalid dates.  They may be\n        specified in any order, and NaT (not-a-time) dates are ignored.\n        This list is saved in a normalized form that is suited for\n        fast calculations of valid days.\n    busdaycal : busdaycalendar, optional\n        A `busdaycalendar` object which specifies the valid days. If this\n        parameter is provided, neither weekmask nor holidays may be\n        provided.\n    out : array of datetime64[D], optional\n        If provided, this array is filled with the result.\n\n    Returns\n    -------\n    out : array of datetime64[D]\n        An array with a shape from broadcasting ``dates`` and ``offsets``\n        together, containing the dates with offsets applied.\n\n    See Also\n    --------\n    busdaycalendar : An object that specifies a custom set of valid days.\n    is_busday : Returns a boolean array indicating valid days.\n    busday_count : Counts how many valid days are in a half-open date range.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> # First business day in October 2011 (not accounting for holidays)\n    ... np.busday_offset('2011-10', 0, roll='forward')\n    np.datetime64('2011-10-03')\n    >>> # Last business day in February 2012 (not accounting for holidays)\n    ... np.busday_offset('2012-03', -1, roll='forward')\n    np.datetime64('2012-02-29')\n    >>> # Third Wednesday in January 2011\n    ... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')\n    np.datetime64('2011-01-19')\n    >>> # 2012 Mother's Day in Canada and the U.S.\n    ... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')\n    np.datetime64('2012-05-13')\n\n    >>> # First business day on or after a date\n    ... np.busday_offset('2011-03-20', 0, roll='forward')\n    np.datetime64('2011-03-21')\n    >>> np.busday_offset('2011-03-22', 0, roll='forward')\n    np.datetime64('2011-03-22')\n    >>> # First business day after a date\n    ... np.busday_offset('2011-03-20', 1, roll='backward')\n    np.datetime64('2011-03-21')\n    >>> np.busday_offset('2011-03-22', 1, roll='backward')\n    np.datetime64('2011-03-23')\n    \"\"\"\n    return (dates, offsets, weekmask, holidays, out)\n\n\n@array_function_from_c_func_and_dispatcher(_multiarray_umath.busday_count)\ndef busday_count(begindates, enddates, weekmask=None, holidays=None,\n                 busdaycal=None, out=None):\n    \"\"\"\n    busday_count(\n        begindates,\n        enddates,\n        weekmask='1111100',\n        holidays=[],\n        busdaycal=None,\n        out=None\n    )\n\n    Counts the number of valid days between `begindates` and\n    `enddates`, not including the day of `enddates`.\n\n    If ``enddates`` specifies a date value that is earlier than the\n    corresponding ``begindates`` date value, the count will be negative.\n\n    Parameters\n    ----------\n    begindates : array_like of datetime64[D]\n        The array of the first dates for counting.\n    enddates : array_like of datetime64[D]\n        The array of the end dates for counting, which are excluded\n        from the count themselves.\n    weekmask : str or array_like of bool, optional\n        A seven-element array indicating which of Monday through Sunday are\n        valid days. May be specified as a length-seven list or array, like\n        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string\n        like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for\n        weekdays, optionally separated by white space. Valid abbreviations\n        are: Mon Tue Wed Thu Fri Sat Sun\n    holidays : array_like of datetime64[D], optional\n        An array of dates to consider as invalid dates.  They may be\n        specified in any order, and NaT (not-a-time) dates are ignored.\n        This list is saved in a normalized form that is suited for\n        fast calculations of valid days.\n    busdaycal : busdaycalendar, optional\n        A `busdaycalendar` object which specifies the valid days. If this\n        parameter is provided, neither weekmask nor holidays may be\n        provided.\n    out : array of int, optional\n        If provided, this array is filled with the result.\n\n    Returns\n    -------\n    out : array of int\n        An array with a shape from broadcasting ``begindates`` and ``enddates``\n        together, containing the number of valid days between\n        the begin and end dates.\n\n    See Also\n    --------\n    busdaycalendar : An object that specifies a custom set of valid days.\n    is_busday : Returns a boolean array indicating valid days.\n    busday_offset : Applies an offset counted in valid days.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> # Number of weekdays in January 2011\n    ... np.busday_count('2011-01', '2011-02')\n    21\n    >>> # Number of weekdays in 2011\n    >>> np.busday_count('2011', '2012')\n    260\n    >>> # Number of Saturdays in 2011\n    ... np.busday_count('2011', '2012', weekmask='Sat')\n    53\n    \"\"\"\n    return (begindates, enddates, weekmask, holidays, out)\n\n\n@array_function_from_c_func_and_dispatcher(\n    _multiarray_umath.datetime_as_string)\ndef datetime_as_string(arr, unit=None, timezone=None, casting=None):\n    \"\"\"\n    datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')\n\n    Convert an array of datetimes into an array of strings.\n\n    Parameters\n    ----------\n    arr : array_like of datetime64\n        The array of UTC timestamps to format.\n    unit : str\n        One of None, 'auto', or\n        a :ref:`datetime unit <arrays.dtypes.dateunits>`.\n    timezone : {'naive', 'UTC', 'local'} or tzinfo\n        Timezone information to use when displaying the datetime. If 'UTC',\n        end with a Z to indicate UTC time. If 'local', convert to the local\n        timezone first, and suffix with a +-#### timezone offset. If a tzinfo\n        object, then do as with 'local', but use the specified timezone.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}\n        Casting to allow when changing between datetime units.\n\n    Returns\n    -------\n    str_arr : ndarray\n        An array of strings the same shape as `arr`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> import pytz\n    >>> d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')\n    >>> d\n    array(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',\n           '2002-10-27T07:30'], dtype='datetime64[m]')\n\n    Setting the timezone to UTC shows the same information, but with a Z suffix\n\n    >>> np.datetime_as_string(d, timezone='UTC')\n    array(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',\n           '2002-10-27T07:30Z'], dtype='<U35')\n\n    Note that we picked datetimes that cross a DST boundary. Passing in a\n    ``pytz`` timezone object will print the appropriate offset\n\n    >>> np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))\n    array(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',\n           '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='<U39')\n\n    Passing in a unit will change the precision\n\n    >>> np.datetime_as_string(d, unit='h')\n    array(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],\n          dtype='<U32')\n    >>> np.datetime_as_string(d, unit='s')\n    array(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',\n           '2002-10-27T07:30:00'], dtype='<U38')\n\n    'casting' can be used to specify whether precision can be changed\n\n    >>> np.datetime_as_string(d, unit='h', casting='safe')\n    Traceback (most recent call last):\n        ...\n    TypeError: Cannot create a datetime string as units 'h' from a NumPy\n    datetime with units 'm' according to the rule 'safe'\n    \"\"\"\n    return (arr,)\n", 1754], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py": ["import re\nfrom contextlib import contextmanager\nimport functools\nimport operator\nimport warnings\nimport numbers\nfrom collections import namedtuple\nimport inspect\nimport math\nfrom typing import TypeAlias, TypeVar\n\nimport numpy as np\nfrom scipy._lib._array_api import array_namespace, is_numpy, xp_size\nfrom scipy._lib._docscrape import FunctionDoc, Parameter\n\n\nAxisError: type[Exception]\nComplexWarning: type[Warning]\nVisibleDeprecationWarning: type[Warning]\n\nif np.lib.NumpyVersion(np.__version__) >= '1.25.0':\n    from numpy.exceptions import (\n        AxisError, ComplexWarning, VisibleDeprecationWarning,\n        DTypePromotionError\n    )\nelse:\n    from numpy import (  # type: ignore[attr-defined, no-redef]\n        AxisError, ComplexWarning, VisibleDeprecationWarning  # noqa: F401\n    )\n    DTypePromotionError = TypeError  # type: ignore\n\nnp_long: type\nnp_ulong: type\n\nif np.lib.NumpyVersion(np.__version__) >= \"2.0.0.dev0\":\n    try:\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                \"ignore\",\n                r\".*In the future `np\\.long` will be defined as.*\",\n                FutureWarning,\n            )\n            np_long = np.long  # type: ignore[attr-defined]\n            np_ulong = np.ulong  # type: ignore[attr-defined]\n    except AttributeError:\n            np_long = np.int_\n            np_ulong = np.uint\nelse:\n    np_long = np.int_\n    np_ulong = np.uint\n\nIntNumber = int | np.integer\nDecimalNumber = float | np.floating | np.integer\n\ncopy_if_needed: bool | None\n\nif np.lib.NumpyVersion(np.__version__) >= \"2.0.0\":\n    copy_if_needed = None\nelif np.lib.NumpyVersion(np.__version__) < \"1.28.0\":\n    copy_if_needed = False\nelse:\n    # 2.0.0 dev versions, handle cases where copy may or may not exist\n    try:\n        np.array([1]).__array__(copy=None)  # type: ignore[call-overload]\n        copy_if_needed = None\n    except TypeError:\n        copy_if_needed = False\n\n\n_RNG: TypeAlias = np.random.Generator | np.random.RandomState\nSeedType: TypeAlias = IntNumber | _RNG | None\n\nGeneratorType = TypeVar(\"GeneratorType\", bound=_RNG)\n\n# Since Generator was introduced in numpy 1.17, the following condition is needed for\n# backward compatibility\ntry:\n    from numpy.random import Generator as Generator\nexcept ImportError:\n    class Generator:  # type: ignore[no-redef]\n        pass\n\n\ndef _lazywhere(cond, arrays, f, fillvalue=None, f2=None):\n    \"\"\"Return elements chosen from two possibilities depending on a condition\n\n    Equivalent to ``f(*arrays) if cond else fillvalue`` performed elementwise.\n\n    Parameters\n    ----------\n    cond : array\n        The condition (expressed as a boolean array).\n    arrays : tuple of array\n        Arguments to `f` (and `f2`). Must be broadcastable with `cond`.\n    f : callable\n        Where `cond` is True, output will be ``f(arr1[cond], arr2[cond], ...)``\n    fillvalue : object\n        If provided, value with which to fill output array where `cond` is\n        not True.\n    f2 : callable\n        If provided, output will be ``f2(arr1[cond], arr2[cond], ...)`` where\n        `cond` is not True.\n\n    Returns\n    -------\n    out : array\n        An array with elements from the output of `f` where `cond` is True\n        and `fillvalue` (or elements from the output of `f2`) elsewhere. The\n        returned array has data type determined by Type Promotion Rules\n        with the output of `f` and `fillvalue` (or the output of `f2`).\n\n    Notes\n    -----\n    ``xp.where(cond, x, fillvalue)`` requires explicitly forming `x` even where\n    `cond` is False. This function evaluates ``f(arr1[cond], arr2[cond], ...)``\n    onle where `cond` ``is True.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> a, b = np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8])\n    >>> def f(a, b):\n    ...     return a*b\n    >>> _lazywhere(a > 2, (a, b), f, np.nan)\n    array([ nan,  nan,  21.,  32.])\n\n    \"\"\"\n    xp = array_namespace(cond, *arrays)\n\n    if (f2 is fillvalue is None) or (f2 is not None and fillvalue is not None):\n        raise ValueError(\"Exactly one of `fillvalue` or `f2` must be given.\")\n\n    args = xp.broadcast_arrays(cond, *arrays)\n    bool_dtype = xp.asarray([True]).dtype  # numpy 1.xx doesn't have `bool`\n    cond, arrays = xp.astype(args[0], bool_dtype, copy=False), args[1:]\n\n    temp1 = xp.asarray(f(*(arr[cond] for arr in arrays)))\n\n    if f2 is None:\n        # If `fillvalue` is a Python scalar and we convert to `xp.asarray`, it gets the\n        # default `int` or `float` type of `xp`, so `result_type` could be wrong.\n        # `result_type` should/will handle mixed array/Python scalars;\n        # remove this special logic when it does.\n        if type(fillvalue) in {bool, int, float, complex}:\n            with np.errstate(invalid='ignore'):\n                dtype = (temp1 * fillvalue).dtype\n        else:\n           dtype = xp.result_type(temp1.dtype, fillvalue)\n        out = xp.full(cond.shape, dtype=dtype,\n                      fill_value=xp.asarray(fillvalue, dtype=dtype))\n    else:\n        ncond = ~cond\n        temp2 = xp.asarray(f2(*(arr[ncond] for arr in arrays)))\n        dtype = xp.result_type(temp1, temp2)\n        out = xp.empty(cond.shape, dtype=dtype)\n        out[ncond] = temp2\n\n    out[cond] = temp1\n\n    return out\n\n\ndef _lazyselect(condlist, choicelist, arrays, default=0):\n    \"\"\"\n    Mimic `np.select(condlist, choicelist)`.\n\n    Notice, it assumes that all `arrays` are of the same shape or can be\n    broadcasted together.\n\n    All functions in `choicelist` must accept array arguments in the order\n    given in `arrays` and must return an array of the same shape as broadcasted\n    `arrays`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.arange(6)\n    >>> np.select([x <3, x > 3], [x**2, x**3], default=0)\n    array([  0,   1,   4,   0,  64, 125])\n\n    >>> _lazyselect([x < 3, x > 3], [lambda x: x**2, lambda x: x**3], (x,))\n    array([   0.,    1.,    4.,   0.,   64.,  125.])\n\n    >>> a = -np.ones_like(x)\n    >>> _lazyselect([x < 3, x > 3],\n    ...             [lambda x, a: x**2, lambda x, a: a * x**3],\n    ...             (x, a), default=np.nan)\n    array([   0.,    1.,    4.,   nan,  -64., -125.])\n\n    \"\"\"\n    arrays = np.broadcast_arrays(*arrays)\n    tcode = np.mintypecode([a.dtype.char for a in arrays])\n    out = np.full(np.shape(arrays[0]), fill_value=default, dtype=tcode)\n    for func, cond in zip(choicelist, condlist):\n        if np.all(cond is False):\n            continue\n        cond, _ = np.broadcast_arrays(cond, arrays[0])\n        temp = tuple(np.extract(cond, arr) for arr in arrays)\n        np.place(out, cond, func(*temp))\n    return out\n\n\ndef _aligned_zeros(shape, dtype=float, order=\"C\", align=None):\n    \"\"\"Allocate a new ndarray with aligned memory.\n\n    Primary use case for this currently is working around a f2py issue\n    in NumPy 1.9.1, where dtype.alignment is such that np.zeros() does\n    not necessarily create arrays aligned up to it.\n\n    \"\"\"\n    dtype = np.dtype(dtype)\n    if align is None:\n        align = dtype.alignment\n    if not hasattr(shape, '__len__'):\n        shape = (shape,)\n    size = functools.reduce(operator.mul, shape) * dtype.itemsize\n    buf = np.empty(size + align + 1, np.uint8)\n    offset = buf.__array_interface__['data'][0] % align\n    if offset != 0:\n        offset = align - offset\n    # Note: slices producing 0-size arrays do not necessarily change\n    # data pointer --- so we use and allocate size+1\n    buf = buf[offset:offset+size+1][:-1]\n    data = np.ndarray(shape, dtype, buf, order=order)\n    data.fill(0)\n    return data\n\n\ndef _prune_array(array):\n    \"\"\"Return an array equivalent to the input array. If the input\n    array is a view of a much larger array, copy its contents to a\n    newly allocated array. Otherwise, return the input unchanged.\n    \"\"\"\n    if array.base is not None and array.size < array.base.size // 2:\n        return array.copy()\n    return array\n\n\ndef float_factorial(n: int) -> float:\n    \"\"\"Compute the factorial and return as a float\n\n    Returns infinity when result is too large for a double\n    \"\"\"\n    return float(math.factorial(n)) if n < 171 else np.inf\n\n\n_rng_desc = (\n    r\"\"\"If `rng` is passed by keyword, types other than `numpy.random.Generator` are\n    passed to `numpy.random.default_rng` to instantiate a ``Generator``.\n    If `rng` is already a ``Generator`` instance, then the provided instance is\n    used. Specify `rng` for repeatable function behavior.\n\n    If this argument is passed by position or `{old_name}` is passed by keyword,\n    legacy behavior for the argument `{old_name}` applies:\n\n    - If `{old_name}` is None (or `numpy.random`), the `numpy.random.RandomState`\n      singleton is used.\n    - If `{old_name}` is an int, a new ``RandomState`` instance is used,\n      seeded with `{old_name}`.\n    - If `{old_name}` is already a ``Generator`` or ``RandomState`` instance then\n      that instance is used.\n\n    .. versionchanged:: 1.15.0\n        As part of the `SPEC-007 <https://scientific-python.org/specs/spec-0007/>`_\n        transition from use of `numpy.random.RandomState` to\n        `numpy.random.Generator`, this keyword was changed from `{old_name}` to `rng`.\n        For an interim period, both keywords will continue to work, although only one\n        may be specified at a time. After the interim period, function calls using the\n        `{old_name}` keyword will emit warnings. The behavior of both `{old_name}` and\n        `rng` are outlined above, but only the `rng` keyword should be used in new code.\n        \"\"\"\n)\n\n\n# SPEC 7\ndef _transition_to_rng(old_name, *, position_num=None, end_version=None,\n                       replace_doc=True):\n    \"\"\"Example decorator to transition from old PRNG usage to new `rng` behavior\n\n    Suppose the decorator is applied to a function that used to accept parameter\n    `old_name='random_state'` either by keyword or as a positional argument at\n    `position_num=1`. At the time of application, the name of the argument in the\n    function signature is manually changed to the new name, `rng`. If positional\n    use was allowed before, this is not changed.*\n\n    - If the function is called with both `random_state` and `rng`, the decorator\n      raises an error.\n    - If `random_state` is provided as a keyword argument, the decorator passes\n      `random_state` to the function's `rng` argument as a keyword. If `end_version`\n      is specified, the decorator will emit a `DeprecationWarning` about the\n      deprecation of keyword `random_state`.\n    - If `random_state` is provided as a positional argument, the decorator passes\n      `random_state` to the function's `rng` argument by position. If `end_version`\n      is specified, the decorator will emit a `FutureWarning` about the changing\n      interpretation of the argument.\n    - If `rng` is provided as a keyword argument, the decorator validates `rng` using\n      `numpy.random.default_rng` before passing it to the function.\n    - If `end_version` is specified and neither `random_state` nor `rng` is provided\n      by the user, the decorator checks whether `np.random.seed` has been used to set\n      the global seed. If so, it emits a `FutureWarning`, noting that usage of\n      `numpy.random.seed` will eventually have no effect. Either way, the decorator\n      calls the function without explicitly passing the `rng` argument.\n\n    If `end_version` is specified, a user must pass `rng` as a keyword to avoid\n    warnings.\n\n    After the deprecation period, the decorator can be removed, and the function\n    can simply validate the `rng` argument by calling `np.random.default_rng(rng)`.\n\n    * A `FutureWarning` is emitted when the PRNG argument is used by\n      position. It indicates that the \"Hinsen principle\" (same\n      code yielding different results in two versions of the software)\n      will be violated, unless positional use is deprecated. Specifically:\n\n      - If `None` is passed by position and `np.random.seed` has been used,\n        the function will change from being seeded to being unseeded.\n      - If an integer is passed by position, the random stream will change.\n      - If `np.random` or an instance of `RandomState` is passed by position,\n        an error will be raised.\n\n      We suggest that projects consider deprecating positional use of\n      `random_state`/`rng` (i.e., change their function signatures to\n      ``def my_func(..., *, rng=None)``); that might not make sense\n      for all projects, so this SPEC does not make that\n      recommendation, neither does this decorator enforce it.\n\n    Parameters\n    ----------\n    old_name : str\n        The old name of the PRNG argument (e.g. `seed` or `random_state`).\n    position_num : int, optional\n        The (0-indexed) position of the old PRNG argument (if accepted by position).\n        Maintainers are welcome to eliminate this argument and use, for example,\n        `inspect`, if preferred.\n    end_version : str, optional\n        The full version number of the library when the behavior described in\n        `DeprecationWarning`s and `FutureWarning`s will take effect. If left\n        unspecified, no warnings will be emitted by the decorator.\n    replace_doc : bool, default: True\n        Whether the decorator should replace the documentation for parameter `rng` with\n        `_rng_desc` (defined above), which documents both new `rng` keyword behavior\n        and typical legacy `random_state`/`seed` behavior. If True, manually replace\n        the first paragraph of the function's old `random_state`/`seed` documentation\n        with the desired *final* `rng` documentation; this way, no changes to\n        documentation are needed when the decorator is removed. Documentation of `rng`\n        after the first blank line is preserved. Use False if the function's old\n        `random_state`/`seed` behavior does not match that described by `_rng_desc`.\n\n    \"\"\"\n    NEW_NAME = \"rng\"\n\n    cmn_msg = (\n        \"To silence this warning and ensure consistent behavior in SciPy \"\n        f\"{end_version}, control the RNG using argument `{NEW_NAME}`. Arguments passed \"\n        f\"to keyword `{NEW_NAME}` will be validated by `np.random.default_rng`, so the \"\n        \"behavior corresponding with a given value may change compared to use of \"\n        f\"`{old_name}`. For example, \"\n        \"1) `None` will result in unpredictable random numbers, \"\n        \"2) an integer will result in a different stream of random numbers, (with the \"\n        \"same distribution), and \"\n        \"3) `np.random` or `RandomState` instances will result in an error. \"\n        \"See the documentation of `default_rng` for more information.\"\n    )\n\n    def decorator(fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            # Determine how PRNG was passed\n            as_old_kwarg = old_name in kwargs\n            as_new_kwarg = NEW_NAME in kwargs\n            as_pos_arg = position_num is not None and len(args) >= position_num + 1\n            emit_warning = end_version is not None\n\n            # Can only specify PRNG one of the three ways\n            if int(as_old_kwarg) + int(as_new_kwarg) + int(as_pos_arg) > 1:\n                message = (\n                    f\"{fun.__name__}() got multiple values for \"\n                    f\"argument now known as `{NEW_NAME}`. Specify one of \"\n                    f\"`{NEW_NAME}` or `{old_name}`.\"\n                )\n                raise TypeError(message)\n\n            # Check whether global random state has been set\n            global_seed_set = np.random.mtrand._rand._bit_generator._seed_seq is None\n\n            if as_old_kwarg:  # warn about deprecated use of old kwarg\n                kwargs[NEW_NAME] = kwargs.pop(old_name)\n                if emit_warning:\n                    message = (\n                        f\"Use of keyword argument `{old_name}` is \"\n                        f\"deprecated and replaced by `{NEW_NAME}`.  \"\n                        f\"Support for `{old_name}` will be removed \"\n                        f\"in SciPy {end_version}. \"\n                    ) + cmn_msg\n                    warnings.warn(message, DeprecationWarning, stacklevel=2)\n\n            elif as_pos_arg:\n                # Warn about changing meaning of positional arg\n\n                # Note that this decorator does not deprecate positional use of the\n                # argument; it only warns that the behavior will change in the future.\n                # Simultaneously transitioning to keyword-only use is another option.\n\n                arg = args[position_num]\n                # If the argument is None and the global seed wasn't set, or if the\n                # argument is one of a few new classes, the user will not notice change\n                # in behavior.\n                ok_classes = (\n                    np.random.Generator,\n                    np.random.SeedSequence,\n                    np.random.BitGenerator,\n                )\n                if (arg is None and not global_seed_set) or isinstance(arg, ok_classes):\n                    pass\n                elif emit_warning:\n                    message = (\n                        f\"Positional use of `{NEW_NAME}` (formerly known as \"\n                        f\"`{old_name}`) is still allowed, but the behavior is \"\n                        \"changing: the argument will be normalized using \"\n                        f\"`np.random.default_rng` beginning in SciPy {end_version}, \"\n                        \"and the resulting `Generator` will be used to generate \"\n                        \"random numbers.\"\n                    ) + cmn_msg\n                    warnings.warn(message, FutureWarning, stacklevel=2)\n\n            elif as_new_kwarg:  # no warnings; this is the preferred use\n                # After the removal of the decorator, normalization with\n                # np.random.default_rng will be done inside the decorated function\n                kwargs[NEW_NAME] = np.random.default_rng(kwargs[NEW_NAME])\n\n            elif global_seed_set and emit_warning:\n                # Emit FutureWarning if `np.random.seed` was used and no PRNG was passed\n                message = (\n                    \"The NumPy global RNG was seeded by calling \"\n                    f\"`np.random.seed`. Beginning in {end_version}, this \"\n                    \"function will no longer use the global RNG.\"\n                ) + cmn_msg\n                warnings.warn(message, FutureWarning, stacklevel=2)\n\n            return fun(*args, **kwargs)\n\n        if replace_doc:\n            doc = FunctionDoc(wrapper)\n            parameter_names = [param.name for param in doc['Parameters']]\n            if 'rng' in parameter_names:\n                _type = \"{None, int, `numpy.random.Generator`}, optional\"\n                _desc = _rng_desc.replace(\"{old_name}\", old_name)\n                old_doc = doc['Parameters'][parameter_names.index('rng')].desc\n                old_doc_keep = old_doc[old_doc.index(\"\") + 1:] if \"\" in old_doc else []\n                new_doc = [_desc] + old_doc_keep\n                _rng_parameter_doc = Parameter('rng', _type, new_doc)\n                doc['Parameters'][parameter_names.index('rng')] = _rng_parameter_doc\n                doc = str(doc).split(\"\\n\", 1)[1]  # remove signature\n                wrapper.__doc__ = str(doc)\n        return wrapper\n\n    return decorator\n\n\n# copy-pasted from scikit-learn utils/validation.py\ndef check_random_state(seed):\n    \"\"\"Turn `seed` into a `np.random.RandomState` instance.\n\n    Parameters\n    ----------\n    seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional\n        If `seed` is None (or `np.random`), the `numpy.random.RandomState`\n        singleton is used.\n        If `seed` is an int, a new ``RandomState`` instance is used,\n        seeded with `seed`.\n        If `seed` is already a ``Generator`` or ``RandomState`` instance then\n        that instance is used.\n\n    Returns\n    -------\n    seed : {`numpy.random.Generator`, `numpy.random.RandomState`}\n        Random number generator.\n\n    \"\"\"\n    if seed is None or seed is np.random:\n        return np.random.mtrand._rand\n    if isinstance(seed, numbers.Integral | np.integer):\n        return np.random.RandomState(seed)\n    if isinstance(seed, np.random.RandomState | np.random.Generator):\n        return seed\n\n    raise ValueError(f\"'{seed}' cannot be used to seed a numpy.random.RandomState\"\n                     \" instance\")\n\n\ndef _asarray_validated(a, check_finite=True,\n                       sparse_ok=False, objects_ok=False, mask_ok=False,\n                       as_inexact=False):\n    \"\"\"\n    Helper function for SciPy argument validation.\n\n    Many SciPy linear algebra functions do support arbitrary array-like\n    input arguments. Examples of commonly unsupported inputs include\n    matrices containing inf/nan, sparse matrix representations, and\n    matrices with complicated elements.\n\n    Parameters\n    ----------\n    a : array_like\n        The array-like input.\n    check_finite : bool, optional\n        Whether to check that the input matrices contain only finite numbers.\n        Disabling may give a performance gain, but may result in problems\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\n        Default: True\n    sparse_ok : bool, optional\n        True if scipy sparse matrices are allowed.\n    objects_ok : bool, optional\n        True if arrays with dype('O') are allowed.\n    mask_ok : bool, optional\n        True if masked arrays are allowed.\n    as_inexact : bool, optional\n        True to convert the input array to a np.inexact dtype.\n\n    Returns\n    -------\n    ret : ndarray\n        The converted validated array.\n\n    \"\"\"\n    if not sparse_ok:\n        import scipy.sparse\n        if scipy.sparse.issparse(a):\n            msg = ('Sparse arrays/matrices are not supported by this function. '\n                   'Perhaps one of the `scipy.sparse.linalg` functions '\n                   'would work instead.')\n            raise ValueError(msg)\n    if not mask_ok:\n        if np.ma.isMaskedArray(a):\n            raise ValueError('masked arrays are not supported')\n    toarray = np.asarray_chkfinite if check_finite else np.asarray\n    a = toarray(a)\n    if not objects_ok:\n        if a.dtype is np.dtype('O'):\n            raise ValueError('object arrays are not supported')\n    if as_inexact:\n        if not np.issubdtype(a.dtype, np.inexact):\n            a = toarray(a, dtype=np.float64)\n    return a\n\n\ndef _validate_int(k, name, minimum=None):\n    \"\"\"\n    Validate a scalar integer.\n\n    This function can be used to validate an argument to a function\n    that expects the value to be an integer.  It uses `operator.index`\n    to validate the value (so, for example, k=2.0 results in a\n    TypeError).\n\n    Parameters\n    ----------\n    k : int\n        The value to be validated.\n    name : str\n        The name of the parameter.\n    minimum : int, optional\n        An optional lower bound.\n    \"\"\"\n    try:\n        k = operator.index(k)\n    except TypeError:\n        raise TypeError(f'{name} must be an integer.') from None\n    if minimum is not None and k < minimum:\n        raise ValueError(f'{name} must be an integer not less '\n                         f'than {minimum}') from None\n    return k\n\n\n# Add a replacement for inspect.getfullargspec()/\n# The version below is borrowed from Django,\n# https://github.com/django/django/pull/4846.\n\n# Note an inconsistency between inspect.getfullargspec(func) and\n# inspect.signature(func). If `func` is a bound method, the latter does *not*\n# list `self` as a first argument, while the former *does*.\n# Hence, cook up a common ground replacement: `getfullargspec_no_self` which\n# mimics `inspect.getfullargspec` but does not list `self`.\n#\n# This way, the caller code does not need to know whether it uses a legacy\n# .getfullargspec or a bright and shiny .signature.\n\nFullArgSpec = namedtuple('FullArgSpec',\n                         ['args', 'varargs', 'varkw', 'defaults',\n                          'kwonlyargs', 'kwonlydefaults', 'annotations'])\n\n\ndef getfullargspec_no_self(func):\n    \"\"\"inspect.getfullargspec replacement using inspect.signature.\n\n    If func is a bound method, do not list the 'self' parameter.\n\n    Parameters\n    ----------\n    func : callable\n        A callable to inspect\n\n    Returns\n    -------\n    fullargspec : FullArgSpec(args, varargs, varkw, defaults, kwonlyargs,\n                              kwonlydefaults, annotations)\n\n        NOTE: if the first argument of `func` is self, it is *not*, I repeat\n        *not*, included in fullargspec.args.\n        This is done for consistency between inspect.getargspec() under\n        Python 2.x, and inspect.signature() under Python 3.x.\n\n    \"\"\"\n    sig = inspect.signature(func)\n    args = [\n        p.name for p in sig.parameters.values()\n        if p.kind in [inspect.Parameter.POSITIONAL_OR_KEYWORD,\n                      inspect.Parameter.POSITIONAL_ONLY]\n    ]\n    varargs = [\n        p.name for p in sig.parameters.values()\n        if p.kind == inspect.Parameter.VAR_POSITIONAL\n    ]\n    varargs = varargs[0] if varargs else None\n    varkw = [\n        p.name for p in sig.parameters.values()\n        if p.kind == inspect.Parameter.VAR_KEYWORD\n    ]\n    varkw = varkw[0] if varkw else None\n    defaults = tuple(\n        p.default for p in sig.parameters.values()\n        if (p.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD and\n            p.default is not p.empty)\n    ) or None\n    kwonlyargs = [\n        p.name for p in sig.parameters.values()\n        if p.kind == inspect.Parameter.KEYWORD_ONLY\n    ]\n    kwdefaults = {p.name: p.default for p in sig.parameters.values()\n                  if p.kind == inspect.Parameter.KEYWORD_ONLY and\n                  p.default is not p.empty}\n    annotations = {p.name: p.annotation for p in sig.parameters.values()\n                   if p.annotation is not p.empty}\n    return FullArgSpec(args, varargs, varkw, defaults, kwonlyargs,\n                       kwdefaults or None, annotations)\n\n\nclass _FunctionWrapper:\n    \"\"\"\n    Object to wrap user's function, allowing picklability\n    \"\"\"\n    def __init__(self, f, args):\n        self.f = f\n        self.args = [] if args is None else args\n\n    def __call__(self, x):\n        return self.f(x, *self.args)\n\n\nclass MapWrapper:\n    \"\"\"\n    Parallelisation wrapper for working with map-like callables, such as\n    `multiprocessing.Pool.map`.\n\n    Parameters\n    ----------\n    pool : int or map-like callable\n        If `pool` is an integer, then it specifies the number of threads to\n        use for parallelization. If ``int(pool) == 1``, then no parallel\n        processing is used and the map builtin is used.\n        If ``pool == -1``, then the pool will utilize all available CPUs.\n        If `pool` is a map-like callable that follows the same\n        calling sequence as the built-in map function, then this callable is\n        used for parallelization.\n    \"\"\"\n    def __init__(self, pool=1):\n        self.pool = None\n        self._mapfunc = map\n        self._own_pool = False\n\n        if callable(pool):\n            self.pool = pool\n            self._mapfunc = self.pool\n        else:\n            from multiprocessing import Pool\n            # user supplies a number\n            if int(pool) == -1:\n                # use as many processors as possible\n                self.pool = Pool()\n                self._mapfunc = self.pool.map\n                self._own_pool = True\n            elif int(pool) == 1:\n                pass\n            elif int(pool) > 1:\n                # use the number of processors requested\n                self.pool = Pool(processes=int(pool))\n                self._mapfunc = self.pool.map\n                self._own_pool = True\n            else:\n                raise RuntimeError(\"Number of workers specified must be -1,\"\n                                   \" an int >= 1, or an object with a 'map' \"\n                                   \"method\")\n\n    def __enter__(self):\n        return self\n\n    def terminate(self):\n        if self._own_pool:\n            self.pool.terminate()\n\n    def join(self):\n        if self._own_pool:\n            self.pool.join()\n\n    def close(self):\n        if self._own_pool:\n            self.pool.close()\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if self._own_pool:\n            self.pool.close()\n            self.pool.terminate()\n\n    def __call__(self, func, iterable):\n        # only accept one iterable because that's all Pool.map accepts\n        try:\n            return self._mapfunc(func, iterable)\n        except TypeError as e:\n            # wrong number of arguments\n            raise TypeError(\"The map-like callable must be of the\"\n                            \" form f(func, iterable)\") from e\n\n\ndef rng_integers(gen, low, high=None, size=None, dtype='int64',\n                 endpoint=False):\n    \"\"\"\n    Return random integers from low (inclusive) to high (exclusive), or if\n    endpoint=True, low (inclusive) to high (inclusive). Replaces\n    `RandomState.randint` (with endpoint=False) and\n    `RandomState.random_integers` (with endpoint=True).\n\n    Return random integers from the \"discrete uniform\" distribution of the\n    specified dtype. If high is None (the default), then results are from\n    0 to low.\n\n    Parameters\n    ----------\n    gen : {None, np.random.RandomState, np.random.Generator}\n        Random number generator. If None, then the np.random.RandomState\n        singleton is used.\n    low : int or array-like of ints\n        Lowest (signed) integers to be drawn from the distribution (unless\n        high=None, in which case this parameter is 0 and this value is used\n        for high).\n    high : int or array-like of ints\n        If provided, one above the largest (signed) integer to be drawn from\n        the distribution (see above for behavior if high=None). If array-like,\n        must contain integer values.\n    size : array-like of ints, optional\n        Output shape. If the given shape is, e.g., (m, n, k), then m * n * k\n        samples are drawn. Default is None, in which case a single value is\n        returned.\n    dtype : {str, dtype}, optional\n        Desired dtype of the result. All dtypes are determined by their name,\n        i.e., 'int64', 'int', etc, so byteorder is not available and a specific\n        precision may have different C types depending on the platform.\n        The default value is 'int64'.\n    endpoint : bool, optional\n        If True, sample from the interval [low, high] instead of the default\n        [low, high) Defaults to False.\n\n    Returns\n    -------\n    out: int or ndarray of ints\n        size-shaped array of random integers from the appropriate distribution,\n        or a single such random int if size not provided.\n    \"\"\"\n    if isinstance(gen, Generator):\n        return gen.integers(low, high=high, size=size, dtype=dtype,\n                            endpoint=endpoint)\n    else:\n        if gen is None:\n            # default is RandomState singleton used by np.random.\n            gen = np.random.mtrand._rand\n        if endpoint:\n            # inclusive of endpoint\n            # remember that low and high can be arrays, so don't modify in\n            # place\n            if high is None:\n                return gen.randint(low + 1, size=size, dtype=dtype)\n            if high is not None:\n                return gen.randint(low, high=high + 1, size=size, dtype=dtype)\n\n        # exclusive\n        return gen.randint(low, high=high, size=size, dtype=dtype)\n\n\n@contextmanager\ndef _fixed_default_rng(seed=1638083107694713882823079058616272161):\n    \"\"\"Context with a fixed np.random.default_rng seed.\"\"\"\n    orig_fun = np.random.default_rng\n    np.random.default_rng = lambda seed=seed: orig_fun(seed)\n    try:\n        yield\n    finally:\n        np.random.default_rng = orig_fun\n\n\ndef _rng_html_rewrite(func):\n    \"\"\"Rewrite the HTML rendering of ``np.random.default_rng``.\n\n    This is intended to decorate\n    ``numpydoc.docscrape_sphinx.SphinxDocString._str_examples``.\n\n    Examples are only run by Sphinx when there are plot involved. Even so,\n    it does not change the result values getting printed.\n    \"\"\"\n    # hexadecimal or number seed, case-insensitive\n    pattern = re.compile(r'np.random.default_rng\\((0x[0-9A-F]+|\\d+)\\)', re.I)\n\n    def _wrapped(*args, **kwargs):\n        res = func(*args, **kwargs)\n        lines = [\n            re.sub(pattern, 'np.random.default_rng()', line)\n            for line in res\n        ]\n        return lines\n\n    return _wrapped\n\n\ndef _argmin(a, keepdims=False, axis=None):\n    \"\"\"\n    argmin with a `keepdims` parameter.\n\n    See https://github.com/numpy/numpy/issues/8710\n\n    If axis is not None, a.shape[axis] must be greater than 0.\n    \"\"\"\n    res = np.argmin(a, axis=axis)\n    if keepdims and axis is not None:\n        res = np.expand_dims(res, axis=axis)\n    return res\n\n\ndef _first_nonnan(a, axis):\n    \"\"\"\n    Return the first non-nan value along the given axis.\n\n    If a slice is all nan, nan is returned for that slice.\n\n    The shape of the return value corresponds to ``keepdims=True``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> nan = np.nan\n    >>> a = np.array([[ 3.,  3., nan,  3.],\n                      [ 1., nan,  2.,  4.],\n                      [nan, nan,  9., -1.],\n                      [nan,  5.,  4.,  3.],\n                      [ 2.,  2.,  2.,  2.],\n                      [nan, nan, nan, nan]])\n    >>> _first_nonnan(a, axis=0)\n    array([[3., 3., 2., 3.]])\n    >>> _first_nonnan(a, axis=1)\n    array([[ 3.],\n           [ 1.],\n           [ 9.],\n           [ 5.],\n           [ 2.],\n           [nan]])\n    \"\"\"\n    k = _argmin(np.isnan(a), axis=axis, keepdims=True)\n    return np.take_along_axis(a, k, axis=axis)\n\n\ndef _nan_allsame(a, axis, keepdims=False):\n    \"\"\"\n    Determine if the values along an axis are all the same.\n\n    nan values are ignored.\n\n    `a` must be a numpy array.\n\n    `axis` is assumed to be normalized; that is, 0 <= axis < a.ndim.\n\n    For an axis of length 0, the result is True.  That is, we adopt the\n    convention that ``allsame([])`` is True. (There are no values in the\n    input that are different.)\n\n    `True` is returned for slices that are all nan--not because all the\n    values are the same, but because this is equivalent to ``allsame([])``.\n\n    Examples\n    --------\n    >>> from numpy import nan, array\n    >>> a = array([[ 3.,  3., nan,  3.],\n    ...            [ 1., nan,  2.,  4.],\n    ...            [nan, nan,  9., -1.],\n    ...            [nan,  5.,  4.,  3.],\n    ...            [ 2.,  2.,  2.,  2.],\n    ...            [nan, nan, nan, nan]])\n    >>> _nan_allsame(a, axis=1, keepdims=True)\n    array([[ True],\n           [False],\n           [False],\n           [False],\n           [ True],\n           [ True]])\n    \"\"\"\n    if axis is None:\n        if a.size == 0:\n            return True\n        a = a.ravel()\n        axis = 0\n    else:\n        shp = a.shape\n        if shp[axis] == 0:\n            shp = shp[:axis] + (1,)*keepdims + shp[axis + 1:]\n            return np.full(shp, fill_value=True, dtype=bool)\n    a0 = _first_nonnan(a, axis=axis)\n    return ((a0 == a) | np.isnan(a)).all(axis=axis, keepdims=keepdims)\n\n\ndef _contains_nan(a, nan_policy='propagate', policies=None, *,\n                  xp_omit_okay=False, xp=None):\n    # Regarding `xp_omit_okay`: Temporarily, while `_axis_nan_policy` does not\n    # handle non-NumPy arrays, most functions that call `_contains_nan` want\n    # it to raise an error if `nan_policy='omit'` and `xp` is not `np`.\n    # Some functions support `nan_policy='omit'` natively, so setting this to\n    # `True` prevents the error from being raised.\n    if xp is None:\n        xp = array_namespace(a)\n    not_numpy = not is_numpy(xp)\n\n    if policies is None:\n        policies = {'propagate', 'raise', 'omit'}\n    if nan_policy not in policies:\n        raise ValueError(f\"nan_policy must be one of {set(policies)}.\")\n\n    if xp_size(a) == 0:\n        contains_nan = False\n    elif xp.isdtype(a.dtype, \"real floating\"):\n        # Faster and less memory-intensive than xp.any(xp.isnan(a)), and unlike other\n        # reductions, `max`/`min` won't return NaN unless there is a NaN in the data.\n        contains_nan = xp.isnan(xp.max(a))\n    elif xp.isdtype(a.dtype, \"complex floating\"):\n        # Typically `real` and `imag` produce views; otherwise, `xp.any(xp.isnan(a))`\n        # would be more efficient.\n        contains_nan = xp.isnan(xp.max(xp.real(a))) | xp.isnan(xp.max(xp.imag(a)))\n    elif is_numpy(xp) and np.issubdtype(a.dtype, object):\n        contains_nan = False\n        for el in a.ravel():\n            # isnan doesn't work on non-numeric elements\n            if np.issubdtype(type(el), np.number) and np.isnan(el):\n                contains_nan = True\n                break\n    else:\n        # Only `object` and `inexact` arrays can have NaNs\n        contains_nan = False\n\n    if contains_nan and nan_policy == 'raise':\n        raise ValueError(\"The input contains nan values\")\n\n    if not xp_omit_okay and not_numpy and contains_nan and nan_policy=='omit':\n        message = \"`nan_policy='omit' is incompatible with non-NumPy arrays.\"\n        raise ValueError(message)\n\n    return contains_nan, nan_policy\n\n\ndef _rename_parameter(old_name, new_name, dep_version=None):\n    \"\"\"\n    Generate decorator for backward-compatible keyword renaming.\n\n    Apply the decorator generated by `_rename_parameter` to functions with a\n    recently renamed parameter to maintain backward-compatibility.\n\n    After decoration, the function behaves as follows:\n    If only the new parameter is passed into the function, behave as usual.\n    If only the old parameter is passed into the function (as a keyword), raise\n    a DeprecationWarning if `dep_version` is provided, and behave as usual\n    otherwise.\n    If both old and new parameters are passed into the function, raise a\n    DeprecationWarning if `dep_version` is provided, and raise the appropriate\n    TypeError (function got multiple values for argument).\n\n    Parameters\n    ----------\n    old_name : str\n        Old name of parameter\n    new_name : str\n        New name of parameter\n    dep_version : str, optional\n        Version of SciPy in which old parameter was deprecated in the format\n        'X.Y.Z'. If supplied, the deprecation message will indicate that\n        support for the old parameter will be removed in version 'X.Y+2.Z'\n\n    Notes\n    -----\n    Untested with functions that accept *args. Probably won't work as written.\n\n    \"\"\"\n    def decorator(fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            if old_name in kwargs:\n                if dep_version:\n                    end_version = dep_version.split('.')\n                    end_version[1] = str(int(end_version[1]) + 2)\n                    end_version = '.'.join(end_version)\n                    message = (f\"Use of keyword argument `{old_name}` is \"\n                               f\"deprecated and replaced by `{new_name}`.  \"\n                               f\"Support for `{old_name}` will be removed \"\n                               f\"in SciPy {end_version}.\")\n                    warnings.warn(message, DeprecationWarning, stacklevel=2)\n                if new_name in kwargs:\n                    message = (f\"{fun.__name__}() got multiple values for \"\n                               f\"argument now known as `{new_name}`\")\n                    raise TypeError(message)\n                kwargs[new_name] = kwargs.pop(old_name)\n            return fun(*args, **kwargs)\n        return wrapper\n    return decorator\n\n\ndef _rng_spawn(rng, n_children):\n    # spawns independent RNGs from a parent RNG\n    bg = rng._bit_generator\n    ss = bg._seed_seq\n    child_rngs = [np.random.Generator(type(bg)(child_ss))\n                  for child_ss in ss.spawn(n_children)]\n    return child_rngs\n\n\ndef _get_nan(*data, xp=None):\n    xp = array_namespace(*data) if xp is None else xp\n    # Get NaN of appropriate dtype for data\n    data = [xp.asarray(item) for item in data]\n    try:\n        min_float = getattr(xp, 'float16', xp.float32)\n        dtype = xp.result_type(*data, min_float)  # must be at least a float\n    except DTypePromotionError:\n        # fallback to float64\n        dtype = xp.float64\n    return xp.asarray(xp.nan, dtype=dtype)[()]\n\n\ndef normalize_axis_index(axis, ndim):\n    # Check if `axis` is in the correct range and normalize it\n    if axis < -ndim or axis >= ndim:\n        msg = f\"axis {axis} is out of bounds for array of dimension {ndim}\"\n        raise AxisError(msg)\n\n    if axis < 0:\n        axis = axis + ndim\n    return axis\n\n\ndef _call_callback_maybe_halt(callback, res):\n    \"\"\"Call wrapped callback; return True if algorithm should stop.\n\n    Parameters\n    ----------\n    callback : callable or None\n        A user-provided callback wrapped with `_wrap_callback`\n    res : OptimizeResult\n        Information about the current iterate\n\n    Returns\n    -------\n    halt : bool\n        True if minimization should stop\n\n    \"\"\"\n    if callback is None:\n        return False\n    try:\n        callback(res)\n        return False\n    except StopIteration:\n        callback.stop_iteration = True\n        return True\n\n\nclass _RichResult(dict):\n    \"\"\" Container for multiple outputs with pretty-printing \"\"\"\n    def __getattr__(self, name):\n        try:\n            return self[name]\n        except KeyError as e:\n            raise AttributeError(name) from e\n\n    __setattr__ = dict.__setitem__  # type: ignore[assignment]\n    __delattr__ = dict.__delitem__  # type: ignore[assignment]\n\n    def __repr__(self):\n        order_keys = ['message', 'success', 'status', 'fun', 'funl', 'x', 'xl',\n                      'col_ind', 'nit', 'lower', 'upper', 'eqlin', 'ineqlin',\n                      'converged', 'flag', 'function_calls', 'iterations',\n                      'root']\n        order_keys = getattr(self, '_order_keys', order_keys)\n        # 'slack', 'con' are redundant with residuals\n        # 'crossover_nit' is probably not interesting to most users\n        omit_keys = {'slack', 'con', 'crossover_nit', '_order_keys'}\n\n        def key(item):\n            try:\n                return order_keys.index(item[0].lower())\n            except ValueError:  # item not in list\n                return np.inf\n\n        def omit_redundant(items):\n            for item in items:\n                if item[0] in omit_keys:\n                    continue\n                yield item\n\n        def item_sorter(d):\n            return sorted(omit_redundant(d.items()), key=key)\n\n        if self.keys():\n            return _dict_formatter(self, sorter=item_sorter)\n        else:\n            return self.__class__.__name__ + \"()\"\n\n    def __dir__(self):\n        return list(self.keys())\n\n\ndef _indenter(s, n=0):\n    \"\"\"\n    Ensures that lines after the first are indented by the specified amount\n    \"\"\"\n    split = s.split(\"\\n\")\n    indent = \" \"*n\n    return (\"\\n\" + indent).join(split)\n\n\ndef _float_formatter_10(x):\n    \"\"\"\n    Returns a string representation of a float with exactly ten characters\n    \"\"\"\n    if np.isposinf(x):\n        return \"       inf\"\n    elif np.isneginf(x):\n        return \"      -inf\"\n    elif np.isnan(x):\n        return \"       nan\"\n    return np.format_float_scientific(x, precision=3, pad_left=2, unique=False)\n\n\ndef _dict_formatter(d, n=0, mplus=1, sorter=None):\n    \"\"\"\n    Pretty printer for dictionaries\n\n    `n` keeps track of the starting indentation;\n    lines are indented by this much after a line break.\n    `mplus` is additional left padding applied to keys\n    \"\"\"\n    if isinstance(d, dict):\n        m = max(map(len, list(d.keys()))) + mplus  # width to print keys\n        s = '\\n'.join([k.rjust(m) + ': ' +  # right justified, width m\n                       _indenter(_dict_formatter(v, m+n+2, 0, sorter), m+2)\n                       for k, v in sorter(d)])  # +2 for ': '\n    else:\n        # By default, NumPy arrays print with linewidth=76. `n` is\n        # the indent at which a line begins printing, so it is subtracted\n        # from the default to avoid exceeding 76 characters total.\n        # `edgeitems` is the number of elements to include before and after\n        # ellipses when arrays are not shown in full.\n        # `threshold` is the maximum number of elements for which an\n        # array is shown in full.\n        # These values tend to work well for use with OptimizeResult.\n        with np.printoptions(linewidth=76-n, edgeitems=2, threshold=12,\n                             formatter={'float_kind': _float_formatter_10}):\n            s = str(d)\n    return s\n", 1179], "/usr/lib/python3.11/contextlib.py": ["\"\"\"Utilities for with-statement contexts.  See PEP 343.\"\"\"\nimport abc\nimport os\nimport sys\nimport _collections_abc\nfrom collections import deque\nfrom functools import wraps\nfrom types import MethodType, GenericAlias\n\n__all__ = [\"asynccontextmanager\", \"contextmanager\", \"closing\", \"nullcontext\",\n           \"AbstractContextManager\", \"AbstractAsyncContextManager\",\n           \"AsyncExitStack\", \"ContextDecorator\", \"ExitStack\",\n           \"redirect_stdout\", \"redirect_stderr\", \"suppress\", \"aclosing\",\n           \"chdir\"]\n\n\nclass AbstractContextManager(abc.ABC):\n\n    \"\"\"An abstract base class for context managers.\"\"\"\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n    def __enter__(self):\n        \"\"\"Return `self` upon entering the runtime context.\"\"\"\n        return self\n\n    @abc.abstractmethod\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Raise any exception triggered within the runtime context.\"\"\"\n        return None\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AbstractContextManager:\n            return _collections_abc._check_methods(C, \"__enter__\", \"__exit__\")\n        return NotImplemented\n\n\nclass AbstractAsyncContextManager(abc.ABC):\n\n    \"\"\"An abstract base class for asynchronous context managers.\"\"\"\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n    async def __aenter__(self):\n        \"\"\"Return `self` upon entering the runtime context.\"\"\"\n        return self\n\n    @abc.abstractmethod\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        \"\"\"Raise any exception triggered within the runtime context.\"\"\"\n        return None\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AbstractAsyncContextManager:\n            return _collections_abc._check_methods(C, \"__aenter__\",\n                                                   \"__aexit__\")\n        return NotImplemented\n\n\nclass ContextDecorator(object):\n    \"A base class or mixin that enables context managers to work as decorators.\"\n\n    def _recreate_cm(self):\n        \"\"\"Return a recreated instance of self.\n\n        Allows an otherwise one-shot context manager like\n        _GeneratorContextManager to support use as\n        a decorator via implicit recreation.\n\n        This is a private interface just for _GeneratorContextManager.\n        See issue #11647 for details.\n        \"\"\"\n        return self\n\n    def __call__(self, func):\n        @wraps(func)\n        def inner(*args, **kwds):\n            with self._recreate_cm():\n                return func(*args, **kwds)\n        return inner\n\n\nclass AsyncContextDecorator(object):\n    \"A base class or mixin that enables async context managers to work as decorators.\"\n\n    def _recreate_cm(self):\n        \"\"\"Return a recreated instance of self.\n        \"\"\"\n        return self\n\n    def __call__(self, func):\n        @wraps(func)\n        async def inner(*args, **kwds):\n            async with self._recreate_cm():\n                return await func(*args, **kwds)\n        return inner\n\n\nclass _GeneratorContextManagerBase:\n    \"\"\"Shared functionality for @contextmanager and @asynccontextmanager.\"\"\"\n\n    def __init__(self, func, args, kwds):\n        self.gen = func(*args, **kwds)\n        self.func, self.args, self.kwds = func, args, kwds\n        # Issue 19330: ensure context manager instances have good docstrings\n        doc = getattr(func, \"__doc__\", None)\n        if doc is None:\n            doc = type(self).__doc__\n        self.__doc__ = doc\n        # Unfortunately, this still doesn't provide good help output when\n        # inspecting the created context manager instances, since pydoc\n        # currently bypasses the instance docstring and shows the docstring\n        # for the class instead.\n        # See http://bugs.python.org/issue19404 for more details.\n\n    def _recreate_cm(self):\n        # _GCMB instances are one-shot context managers, so the\n        # CM must be recreated each time a decorated function is\n        # called\n        return self.__class__(self.func, self.args, self.kwds)\n\n\nclass _GeneratorContextManager(\n    _GeneratorContextManagerBase,\n    AbstractContextManager,\n    ContextDecorator,\n):\n    \"\"\"Helper for @contextmanager decorator.\"\"\"\n\n    def __enter__(self):\n        # do not keep args and kwds alive unnecessarily\n        # they are only needed for recreation, which is not possible anymore\n        del self.args, self.kwds, self.func\n        try:\n            return next(self.gen)\n        except StopIteration:\n            raise RuntimeError(\"generator didn't yield\") from None\n\n    def __exit__(self, typ, value, traceback):\n        if typ is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                try:\n                    raise RuntimeError(\"generator didn't stop\")\n                finally:\n                    self.gen.close()\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = typ()\n            try:\n                self.gen.throw(typ, value, traceback)\n            except StopIteration as exc:\n                # Suppress StopIteration *unless* it's the same exception that\n                # was passed to throw().  This prevents a StopIteration\n                # raised inside the \"with\" statement from being suppressed.\n                return exc is not value\n            except RuntimeError as exc:\n                # Don't re-raise the passed in exception. (issue27122)\n                if exc is value:\n                    exc.__traceback__ = traceback\n                    return False\n                # Avoid suppressing if a StopIteration exception\n                # was passed to throw() and later wrapped into a RuntimeError\n                # (see PEP 479 for sync generators; async generators also\n                # have this behavior). But do this only if the exception wrapped\n                # by the RuntimeError is actually Stop(Async)Iteration (see\n                # issue29692).\n                if (\n                    isinstance(value, StopIteration)\n                    and exc.__cause__ is value\n                ):\n                    value.__traceback__ = traceback\n                    return False\n                raise\n            except BaseException as exc:\n                # only re-raise if it's *not* the exception that was\n                # passed to throw(), because __exit__() must not raise\n                # an exception unless __exit__() itself failed.  But throw()\n                # has to raise the exception to signal propagation, so this\n                # fixes the impedance mismatch between the throw() protocol\n                # and the __exit__() protocol.\n                if exc is not value:\n                    raise\n                exc.__traceback__ = traceback\n                return False\n            try:\n                raise RuntimeError(\"generator didn't stop after throw()\")\n            finally:\n                self.gen.close()\n\nclass _AsyncGeneratorContextManager(\n    _GeneratorContextManagerBase,\n    AbstractAsyncContextManager,\n    AsyncContextDecorator,\n):\n    \"\"\"Helper for @asynccontextmanager decorator.\"\"\"\n\n    async def __aenter__(self):\n        # do not keep args and kwds alive unnecessarily\n        # they are only needed for recreation, which is not possible anymore\n        del self.args, self.kwds, self.func\n        try:\n            return await anext(self.gen)\n        except StopAsyncIteration:\n            raise RuntimeError(\"generator didn't yield\") from None\n\n    async def __aexit__(self, typ, value, traceback):\n        if typ is None:\n            try:\n                await anext(self.gen)\n            except StopAsyncIteration:\n                return False\n            else:\n                try:\n                    raise RuntimeError(\"generator didn't stop\")\n                finally:\n                    await self.gen.aclose()\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = typ()\n            try:\n                await self.gen.athrow(typ, value, traceback)\n            except StopAsyncIteration as exc:\n                # Suppress StopIteration *unless* it's the same exception that\n                # was passed to throw().  This prevents a StopIteration\n                # raised inside the \"with\" statement from being suppressed.\n                return exc is not value\n            except RuntimeError as exc:\n                # Don't re-raise the passed in exception. (issue27122)\n                if exc is value:\n                    exc.__traceback__ = traceback\n                    return False\n                # Avoid suppressing if a Stop(Async)Iteration exception\n                # was passed to athrow() and later wrapped into a RuntimeError\n                # (see PEP 479 for sync generators; async generators also\n                # have this behavior). But do this only if the exception wrapped\n                # by the RuntimeError is actually Stop(Async)Iteration (see\n                # issue29692).\n                if (\n                    isinstance(value, (StopIteration, StopAsyncIteration))\n                    and exc.__cause__ is value\n                ):\n                    value.__traceback__ = traceback\n                    return False\n                raise\n            except BaseException as exc:\n                # only re-raise if it's *not* the exception that was\n                # passed to throw(), because __exit__() must not raise\n                # an exception unless __exit__() itself failed.  But throw()\n                # has to raise the exception to signal propagation, so this\n                # fixes the impedance mismatch between the throw() protocol\n                # and the __exit__() protocol.\n                if exc is not value:\n                    raise\n                exc.__traceback__ = traceback\n                return False\n            try:\n                raise RuntimeError(\"generator didn't stop after athrow()\")\n            finally:\n                await self.gen.aclose()\n\n\ndef contextmanager(func):\n    \"\"\"@contextmanager decorator.\n\n    Typical usage:\n\n        @contextmanager\n        def some_generator(<arguments>):\n            <setup>\n            try:\n                yield <value>\n            finally:\n                <cleanup>\n\n    This makes this:\n\n        with some_generator(<arguments>) as <variable>:\n            <body>\n\n    equivalent to this:\n\n        <setup>\n        try:\n            <variable> = <value>\n            <body>\n        finally:\n            <cleanup>\n    \"\"\"\n    @wraps(func)\n    def helper(*args, **kwds):\n        return _GeneratorContextManager(func, args, kwds)\n    return helper\n\n\ndef asynccontextmanager(func):\n    \"\"\"@asynccontextmanager decorator.\n\n    Typical usage:\n\n        @asynccontextmanager\n        async def some_async_generator(<arguments>):\n            <setup>\n            try:\n                yield <value>\n            finally:\n                <cleanup>\n\n    This makes this:\n\n        async with some_async_generator(<arguments>) as <variable>:\n            <body>\n\n    equivalent to this:\n\n        <setup>\n        try:\n            <variable> = <value>\n            <body>\n        finally:\n            <cleanup>\n    \"\"\"\n    @wraps(func)\n    def helper(*args, **kwds):\n        return _AsyncGeneratorContextManager(func, args, kwds)\n    return helper\n\n\nclass closing(AbstractContextManager):\n    \"\"\"Context to automatically close something at the end of a block.\n\n    Code like this:\n\n        with closing(<module>.open(<arguments>)) as f:\n            <block>\n\n    is equivalent to this:\n\n        f = <module>.open(<arguments>)\n        try:\n            <block>\n        finally:\n            f.close()\n\n    \"\"\"\n    def __init__(self, thing):\n        self.thing = thing\n    def __enter__(self):\n        return self.thing\n    def __exit__(self, *exc_info):\n        self.thing.close()\n\n\nclass aclosing(AbstractAsyncContextManager):\n    \"\"\"Async context manager for safely finalizing an asynchronously cleaned-up\n    resource such as an async generator, calling its ``aclose()`` method.\n\n    Code like this:\n\n        async with aclosing(<module>.fetch(<arguments>)) as agen:\n            <block>\n\n    is equivalent to this:\n\n        agen = <module>.fetch(<arguments>)\n        try:\n            <block>\n        finally:\n            await agen.aclose()\n\n    \"\"\"\n    def __init__(self, thing):\n        self.thing = thing\n    async def __aenter__(self):\n        return self.thing\n    async def __aexit__(self, *exc_info):\n        await self.thing.aclose()\n\n\nclass _RedirectStream(AbstractContextManager):\n\n    _stream = None\n\n    def __init__(self, new_target):\n        self._new_target = new_target\n        # We use a list of old targets to make this CM re-entrant\n        self._old_targets = []\n\n    def __enter__(self):\n        self._old_targets.append(getattr(sys, self._stream))\n        setattr(sys, self._stream, self._new_target)\n        return self._new_target\n\n    def __exit__(self, exctype, excinst, exctb):\n        setattr(sys, self._stream, self._old_targets.pop())\n\n\nclass redirect_stdout(_RedirectStream):\n    \"\"\"Context manager for temporarily redirecting stdout to another file.\n\n        # How to send help() to stderr\n        with redirect_stdout(sys.stderr):\n            help(dir)\n\n        # How to write help() to a file\n        with open('help.txt', 'w') as f:\n            with redirect_stdout(f):\n                help(pow)\n    \"\"\"\n\n    _stream = \"stdout\"\n\n\nclass redirect_stderr(_RedirectStream):\n    \"\"\"Context manager for temporarily redirecting stderr to another file.\"\"\"\n\n    _stream = \"stderr\"\n\n\nclass suppress(AbstractContextManager):\n    \"\"\"Context manager to suppress specified exceptions\n\n    After the exception is suppressed, execution proceeds with the next\n    statement following the with statement.\n\n         with suppress(FileNotFoundError):\n             os.remove(somefile)\n         # Execution still resumes here if the file was already removed\n    \"\"\"\n\n    def __init__(self, *exceptions):\n        self._exceptions = exceptions\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exctype, excinst, exctb):\n        # Unlike isinstance and issubclass, CPython exception handling\n        # currently only looks at the concrete type hierarchy (ignoring\n        # the instance and subclass checking hooks). While Guido considers\n        # that a bug rather than a feature, it's a fairly hard one to fix\n        # due to various internal implementation details. suppress provides\n        # the simpler issubclass based semantics, rather than trying to\n        # exactly reproduce the limitations of the CPython interpreter.\n        #\n        # See http://bugs.python.org/issue12029 for more details\n        return exctype is not None and issubclass(exctype, self._exceptions)\n\n\nclass _BaseExitStack:\n    \"\"\"A base class for ExitStack and AsyncExitStack.\"\"\"\n\n    @staticmethod\n    def _create_exit_wrapper(cm, cm_exit):\n        return MethodType(cm_exit, cm)\n\n    @staticmethod\n    def _create_cb_wrapper(callback, /, *args, **kwds):\n        def _exit_wrapper(exc_type, exc, tb):\n            callback(*args, **kwds)\n        return _exit_wrapper\n\n    def __init__(self):\n        self._exit_callbacks = deque()\n\n    def pop_all(self):\n        \"\"\"Preserve the context stack by transferring it to a new instance.\"\"\"\n        new_stack = type(self)()\n        new_stack._exit_callbacks = self._exit_callbacks\n        self._exit_callbacks = deque()\n        return new_stack\n\n    def push(self, exit):\n        \"\"\"Registers a callback with the standard __exit__ method signature.\n\n        Can suppress exceptions the same way __exit__ method can.\n        Also accepts any object with an __exit__ method (registering a call\n        to the method instead of the object itself).\n        \"\"\"\n        # We use an unbound method rather than a bound method to follow\n        # the standard lookup behaviour for special methods.\n        _cb_type = type(exit)\n\n        try:\n            exit_method = _cb_type.__exit__\n        except AttributeError:\n            # Not a context manager, so assume it's a callable.\n            self._push_exit_callback(exit)\n        else:\n            self._push_cm_exit(exit, exit_method)\n        return exit  # Allow use as a decorator.\n\n    def enter_context(self, cm):\n        \"\"\"Enters the supplied context manager.\n\n        If successful, also pushes its __exit__ method as a callback and\n        returns the result of the __enter__ method.\n        \"\"\"\n        # We look up the special methods on the type to match the with\n        # statement.\n        cls = type(cm)\n        try:\n            _enter = cls.__enter__\n            _exit = cls.__exit__\n        except AttributeError:\n            raise TypeError(f\"'{cls.__module__}.{cls.__qualname__}' object does \"\n                            f\"not support the context manager protocol\") from None\n        result = _enter(cm)\n        self._push_cm_exit(cm, _exit)\n        return result\n\n    def callback(self, callback, /, *args, **kwds):\n        \"\"\"Registers an arbitrary callback and arguments.\n\n        Cannot suppress exceptions.\n        \"\"\"\n        _exit_wrapper = self._create_cb_wrapper(callback, *args, **kwds)\n\n        # We changed the signature, so using @wraps is not appropriate, but\n        # setting __wrapped__ may still help with introspection.\n        _exit_wrapper.__wrapped__ = callback\n        self._push_exit_callback(_exit_wrapper)\n        return callback  # Allow use as a decorator\n\n    def _push_cm_exit(self, cm, cm_exit):\n        \"\"\"Helper to correctly register callbacks to __exit__ methods.\"\"\"\n        _exit_wrapper = self._create_exit_wrapper(cm, cm_exit)\n        self._push_exit_callback(_exit_wrapper, True)\n\n    def _push_exit_callback(self, callback, is_sync=True):\n        self._exit_callbacks.append((is_sync, callback))\n\n\n# Inspired by discussions on http://bugs.python.org/issue13585\nclass ExitStack(_BaseExitStack, AbstractContextManager):\n    \"\"\"Context manager for dynamic management of a stack of exit callbacks.\n\n    For example:\n        with ExitStack() as stack:\n            files = [stack.enter_context(open(fname)) for fname in filenames]\n            # All opened files will automatically be closed at the end of\n            # the with statement, even if attempts to open files later\n            # in the list raise an exception.\n    \"\"\"\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc_details):\n        received_exc = exc_details[0] is not None\n\n        # We manipulate the exception state so it behaves as though\n        # we were actually nesting multiple with statements\n        frame_exc = sys.exc_info()[1]\n        def _fix_exception_context(new_exc, old_exc):\n            # Context may not be correct, so find the end of the chain\n            while 1:\n                exc_context = new_exc.__context__\n                if exc_context is None or exc_context is old_exc:\n                    # Context is already set correctly (see issue 20317)\n                    return\n                if exc_context is frame_exc:\n                    break\n                new_exc = exc_context\n            # Change the end of the chain to point to the exception\n            # we expect it to reference\n            new_exc.__context__ = old_exc\n\n        # Callbacks are invoked in LIFO order to match the behaviour of\n        # nested context managers\n        suppressed_exc = False\n        pending_raise = False\n        while self._exit_callbacks:\n            is_sync, cb = self._exit_callbacks.pop()\n            assert is_sync\n            try:\n                if cb(*exc_details):\n                    suppressed_exc = True\n                    pending_raise = False\n                    exc_details = (None, None, None)\n            except:\n                new_exc_details = sys.exc_info()\n                # simulate the stack of exceptions by setting the context\n                _fix_exception_context(new_exc_details[1], exc_details[1])\n                pending_raise = True\n                exc_details = new_exc_details\n        if pending_raise:\n            try:\n                # bare \"raise exc_details[1]\" replaces our carefully\n                # set-up context\n                fixed_ctx = exc_details[1].__context__\n                raise exc_details[1]\n            except BaseException:\n                exc_details[1].__context__ = fixed_ctx\n                raise\n        return received_exc and suppressed_exc\n\n    def close(self):\n        \"\"\"Immediately unwind the context stack.\"\"\"\n        self.__exit__(None, None, None)\n\n\n# Inspired by discussions on https://bugs.python.org/issue29302\nclass AsyncExitStack(_BaseExitStack, AbstractAsyncContextManager):\n    \"\"\"Async context manager for dynamic management of a stack of exit\n    callbacks.\n\n    For example:\n        async with AsyncExitStack() as stack:\n            connections = [await stack.enter_async_context(get_connection())\n                for i in range(5)]\n            # All opened connections will automatically be released at the\n            # end of the async with statement, even if attempts to open a\n            # connection later in the list raise an exception.\n    \"\"\"\n\n    @staticmethod\n    def _create_async_exit_wrapper(cm, cm_exit):\n        return MethodType(cm_exit, cm)\n\n    @staticmethod\n    def _create_async_cb_wrapper(callback, /, *args, **kwds):\n        async def _exit_wrapper(exc_type, exc, tb):\n            await callback(*args, **kwds)\n        return _exit_wrapper\n\n    async def enter_async_context(self, cm):\n        \"\"\"Enters the supplied async context manager.\n\n        If successful, also pushes its __aexit__ method as a callback and\n        returns the result of the __aenter__ method.\n        \"\"\"\n        cls = type(cm)\n        try:\n            _enter = cls.__aenter__\n            _exit = cls.__aexit__\n        except AttributeError:\n            raise TypeError(f\"'{cls.__module__}.{cls.__qualname__}' object does \"\n                            f\"not support the asynchronous context manager protocol\"\n                           ) from None\n        result = await _enter(cm)\n        self._push_async_cm_exit(cm, _exit)\n        return result\n\n    def push_async_exit(self, exit):\n        \"\"\"Registers a coroutine function with the standard __aexit__ method\n        signature.\n\n        Can suppress exceptions the same way __aexit__ method can.\n        Also accepts any object with an __aexit__ method (registering a call\n        to the method instead of the object itself).\n        \"\"\"\n        _cb_type = type(exit)\n        try:\n            exit_method = _cb_type.__aexit__\n        except AttributeError:\n            # Not an async context manager, so assume it's a coroutine function\n            self._push_exit_callback(exit, False)\n        else:\n            self._push_async_cm_exit(exit, exit_method)\n        return exit  # Allow use as a decorator\n\n    def push_async_callback(self, callback, /, *args, **kwds):\n        \"\"\"Registers an arbitrary coroutine function and arguments.\n\n        Cannot suppress exceptions.\n        \"\"\"\n        _exit_wrapper = self._create_async_cb_wrapper(callback, *args, **kwds)\n\n        # We changed the signature, so using @wraps is not appropriate, but\n        # setting __wrapped__ may still help with introspection.\n        _exit_wrapper.__wrapped__ = callback\n        self._push_exit_callback(_exit_wrapper, False)\n        return callback  # Allow use as a decorator\n\n    async def aclose(self):\n        \"\"\"Immediately unwind the context stack.\"\"\"\n        await self.__aexit__(None, None, None)\n\n    def _push_async_cm_exit(self, cm, cm_exit):\n        \"\"\"Helper to correctly register coroutine function to __aexit__\n        method.\"\"\"\n        _exit_wrapper = self._create_async_exit_wrapper(cm, cm_exit)\n        self._push_exit_callback(_exit_wrapper, False)\n\n    async def __aenter__(self):\n        return self\n\n    async def __aexit__(self, *exc_details):\n        received_exc = exc_details[0] is not None\n\n        # We manipulate the exception state so it behaves as though\n        # we were actually nesting multiple with statements\n        frame_exc = sys.exc_info()[1]\n        def _fix_exception_context(new_exc, old_exc):\n            # Context may not be correct, so find the end of the chain\n            while 1:\n                exc_context = new_exc.__context__\n                if exc_context is None or exc_context is old_exc:\n                    # Context is already set correctly (see issue 20317)\n                    return\n                if exc_context is frame_exc:\n                    break\n                new_exc = exc_context\n            # Change the end of the chain to point to the exception\n            # we expect it to reference\n            new_exc.__context__ = old_exc\n\n        # Callbacks are invoked in LIFO order to match the behaviour of\n        # nested context managers\n        suppressed_exc = False\n        pending_raise = False\n        while self._exit_callbacks:\n            is_sync, cb = self._exit_callbacks.pop()\n            try:\n                if is_sync:\n                    cb_suppress = cb(*exc_details)\n                else:\n                    cb_suppress = await cb(*exc_details)\n\n                if cb_suppress:\n                    suppressed_exc = True\n                    pending_raise = False\n                    exc_details = (None, None, None)\n            except:\n                new_exc_details = sys.exc_info()\n                # simulate the stack of exceptions by setting the context\n                _fix_exception_context(new_exc_details[1], exc_details[1])\n                pending_raise = True\n                exc_details = new_exc_details\n        if pending_raise:\n            try:\n                # bare \"raise exc_details[1]\" replaces our carefully\n                # set-up context\n                fixed_ctx = exc_details[1].__context__\n                raise exc_details[1]\n            except BaseException:\n                exc_details[1].__context__ = fixed_ctx\n                raise\n        return received_exc and suppressed_exc\n\n\nclass nullcontext(AbstractContextManager, AbstractAsyncContextManager):\n    \"\"\"Context manager that does no additional processing.\n\n    Used as a stand-in for a normal context manager, when a particular\n    block of code is only sometimes used with a normal context manager:\n\n    cm = optional_cm if condition else nullcontext()\n    with cm:\n        # Perform operation, using optional_cm if condition is True\n    \"\"\"\n\n    def __init__(self, enter_result=None):\n        self.enter_result = enter_result\n\n    def __enter__(self):\n        return self.enter_result\n\n    def __exit__(self, *excinfo):\n        pass\n\n    async def __aenter__(self):\n        return self.enter_result\n\n    async def __aexit__(self, *excinfo):\n        pass\n\n\nclass chdir(AbstractContextManager):\n    \"\"\"Non thread-safe context manager to change the current working directory.\"\"\"\n\n    def __init__(self, path):\n        self.path = path\n        self._old_cwd = []\n\n    def __enter__(self):\n        self._old_cwd.append(os.getcwd())\n        os.chdir(self.path)\n\n    def __exit__(self, *excinfo):\n        os.chdir(self._old_cwd.pop())\n", 791], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py": ["\"\"\"Array printing function\n\n$Id: arrayprint.py,v 1.9 2005/09/13 13:58:44 teoliphant Exp $\n\n\"\"\"\n__all__ = [\"array2string\", \"array_str\", \"array_repr\",\n           \"set_printoptions\", \"get_printoptions\", \"printoptions\",\n           \"format_float_positional\", \"format_float_scientific\"]\n__docformat__ = 'restructuredtext'\n\n#\n# Written by Konrad Hinsen <hinsenk@ere.umontreal.ca>\n# last revision: 1996-3-13\n# modified by Jim Hugunin 1997-3-3 for repr's and str's (and other details)\n# and by Perry Greenfield 2000-4-1 for numarray\n# and by Travis Oliphant  2005-8-22 for numpy\n\n\n# Note: Both scalartypes.c.src and arrayprint.py implement strs for numpy\n# scalars but for different purposes. scalartypes.c.src has str/reprs for when\n# the scalar is printed on its own, while arrayprint.py has strs for when\n# scalars are printed inside an ndarray. Only the latter strs are currently\n# user-customizable.\n\nimport functools\nimport numbers\nimport sys\ntry:\n    from _thread import get_ident\nexcept ImportError:\n    from _dummy_thread import get_ident\n\nimport numpy as np\nfrom . import numerictypes as _nt\nfrom .umath import absolute, isinf, isfinite, isnat\nfrom . import multiarray\nfrom .multiarray import (array, dragon4_positional, dragon4_scientific,\n                         datetime_as_string, datetime_data, ndarray)\nfrom .fromnumeric import any\nfrom .numeric import concatenate, asarray, errstate\nfrom .numerictypes import (longlong, intc, int_, float64, complex128,\n                           flexible)\nfrom .overrides import array_function_dispatch, set_module\nfrom .printoptions import format_options\nimport operator\nimport warnings\nimport contextlib\n\n\ndef _make_options_dict(precision=None, threshold=None, edgeitems=None,\n                       linewidth=None, suppress=None, nanstr=None, infstr=None,\n                       sign=None, formatter=None, floatmode=None, legacy=None,\n                       override_repr=None):\n    \"\"\"\n    Make a dictionary out of the non-None arguments, plus conversion of\n    *legacy* and sanity checks.\n    \"\"\"\n\n    options = {k: v for k, v in list(locals().items()) if v is not None}\n\n    if suppress is not None:\n        options['suppress'] = bool(suppress)\n\n    modes = ['fixed', 'unique', 'maxprec', 'maxprec_equal']\n    if floatmode not in modes + [None]:\n        raise ValueError(\"floatmode option must be one of \" +\n                         \", \".join('\"{}\"'.format(m) for m in modes))\n\n    if sign not in [None, '-', '+', ' ']:\n        raise ValueError(\"sign option must be one of ' ', '+', or '-'\")\n\n    if legacy is False:\n        options['legacy'] = sys.maxsize\n    elif legacy == False:  # noqa: E712\n        warnings.warn(\n            f\"Passing `legacy={legacy!r}` is deprecated.\",\n            FutureWarning, stacklevel=3\n        )\n        options['legacy'] = sys.maxsize\n    elif legacy == '1.13':\n        options['legacy'] = 113\n    elif legacy == '1.21':\n        options['legacy'] = 121\n    elif legacy == '1.25':\n        options['legacy'] = 125\n    elif legacy == '2.1':\n        options['legacy'] = 201\n    elif legacy is None:\n        pass  # OK, do nothing.\n    else:\n        warnings.warn(\n            \"legacy printing option can currently only be '1.13', '1.21', \"\n            \"'1.25', '2.1, or `False`\", stacklevel=3)\n\n    if threshold is not None:\n        # forbid the bad threshold arg suggested by stack overflow, gh-12351\n        if not isinstance(threshold, numbers.Number):\n            raise TypeError(\"threshold must be numeric\")\n        if np.isnan(threshold):\n            raise ValueError(\"threshold must be non-NAN, try \"\n                             \"sys.maxsize for untruncated representation\")\n\n    if precision is not None:\n        # forbid the bad precision arg as suggested by issue #18254\n        try:\n            options['precision'] = operator.index(precision)\n        except TypeError as e:\n            raise TypeError('precision must be an integer') from e\n\n    return options\n\n\n@set_module('numpy')\ndef set_printoptions(precision=None, threshold=None, edgeitems=None,\n                     linewidth=None, suppress=None, nanstr=None,\n                     infstr=None, formatter=None, sign=None, floatmode=None,\n                     *, legacy=None, override_repr=None):\n    \"\"\"\n    Set printing options.\n\n    These options determine the way floating point numbers, arrays and\n    other NumPy objects are displayed.\n\n    Parameters\n    ----------\n    precision : int or None, optional\n        Number of digits of precision for floating point output (default 8).\n        May be None if `floatmode` is not `fixed`, to print as many digits as\n        necessary to uniquely specify the value.\n    threshold : int, optional\n        Total number of array elements which trigger summarization\n        rather than full repr (default 1000).\n        To always use the full repr without summarization, pass `sys.maxsize`.\n    edgeitems : int, optional\n        Number of array items in summary at beginning and end of\n        each dimension (default 3).\n    linewidth : int, optional\n        The number of characters per line for the purpose of inserting\n        line breaks (default 75).\n    suppress : bool, optional\n        If True, always print floating point numbers using fixed point\n        notation, in which case numbers equal to zero in the current precision\n        will print as zero.  If False, then scientific notation is used when\n        absolute value of the smallest number is < 1e-4 or the ratio of the\n        maximum absolute value to the minimum is > 1e3. The default is False.\n    nanstr : str, optional\n        String representation of floating point not-a-number (default nan).\n    infstr : str, optional\n        String representation of floating point infinity (default inf).\n    sign : string, either '-', '+', or ' ', optional\n        Controls printing of the sign of floating-point types. If '+', always\n        print the sign of positive values. If ' ', always prints a space\n        (whitespace character) in the sign position of positive values.  If\n        '-', omit the sign character of positive values. (default '-')\n\n        .. versionchanged:: 2.0\n             The sign parameter can now be an integer type, previously\n             types were floating-point types.\n\n    formatter : dict of callables, optional\n        If not None, the keys should indicate the type(s) that the respective\n        formatting function applies to.  Callables should return a string.\n        Types that are not specified (by their corresponding keys) are handled\n        by the default formatters.  Individual types for which a formatter\n        can be set are:\n\n        - 'bool'\n        - 'int'\n        - 'timedelta' : a `numpy.timedelta64`\n        - 'datetime' : a `numpy.datetime64`\n        - 'float'\n        - 'longfloat' : 128-bit floats\n        - 'complexfloat'\n        - 'longcomplexfloat' : composed of two 128-bit floats\n        - 'numpystr' : types `numpy.bytes_` and `numpy.str_`\n        - 'object' : `np.object_` arrays\n\n        Other keys that can be used to set a group of types at once are:\n\n        - 'all' : sets all types\n        - 'int_kind' : sets 'int'\n        - 'float_kind' : sets 'float' and 'longfloat'\n        - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'\n        - 'str_kind' : sets 'numpystr'\n    floatmode : str, optional\n        Controls the interpretation of the `precision` option for\n        floating-point types. Can take the following values\n        (default maxprec_equal):\n\n        * 'fixed': Always print exactly `precision` fractional digits,\n                even if this would print more or fewer digits than\n                necessary to specify the value uniquely.\n        * 'unique': Print the minimum number of fractional digits necessary\n                to represent each value uniquely. Different elements may\n                have a different number of digits. The value of the\n                `precision` option is ignored.\n        * 'maxprec': Print at most `precision` fractional digits, but if\n                an element can be uniquely represented with fewer digits\n                only print it with that many.\n        * 'maxprec_equal': Print at most `precision` fractional digits,\n                but if every element in the array can be uniquely\n                represented with an equal number of fewer digits, use that\n                many digits for all elements.\n    legacy : string or `False`, optional\n        If set to the string ``'1.13'`` enables 1.13 legacy printing mode. This\n        approximates numpy 1.13 print output by including a space in the sign\n        position of floats and different behavior for 0d arrays. This also\n        enables 1.21 legacy printing mode (described below).\n\n        If set to the string ``'1.21'`` enables 1.21 legacy printing mode. This\n        approximates numpy 1.21 print output of complex structured dtypes\n        by not inserting spaces after commas that separate fields and after\n        colons.\n\n        If set to ``'1.25'`` approximates printing of 1.25 which mainly means\n        that numeric scalars are printed without their type information, e.g.\n        as ``3.0`` rather than ``np.float64(3.0)``.\n\n        If set to ``'2.1'``, shape information is not given when arrays are\n        summarized (i.e., multiple elements replaced with ``...``).\n\n        If set to `False`, disables legacy mode.\n\n        Unrecognized strings will be ignored with a warning for forward\n        compatibility.\n\n        .. versionchanged:: 1.22.0\n        .. versionchanged:: 2.2\n\n    override_repr: callable, optional\n        If set a passed function will be used for generating arrays' repr.\n        Other options will be ignored.\n\n    See Also\n    --------\n    get_printoptions, printoptions, array2string\n\n    Notes\n    -----\n    `formatter` is always reset with a call to `set_printoptions`.\n\n    Use `printoptions` as a context manager to set the values temporarily.\n\n    Examples\n    --------\n    Floating point precision can be set:\n\n    >>> import numpy as np\n    >>> np.set_printoptions(precision=4)\n    >>> np.array([1.123456789])\n    [1.1235]\n\n    Long arrays can be summarised:\n\n    >>> np.set_printoptions(threshold=5)\n    >>> np.arange(10)\n    array([0, 1, 2, ..., 7, 8, 9], shape=(10,))\n\n    Small results can be suppressed:\n\n    >>> eps = np.finfo(float).eps\n    >>> x = np.arange(4.)\n    >>> x**2 - (x + eps)**2\n    array([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])\n    >>> np.set_printoptions(suppress=True)\n    >>> x**2 - (x + eps)**2\n    array([-0., -0.,  0.,  0.])\n\n    A custom formatter can be used to display array elements as desired:\n\n    >>> np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})\n    >>> x = np.arange(3)\n    >>> x\n    array([int: 0, int: -1, int: -2])\n    >>> np.set_printoptions()  # formatter gets reset\n    >>> x\n    array([0, 1, 2])\n\n    To put back the default options, you can use:\n\n    >>> np.set_printoptions(edgeitems=3, infstr='inf',\n    ... linewidth=75, nanstr='nan', precision=8,\n    ... suppress=False, threshold=1000, formatter=None)\n\n    Also to temporarily override options, use `printoptions`\n    as a context manager:\n\n    >>> with np.printoptions(precision=2, suppress=True, threshold=5):\n    ...     np.linspace(0, 10, 10)\n    array([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ], shape=(10,))\n\n    \"\"\"\n    _set_printoptions(precision, threshold, edgeitems, linewidth, suppress,\n                      nanstr, infstr, formatter, sign, floatmode,\n                      legacy=legacy, override_repr=override_repr)\n\n\ndef _set_printoptions(precision=None, threshold=None, edgeitems=None,\n                      linewidth=None, suppress=None, nanstr=None,\n                      infstr=None, formatter=None, sign=None, floatmode=None,\n                      *, legacy=None, override_repr=None):\n    new_opt = _make_options_dict(precision, threshold, edgeitems, linewidth,\n                                 suppress, nanstr, infstr, sign, formatter,\n                                 floatmode, legacy)\n    # formatter and override_repr are always reset\n    new_opt['formatter'] = formatter\n    new_opt['override_repr'] = override_repr\n\n    updated_opt = format_options.get() | new_opt\n    updated_opt.update(new_opt)\n\n    if updated_opt['legacy'] == 113:\n        updated_opt['sign'] = '-'\n\n    return format_options.set(updated_opt)\n\n\n@set_module('numpy')\ndef get_printoptions():\n    \"\"\"\n    Return the current print options.\n\n    Returns\n    -------\n    print_opts : dict\n        Dictionary of current print options with keys\n\n        - precision : int\n        - threshold : int\n        - edgeitems : int\n        - linewidth : int\n        - suppress : bool\n        - nanstr : str\n        - infstr : str\n        - sign : str\n        - formatter : dict of callables\n        - floatmode : str\n        - legacy : str or False\n\n        For a full description of these options, see `set_printoptions`.\n\n    See Also\n    --------\n    set_printoptions, printoptions\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    >>> np.get_printoptions()\n    {'edgeitems': 3, 'threshold': 1000, ..., 'override_repr': None}\n\n    >>> np.get_printoptions()['linewidth']\n    75\n    >>> np.set_printoptions(linewidth=100)\n    >>> np.get_printoptions()['linewidth']\n    100\n\n    \"\"\"\n    opts = format_options.get().copy()\n    opts['legacy'] = {\n        113: '1.13', 121: '1.21', 125: '1.25', sys.maxsize: False,\n    }[opts['legacy']]\n    return opts\n\n\ndef _get_legacy_print_mode():\n    \"\"\"Return the legacy print mode as an int.\"\"\"\n    return format_options.get()['legacy']\n\n\n@set_module('numpy')\n@contextlib.contextmanager\ndef printoptions(*args, **kwargs):\n    \"\"\"Context manager for setting print options.\n\n    Set print options for the scope of the `with` block, and restore the old\n    options at the end. See `set_printoptions` for the full description of\n    available options.\n\n    Examples\n    --------\n    >>> import numpy as np\n\n    >>> from numpy.testing import assert_equal\n    >>> with np.printoptions(precision=2):\n    ...     np.array([2.0]) / 3\n    array([0.67])\n\n    The `as`-clause of the `with`-statement gives the current print options:\n\n    >>> with np.printoptions(precision=2) as opts:\n    ...      assert_equal(opts, np.get_printoptions())\n\n    See Also\n    --------\n    set_printoptions, get_printoptions\n\n    \"\"\"\n    token = _set_printoptions(*args, **kwargs)\n\n    try:\n        yield get_printoptions()\n    finally:\n        format_options.reset(token)\n\n\ndef _leading_trailing(a, edgeitems, index=()):\n    \"\"\"\n    Keep only the N-D corners (leading and trailing edges) of an array.\n\n    Should be passed a base-class ndarray, since it makes no guarantees about\n    preserving subclasses.\n    \"\"\"\n    axis = len(index)\n    if axis == a.ndim:\n        return a[index]\n\n    if a.shape[axis] > 2*edgeitems:\n        return concatenate((\n            _leading_trailing(a, edgeitems, index + np.index_exp[:edgeitems]),\n            _leading_trailing(a, edgeitems, index + np.index_exp[-edgeitems:])\n        ), axis=axis)\n    else:\n        return _leading_trailing(a, edgeitems, index + np.index_exp[:])\n\n\ndef _object_format(o):\n    \"\"\" Object arrays containing lists should be printed unambiguously \"\"\"\n    if type(o) is list:\n        fmt = 'list({!r})'\n    else:\n        fmt = '{!r}'\n    return fmt.format(o)\n\ndef repr_format(x):\n    if isinstance(x, (np.str_, np.bytes_)):\n        return repr(x.item())\n    return repr(x)\n\ndef str_format(x):\n    if isinstance(x, (np.str_, np.bytes_)):\n        return str(x.item())\n    return str(x)\n\ndef _get_formatdict(data, *, precision, floatmode, suppress, sign, legacy,\n                    formatter, **kwargs):\n    # note: extra arguments in kwargs are ignored\n\n    # wrapped in lambdas to avoid taking a code path\n    # with the wrong type of data\n    formatdict = {\n        'bool': lambda: BoolFormat(data),\n        'int': lambda: IntegerFormat(data, sign),\n        'float': lambda: FloatingFormat(\n            data, precision, floatmode, suppress, sign, legacy=legacy),\n        'longfloat': lambda: FloatingFormat(\n            data, precision, floatmode, suppress, sign, legacy=legacy),\n        'complexfloat': lambda: ComplexFloatingFormat(\n            data, precision, floatmode, suppress, sign, legacy=legacy),\n        'longcomplexfloat': lambda: ComplexFloatingFormat(\n            data, precision, floatmode, suppress, sign, legacy=legacy),\n        'datetime': lambda: DatetimeFormat(data, legacy=legacy),\n        'timedelta': lambda: TimedeltaFormat(data),\n        'object': lambda: _object_format,\n        'void': lambda: str_format,\n        'numpystr': lambda: repr_format}\n\n    # we need to wrap values in `formatter` in a lambda, so that the interface\n    # is the same as the above values.\n    def indirect(x):\n        return lambda: x\n\n    if formatter is not None:\n        fkeys = [k for k in formatter.keys() if formatter[k] is not None]\n        if 'all' in fkeys:\n            for key in formatdict.keys():\n                formatdict[key] = indirect(formatter['all'])\n        if 'int_kind' in fkeys:\n            for key in ['int']:\n                formatdict[key] = indirect(formatter['int_kind'])\n        if 'float_kind' in fkeys:\n            for key in ['float', 'longfloat']:\n                formatdict[key] = indirect(formatter['float_kind'])\n        if 'complex_kind' in fkeys:\n            for key in ['complexfloat', 'longcomplexfloat']:\n                formatdict[key] = indirect(formatter['complex_kind'])\n        if 'str_kind' in fkeys:\n            formatdict['numpystr'] = indirect(formatter['str_kind'])\n        for key in formatdict.keys():\n            if key in fkeys:\n                formatdict[key] = indirect(formatter[key])\n\n    return formatdict\n\ndef _get_format_function(data, **options):\n    \"\"\"\n    find the right formatting function for the dtype_\n    \"\"\"\n    dtype_ = data.dtype\n    dtypeobj = dtype_.type\n    formatdict = _get_formatdict(data, **options)\n    if dtypeobj is None:\n        return formatdict[\"numpystr\"]()\n    elif issubclass(dtypeobj, _nt.bool):\n        return formatdict['bool']()\n    elif issubclass(dtypeobj, _nt.integer):\n        if issubclass(dtypeobj, _nt.timedelta64):\n            return formatdict['timedelta']()\n        else:\n            return formatdict['int']()\n    elif issubclass(dtypeobj, _nt.floating):\n        if issubclass(dtypeobj, _nt.longdouble):\n            return formatdict['longfloat']()\n        else:\n            return formatdict['float']()\n    elif issubclass(dtypeobj, _nt.complexfloating):\n        if issubclass(dtypeobj, _nt.clongdouble):\n            return formatdict['longcomplexfloat']()\n        else:\n            return formatdict['complexfloat']()\n    elif issubclass(dtypeobj, (_nt.str_, _nt.bytes_)):\n        return formatdict['numpystr']()\n    elif issubclass(dtypeobj, _nt.datetime64):\n        return formatdict['datetime']()\n    elif issubclass(dtypeobj, _nt.object_):\n        return formatdict['object']()\n    elif issubclass(dtypeobj, _nt.void):\n        if dtype_.names is not None:\n            return StructuredVoidFormat.from_data(data, **options)\n        else:\n            return formatdict['void']()\n    else:\n        return formatdict['numpystr']()\n\n\ndef _recursive_guard(fillvalue='...'):\n    \"\"\"\n    Like the python 3.2 reprlib.recursive_repr, but forwards *args and **kwargs\n\n    Decorates a function such that if it calls itself with the same first\n    argument, it returns `fillvalue` instead of recursing.\n\n    Largely copied from reprlib.recursive_repr\n    \"\"\"\n\n    def decorating_function(f):\n        repr_running = set()\n\n        @functools.wraps(f)\n        def wrapper(self, *args, **kwargs):\n            key = id(self), get_ident()\n            if key in repr_running:\n                return fillvalue\n            repr_running.add(key)\n            try:\n                return f(self, *args, **kwargs)\n            finally:\n                repr_running.discard(key)\n\n        return wrapper\n\n    return decorating_function\n\n\n# gracefully handle recursive calls, when object arrays contain themselves\n@_recursive_guard()\ndef _array2string(a, options, separator=' ', prefix=\"\"):\n    # The formatter __init__s in _get_format_function cannot deal with\n    # subclasses yet, and we also need to avoid recursion issues in\n    # _formatArray with subclasses which return 0d arrays in place of scalars\n    data = asarray(a)\n    if a.shape == ():\n        a = data\n\n    if a.size > options['threshold']:\n        summary_insert = \"...\"\n        data = _leading_trailing(data, options['edgeitems'])\n    else:\n        summary_insert = \"\"\n\n    # find the right formatting function for the array\n    format_function = _get_format_function(data, **options)\n\n    # skip over \"[\"\n    next_line_prefix = \" \"\n    # skip over array(\n    next_line_prefix += \" \"*len(prefix)\n\n    lst = _formatArray(a, format_function, options['linewidth'],\n                       next_line_prefix, separator, options['edgeitems'],\n                       summary_insert, options['legacy'])\n    return lst\n\n\ndef _array2string_dispatcher(\n        a, max_line_width=None, precision=None,\n        suppress_small=None, separator=None, prefix=None,\n        style=None, formatter=None, threshold=None,\n        edgeitems=None, sign=None, floatmode=None, suffix=None,\n        *, legacy=None):\n    return (a,)\n\n\n@array_function_dispatch(_array2string_dispatcher, module='numpy')\ndef array2string(a, max_line_width=None, precision=None,\n                 suppress_small=None, separator=' ', prefix=\"\",\n                 style=np._NoValue, formatter=None, threshold=None,\n                 edgeitems=None, sign=None, floatmode=None, suffix=\"\",\n                 *, legacy=None):\n    \"\"\"\n    Return a string representation of an array.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.\n        Defaults to ``numpy.get_printoptions()['linewidth']``.\n    precision : int or None, optional\n        Floating point precision.\n        Defaults to ``numpy.get_printoptions()['precision']``.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n        Defaults to ``numpy.get_printoptions()['suppress']``.\n    separator : str, optional\n        Inserted between elements.\n    prefix : str, optional\n    suffix : str, optional\n        The length of the prefix and suffix strings are used to respectively\n        align and wrap the output. An array is typically printed as::\n\n          prefix + array2string(a) + suffix\n\n        The output is left-padded by the length of the prefix string, and\n        wrapping is forced at the column ``max_line_width - len(suffix)``.\n        It should be noted that the content of prefix and suffix strings are\n        not included in the output.\n    style : _NoValue, optional\n        Has no effect, do not use.\n\n        .. deprecated:: 1.14.0\n    formatter : dict of callables, optional\n        If not None, the keys should indicate the type(s) that the respective\n        formatting function applies to.  Callables should return a string.\n        Types that are not specified (by their corresponding keys) are handled\n        by the default formatters.  Individual types for which a formatter\n        can be set are:\n\n        - 'bool'\n        - 'int'\n        - 'timedelta' : a `numpy.timedelta64`\n        - 'datetime' : a `numpy.datetime64`\n        - 'float'\n        - 'longfloat' : 128-bit floats\n        - 'complexfloat'\n        - 'longcomplexfloat' : composed of two 128-bit floats\n        - 'void' : type `numpy.void`\n        - 'numpystr' : types `numpy.bytes_` and `numpy.str_`\n\n        Other keys that can be used to set a group of types at once are:\n\n        - 'all' : sets all types\n        - 'int_kind' : sets 'int'\n        - 'float_kind' : sets 'float' and 'longfloat'\n        - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'\n        - 'str_kind' : sets 'numpystr'\n    threshold : int, optional\n        Total number of array elements which trigger summarization\n        rather than full repr.\n        Defaults to ``numpy.get_printoptions()['threshold']``.\n    edgeitems : int, optional\n        Number of array items in summary at beginning and end of\n        each dimension.\n        Defaults to ``numpy.get_printoptions()['edgeitems']``.\n    sign : string, either '-', '+', or ' ', optional\n        Controls printing of the sign of floating-point types. If '+', always\n        print the sign of positive values. If ' ', always prints a space\n        (whitespace character) in the sign position of positive values.  If\n        '-', omit the sign character of positive values.\n        Defaults to ``numpy.get_printoptions()['sign']``.\n\n        .. versionchanged:: 2.0\n             The sign parameter can now be an integer type, previously\n             types were floating-point types.\n\n    floatmode : str, optional\n        Controls the interpretation of the `precision` option for\n        floating-point types.\n        Defaults to ``numpy.get_printoptions()['floatmode']``.\n        Can take the following values:\n\n        - 'fixed': Always print exactly `precision` fractional digits,\n          even if this would print more or fewer digits than\n          necessary to specify the value uniquely.\n        - 'unique': Print the minimum number of fractional digits necessary\n          to represent each value uniquely. Different elements may\n          have a different number of digits.  The value of the\n          `precision` option is ignored.\n        - 'maxprec': Print at most `precision` fractional digits, but if\n          an element can be uniquely represented with fewer digits\n          only print it with that many.\n        - 'maxprec_equal': Print at most `precision` fractional digits,\n          but if every element in the array can be uniquely\n          represented with an equal number of fewer digits, use that\n          many digits for all elements.\n    legacy : string or `False`, optional\n        If set to the string ``'1.13'`` enables 1.13 legacy printing mode. This\n        approximates numpy 1.13 print output by including a space in the sign\n        position of floats and different behavior for 0d arrays. If set to\n        `False`, disables legacy mode. Unrecognized strings will be ignored\n        with a warning for forward compatibility.\n\n    Returns\n    -------\n    array_str : str\n        String representation of the array.\n\n    Raises\n    ------\n    TypeError\n        if a callable in `formatter` does not return a string.\n\n    See Also\n    --------\n    array_str, array_repr, set_printoptions, get_printoptions\n\n    Notes\n    -----\n    If a formatter is specified for a certain type, the `precision` keyword is\n    ignored for that type.\n\n    This is a very flexible function; `array_repr` and `array_str` are using\n    `array2string` internally so keywords with the same name should work\n    identically in all three functions.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = np.array([1e-16,1,2,3])\n    >>> np.array2string(x, precision=2, separator=',',\n    ...                       suppress_small=True)\n    '[0.,1.,2.,3.]'\n\n    >>> x  = np.arange(3.)\n    >>> np.array2string(x, formatter={'float_kind':lambda x: \"%.2f\" % x})\n    '[0.00 1.00 2.00]'\n\n    >>> x  = np.arange(3)\n    >>> np.array2string(x, formatter={'int':lambda x: hex(x)})\n    '[0x0 0x1 0x2]'\n\n    \"\"\"\n\n    overrides = _make_options_dict(precision, threshold, edgeitems,\n                                   max_line_width, suppress_small, None, None,\n                                   sign, formatter, floatmode, legacy)\n    options = format_options.get().copy()\n    options.update(overrides)\n\n    if options['legacy'] <= 113:\n        if style is np._NoValue:\n            style = repr\n\n        if a.shape == () and a.dtype.names is None:\n            return style(a.item())\n    elif style is not np._NoValue:\n        # Deprecation 11-9-2017  v1.14\n        warnings.warn(\"'style' argument is deprecated and no longer functional\"\n                      \" except in 1.13 'legacy' mode\",\n                      DeprecationWarning, stacklevel=2)\n\n    if options['legacy'] > 113:\n        options['linewidth'] -= len(suffix)\n\n    # treat as a null array if any of shape elements == 0\n    if a.size == 0:\n        return \"[]\"\n\n    return _array2string(a, options, separator, prefix)\n\n\ndef _extendLine(s, line, word, line_width, next_line_prefix, legacy):\n    needs_wrap = len(line) + len(word) > line_width\n    if legacy > 113:\n        # don't wrap lines if it won't help\n        if len(line) <= len(next_line_prefix):\n            needs_wrap = False\n\n    if needs_wrap:\n        s += line.rstrip() + \"\\n\"\n        line = next_line_prefix\n    line += word\n    return s, line\n\n\ndef _extendLine_pretty(s, line, word, line_width, next_line_prefix, legacy):\n    \"\"\"\n    Extends line with nicely formatted (possibly multi-line) string ``word``.\n    \"\"\"\n    words = word.splitlines()\n    if len(words) == 1 or legacy <= 113:\n        return _extendLine(s, line, word, line_width, next_line_prefix, legacy)\n\n    max_word_length = max(len(word) for word in words)\n    if (len(line) + max_word_length > line_width and\n            len(line) > len(next_line_prefix)):\n        s += line.rstrip() + '\\n'\n        line = next_line_prefix + words[0]\n        indent = next_line_prefix\n    else:\n        indent = len(line)*' '\n        line += words[0]\n\n    for word in words[1::]:\n        s += line.rstrip() + '\\n'\n        line = indent + word\n\n    suffix_length = max_word_length - len(words[-1])\n    line += suffix_length*' '\n\n    return s, line\n\ndef _formatArray(a, format_function, line_width, next_line_prefix,\n                 separator, edge_items, summary_insert, legacy):\n    \"\"\"formatArray is designed for two modes of operation:\n\n    1. Full output\n\n    2. Summarized output\n\n    \"\"\"\n    def recurser(index, hanging_indent, curr_width):\n        \"\"\"\n        By using this local function, we don't need to recurse with all the\n        arguments. Since this function is not created recursively, the cost is\n        not significant\n        \"\"\"\n        axis = len(index)\n        axes_left = a.ndim - axis\n\n        if axes_left == 0:\n            return format_function(a[index])\n\n        # when recursing, add a space to align with the [ added, and reduce the\n        # length of the line by 1\n        next_hanging_indent = hanging_indent + ' '\n        if legacy <= 113:\n            next_width = curr_width\n        else:\n            next_width = curr_width - len(']')\n\n        a_len = a.shape[axis]\n        show_summary = summary_insert and 2*edge_items < a_len\n        if show_summary:\n            leading_items = edge_items\n            trailing_items = edge_items\n        else:\n            leading_items = 0\n            trailing_items = a_len\n\n        # stringify the array with the hanging indent on the first line too\n        s = ''\n\n        # last axis (rows) - wrap elements if they would not fit on one line\n        if axes_left == 1:\n            # the length up until the beginning of the separator / bracket\n            if legacy <= 113:\n                elem_width = curr_width - len(separator.rstrip())\n            else:\n                elem_width = curr_width - max(\n                    len(separator.rstrip()), len(']')\n                )\n\n            line = hanging_indent\n            for i in range(leading_items):\n                word = recurser(index + (i,), next_hanging_indent, next_width)\n                s, line = _extendLine_pretty(\n                    s, line, word, elem_width, hanging_indent, legacy)\n                line += separator\n\n            if show_summary:\n                s, line = _extendLine(\n                    s, line, summary_insert, elem_width, hanging_indent, legacy\n                )\n                if legacy <= 113:\n                    line += \", \"\n                else:\n                    line += separator\n\n            for i in range(trailing_items, 1, -1):\n                word = recurser(index + (-i,), next_hanging_indent, next_width)\n                s, line = _extendLine_pretty(\n                    s, line, word, elem_width, hanging_indent, legacy)\n                line += separator\n\n            if legacy <= 113:\n                # width of the separator is not considered on 1.13\n                elem_width = curr_width\n            word = recurser(index + (-1,), next_hanging_indent, next_width)\n            s, line = _extendLine_pretty(\n                s, line, word, elem_width, hanging_indent, legacy)\n\n            s += line\n\n        # other axes - insert newlines between rows\n        else:\n            s = ''\n            line_sep = separator.rstrip() + '\\n'*(axes_left - 1)\n\n            for i in range(leading_items):\n                nested = recurser(\n                    index + (i,), next_hanging_indent, next_width\n                )\n                s += hanging_indent + nested + line_sep\n\n            if show_summary:\n                if legacy <= 113:\n                    # trailing space, fixed nbr of newlines,\n                    # and fixed separator\n                    s += hanging_indent + summary_insert + \", \\n\"\n                else:\n                    s += hanging_indent + summary_insert + line_sep\n\n            for i in range(trailing_items, 1, -1):\n                nested = recurser(index + (-i,), next_hanging_indent,\n                                  next_width)\n                s += hanging_indent + nested + line_sep\n\n            nested = recurser(index + (-1,), next_hanging_indent, next_width)\n            s += hanging_indent + nested\n\n        # remove the hanging indent, and wrap in []\n        s = '[' + s[len(hanging_indent):] + ']'\n        return s\n\n    try:\n        # invoke the recursive part with an initial index and prefix\n        return recurser(index=(),\n                        hanging_indent=next_line_prefix,\n                        curr_width=line_width)\n    finally:\n        # recursive closures have a cyclic reference to themselves, which\n        # requires gc to collect (gh-10620). To avoid this problem, for\n        # performance and PyPy friendliness, we break the cycle:\n        recurser = None\n\ndef _none_or_positive_arg(x, name):\n    if x is None:\n        return -1\n    if x < 0:\n        raise ValueError(\"{} must be >= 0\".format(name))\n    return x\n\nclass FloatingFormat:\n    \"\"\" Formatter for subtypes of np.floating \"\"\"\n    def __init__(self, data, precision, floatmode, suppress_small, sign=False,\n                 *, legacy=None):\n        # for backcompatibility, accept bools\n        if isinstance(sign, bool):\n            sign = '+' if sign else '-'\n\n        self._legacy = legacy\n        if self._legacy <= 113:\n            # when not 0d, legacy does not support '-'\n            if data.shape != () and sign == '-':\n                sign = ' '\n\n        self.floatmode = floatmode\n        if floatmode == 'unique':\n            self.precision = None\n        else:\n            self.precision = precision\n\n        self.precision = _none_or_positive_arg(self.precision, 'precision')\n\n        self.suppress_small = suppress_small\n        self.sign = sign\n        self.exp_format = False\n        self.large_exponent = False\n        self.fillFormat(data)\n\n    def fillFormat(self, data):\n        # only the finite values are used to compute the number of digits\n        finite_vals = data[isfinite(data)]\n\n        # choose exponential mode based on the non-zero finite values:\n        abs_non_zero = absolute(finite_vals[finite_vals != 0])\n        if len(abs_non_zero) != 0:\n            max_val = np.max(abs_non_zero)\n            min_val = np.min(abs_non_zero)\n            with errstate(over='ignore'):  # division can overflow\n                if max_val >= 1.e8 or (not self.suppress_small and\n                        (min_val < 0.0001 or max_val/min_val > 1000.)):\n                    self.exp_format = True\n\n        # do a first pass of printing all the numbers, to determine sizes\n        if len(finite_vals) == 0:\n            self.pad_left = 0\n            self.pad_right = 0\n            self.trim = '.'\n            self.exp_size = -1\n            self.unique = True\n            self.min_digits = None\n        elif self.exp_format:\n            trim, unique = '.', True\n            if self.floatmode == 'fixed' or self._legacy <= 113:\n                trim, unique = 'k', False\n            strs = (dragon4_scientific(x, precision=self.precision,\n                               unique=unique, trim=trim, sign=self.sign == '+')\n                    for x in finite_vals)\n            frac_strs, _, exp_strs = zip(*(s.partition('e') for s in strs))\n            int_part, frac_part = zip(*(s.split('.') for s in frac_strs))\n            self.exp_size = max(len(s) for s in exp_strs) - 1\n\n            self.trim = 'k'\n            self.precision = max(len(s) for s in frac_part)\n            self.min_digits = self.precision\n            self.unique = unique\n\n            # for back-compat with np 1.13, use 2 spaces & sign and full prec\n            if self._legacy <= 113:\n                self.pad_left = 3\n            else:\n                # this should be only 1 or 2. Can be calculated from sign.\n                self.pad_left = max(len(s) for s in int_part)\n            # pad_right is only needed for nan length calculation\n            self.pad_right = self.exp_size + 2 + self.precision\n        else:\n            trim, unique = '.', True\n            if self.floatmode == 'fixed':\n                trim, unique = 'k', False\n            strs = (dragon4_positional(x, precision=self.precision,\n                                       fractional=True,\n                                       unique=unique, trim=trim,\n                                       sign=self.sign == '+')\n                    for x in finite_vals)\n            int_part, frac_part = zip(*(s.split('.') for s in strs))\n            if self._legacy <= 113:\n                self.pad_left = 1 + max(len(s.lstrip('-+')) for s in int_part)\n            else:\n                self.pad_left = max(len(s) for s in int_part)\n            self.pad_right = max(len(s) for s in frac_part)\n            self.exp_size = -1\n            self.unique = unique\n\n            if self.floatmode in ['fixed', 'maxprec_equal']:\n                self.precision = self.min_digits = self.pad_right\n                self.trim = 'k'\n            else:\n                self.trim = '.'\n                self.min_digits = 0\n\n        if self._legacy > 113:\n            # account for sign = ' ' by adding one to pad_left\n            if self.sign == ' ' and not any(np.signbit(finite_vals)):\n                self.pad_left += 1\n\n        # if there are non-finite values, may need to increase pad_left\n        if data.size != finite_vals.size:\n            neginf = self.sign != '-' or any(data[isinf(data)] < 0)\n            offset = self.pad_right + 1  # +1 for decimal pt\n            current_options = format_options.get()\n            self.pad_left = max(\n                self.pad_left, len(current_options['nanstr']) - offset,\n                len(current_options['infstr']) + neginf - offset\n            )\n\n    def __call__(self, x):\n        if not np.isfinite(x):\n            with errstate(invalid='ignore'):\n                current_options = format_options.get()\n                if np.isnan(x):\n                    sign = '+' if self.sign == '+' else ''\n                    ret = sign + current_options['nanstr']\n                else:  # isinf\n                    sign = '-' if x < 0 else '+' if self.sign == '+' else ''\n                    ret = sign + current_options['infstr']\n                return ' '*(\n                    self.pad_left + self.pad_right + 1 - len(ret)\n                ) + ret\n\n        if self.exp_format:\n            return dragon4_scientific(x,\n                                      precision=self.precision,\n                                      min_digits=self.min_digits,\n                                      unique=self.unique,\n                                      trim=self.trim,\n                                      sign=self.sign == '+',\n                                      pad_left=self.pad_left,\n                                      exp_digits=self.exp_size)\n        else:\n            return dragon4_positional(x,\n                                      precision=self.precision,\n                                      min_digits=self.min_digits,\n                                      unique=self.unique,\n                                      fractional=True,\n                                      trim=self.trim,\n                                      sign=self.sign == '+',\n                                      pad_left=self.pad_left,\n                                      pad_right=self.pad_right)\n\n\n@set_module('numpy')\ndef format_float_scientific(x, precision=None, unique=True, trim='k',\n                            sign=False, pad_left=None, exp_digits=None,\n                            min_digits=None):\n    \"\"\"\n    Format a floating-point scalar as a decimal string in scientific notation.\n\n    Provides control over rounding, trimming and padding. Uses and assumes\n    IEEE unbiased rounding. Uses the \"Dragon4\" algorithm.\n\n    Parameters\n    ----------\n    x : python float or numpy floating scalar\n        Value to format.\n    precision : non-negative integer or None, optional\n        Maximum number of digits to print. May be None if `unique` is\n        `True`, but must be an integer if unique is `False`.\n    unique : boolean, optional\n        If `True`, use a digit-generation strategy which gives the shortest\n        representation which uniquely identifies the floating-point number from\n        other values of the same type, by judicious rounding. If `precision`\n        is given fewer digits than necessary can be printed. If `min_digits`\n        is given more can be printed, in which cases the last digit is rounded\n        with unbiased rounding.\n        If `False`, digits are generated as if printing an infinite-precision\n        value and stopping after `precision` digits, rounding the remaining\n        value with unbiased rounding\n    trim : one of 'k', '.', '0', '-', optional\n        Controls post-processing trimming of trailing digits, as follows:\n\n        * 'k' : keep trailing zeros, keep decimal point (no trimming)\n        * '.' : trim all trailing zeros, leave decimal point\n        * '0' : trim all but the zero before the decimal point. Insert the\n          zero if it is missing.\n        * '-' : trim trailing zeros and any trailing decimal point\n    sign : boolean, optional\n        Whether to show the sign for positive values.\n    pad_left : non-negative integer, optional\n        Pad the left side of the string with whitespace until at least that\n        many characters are to the left of the decimal point.\n    exp_digits : non-negative integer, optional\n        Pad the exponent with zeros until it contains at least this\n        many digits. If omitted, the exponent will be at least 2 digits.\n    min_digits : non-negative integer or None, optional\n        Minimum number of digits to print. This only has an effect for\n        `unique=True`. In that case more digits than necessary to uniquely\n        identify the value may be printed and rounded unbiased.\n\n        .. versionadded:: 1.21.0\n\n    Returns\n    -------\n    rep : string\n        The string representation of the floating point value\n\n    See Also\n    --------\n    format_float_positional\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.format_float_scientific(np.float32(np.pi))\n    '3.1415927e+00'\n    >>> s = np.float32(1.23e24)\n    >>> np.format_float_scientific(s, unique=False, precision=15)\n    '1.230000071797338e+24'\n    >>> np.format_float_scientific(s, exp_digits=4)\n    '1.23e+0024'\n    \"\"\"\n    precision = _none_or_positive_arg(precision, 'precision')\n    pad_left = _none_or_positive_arg(pad_left, 'pad_left')\n    exp_digits = _none_or_positive_arg(exp_digits, 'exp_digits')\n    min_digits = _none_or_positive_arg(min_digits, 'min_digits')\n    if min_digits > 0 and precision > 0 and min_digits > precision:\n        raise ValueError(\"min_digits must be less than or equal to precision\")\n    return dragon4_scientific(x, precision=precision, unique=unique,\n                              trim=trim, sign=sign, pad_left=pad_left,\n                              exp_digits=exp_digits, min_digits=min_digits)\n\n\n@set_module('numpy')\ndef format_float_positional(x, precision=None, unique=True,\n                            fractional=True, trim='k', sign=False,\n                            pad_left=None, pad_right=None, min_digits=None):\n    \"\"\"\n    Format a floating-point scalar as a decimal string in positional notation.\n\n    Provides control over rounding, trimming and padding. Uses and assumes\n    IEEE unbiased rounding. Uses the \"Dragon4\" algorithm.\n\n    Parameters\n    ----------\n    x : python float or numpy floating scalar\n        Value to format.\n    precision : non-negative integer or None, optional\n        Maximum number of digits to print. May be None if `unique` is\n        `True`, but must be an integer if unique is `False`.\n    unique : boolean, optional\n        If `True`, use a digit-generation strategy which gives the shortest\n        representation which uniquely identifies the floating-point number from\n        other values of the same type, by judicious rounding. If `precision`\n        is given fewer digits than necessary can be printed, or if `min_digits`\n        is given more can be printed, in which cases the last digit is rounded\n        with unbiased rounding.\n        If `False`, digits are generated as if printing an infinite-precision\n        value and stopping after `precision` digits, rounding the remaining\n        value with unbiased rounding\n    fractional : boolean, optional\n        If `True`, the cutoffs of `precision` and `min_digits` refer to the\n        total number of digits after the decimal point, including leading\n        zeros.\n        If `False`, `precision` and `min_digits` refer to the total number of\n        significant digits, before or after the decimal point, ignoring leading\n        zeros.\n    trim : one of 'k', '.', '0', '-', optional\n        Controls post-processing trimming of trailing digits, as follows:\n\n        * 'k' : keep trailing zeros, keep decimal point (no trimming)\n        * '.' : trim all trailing zeros, leave decimal point\n        * '0' : trim all but the zero before the decimal point. Insert the\n          zero if it is missing.\n        * '-' : trim trailing zeros and any trailing decimal point\n    sign : boolean, optional\n        Whether to show the sign for positive values.\n    pad_left : non-negative integer, optional\n        Pad the left side of the string with whitespace until at least that\n        many characters are to the left of the decimal point.\n    pad_right : non-negative integer, optional\n        Pad the right side of the string with whitespace until at least that\n        many characters are to the right of the decimal point.\n    min_digits : non-negative integer or None, optional\n        Minimum number of digits to print. Only has an effect if `unique=True`\n        in which case additional digits past those necessary to uniquely\n        identify the value may be printed, rounding the last additional digit.\n\n        .. versionadded:: 1.21.0\n\n    Returns\n    -------\n    rep : string\n        The string representation of the floating point value\n\n    See Also\n    --------\n    format_float_scientific\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.format_float_positional(np.float32(np.pi))\n    '3.1415927'\n    >>> np.format_float_positional(np.float16(np.pi))\n    '3.14'\n    >>> np.format_float_positional(np.float16(0.3))\n    '0.3'\n    >>> np.format_float_positional(np.float16(0.3), unique=False, precision=10)\n    '0.3000488281'\n    \"\"\"\n    precision = _none_or_positive_arg(precision, 'precision')\n    pad_left = _none_or_positive_arg(pad_left, 'pad_left')\n    pad_right = _none_or_positive_arg(pad_right, 'pad_right')\n    min_digits = _none_or_positive_arg(min_digits, 'min_digits')\n    if not fractional and precision == 0:\n        raise ValueError(\"precision must be greater than 0 if \"\n                         \"fractional=False\")\n    if min_digits > 0 and precision > 0 and min_digits > precision:\n        raise ValueError(\"min_digits must be less than or equal to precision\")\n    return dragon4_positional(x, precision=precision, unique=unique,\n                              fractional=fractional, trim=trim,\n                              sign=sign, pad_left=pad_left,\n                              pad_right=pad_right, min_digits=min_digits)\n\nclass IntegerFormat:\n    def __init__(self, data, sign='-'):\n        if data.size > 0:\n            data_max = np.max(data)\n            data_min = np.min(data)\n            data_max_str_len = len(str(data_max))\n            if sign == ' ' and data_min < 0:\n                sign = '-'\n            if data_max >= 0 and sign in \"+ \":\n                data_max_str_len += 1\n            max_str_len = max(data_max_str_len,\n                              len(str(data_min)))\n        else:\n            max_str_len = 0\n        self.format = f'{{:{sign}{max_str_len}d}}'\n\n    def __call__(self, x):\n        return self.format.format(x)\n\nclass BoolFormat:\n    def __init__(self, data, **kwargs):\n        # add an extra space so \" True\" and \"False\" have the same length and\n        # array elements align nicely when printed, except in 0d arrays\n        self.truestr = ' True' if data.shape != () else 'True'\n\n    def __call__(self, x):\n        return self.truestr if x else \"False\"\n\n\nclass ComplexFloatingFormat:\n    \"\"\" Formatter for subtypes of np.complexfloating \"\"\"\n    def __init__(self, x, precision, floatmode, suppress_small,\n                 sign=False, *, legacy=None):\n        # for backcompatibility, accept bools\n        if isinstance(sign, bool):\n            sign = '+' if sign else '-'\n\n        floatmode_real = floatmode_imag = floatmode\n        if legacy <= 113:\n            floatmode_real = 'maxprec_equal'\n            floatmode_imag = 'maxprec'\n\n        self.real_format = FloatingFormat(\n            x.real, precision, floatmode_real, suppress_small,\n            sign=sign, legacy=legacy\n        )\n        self.imag_format = FloatingFormat(\n            x.imag, precision, floatmode_imag, suppress_small,\n            sign='+', legacy=legacy\n        )\n\n    def __call__(self, x):\n        r = self.real_format(x.real)\n        i = self.imag_format(x.imag)\n\n        # add the 'j' before the terminal whitespace in i\n        sp = len(i.rstrip())\n        i = i[:sp] + 'j' + i[sp:]\n\n        return r + i\n\n\nclass _TimelikeFormat:\n    def __init__(self, data):\n        non_nat = data[~isnat(data)]\n        if len(non_nat) > 0:\n            # Max str length of non-NaT elements\n            max_str_len = max(len(self._format_non_nat(np.max(non_nat))),\n                              len(self._format_non_nat(np.min(non_nat))))\n        else:\n            max_str_len = 0\n        if len(non_nat) < data.size:\n            # data contains a NaT\n            max_str_len = max(max_str_len, 5)\n        self._format = '%{}s'.format(max_str_len)\n        self._nat = \"'NaT'\".rjust(max_str_len)\n\n    def _format_non_nat(self, x):\n        # override in subclass\n        raise NotImplementedError\n\n    def __call__(self, x):\n        if isnat(x):\n            return self._nat\n        else:\n            return self._format % self._format_non_nat(x)\n\n\nclass DatetimeFormat(_TimelikeFormat):\n    def __init__(self, x, unit=None, timezone=None, casting='same_kind',\n                 legacy=False):\n        # Get the unit from the dtype\n        if unit is None:\n            if x.dtype.kind == 'M':\n                unit = datetime_data(x.dtype)[0]\n            else:\n                unit = 's'\n\n        if timezone is None:\n            timezone = 'naive'\n        self.timezone = timezone\n        self.unit = unit\n        self.casting = casting\n        self.legacy = legacy\n\n        # must be called after the above are configured\n        super().__init__(x)\n\n    def __call__(self, x):\n        if self.legacy <= 113:\n            return self._format_non_nat(x)\n        return super().__call__(x)\n\n    def _format_non_nat(self, x):\n        return \"'%s'\" % datetime_as_string(x,\n                                    unit=self.unit,\n                                    timezone=self.timezone,\n                                    casting=self.casting)\n\n\nclass TimedeltaFormat(_TimelikeFormat):\n    def _format_non_nat(self, x):\n        return str(x.astype('i8'))\n\n\nclass SubArrayFormat:\n    def __init__(self, format_function, **options):\n        self.format_function = format_function\n        self.threshold = options['threshold']\n        self.edge_items = options['edgeitems']\n\n    def __call__(self, a):\n        self.summary_insert = \"...\" if a.size > self.threshold else \"\"\n        return self.format_array(a)\n\n    def format_array(self, a):\n        if np.ndim(a) == 0:\n            return self.format_function(a)\n\n        if self.summary_insert and a.shape[0] > 2*self.edge_items:\n            formatted = (\n                [self.format_array(a_) for a_ in a[:self.edge_items]]\n                + [self.summary_insert]\n                + [self.format_array(a_) for a_ in a[-self.edge_items:]]\n            )\n        else:\n            formatted = [self.format_array(a_) for a_ in a]\n\n        return \"[\" + \", \".join(formatted) + \"]\"\n\n\nclass StructuredVoidFormat:\n    \"\"\"\n    Formatter for structured np.void objects.\n\n    This does not work on structured alias types like\n    np.dtype(('i4', 'i2,i2')), as alias scalars lose their field information,\n    and the implementation relies upon np.void.__getitem__.\n    \"\"\"\n    def __init__(self, format_functions):\n        self.format_functions = format_functions\n\n    @classmethod\n    def from_data(cls, data, **options):\n        \"\"\"\n        This is a second way to initialize StructuredVoidFormat,\n        using the raw data as input. Added to avoid changing\n        the signature of __init__.\n        \"\"\"\n        format_functions = []\n        for field_name in data.dtype.names:\n            format_function = _get_format_function(data[field_name], **options)\n            if data.dtype[field_name].shape != ():\n                format_function = SubArrayFormat(format_function, **options)\n            format_functions.append(format_function)\n        return cls(format_functions)\n\n    def __call__(self, x):\n        str_fields = [\n            format_function(field)\n            for field, format_function in zip(x, self.format_functions)\n        ]\n        if len(str_fields) == 1:\n            return \"({},)\".format(str_fields[0])\n        else:\n            return \"({})\".format(\", \".join(str_fields))\n\n\ndef _void_scalar_to_string(x, is_repr=True):\n    \"\"\"\n    Implements the repr for structured-void scalars. It is called from the\n    scalartypes.c.src code, and is placed here because it uses the elementwise\n    formatters defined above.\n    \"\"\"\n    options = format_options.get().copy()\n\n    if options[\"legacy\"] <= 125:\n        return StructuredVoidFormat.from_data(array(x), **options)(x)\n\n    if options.get('formatter') is None:\n        options['formatter'] = {}\n    options['formatter'].setdefault('float_kind', str)\n    val_repr = StructuredVoidFormat.from_data(array(x), **options)(x)\n    if not is_repr:\n        return val_repr\n    cls = type(x)\n    cls_fqn = cls.__module__.replace(\"numpy\", \"np\") + \".\" + cls.__name__\n    void_dtype = np.dtype((np.void, x.dtype))\n    return f\"{cls_fqn}({val_repr}, dtype={void_dtype!s})\"\n\n\n_typelessdata = [int_, float64, complex128, _nt.bool]\n\n\ndef dtype_is_implied(dtype):\n    \"\"\"\n    Determine if the given dtype is implied by the representation\n    of its values.\n\n    Parameters\n    ----------\n    dtype : dtype\n        Data type\n\n    Returns\n    -------\n    implied : bool\n        True if the dtype is implied by the representation of its values.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np._core.arrayprint.dtype_is_implied(int)\n    True\n    >>> np.array([1, 2, 3], int)\n    array([1, 2, 3])\n    >>> np._core.arrayprint.dtype_is_implied(np.int8)\n    False\n    >>> np.array([1, 2, 3], np.int8)\n    array([1, 2, 3], dtype=int8)\n    \"\"\"\n    dtype = np.dtype(dtype)\n    if format_options.get()['legacy'] <= 113 and dtype.type == np.bool:\n        return False\n\n    # not just void types can be structured, and names are not part of the repr\n    if dtype.names is not None:\n        return False\n\n    # should care about endianness *unless size is 1* (e.g., int8, bool)\n    if not dtype.isnative:\n        return False\n\n    return dtype.type in _typelessdata\n\n\ndef dtype_short_repr(dtype):\n    \"\"\"\n    Convert a dtype to a short form which evaluates to the same dtype.\n\n    The intent is roughly that the following holds\n\n    >>> from numpy import *\n    >>> dt = np.int64([1, 2]).dtype\n    >>> assert eval(dtype_short_repr(dt)) == dt\n    \"\"\"\n    if type(dtype).__repr__ != np.dtype.__repr__:\n        # TODO: Custom repr for user DTypes, logic should likely move.\n        return repr(dtype)\n    if dtype.names is not None:\n        # structured dtypes give a list or tuple repr\n        return str(dtype)\n    elif issubclass(dtype.type, flexible):\n        # handle these separately so they don't give garbage like str256\n        return \"'%s'\" % str(dtype)\n\n    typename = dtype.name\n    if not dtype.isnative:\n        # deal with cases like dtype('<u2') that are identical to an\n        # established dtype (in this case uint16)\n        # except that they have a different endianness.\n        return \"'%s'\" % str(dtype)\n    # quote typenames which can't be represented as python variable names\n    if typename and not (typename[0].isalpha() and typename.isalnum()):\n        typename = repr(typename)\n    return typename\n\n\ndef _array_repr_implementation(\n        arr, max_line_width=None, precision=None, suppress_small=None,\n        array2string=array2string):\n    \"\"\"Internal version of array_repr() that allows overriding array2string.\"\"\"\n    current_options = format_options.get()\n    override_repr = current_options[\"override_repr\"]\n    if override_repr is not None:\n        return override_repr(arr)\n\n    if max_line_width is None:\n        max_line_width = current_options['linewidth']\n\n    if type(arr) is not ndarray:\n        class_name = type(arr).__name__\n    else:\n        class_name = \"array\"\n\n    prefix = class_name + \"(\"\n    if (current_options['legacy'] <= 113 and\n            arr.shape == () and not arr.dtype.names):\n        lst = repr(arr.item())\n    else:\n        lst = array2string(arr, max_line_width, precision, suppress_small,\n                           ', ', prefix, suffix=\")\")\n\n    # Add dtype and shape information if these cannot be inferred from\n    # the array string.\n    extras = []\n    if (arr.size == 0 and arr.shape != (0,)\n            or current_options['legacy'] > 210\n            and arr.size > current_options['threshold']):\n        extras.append(f\"shape={arr.shape}\")\n    if not dtype_is_implied(arr.dtype) or arr.size == 0:\n        extras.append(f\"dtype={dtype_short_repr(arr.dtype)}\")\n\n    if not extras:\n        return prefix + lst + \")\"\n\n    arr_str = prefix + lst + \",\"\n    extra_str = \", \".join(extras) + \")\"\n    # compute whether we should put extras on a new line: Do so if adding the\n    # extras would extend the last line past max_line_width.\n    # Note: This line gives the correct result even when rfind returns -1.\n    last_line_len = len(arr_str) - (arr_str.rfind('\\n') + 1)\n    spacer = \" \"\n    if current_options['legacy'] <= 113:\n        if issubclass(arr.dtype.type, flexible):\n            spacer = '\\n' + ' '*len(prefix)\n    elif last_line_len + len(extra_str) + 1 > max_line_width:\n        spacer = '\\n' + ' '*len(prefix)\n\n    return arr_str + spacer + extra_str\n\n\ndef _array_repr_dispatcher(\n        arr, max_line_width=None, precision=None, suppress_small=None):\n    return (arr,)\n\n\n@array_function_dispatch(_array_repr_dispatcher, module='numpy')\ndef array_repr(arr, max_line_width=None, precision=None, suppress_small=None):\n    \"\"\"\n    Return the string representation of an array.\n\n    Parameters\n    ----------\n    arr : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.\n        Defaults to ``numpy.get_printoptions()['linewidth']``.\n    precision : int, optional\n        Floating point precision.\n        Defaults to ``numpy.get_printoptions()['precision']``.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n        Defaults to ``numpy.get_printoptions()['suppress']``.\n\n    Returns\n    -------\n    string : str\n      The string representation of an array.\n\n    See Also\n    --------\n    array_str, array2string, set_printoptions\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.array_repr(np.array([1,2]))\n    'array([1, 2])'\n    >>> np.array_repr(np.ma.array([0.]))\n    'MaskedArray([0.])'\n    >>> np.array_repr(np.array([], np.int32))\n    'array([], dtype=int32)'\n\n    >>> x = np.array([1e-6, 4e-7, 2, 3])\n    >>> np.array_repr(x, precision=6, suppress_small=True)\n    'array([0.000001,  0.      ,  2.      ,  3.      ])'\n\n    \"\"\"\n    return _array_repr_implementation(\n        arr, max_line_width, precision, suppress_small)\n\n\n@_recursive_guard()\ndef _guarded_repr_or_str(v):\n    if isinstance(v, bytes):\n        return repr(v)\n    return str(v)\n\n\ndef _array_str_implementation(\n        a, max_line_width=None, precision=None, suppress_small=None,\n        array2string=array2string):\n    \"\"\"Internal version of array_str() that allows overriding array2string.\"\"\"\n    if (format_options.get()['legacy'] <= 113 and\n            a.shape == () and not a.dtype.names):\n        return str(a.item())\n\n    # the str of 0d arrays is a special case: It should appear like a scalar,\n    # so floats are not truncated by `precision`, and strings are not wrapped\n    # in quotes. So we return the str of the scalar value.\n    if a.shape == ():\n        # obtain a scalar and call str on it, avoiding problems for subclasses\n        # for which indexing with () returns a 0d instead of a scalar by using\n        # ndarray's getindex. Also guard against recursive 0d object arrays.\n        return _guarded_repr_or_str(np.ndarray.__getitem__(a, ()))\n\n    return array2string(a, max_line_width, precision, suppress_small, ' ', \"\")\n\n\ndef _array_str_dispatcher(\n        a, max_line_width=None, precision=None, suppress_small=None):\n    return (a,)\n\n\n@array_function_dispatch(_array_str_dispatcher, module='numpy')\ndef array_str(a, max_line_width=None, precision=None, suppress_small=None):\n    \"\"\"\n    Return a string representation of the data in an array.\n\n    The data in the array is returned as a single string.  This function is\n    similar to `array_repr`, the difference being that `array_repr` also\n    returns information on the kind of array and its data type.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.\n        Defaults to ``numpy.get_printoptions()['linewidth']``.\n    precision : int, optional\n        Floating point precision.\n        Defaults to ``numpy.get_printoptions()['precision']``.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n        Defaults to ``numpy.get_printoptions()['suppress']``.\n\n    See Also\n    --------\n    array2string, array_repr, set_printoptions\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.array_str(np.arange(3))\n    '[0 1 2]'\n\n    \"\"\"\n    return _array_str_implementation(\n        a, max_line_width, precision, suppress_small)\n\n\n# needed if __array_function__ is disabled\n_array2string_impl = getattr(array2string, '__wrapped__', array2string)\n_default_array_str = functools.partial(_array_str_implementation,\n                                       array2string=_array2string_impl)\n_default_array_repr = functools.partial(_array_repr_implementation,\n                                        array2string=_array2string_impl)\n", 1756], "<frozen abc>": ["# Copyright 2007 Google, Inc. All Rights Reserved.\n# Licensed to PSF under a Contributor Agreement.\n\n\"\"\"Abstract Base Classes (ABCs) according to PEP 3119.\"\"\"\n\n\ndef abstractmethod(funcobj):\n    \"\"\"A decorator indicating abstract methods.\n\n    Requires that the metaclass is ABCMeta or derived from it.  A\n    class that has a metaclass derived from ABCMeta cannot be\n    instantiated unless all of its abstract methods are overridden.\n    The abstract methods can be called using any of the normal\n    'super' call mechanisms.  abstractmethod() may be used to declare\n    abstract methods for properties and descriptors.\n\n    Usage:\n\n        class C(metaclass=ABCMeta):\n            @abstractmethod\n            def my_abstract_method(self, arg1, arg2, argN):\n                ...\n    \"\"\"\n    funcobj.__isabstractmethod__ = True\n    return funcobj\n\n\nclass abstractclassmethod(classmethod):\n    \"\"\"A decorator indicating abstract classmethods.\n\n    Deprecated, use 'classmethod' with 'abstractmethod' instead:\n\n        class C(ABC):\n            @classmethod\n            @abstractmethod\n            def my_abstract_classmethod(cls, ...):\n                ...\n\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n    def __init__(self, callable):\n        callable.__isabstractmethod__ = True\n        super().__init__(callable)\n\n\nclass abstractstaticmethod(staticmethod):\n    \"\"\"A decorator indicating abstract staticmethods.\n\n    Deprecated, use 'staticmethod' with 'abstractmethod' instead:\n\n        class C(ABC):\n            @staticmethod\n            @abstractmethod\n            def my_abstract_staticmethod(...):\n                ...\n\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n    def __init__(self, callable):\n        callable.__isabstractmethod__ = True\n        super().__init__(callable)\n\n\nclass abstractproperty(property):\n    \"\"\"A decorator indicating abstract properties.\n\n    Deprecated, use 'property' with 'abstractmethod' instead:\n\n        class C(ABC):\n            @property\n            @abstractmethod\n            def my_abstract_property(self):\n                ...\n\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n\ntry:\n    from _abc import (get_cache_token, _abc_init, _abc_register,\n                      _abc_instancecheck, _abc_subclasscheck, _get_dump,\n                      _reset_registry, _reset_caches)\nexcept ImportError:\n    from _py_abc import ABCMeta, get_cache_token\n    ABCMeta.__module__ = 'abc'\nelse:\n    class ABCMeta(type):\n        \"\"\"Metaclass for defining Abstract Base Classes (ABCs).\n\n        Use this metaclass to create an ABC.  An ABC can be subclassed\n        directly, and then acts as a mix-in class.  You can also register\n        unrelated concrete classes (even built-in classes) and unrelated\n        ABCs as 'virtual subclasses' -- these and their descendants will\n        be considered subclasses of the registering ABC by the built-in\n        issubclass() function, but the registering ABC won't show up in\n        their MRO (Method Resolution Order) nor will method\n        implementations defined by the registering ABC be callable (not\n        even via super()).\n        \"\"\"\n        def __new__(mcls, name, bases, namespace, /, **kwargs):\n            cls = super().__new__(mcls, name, bases, namespace, **kwargs)\n            _abc_init(cls)\n            return cls\n\n        def register(cls, subclass):\n            \"\"\"Register a virtual subclass of an ABC.\n\n            Returns the subclass, to allow usage as a class decorator.\n            \"\"\"\n            return _abc_register(cls, subclass)\n\n        def __instancecheck__(cls, instance):\n            \"\"\"Override for isinstance(instance, cls).\"\"\"\n            return _abc_instancecheck(cls, instance)\n\n        def __subclasscheck__(cls, subclass):\n            \"\"\"Override for issubclass(subclass, cls).\"\"\"\n            return _abc_subclasscheck(cls, subclass)\n\n        def _dump_registry(cls, file=None):\n            \"\"\"Debug helper to print the ABC registry.\"\"\"\n            print(f\"Class: {cls.__module__}.{cls.__qualname__}\", file=file)\n            print(f\"Inv. counter: {get_cache_token()}\", file=file)\n            (_abc_registry, _abc_cache, _abc_negative_cache,\n             _abc_negative_cache_version) = _get_dump(cls)\n            print(f\"_abc_registry: {_abc_registry!r}\", file=file)\n            print(f\"_abc_cache: {_abc_cache!r}\", file=file)\n            print(f\"_abc_negative_cache: {_abc_negative_cache!r}\", file=file)\n            print(f\"_abc_negative_cache_version: {_abc_negative_cache_version!r}\",\n                  file=file)\n\n        def _abc_registry_clear(cls):\n            \"\"\"Clear the registry (for debugging or testing).\"\"\"\n            _reset_registry(cls)\n\n        def _abc_caches_clear(cls):\n            \"\"\"Clear the caches (for debugging or testing).\"\"\"\n            _reset_caches(cls)\n\n\ndef update_abstractmethods(cls):\n    \"\"\"Recalculate the set of abstract methods of an abstract class.\n\n    If a class has had one of its abstract methods implemented after the\n    class was created, the method will not be considered implemented until\n    this function is called. Alternatively, if a new abstract method has been\n    added to the class, it will only be considered an abstract method of the\n    class after this function is called.\n\n    This function should be called before any use is made of the class,\n    usually in class decorators that add methods to the subject class.\n\n    Returns cls, to allow usage as a class decorator.\n\n    If cls is not an instance of ABCMeta, does nothing.\n    \"\"\"\n    if not hasattr(cls, '__abstractmethods__'):\n        # We check for __abstractmethods__ here because cls might by a C\n        # implementation or a python implementation (especially during\n        # testing), and we want to handle both cases.\n        return cls\n\n    abstracts = set()\n    # Check the existing abstract methods of the parents, keep only the ones\n    # that are not implemented.\n    for scls in cls.__bases__:\n        for name in getattr(scls, '__abstractmethods__', ()):\n            value = getattr(cls, name, None)\n            if getattr(value, \"__isabstractmethod__\", False):\n                abstracts.add(name)\n    # Also add any other newly added abstract methods.\n    for name, value in cls.__dict__.items():\n        if getattr(value, \"__isabstractmethod__\", False):\n            abstracts.add(name)\n    cls.__abstractmethods__ = frozenset(abstracts)\n    return cls\n\n\nclass ABC(metaclass=ABCMeta):\n    \"\"\"Helper class that provides a standard way to create an ABC using\n    inheritance.\n    \"\"\"\n    __slots__ = ()\n", 188], "/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py": ["\"\"\"\nModule of functions that are like ufuncs in acting on arrays and optionally\nstoring results in an output array.\n\n\"\"\"\n__all__ = ['fix', 'isneginf', 'isposinf']\n\nimport numpy._core.numeric as nx\nfrom numpy._core.overrides import array_function_dispatch\n\n\ndef _dispatcher(x, out=None):\n    return (x, out)\n\n\n@array_function_dispatch(_dispatcher, verify=False, module='numpy')\ndef fix(x, out=None):\n    \"\"\"\n    Round to nearest integer towards zero.\n\n    Round an array of floats element-wise to nearest integer towards zero.\n    The rounded values have the same data-type as the input.\n\n    Parameters\n    ----------\n    x : array_like\n        An array to be rounded\n    out : ndarray, optional\n        A location into which the result is stored. If provided, it must have\n        a shape that the input broadcasts to. If not provided or None, a\n        freshly-allocated array is returned.\n\n    Returns\n    -------\n    out : ndarray of floats\n        An array with the same dimensions and data-type as the input.\n        If second argument is not supplied then a new array is returned\n        with the rounded values.\n\n        If a second argument is supplied the result is stored there.\n        The return value ``out`` is then a reference to that array.\n\n    See Also\n    --------\n    rint, trunc, floor, ceil\n    around : Round to given number of decimals\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.fix(3.14)\n    3.0\n    >>> np.fix(3)\n    3\n    >>> np.fix([2.1, 2.9, -2.1, -2.9])\n    array([ 2.,  2., -2., -2.])\n\n    \"\"\"\n    # promote back to an array if flattened\n    res = nx.asanyarray(nx.ceil(x, out=out))\n    res = nx.floor(x, out=res, where=nx.greater_equal(x, 0))\n\n    # when no out argument is passed and no subclasses are involved, flatten\n    # scalars\n    if out is None and type(res) is nx.ndarray:\n        res = res[()]\n    return res\n\n\n@array_function_dispatch(_dispatcher, verify=False, module='numpy')\ndef isposinf(x, out=None):\n    \"\"\"\n    Test element-wise for positive infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    out : array_like, optional\n        A location into which the result is stored. If provided, it must have a\n        shape that the input broadcasts to. If not provided or None, a\n        freshly-allocated boolean array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a boolean array is returned\n        with values True where the corresponding element of the input is\n        positive infinity and values False where the element of the input is\n        not positive infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as zeros\n        and ones, if the type is boolean then as False and True.\n        The return value `out` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isneginf, isfinite, isnan\n\n    Notes\n    -----\n    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when x is a scalar\n    input, if first and second arguments have different shapes, or if the\n    first argument has complex values\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.isposinf(np.inf)\n    True\n    >>> np.isposinf(-np.inf)\n    False\n    >>> np.isposinf([-np.inf, 0., np.inf])\n    array([False, False,  True])\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isposinf(x, y)\n    array([0, 0, 1])\n    >>> y\n    array([0, 0, 1])\n\n    \"\"\"\n    is_inf = nx.isinf(x)\n    try:\n        signbit = ~nx.signbit(x)\n    except TypeError as e:\n        dtype = nx.asanyarray(x).dtype\n        raise TypeError(f'This operation is not supported for {dtype} values '\n                        'because it would be ambiguous.') from e\n    else:\n        return nx.logical_and(is_inf, signbit, out)\n\n\n@array_function_dispatch(_dispatcher, verify=False, module='numpy')\ndef isneginf(x, out=None):\n    \"\"\"\n    Test element-wise for negative infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    out : array_like, optional\n        A location into which the result is stored. If provided, it must have a\n        shape that the input broadcasts to. If not provided or None, a\n        freshly-allocated boolean array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a numpy boolean array is\n        returned with values True where the corresponding element of the\n        input is negative infinity and values False where the element of\n        the input is not negative infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as\n        zeros and ones, if the type is boolean then as False and True. The\n        return value `out` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isposinf, isnan, isfinite\n\n    Notes\n    -----\n    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when x is a scalar\n    input, if first and second arguments have different shapes, or if the\n    first argument has complex values.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.isneginf(-np.inf)\n    True\n    >>> np.isneginf(np.inf)\n    False\n    >>> np.isneginf([-np.inf, 0., np.inf])\n    array([ True, False, False])\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isneginf(x, y)\n    array([1, 0, 0])\n    >>> y\n    array([1, 0, 0])\n\n    \"\"\"\n    is_inf = nx.isinf(x)\n    try:\n        signbit = nx.signbit(x)\n    except TypeError as e:\n        dtype = nx.asanyarray(x).dtype\n        raise TypeError(f'This operation is not supported for {dtype} values '\n                        'because it would be ambiguous.') from e\n    else:\n        return nx.logical_and(is_inf, signbit, out)\n", 207]}, "functions": {"_atleast_1d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:17)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py", 17], "atleast_1d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:21)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py", 21], "standardize_constraints (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py:1066)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py", 1066], "_arr_to_scalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:11)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py", 11], "old_bound_to_new.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:437)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py", 437], "old_bound_to_new.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:439)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py", 439], "old_bound_to_new (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:424)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py", 424], "issparse (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/sparse/_base.py:1388)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/sparse/_base.py", 1388], "_broadcast_arrays_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:477)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py", 477], "broadcast_arrays.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:542)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py", 542], "_broadcast_shape (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:413)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py", 413], "iterable (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:339)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py", 339], "_broadcast_to.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:345)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py", 345], "_maybe_view_as_subclass (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:24)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py", 24], "_broadcast_to (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:340)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py", 340], "broadcast_arrays.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:546)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py", 546], "broadcast_arrays (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:481)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py", 481], "Bounds._input_validation (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:249)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py", 249], "Bounds.__init__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:257)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py", 257], "standardize_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py:1053)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py", 1053], "_any_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2472)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 2472], "_wrapreduction_any_all.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:91)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 91], "_wrapreduction_any_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:89)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 89], "any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2477)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 2477], "_broadcast_to_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:363)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py", 363], "broadcast_to (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py:367)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_stride_tricks_impl.py", 367], "_validate_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py:1037)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py", 1037], "_all_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2584)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 2584], "all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2589)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 2589], "_any (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:58)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py", 58], "new_bounds_to_old.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:418)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py", 418], "new_bounds_to_old.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:419)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py", 419], "new_bounds_to_old (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py:406)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_constraints.py", 406], "_wrap_callback (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:88)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py", 88], "_check_unknown_options (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:175)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py", 175], "array_namespace (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py:114)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_array_api.py", 114], "Enum.value (/usr/lib/python3.11/enum.py:1257)": ["/usr/lib/python3.11/enum.py", 1257], "property.__get__ (/usr/lib/python3.11/enum.py:193)": ["/usr/lib/python3.11/enum.py", 193], "asarray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py:78)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/numpy/_aliases.py", 78], "atleast_nd (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py:12)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_extra/_funcs.py", 12], "_preprocess_dtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:368)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py", 368], "isdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:381)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py", 381], "astype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:236)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py", 236], "_reshape_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:206)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 206], "_wrapfunc (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:51)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 51], "reshape (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:211)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 211], "reshape (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py:371)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/common/_aliases.py", 371], "get_xp.<locals>.inner.<locals>.wrapped_f (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/_internal.py:26)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/array_api_compat/_internal.py", 26], "_clip_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2236)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 2236], "_clip (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:99)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py", 99], "clip (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:2241)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 2241], "_minimize_slsqp.<locals>.cjac_factory (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:299)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py", 299], "_minimize_slsqp.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:334)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py", 334], "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:12)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py", 12], "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:13)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py", 13], "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:14)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py", 14], "_minimize_slsqp.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:336)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py", 336], "_amax (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:42)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py", 42], "_minimize_slsqp.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:361)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py", 361], "errstate.__init__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py:430)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py", 430], "errstate.__enter__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py:440)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py", 440], "errstate.__exit__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py:456)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_ufunc_config.py", 456], "_wrapper_fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:13)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 13], "_copy_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:894)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py", 894], "copy (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:898)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py", 898], "main.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:8)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py", 8], "isscalar (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:1927)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py", 1927], "_wrapper_fun.<locals>.wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:16)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 16], "ScalarFunction._update_fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:293)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 293], "_wrapper_grad (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:35)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 35], "_prepare_bounds.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:206)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py", 206], "_prepare_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:195)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py", 195], "finfo.__new__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/getlimits.py:493)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/getlimits.py", 493], "issubclass_ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:289)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py", 289], "issubdtype (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py:471)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numerictypes.py", 471], "_eps_for_method (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:92)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py", 92], "where (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:383)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py", 383], "_ones_like_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:207)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py", 207], "empty_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:107)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py", 107], "copyto (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:1098)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py", 1098], "ones_like (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:213)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py", 213], "_adjust_scheme_to_bounds (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:13)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py", 13], "approx_derivative.<locals>.fun_wrapped (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:468)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py", 468], "_ravel_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1900)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 1900], "ravel (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:1904)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 1904], "_dense_difference (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:584)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py", 584], "approx_derivative (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py:277)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_numdiff.py", 277], "_wrapper_grad.<locals>.wrapped1 (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:46)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 46], "ScalarFunction._update_grad (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:303)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 303], "_prepare_scalar_function.<locals>.hess (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:283)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py", 283], "_atleast_2d_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:76)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py", 76], "atleast_2d (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:80)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py", 80], "_wrapper_hess (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:55)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 55], "ScalarFunction.__init__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:166)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 166], "_prepare_scalar_function (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:203)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py", 203], "_clip_x_for_func (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:297)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py", 297], "_check_clip_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:310)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py", 310], "_array_equal_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2456)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py", 2456], "_all (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py:67)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/_methods.py", 67], "array_equal (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2475)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/numeric.py", 2475], "ScalarFunction.fun (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:323)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 323], "_clip_x_for_func.<locals>.eval (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py:303)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_optimize.py", 303], "ScalarFunction.grad (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:329)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 329], "_append_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:5640)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py", 5640], "concatenate (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py:180)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/multiarray.py", 180], "append (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py:5644)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_function_base_impl.py", 5644], "_eval_constraint.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:480)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py", 480], "_eval_constraint (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:471)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py", 471], "_minimize_slsqp.<locals>.cjac_factory.<locals>.cjac (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:300)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py", 300], "_eval_con_normals.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:499)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py", 499], "_arrays_for_stack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:208)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py", 208], "_vhstack_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:216)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py", 216], "vstack (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py:220)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/shape_base.py", 220], "_eval_con_normals (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:490)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py", 490], "ScalarFunction._update_x (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:270)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 270], "ScalarFunction.nfev (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:258)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 258], "ScalarFunction.ngev (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py:262)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_differentiable_functions.py", 262], "_minimize_slsqp (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py:216)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_slsqp_py.py", 216], "minimize (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py:53)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/optimize/_minimize.py", 53], "_RichResult.__getattr__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1089)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py", 1089], "_RichResult.__repr__.<locals>.omit_redundant (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1114)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py", 1114], "_RichResult.__repr__.<locals>.key (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1108)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py", 1108], "_RichResult.__repr__.<locals>.item_sorter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1120)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py", 1120], "_GeneratorContextManagerBase.__init__ (/usr/lib/python3.11/contextlib.py:104)": ["/usr/lib/python3.11/contextlib.py", 104], "contextmanager.<locals>.helper (/usr/lib/python3.11/contextlib.py:299)": ["/usr/lib/python3.11/contextlib.py", 299], "_make_options_dict.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:59)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 59], "ABCMeta.__subclasscheck__ (<frozen abc>:121)": ["<frozen abc>", 121], "ABCMeta.__instancecheck__ (<frozen abc>:117)": ["<frozen abc>", 117], "_make_options_dict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:50)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 50], "_set_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:298)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 298], "get_printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:318)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 318], "printoptions (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:372)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 372], "_GeneratorContextManager.__enter__ (/usr/lib/python3.11/contextlib.py:132)": ["/usr/lib/python3.11/contextlib.py", 132], "_GeneratorContextManager.__exit__ (/usr/lib/python3.11/contextlib.py:141)": ["/usr/lib/python3.11/contextlib.py", 141], "_dict_formatter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1154)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py", 1154], "_indenter (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1132)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py", 1132], "_get_formatdict.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:475)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 475], "_get_formatdict.<locals>.indirect (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:471)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 471], "_get_formatdict (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:446)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 446], "_get_formatdict.<locals>.indirect.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:472)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 472], "_get_format_function (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:496)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 496], "_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:12)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py", 12], "isposinf (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:70)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py", 70], "isneginf (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py:140)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/lib/_ufunclike_impl.py", 140], "_none_or_positive_arg (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:952)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 952], "format_float_scientific (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1108)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 1108], "_float_formatter_10 (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1141)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py", 1141], "_formatArray.<locals>.recurser (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:837)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 837], "_extendLine (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:787)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 787], "_extendLine_pretty (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:801)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 801], "_formatArray (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:828)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 828], "_array2string (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:567)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 567], "_recursive_guard.<locals>.decorating_function.<locals>.wrapper (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:550)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 550], "array2string (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:605)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 605], "_array_str_implementation (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1685)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 1685], "_dict_formatter.<locals>.<listcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1164)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py", 1164], "_RichResult.__repr__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1098)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/scipy/_lib/_util.py", 1098], "_max_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:3047)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 3047], "_wrapreduction.<locals>.<dictcomp> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:70)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 70], "_wrapreduction (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:69)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 69], "max (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:3052)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 3052], "_min_dispatcher (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:3185)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 3185], "min (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py:3190)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/fromnumeric.py", 3190], "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1037)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 1037], "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1042)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 1042], "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1046)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 1046], "FloatingFormat.fillFormat.<locals>.<genexpr> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1047)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 1047], "FloatingFormat.fillFormat (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:987)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 987], "FloatingFormat.__init__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:961)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 961], "_get_formatdict.<locals>.<lambda> (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:455)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 455], "FloatingFormat.__call__ (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py:1073)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/.venv/lib/python3.11/site-packages/numpy/_core/arrayprint.py", 1073], "main (/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py:6)": ["/home/tomerw/Repos/demo_for_performance/ChicPythonPerformance/in_code_profilers_demo/viztracer_demo/main.py", 6]}}}